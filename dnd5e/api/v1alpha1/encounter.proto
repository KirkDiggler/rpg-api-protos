syntax = "proto3";

package dnd5e.api.v1alpha1;

import "api/v1alpha1/room_common.proto";

// Note: Using Position from api.v1alpha1.room_common

// EntityPlacement represents where an entity is positioned
// Matches toolkit's EntityPlacement structure exactly
message EntityPlacement {
  // Unique identifier for the entity
  string entity_id = 1;
  // Type of entity (e.g., "character", "monster", "object")
  string entity_type = 2;
  // Position in the room
  .api.v1alpha1.Position position = 3;
  // Size of the entity in grid units (default 1)
  int32 size = 4;
  // Whether this entity blocks movement through its space
  bool blocks_movement = 5;
  // Whether this entity blocks line of sight
  bool blocks_line_of_sight = 6;
}

// Room represents a spatial area where encounters take place
// Matches toolkit's RoomData structure exactly for direct field mapping
message Room {
  // Unique identifier for the room
  string id = 1;
  // Type of room (e.g., "dungeon", "tavern", "outdoor")
  string type = 2;
  // Width of the room in grid units
  int32 width = 3;
  // Height of the room in grid units
  int32 height = 4;
  // Grid system used in this room
  .api.v1alpha1.GridType grid_type = 5;
  // Hex orientation: true for pointy-top, false for flat-top
  // Only used when grid_type is HEX, defaults to true (pointy-top) for D&D 5e compatibility
  // Uses optional to distinguish between explicit false and unset (which defaults to true)
  optional bool hex_orientation = 6;
  // Entities placed in the room - map of entity ID to their placement data
  // Matches toolkit's map[string]EntityPlacement structure
  map<string, EntityPlacement> entities = 7;
}

// DungeonStartRequest initiates a simple dungeon encounter
message DungeonStartRequest {
  // IDs of the characters entering the dungeon
  repeated string character_ids = 1;
}

// DungeonStartResponse contains the generated encounter
message DungeonStartResponse {
  // Unique identifier for this encounter
  string encounter_id = 1;
  // The generated room with all entities placed (including characters)
  Room room = 2;
}

// ============================================================================
// PHASE 1: COMBAT STATE MANAGEMENT
// ============================================================================

// InitiativeRoll represents a pre-rolled initiative value (optional)
message InitiativeRoll {
  string entity_id = 1;
  int32 roll = 2; // d20 result
  int32 modifier = 3; // DEX modifier
}

// StartCombatRequest initiates combat for an encounter
message StartCombatRequest {
  string encounter_id = 1;
  // Optional pre-rolled initiative values. If not provided, system rolls.
  repeated InitiativeRoll initiative_rolls = 2;
  // Optional seed for deterministic initiative rolling
  optional string seed = 3;
}

// InitiativeEntry represents one combatant in turn order
message InitiativeEntry {
  string entity_id = 1;
  string entity_type = 2; // "character", "monster", "npc"
  int32 initiative = 3; // Total initiative value (roll + modifier)
  int32 modifier = 4; // DEX modifier used
  bool has_acted = 5; // Has this entity acted this round?
}

// TurnState tracks resources available during a turn
message TurnState {
  string entity_id = 1;
  int32 movement_used = 2;
  int32 movement_max = 3;
  bool action_used = 4;
  bool bonus_action_used = 5;
  bool reaction_available = 6;
  .api.v1alpha1.Position position = 7;
}

// CombatState represents the complete state of combat
message CombatState {
  string encounter_id = 1;
  int32 round = 2;
  repeated InitiativeEntry turn_order = 3;
  int32 active_index = 4; // Index in turn_order of current actor
  TurnState current_turn = 5;
  bool combat_started = 6;
  bool combat_ended = 7;
}

// StartCombatResponse returns the initial combat state
message StartCombatResponse {
  CombatState combat_state = 1;
}

// GetCombatStateRequest retrieves current combat state
message GetCombatStateRequest {
  string encounter_id = 1;
}

// GetCombatStateResponse returns the current combat state
message GetCombatStateResponse {
  CombatState combat_state = 1;
}

// ============================================================================
// PHASE 2: MOVEMENT
// ============================================================================

// MoveCharacterRequest requests movement to a new position
message MoveCharacterRequest {
  string encounter_id = 1;
  string entity_id = 2;
  .api.v1alpha1.Position target_position = 3;
}

// MovementError provides detailed movement failure information
message MovementError {
  enum ErrorCode {
    ERROR_CODE_UNSPECIFIED = 0;
    ERROR_CODE_INVALID_POSITION = 1;
    ERROR_CODE_INSUFFICIENT_MOVEMENT = 2;
    ERROR_CODE_PATH_BLOCKED = 3;
    ERROR_CODE_POSITION_OCCUPIED = 4;
    ERROR_CODE_OUT_OF_BOUNDS = 5;
    ERROR_CODE_NOT_YOUR_TURN = 6;
  }
  ErrorCode code = 1;
  string message = 2;
  map<string, string> details = 3;
}

// MoveCharacterResponse returns movement result
message MoveCharacterResponse {
  bool success = 1;
  MovementError error = 2;
  int32 movement_remaining = 3;
  Room updated_room = 4; // Updated room with new positions
  CombatState combat_state = 5; // Updated combat state
}

// GetMovementOptionsRequest queries valid movement positions
message GetMovementOptionsRequest {
  string encounter_id = 1;
  string entity_id = 2;
}

// GetMovementOptionsResponse returns valid movement targets
message GetMovementOptionsResponse {
  repeated .api.v1alpha1.Position valid_positions = 1;
  int32 movement_remaining = 2;
  map<string, int32> position_costs = 3; // Position key -> movement cost
}

// ============================================================================
// PHASE 3: TURN MANAGEMENT
// ============================================================================

// EndTurnRequest ends the current entity's turn
message EndTurnRequest {
  string encounter_id = 1;
  string entity_id = 2; // Must match current turn
}

// TurnChangeEvent describes a turn transition
message TurnChangeEvent {
  string previous_entity_id = 1;
  string next_entity_id = 2;
  int32 round = 3;
  bool new_round = 4; // True if this starts a new round
}

// EndTurnResponse returns the updated state after turn end
message EndTurnResponse {
  bool success = 1;
  CombatState combat_state = 2;
  TurnChangeEvent turn_change = 3;
}

// ============================================================================
// PHASE 3.5: BASIC COMBAT ACTIONS (for Week 3)
// ============================================================================

// AttackRequest represents a melee or ranged attack
message AttackRequest {
  string encounter_id = 1;
  string attacker_id = 2;
  string target_id = 3;
  string weapon_id = 4; // Optional, uses default weapon if not specified
}

// AttackResult contains the outcome of an attack
message AttackResult {
  bool hit = 1;
  int32 attack_roll = 2;
  int32 attack_total = 3; // roll + modifiers
  int32 target_ac = 4;
  int32 damage = 5;
  string damage_type = 6; // "slashing", "piercing", etc.
  bool critical = 7;
}

// AttackResponse returns the attack outcome
message AttackResponse {
  bool success = 1;
  string error = 2;
  AttackResult result = 3;
  CombatState combat_state = 4;
  Room updated_room = 5; // Updated if entities are defeated/removed
}

// ============================================================================
// SERVICE DEFINITION
// ============================================================================

// EncounterService manages D&D 5e encounters
service EncounterService {
  // DungeonStart generates a simple starting room for testing
  rpc DungeonStart(DungeonStartRequest) returns (DungeonStartResponse);

  // Phase 1: Combat State Management
  rpc StartCombat(StartCombatRequest) returns (StartCombatResponse);
  rpc GetCombatState(GetCombatStateRequest) returns (GetCombatStateResponse);

  // Phase 2: Movement
  rpc MoveCharacter(MoveCharacterRequest) returns (MoveCharacterResponse);
  rpc GetMovementOptions(GetMovementOptionsRequest) returns (GetMovementOptionsResponse);

  // Phase 3: Turn Management
  rpc EndTurn(EndTurnRequest) returns (EndTurnResponse);

  // Phase 3.5: Basic Combat
  rpc Attack(AttackRequest) returns (AttackResponse);
}
