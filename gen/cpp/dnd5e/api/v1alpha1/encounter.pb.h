// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: dnd5e/api/v1alpha1/encounter.proto
// Protobuf C++ Version: 6.33.1

#ifndef dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_2epb_2eh
#define dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/v1alpha1/room_common.pb.h"
#include "dnd5e/api/v1alpha1/character.pb.h"
#include "dnd5e/api/v1alpha1/common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
}  // extern "C"
namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum MovementError_ErrorCode : int;
extern const uint32_t MovementError_ErrorCode_internal_data_[];
class ActivateFeatureRequest;
struct ActivateFeatureRequestDefaultTypeInternal;
extern ActivateFeatureRequestDefaultTypeInternal _ActivateFeatureRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ActivateFeatureRequest_class_data_;
class ActivateFeatureResponse;
struct ActivateFeatureResponseDefaultTypeInternal;
extern ActivateFeatureResponseDefaultTypeInternal _ActivateFeatureResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ActivateFeatureResponse_class_data_;
class AttackRequest;
struct AttackRequestDefaultTypeInternal;
extern AttackRequestDefaultTypeInternal _AttackRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AttackRequest_class_data_;
class AttackResponse;
struct AttackResponseDefaultTypeInternal;
extern AttackResponseDefaultTypeInternal _AttackResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AttackResponse_class_data_;
class AttackResult;
struct AttackResultDefaultTypeInternal;
extern AttackResultDefaultTypeInternal _AttackResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AttackResult_class_data_;
class CombatState;
struct CombatStateDefaultTypeInternal;
extern CombatStateDefaultTypeInternal _CombatState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CombatState_class_data_;
class DamageBreakdown;
struct DamageBreakdownDefaultTypeInternal;
extern DamageBreakdownDefaultTypeInternal _DamageBreakdown_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DamageBreakdown_class_data_;
class DamageComponent;
struct DamageComponentDefaultTypeInternal;
extern DamageComponentDefaultTypeInternal _DamageComponent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DamageComponent_class_data_;
class DungeonStartRequest;
struct DungeonStartRequestDefaultTypeInternal;
extern DungeonStartRequestDefaultTypeInternal _DungeonStartRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DungeonStartRequest_class_data_;
class DungeonStartResponse;
struct DungeonStartResponseDefaultTypeInternal;
extern DungeonStartResponseDefaultTypeInternal _DungeonStartResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DungeonStartResponse_class_data_;
class EndTurnRequest;
struct EndTurnRequestDefaultTypeInternal;
extern EndTurnRequestDefaultTypeInternal _EndTurnRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EndTurnRequest_class_data_;
class EndTurnResponse;
struct EndTurnResponseDefaultTypeInternal;
extern EndTurnResponseDefaultTypeInternal _EndTurnResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EndTurnResponse_class_data_;
class EntityPlacement;
struct EntityPlacementDefaultTypeInternal;
extern EntityPlacementDefaultTypeInternal _EntityPlacement_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EntityPlacement_class_data_;
class GetCombatStateRequest;
struct GetCombatStateRequestDefaultTypeInternal;
extern GetCombatStateRequestDefaultTypeInternal _GetCombatStateRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCombatStateRequest_class_data_;
class GetCombatStateResponse;
struct GetCombatStateResponseDefaultTypeInternal;
extern GetCombatStateResponseDefaultTypeInternal _GetCombatStateResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCombatStateResponse_class_data_;
class InitiativeEntry;
struct InitiativeEntryDefaultTypeInternal;
extern InitiativeEntryDefaultTypeInternal _InitiativeEntry_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InitiativeEntry_class_data_;
class MoveCharacterRequest;
struct MoveCharacterRequestDefaultTypeInternal;
extern MoveCharacterRequestDefaultTypeInternal _MoveCharacterRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MoveCharacterRequest_class_data_;
class MoveCharacterResponse;
struct MoveCharacterResponseDefaultTypeInternal;
extern MoveCharacterResponseDefaultTypeInternal _MoveCharacterResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MoveCharacterResponse_class_data_;
class MovementError;
struct MovementErrorDefaultTypeInternal;
extern MovementErrorDefaultTypeInternal _MovementError_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MovementError_class_data_;
class MovementError_DetailsEntry_DoNotUse;
struct MovementError_DetailsEntry_DoNotUseDefaultTypeInternal;
extern MovementError_DetailsEntry_DoNotUseDefaultTypeInternal _MovementError_DetailsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MovementError_DetailsEntry_DoNotUse_class_data_;
class RerollEvent;
struct RerollEventDefaultTypeInternal;
extern RerollEventDefaultTypeInternal _RerollEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RerollEvent_class_data_;
class Room;
struct RoomDefaultTypeInternal;
extern RoomDefaultTypeInternal _Room_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Room_class_data_;
class Room_EntitiesEntry_DoNotUse;
struct Room_EntitiesEntry_DoNotUseDefaultTypeInternal;
extern Room_EntitiesEntry_DoNotUseDefaultTypeInternal _Room_EntitiesEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Room_EntitiesEntry_DoNotUse_class_data_;
class TurnChangeEvent;
struct TurnChangeEventDefaultTypeInternal;
extern TurnChangeEventDefaultTypeInternal _TurnChangeEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TurnChangeEvent_class_data_;
class TurnState;
struct TurnStateDefaultTypeInternal;
extern TurnStateDefaultTypeInternal _TurnState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TurnState_class_data_;
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::MovementError_ErrorCode_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::MovementError_ErrorCode>;
}  // namespace protobuf
}  // namespace google

namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum MovementError_ErrorCode : int {
  MovementError_ErrorCode_ERROR_CODE_UNSPECIFIED = 0,
  MovementError_ErrorCode_ERROR_CODE_INVALID_POSITION = 1,
  MovementError_ErrorCode_ERROR_CODE_INSUFFICIENT_MOVEMENT = 2,
  MovementError_ErrorCode_ERROR_CODE_PATH_BLOCKED = 3,
  MovementError_ErrorCode_ERROR_CODE_POSITION_OCCUPIED = 4,
  MovementError_ErrorCode_ERROR_CODE_OUT_OF_BOUNDS = 5,
  MovementError_ErrorCode_ERROR_CODE_NOT_YOUR_TURN = 6,
  MovementError_ErrorCode_MovementError_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MovementError_ErrorCode_MovementError_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MovementError_ErrorCode_internal_data_[];
inline constexpr MovementError_ErrorCode MovementError_ErrorCode_ErrorCode_MIN =
    static_cast<MovementError_ErrorCode>(0);
inline constexpr MovementError_ErrorCode MovementError_ErrorCode_ErrorCode_MAX =
    static_cast<MovementError_ErrorCode>(6);
inline bool MovementError_ErrorCode_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int MovementError_ErrorCode_ErrorCode_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MovementError_ErrorCode_descriptor();
template <typename T>
const ::std::string& MovementError_ErrorCode_Name(T value) {
  static_assert(::std::is_same<T, MovementError_ErrorCode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ErrorCode_Name().");
  return MovementError_ErrorCode_Name(static_cast<MovementError_ErrorCode>(value));
}
template <>
inline const ::std::string& MovementError_ErrorCode_Name(MovementError_ErrorCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MovementError_ErrorCode_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool MovementError_ErrorCode_Parse(
    ::absl::string_view name, MovementError_ErrorCode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MovementError_ErrorCode>(MovementError_ErrorCode_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class TurnChangeEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.TurnChangeEvent) */ {
 public:
  inline TurnChangeEvent() : TurnChangeEvent(nullptr) {}
  ~TurnChangeEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TurnChangeEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TurnChangeEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TurnChangeEvent(::google::protobuf::internal::ConstantInitialized);

  inline TurnChangeEvent(const TurnChangeEvent& from) : TurnChangeEvent(nullptr, from) {}
  inline TurnChangeEvent(TurnChangeEvent&& from) noexcept
      : TurnChangeEvent(nullptr, ::std::move(from)) {}
  inline TurnChangeEvent& operator=(const TurnChangeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnChangeEvent& operator=(TurnChangeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnChangeEvent& default_instance() {
    return *reinterpret_cast<const TurnChangeEvent*>(
        &_TurnChangeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(TurnChangeEvent& a, TurnChangeEvent& b) { a.Swap(&b); }
  inline void Swap(TurnChangeEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnChangeEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnChangeEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TurnChangeEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TurnChangeEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TurnChangeEvent& from) { TurnChangeEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TurnChangeEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.TurnChangeEvent"; }

  explicit TurnChangeEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TurnChangeEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TurnChangeEvent& from);
  TurnChangeEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TurnChangeEvent&& from) noexcept
      : TurnChangeEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPreviousEntityIdFieldNumber = 1,
    kNextEntityIdFieldNumber = 2,
    kRoundFieldNumber = 3,
    kNewRoundFieldNumber = 4,
  };
  // string previous_entity_id = 1 [json_name = "previousEntityId"];
  void clear_previous_entity_id() ;
  const ::std::string& previous_entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_previous_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_previous_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_previous_entity_id();
  void set_allocated_previous_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_previous_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_previous_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_previous_entity_id();

  public:
  // string next_entity_id = 2 [json_name = "nextEntityId"];
  void clear_next_entity_id() ;
  const ::std::string& next_entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_next_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_next_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_next_entity_id();
  void set_allocated_next_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_next_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_next_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_next_entity_id();

  public:
  // int32 round = 3 [json_name = "round"];
  void clear_round() ;
  ::int32_t round() const;
  void set_round(::int32_t value);

  private:
  ::int32_t _internal_round() const;
  void _internal_set_round(::int32_t value);

  public:
  // bool new_round = 4 [json_name = "newRound"];
  void clear_new_round() ;
  bool new_round() const;
  void set_new_round(bool value);

  private:
  bool _internal_new_round() const;
  void _internal_set_new_round(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.TurnChangeEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 75,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TurnChangeEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr previous_entity_id_;
    ::google::protobuf::internal::ArenaStringPtr next_entity_id_;
    ::int32_t round_;
    bool new_round_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TurnChangeEvent_class_data_;
// -------------------------------------------------------------------

class RerollEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.RerollEvent) */ {
 public:
  inline RerollEvent() : RerollEvent(nullptr) {}
  ~RerollEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RerollEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RerollEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RerollEvent(::google::protobuf::internal::ConstantInitialized);

  inline RerollEvent(const RerollEvent& from) : RerollEvent(nullptr, from) {}
  inline RerollEvent(RerollEvent&& from) noexcept
      : RerollEvent(nullptr, ::std::move(from)) {}
  inline RerollEvent& operator=(const RerollEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RerollEvent& operator=(RerollEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RerollEvent& default_instance() {
    return *reinterpret_cast<const RerollEvent*>(
        &_RerollEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(RerollEvent& a, RerollEvent& b) { a.Swap(&b); }
  inline void Swap(RerollEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RerollEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RerollEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RerollEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RerollEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RerollEvent& from) { RerollEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RerollEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.RerollEvent"; }

  explicit RerollEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RerollEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RerollEvent& from);
  RerollEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RerollEvent&& from) noexcept
      : RerollEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 4,
    kDieIndexFieldNumber = 1,
    kBeforeFieldNumber = 2,
    kAfterFieldNumber = 3,
  };
  // string reason = 4 [json_name = "reason"];
  void clear_reason() ;
  const ::std::string& reason() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_reason();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_reason();
  void set_allocated_reason(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_reason() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_reason();

  public:
  // int32 die_index = 1 [json_name = "dieIndex"];
  void clear_die_index() ;
  ::int32_t die_index() const;
  void set_die_index(::int32_t value);

  private:
  ::int32_t _internal_die_index() const;
  void _internal_set_die_index(::int32_t value);

  public:
  // int32 before = 2 [json_name = "before"];
  void clear_before() ;
  ::int32_t before() const;
  void set_before(::int32_t value);

  private:
  ::int32_t _internal_before() const;
  void _internal_set_before(::int32_t value);

  public:
  // int32 after = 3 [json_name = "after"];
  void clear_after() ;
  ::int32_t after() const;
  void set_after(::int32_t value);

  private:
  ::int32_t _internal_after() const;
  void _internal_set_after(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.RerollEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 45,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RerollEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::int32_t die_index_;
    ::int32_t before_;
    ::int32_t after_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RerollEvent_class_data_;
// -------------------------------------------------------------------

class MovementError_DetailsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::std::string,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  MovementError_DetailsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MovementError_DetailsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit MovementError_DetailsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_MovementError_DetailsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 62,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull MovementError_DetailsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class InitiativeEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.InitiativeEntry) */ {
 public:
  inline InitiativeEntry() : InitiativeEntry(nullptr) {}
  ~InitiativeEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InitiativeEntry* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InitiativeEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InitiativeEntry(::google::protobuf::internal::ConstantInitialized);

  inline InitiativeEntry(const InitiativeEntry& from) : InitiativeEntry(nullptr, from) {}
  inline InitiativeEntry(InitiativeEntry&& from) noexcept
      : InitiativeEntry(nullptr, ::std::move(from)) {}
  inline InitiativeEntry& operator=(const InitiativeEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitiativeEntry& operator=(InitiativeEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitiativeEntry& default_instance() {
    return *reinterpret_cast<const InitiativeEntry*>(
        &_InitiativeEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(InitiativeEntry& a, InitiativeEntry& b) { a.Swap(&b); }
  inline void Swap(InitiativeEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitiativeEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitiativeEntry* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InitiativeEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InitiativeEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InitiativeEntry& from) { InitiativeEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InitiativeEntry* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.InitiativeEntry"; }

  explicit InitiativeEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InitiativeEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InitiativeEntry& from);
  InitiativeEntry(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InitiativeEntry&& from) noexcept
      : InitiativeEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kEntityTypeFieldNumber = 2,
    kInitiativeFieldNumber = 3,
    kModifierFieldNumber = 4,
    kHasActedFieldNumber = 5,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // string entity_type = 2 [json_name = "entityType"];
  void clear_entity_type() ;
  const ::std::string& entity_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_type();
  void set_allocated_entity_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_type();

  public:
  // int32 initiative = 3 [json_name = "initiative"];
  void clear_initiative() ;
  ::int32_t initiative() const;
  void set_initiative(::int32_t value);

  private:
  ::int32_t _internal_initiative() const;
  void _internal_set_initiative(::int32_t value);

  public:
  // int32 modifier = 4 [json_name = "modifier"];
  void clear_modifier() ;
  ::int32_t modifier() const;
  void set_modifier(::int32_t value);

  private:
  ::int32_t _internal_modifier() const;
  void _internal_set_modifier(::int32_t value);

  public:
  // bool has_acted = 5 [json_name = "hasActed"];
  void clear_has_acted() ;
  bool has_acted() const;
  void set_has_acted(bool value);

  private:
  bool _internal_has_acted() const;
  void _internal_set_has_acted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.InitiativeEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 63,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InitiativeEntry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr entity_type_;
    ::int32_t initiative_;
    ::int32_t modifier_;
    bool has_acted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InitiativeEntry_class_data_;
// -------------------------------------------------------------------

class GetCombatStateRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetCombatStateRequest) */ {
 public:
  inline GetCombatStateRequest() : GetCombatStateRequest(nullptr) {}
  ~GetCombatStateRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCombatStateRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCombatStateRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCombatStateRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetCombatStateRequest(const GetCombatStateRequest& from) : GetCombatStateRequest(nullptr, from) {}
  inline GetCombatStateRequest(GetCombatStateRequest&& from) noexcept
      : GetCombatStateRequest(nullptr, ::std::move(from)) {}
  inline GetCombatStateRequest& operator=(const GetCombatStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCombatStateRequest& operator=(GetCombatStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCombatStateRequest& default_instance() {
    return *reinterpret_cast<const GetCombatStateRequest*>(
        &_GetCombatStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(GetCombatStateRequest& a, GetCombatStateRequest& b) { a.Swap(&b); }
  inline void Swap(GetCombatStateRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCombatStateRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCombatStateRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCombatStateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCombatStateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCombatStateRequest& from) { GetCombatStateRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCombatStateRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetCombatStateRequest"; }

  explicit GetCombatStateRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCombatStateRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCombatStateRequest& from);
  GetCombatStateRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCombatStateRequest&& from) noexcept
      : GetCombatStateRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetCombatStateRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 61,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCombatStateRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCombatStateRequest_class_data_;
// -------------------------------------------------------------------

class EndTurnRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EndTurnRequest) */ {
 public:
  inline EndTurnRequest() : EndTurnRequest(nullptr) {}
  ~EndTurnRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EndTurnRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EndTurnRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EndTurnRequest(::google::protobuf::internal::ConstantInitialized);

  inline EndTurnRequest(const EndTurnRequest& from) : EndTurnRequest(nullptr, from) {}
  inline EndTurnRequest(EndTurnRequest&& from) noexcept
      : EndTurnRequest(nullptr, ::std::move(from)) {}
  inline EndTurnRequest& operator=(const EndTurnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndTurnRequest& operator=(EndTurnRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndTurnRequest& default_instance() {
    return *reinterpret_cast<const EndTurnRequest*>(
        &_EndTurnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(EndTurnRequest& a, EndTurnRequest& b) { a.Swap(&b); }
  inline void Swap(EndTurnRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndTurnRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndTurnRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EndTurnRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EndTurnRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EndTurnRequest& from) { EndTurnRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EndTurnRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EndTurnRequest"; }

  explicit EndTurnRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EndTurnRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EndTurnRequest& from);
  EndTurnRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EndTurnRequest&& from) noexcept
      : EndTurnRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kEntityIdFieldNumber = 2,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string entity_id = 2 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EndTurnRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 63,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EndTurnRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EndTurnRequest_class_data_;
// -------------------------------------------------------------------

class DungeonStartRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DungeonStartRequest) */ {
 public:
  inline DungeonStartRequest() : DungeonStartRequest(nullptr) {}
  ~DungeonStartRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DungeonStartRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DungeonStartRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DungeonStartRequest(::google::protobuf::internal::ConstantInitialized);

  inline DungeonStartRequest(const DungeonStartRequest& from) : DungeonStartRequest(nullptr, from) {}
  inline DungeonStartRequest(DungeonStartRequest&& from) noexcept
      : DungeonStartRequest(nullptr, ::std::move(from)) {}
  inline DungeonStartRequest& operator=(const DungeonStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonStartRequest& operator=(DungeonStartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonStartRequest& default_instance() {
    return *reinterpret_cast<const DungeonStartRequest*>(
        &_DungeonStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(DungeonStartRequest& a, DungeonStartRequest& b) { a.Swap(&b); }
  inline void Swap(DungeonStartRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonStartRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonStartRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DungeonStartRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DungeonStartRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DungeonStartRequest& from) { DungeonStartRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DungeonStartRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DungeonStartRequest"; }

  explicit DungeonStartRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DungeonStartRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DungeonStartRequest& from);
  DungeonStartRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DungeonStartRequest&& from) noexcept
      : DungeonStartRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterIdsFieldNumber = 1,
  };
  // repeated string character_ids = 1 [json_name = "characterIds"];
  int character_ids_size() const;
  private:
  int _internal_character_ids_size() const;

  public:
  void clear_character_ids() ;
  const ::std::string& character_ids(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_character_ids(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_ids(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_character_ids();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_character_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& character_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_character_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_character_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_character_ids();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DungeonStartRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DungeonStartRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> character_ids_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DungeonStartRequest_class_data_;
// -------------------------------------------------------------------

class AttackRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AttackRequest) */ {
 public:
  inline AttackRequest() : AttackRequest(nullptr) {}
  ~AttackRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackRequest(::google::protobuf::internal::ConstantInitialized);

  inline AttackRequest(const AttackRequest& from) : AttackRequest(nullptr, from) {}
  inline AttackRequest(AttackRequest&& from) noexcept
      : AttackRequest(nullptr, ::std::move(from)) {}
  inline AttackRequest& operator=(const AttackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackRequest& operator=(AttackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackRequest& default_instance() {
    return *reinterpret_cast<const AttackRequest*>(
        &_AttackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(AttackRequest& a, AttackRequest& b) { a.Swap(&b); }
  inline void Swap(AttackRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackRequest& from) { AttackRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AttackRequest"; }

  explicit AttackRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AttackRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AttackRequest& from);
  AttackRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AttackRequest&& from) noexcept
      : AttackRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kAttackerIdFieldNumber = 2,
    kTargetIdFieldNumber = 3,
    kWeaponIdFieldNumber = 4,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string attacker_id = 2 [json_name = "attackerId"];
  void clear_attacker_id() ;
  const ::std::string& attacker_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_attacker_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_attacker_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_attacker_id();
  void set_allocated_attacker_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_attacker_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_attacker_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_attacker_id();

  public:
  // string target_id = 3 [json_name = "targetId"];
  void clear_target_id() ;
  const ::std::string& target_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_target_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_target_id();
  void set_allocated_target_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_target_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_target_id();

  public:
  // string weapon_id = 4 [json_name = "weaponId"];
  void clear_weapon_id() ;
  const ::std::string& weapon_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_weapon_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_weapon_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_weapon_id();
  void set_allocated_weapon_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_weapon_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_weapon_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_weapon_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AttackRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 82,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AttackRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr attacker_id_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    ::google::protobuf::internal::ArenaStringPtr weapon_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AttackRequest_class_data_;
// -------------------------------------------------------------------

class ActivateFeatureRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ActivateFeatureRequest) */ {
 public:
  inline ActivateFeatureRequest() : ActivateFeatureRequest(nullptr) {}
  ~ActivateFeatureRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActivateFeatureRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActivateFeatureRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActivateFeatureRequest(::google::protobuf::internal::ConstantInitialized);

  inline ActivateFeatureRequest(const ActivateFeatureRequest& from) : ActivateFeatureRequest(nullptr, from) {}
  inline ActivateFeatureRequest(ActivateFeatureRequest&& from) noexcept
      : ActivateFeatureRequest(nullptr, ::std::move(from)) {}
  inline ActivateFeatureRequest& operator=(const ActivateFeatureRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivateFeatureRequest& operator=(ActivateFeatureRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivateFeatureRequest& default_instance() {
    return *reinterpret_cast<const ActivateFeatureRequest*>(
        &_ActivateFeatureRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(ActivateFeatureRequest& a, ActivateFeatureRequest& b) { a.Swap(&b); }
  inline void Swap(ActivateFeatureRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivateFeatureRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivateFeatureRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActivateFeatureRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActivateFeatureRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActivateFeatureRequest& from) { ActivateFeatureRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActivateFeatureRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ActivateFeatureRequest"; }

  explicit ActivateFeatureRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ActivateFeatureRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ActivateFeatureRequest& from);
  ActivateFeatureRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ActivateFeatureRequest&& from) noexcept
      : ActivateFeatureRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kCharacterIdFieldNumber = 2,
    kFeatureIdFieldNumber = 3,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string character_id = 2 [json_name = "characterId"];
  void clear_character_id() ;
  const ::std::string& character_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_character_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_character_id();
  void set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_character_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_character_id();

  public:
  // string feature_id = 3 [json_name = "featureId"];
  void clear_feature_id() ;
  const ::std::string& feature_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_feature_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_feature_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_feature_id();
  void set_allocated_feature_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_feature_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_feature_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_feature_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ActivateFeatureRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 84,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ActivateFeatureRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    ::google::protobuf::internal::ArenaStringPtr feature_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ActivateFeatureRequest_class_data_;
// -------------------------------------------------------------------

class TurnState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.TurnState) */ {
 public:
  inline TurnState() : TurnState(nullptr) {}
  ~TurnState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TurnState* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TurnState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TurnState(::google::protobuf::internal::ConstantInitialized);

  inline TurnState(const TurnState& from) : TurnState(nullptr, from) {}
  inline TurnState(TurnState&& from) noexcept
      : TurnState(nullptr, ::std::move(from)) {}
  inline TurnState& operator=(const TurnState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnState& operator=(TurnState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnState& default_instance() {
    return *reinterpret_cast<const TurnState*>(
        &_TurnState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(TurnState& a, TurnState& b) { a.Swap(&b); }
  inline void Swap(TurnState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TurnState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TurnState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TurnState& from) { TurnState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TurnState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.TurnState"; }

  explicit TurnState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TurnState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TurnState& from);
  TurnState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TurnState&& from) noexcept
      : TurnState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kPositionFieldNumber = 7,
    kMovementUsedFieldNumber = 2,
    kMovementMaxFieldNumber = 3,
    kActionUsedFieldNumber = 4,
    kBonusActionUsedFieldNumber = 5,
    kReactionAvailableFieldNumber = 6,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // .api.v1alpha1.Position position = 7 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::api::v1alpha1::Position& position() const;
  [[nodiscard]] ::api::v1alpha1::Position* PROTOBUF_NULLABLE release_position();
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  ::api::v1alpha1::Position* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::api::v1alpha1::Position& _internal_position() const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // int32 movement_used = 2 [json_name = "movementUsed"];
  void clear_movement_used() ;
  ::int32_t movement_used() const;
  void set_movement_used(::int32_t value);

  private:
  ::int32_t _internal_movement_used() const;
  void _internal_set_movement_used(::int32_t value);

  public:
  // int32 movement_max = 3 [json_name = "movementMax"];
  void clear_movement_max() ;
  ::int32_t movement_max() const;
  void set_movement_max(::int32_t value);

  private:
  ::int32_t _internal_movement_max() const;
  void _internal_set_movement_max(::int32_t value);

  public:
  // bool action_used = 4 [json_name = "actionUsed"];
  void clear_action_used() ;
  bool action_used() const;
  void set_action_used(bool value);

  private:
  bool _internal_action_used() const;
  void _internal_set_action_used(bool value);

  public:
  // bool bonus_action_used = 5 [json_name = "bonusActionUsed"];
  void clear_bonus_action_used() ;
  bool bonus_action_used() const;
  void set_bonus_action_used(bool value);

  private:
  bool _internal_bonus_action_used() const;
  void _internal_set_bonus_action_used(bool value);

  public:
  // bool reaction_available = 6 [json_name = "reactionAvailable"];
  void clear_reaction_available() ;
  bool reaction_available() const;
  void set_reaction_available(bool value);

  private:
  bool _internal_reaction_available() const;
  void _internal_set_reaction_available(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.TurnState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   1, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TurnState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE position_;
    ::int32_t movement_used_;
    ::int32_t movement_max_;
    bool action_used_;
    bool bonus_action_used_;
    bool reaction_available_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TurnState_class_data_;
// -------------------------------------------------------------------

class MovementError final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MovementError) */ {
 public:
  inline MovementError() : MovementError(nullptr) {}
  ~MovementError() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MovementError* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MovementError));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MovementError(::google::protobuf::internal::ConstantInitialized);

  inline MovementError(const MovementError& from) : MovementError(nullptr, from) {}
  inline MovementError(MovementError&& from) noexcept
      : MovementError(nullptr, ::std::move(from)) {}
  inline MovementError& operator=(const MovementError& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovementError& operator=(MovementError&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovementError& default_instance() {
    return *reinterpret_cast<const MovementError*>(
        &_MovementError_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(MovementError& a, MovementError& b) { a.Swap(&b); }
  inline void Swap(MovementError* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovementError* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MovementError* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MovementError>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MovementError& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MovementError& from) { MovementError::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MovementError* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MovementError"; }

  explicit MovementError(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MovementError(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MovementError& from);
  MovementError(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MovementError&& from) noexcept
      : MovementError(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ErrorCode = MovementError_ErrorCode;
  static constexpr ErrorCode ERROR_CODE_UNSPECIFIED = MovementError_ErrorCode_ERROR_CODE_UNSPECIFIED;
  static constexpr ErrorCode ERROR_CODE_INVALID_POSITION = MovementError_ErrorCode_ERROR_CODE_INVALID_POSITION;
  static constexpr ErrorCode ERROR_CODE_INSUFFICIENT_MOVEMENT = MovementError_ErrorCode_ERROR_CODE_INSUFFICIENT_MOVEMENT;
  static constexpr ErrorCode ERROR_CODE_PATH_BLOCKED = MovementError_ErrorCode_ERROR_CODE_PATH_BLOCKED;
  static constexpr ErrorCode ERROR_CODE_POSITION_OCCUPIED = MovementError_ErrorCode_ERROR_CODE_POSITION_OCCUPIED;
  static constexpr ErrorCode ERROR_CODE_OUT_OF_BOUNDS = MovementError_ErrorCode_ERROR_CODE_OUT_OF_BOUNDS;
  static constexpr ErrorCode ERROR_CODE_NOT_YOUR_TURN = MovementError_ErrorCode_ERROR_CODE_NOT_YOUR_TURN;
  static inline bool ErrorCode_IsValid(int value) {
    return MovementError_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN = MovementError_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX = MovementError_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE = MovementError_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ErrorCode_descriptor() {
    return MovementError_ErrorCode_descriptor();
  }
  template <typename T>
  static inline const ::std::string& ErrorCode_Name(T value) {
    return MovementError_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(
      ::absl::string_view name, ErrorCode* PROTOBUF_NONNULL value) {
    return MovementError_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
    kDetailsFieldNumber = 3,
  };
  // string message = 2 [json_name = "message"];
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // .dnd5e.api.v1alpha1.MovementError.ErrorCode code = 1 [json_name = "code"];
  void clear_code() ;
  ::dnd5e::api::v1alpha1::MovementError_ErrorCode code() const;
  void set_code(::dnd5e::api::v1alpha1::MovementError_ErrorCode value);

  private:
  ::dnd5e::api::v1alpha1::MovementError_ErrorCode _internal_code() const;
  void _internal_set_code(::dnd5e::api::v1alpha1::MovementError_ErrorCode value);

  public:
  // map<string, string> details = 3 [json_name = "details"];
  int details_size() const;
  private:
  int _internal_details_size() const;

  public:
  void clear_details() ;
  const ::google::protobuf::Map<::std::string, ::std::string>& details() const;
  ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL mutable_details();

  private:
  const ::google::protobuf::Map<::std::string, ::std::string>& _internal_details() const;
  ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL _internal_mutable_details();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MovementError)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 3,
                                   1, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MovementError& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    int code_;
    ::google::protobuf::internal::MapField<MovementError_DetailsEntry_DoNotUse, ::std::string, ::std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        details_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MovementError_class_data_;
// -------------------------------------------------------------------

class MoveCharacterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MoveCharacterRequest) */ {
 public:
  inline MoveCharacterRequest() : MoveCharacterRequest(nullptr) {}
  ~MoveCharacterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MoveCharacterRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MoveCharacterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveCharacterRequest(::google::protobuf::internal::ConstantInitialized);

  inline MoveCharacterRequest(const MoveCharacterRequest& from) : MoveCharacterRequest(nullptr, from) {}
  inline MoveCharacterRequest(MoveCharacterRequest&& from) noexcept
      : MoveCharacterRequest(nullptr, ::std::move(from)) {}
  inline MoveCharacterRequest& operator=(const MoveCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveCharacterRequest& operator=(MoveCharacterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveCharacterRequest& default_instance() {
    return *reinterpret_cast<const MoveCharacterRequest*>(
        &_MoveCharacterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(MoveCharacterRequest& a, MoveCharacterRequest& b) { a.Swap(&b); }
  inline void Swap(MoveCharacterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveCharacterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveCharacterRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MoveCharacterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveCharacterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveCharacterRequest& from) { MoveCharacterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MoveCharacterRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MoveCharacterRequest"; }

  explicit MoveCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MoveCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MoveCharacterRequest& from);
  MoveCharacterRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MoveCharacterRequest&& from) noexcept
      : MoveCharacterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 3,
    kEncounterIdFieldNumber = 1,
    kEntityIdFieldNumber = 2,
  };
  // repeated .api.v1alpha1.Position path = 3 [json_name = "path"];
  int path_size() const;
  private:
  int _internal_path_size() const;

  public:
  void clear_path() ;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_path(int index);
  ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL mutable_path();

  private:
  const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>& _internal_path() const;
  ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL _internal_mutable_path();
  public:
  const ::api::v1alpha1::Position& path(int index) const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL add_path();
  const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>& path() const;
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string entity_id = 2 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MoveCharacterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 69,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MoveCharacterRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::api::v1alpha1::Position > path_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MoveCharacterRequest_class_data_;
// -------------------------------------------------------------------

class EntityPlacement final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EntityPlacement) */ {
 public:
  inline EntityPlacement() : EntityPlacement(nullptr) {}
  ~EntityPlacement() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EntityPlacement* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EntityPlacement));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntityPlacement(::google::protobuf::internal::ConstantInitialized);

  inline EntityPlacement(const EntityPlacement& from) : EntityPlacement(nullptr, from) {}
  inline EntityPlacement(EntityPlacement&& from) noexcept
      : EntityPlacement(nullptr, ::std::move(from)) {}
  inline EntityPlacement& operator=(const EntityPlacement& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityPlacement& operator=(EntityPlacement&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityPlacement& default_instance() {
    return *reinterpret_cast<const EntityPlacement*>(
        &_EntityPlacement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(EntityPlacement& a, EntityPlacement& b) { a.Swap(&b); }
  inline void Swap(EntityPlacement* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityPlacement* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityPlacement* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EntityPlacement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntityPlacement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntityPlacement& from) { EntityPlacement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EntityPlacement* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EntityPlacement"; }

  explicit EntityPlacement(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EntityPlacement(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EntityPlacement& from);
  EntityPlacement(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EntityPlacement&& from) noexcept
      : EntityPlacement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kEntityTypeFieldNumber = 2,
    kPositionFieldNumber = 3,
    kSizeFieldNumber = 4,
    kBlocksMovementFieldNumber = 5,
    kBlocksLineOfSightFieldNumber = 6,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // string entity_type = 2 [json_name = "entityType"];
  void clear_entity_type() ;
  const ::std::string& entity_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_type();
  void set_allocated_entity_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_type();

  public:
  // .api.v1alpha1.Position position = 3 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::api::v1alpha1::Position& position() const;
  [[nodiscard]] ::api::v1alpha1::Position* PROTOBUF_NULLABLE release_position();
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  ::api::v1alpha1::Position* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::api::v1alpha1::Position& _internal_position() const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // int32 size = 4 [json_name = "size"];
  void clear_size() ;
  ::int32_t size() const;
  void set_size(::int32_t value);

  private:
  ::int32_t _internal_size() const;
  void _internal_set_size(::int32_t value);

  public:
  // bool blocks_movement = 5 [json_name = "blocksMovement"];
  void clear_blocks_movement() ;
  bool blocks_movement() const;
  void set_blocks_movement(bool value);

  private:
  bool _internal_blocks_movement() const;
  void _internal_set_blocks_movement(bool value);

  public:
  // bool blocks_line_of_sight = 6 [json_name = "blocksLineOfSight"];
  void clear_blocks_line_of_sight() ;
  bool blocks_line_of_sight() const;
  void set_blocks_line_of_sight(bool value);

  private:
  bool _internal_blocks_line_of_sight() const;
  void _internal_set_blocks_line_of_sight(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EntityPlacement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   1, 63,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EntityPlacement& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr entity_type_;
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE position_;
    ::int32_t size_;
    bool blocks_movement_;
    bool blocks_line_of_sight_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EntityPlacement_class_data_;
// -------------------------------------------------------------------

class DamageComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DamageComponent) */ {
 public:
  inline DamageComponent() : DamageComponent(nullptr) {}
  ~DamageComponent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DamageComponent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DamageComponent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DamageComponent(::google::protobuf::internal::ConstantInitialized);

  inline DamageComponent(const DamageComponent& from) : DamageComponent(nullptr, from) {}
  inline DamageComponent(DamageComponent&& from) noexcept
      : DamageComponent(nullptr, ::std::move(from)) {}
  inline DamageComponent& operator=(const DamageComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DamageComponent& operator=(DamageComponent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DamageComponent& default_instance() {
    return *reinterpret_cast<const DamageComponent*>(
        &_DamageComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(DamageComponent& a, DamageComponent& b) { a.Swap(&b); }
  inline void Swap(DamageComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DamageComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DamageComponent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DamageComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DamageComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DamageComponent& from) { DamageComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DamageComponent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DamageComponent"; }

  explicit DamageComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DamageComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DamageComponent& from);
  DamageComponent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DamageComponent&& from) noexcept
      : DamageComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOriginalDiceRollsFieldNumber = 2,
    kFinalDiceRollsFieldNumber = 3,
    kRerollsFieldNumber = 4,
    kSourceFieldNumber = 1,
    kDamageTypeFieldNumber = 6,
    kSourceRefFieldNumber = 8,
    kFlatBonusFieldNumber = 5,
    kIsCriticalFieldNumber = 7,
  };
  // repeated int32 original_dice_rolls = 2 [json_name = "originalDiceRolls"];
  int original_dice_rolls_size() const;
  private:
  int _internal_original_dice_rolls_size() const;

  public:
  void clear_original_dice_rolls() ;
  ::int32_t original_dice_rolls(int index) const;
  void set_original_dice_rolls(int index, ::int32_t value);
  void add_original_dice_rolls(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& original_dice_rolls() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_original_dice_rolls();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_original_dice_rolls() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_original_dice_rolls();

  public:
  // repeated int32 final_dice_rolls = 3 [json_name = "finalDiceRolls"];
  int final_dice_rolls_size() const;
  private:
  int _internal_final_dice_rolls_size() const;

  public:
  void clear_final_dice_rolls() ;
  ::int32_t final_dice_rolls(int index) const;
  void set_final_dice_rolls(int index, ::int32_t value);
  void add_final_dice_rolls(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& final_dice_rolls() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_final_dice_rolls();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_final_dice_rolls() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_final_dice_rolls();

  public:
  // repeated .dnd5e.api.v1alpha1.RerollEvent rerolls = 4 [json_name = "rerolls"];
  int rerolls_size() const;
  private:
  int _internal_rerolls_size() const;

  public:
  void clear_rerolls() ;
  ::dnd5e::api::v1alpha1::RerollEvent* PROTOBUF_NONNULL mutable_rerolls(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>* PROTOBUF_NONNULL mutable_rerolls();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>& _internal_rerolls() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>* PROTOBUF_NONNULL _internal_mutable_rerolls();
  public:
  const ::dnd5e::api::v1alpha1::RerollEvent& rerolls(int index) const;
  ::dnd5e::api::v1alpha1::RerollEvent* PROTOBUF_NONNULL add_rerolls();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>& rerolls() const;
  // string source = 1 [json_name = "source", deprecated = true];
  [[deprecated]]  void clear_source() ;
  [[deprecated]] const ::std::string& source() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  [[deprecated]] void set_source(Arg_&& arg, Args_... args);
  [[deprecated]] ::std::string* PROTOBUF_NONNULL mutable_source();
  [[deprecated]] [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_source();
  [[deprecated]] void set_allocated_source(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_source() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_source(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_source();

  public:
  // string damage_type = 6 [json_name = "damageType"];
  void clear_damage_type() ;
  const ::std::string& damage_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_damage_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_damage_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_damage_type();
  void set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_damage_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_damage_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_damage_type();

  public:
  // .dnd5e.api.v1alpha1.SourceRef source_ref = 8 [json_name = "sourceRef"];
  bool has_source_ref() const;
  void clear_source_ref() ;
  const ::dnd5e::api::v1alpha1::SourceRef& source_ref() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE release_source_ref();
  ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NONNULL mutable_source_ref();
  void set_allocated_source_ref(::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_source_ref(::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE unsafe_arena_release_source_ref();

  private:
  const ::dnd5e::api::v1alpha1::SourceRef& _internal_source_ref() const;
  ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NONNULL _internal_mutable_source_ref();

  public:
  // int32 flat_bonus = 5 [json_name = "flatBonus"];
  void clear_flat_bonus() ;
  ::int32_t flat_bonus() const;
  void set_flat_bonus(::int32_t value);

  private:
  ::int32_t _internal_flat_bonus() const;
  void _internal_set_flat_bonus(::int32_t value);

  public:
  // bool is_critical = 7 [json_name = "isCritical"];
  void clear_is_critical() ;
  bool is_critical() const;
  void set_is_critical(bool value);

  private:
  bool _internal_is_critical() const;
  void _internal_set_is_critical(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DamageComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   2, 68,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DamageComponent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> original_dice_rolls_;
    ::google::protobuf::internal::CachedSize _original_dice_rolls_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> final_dice_rolls_;
    ::google::protobuf::internal::CachedSize _final_dice_rolls_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::RerollEvent > rerolls_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    ::google::protobuf::internal::ArenaStringPtr damage_type_;
    ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE source_ref_;
    ::int32_t flat_bonus_;
    bool is_critical_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DamageComponent_class_data_;
// -------------------------------------------------------------------

class Room_EntitiesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  Room_EntitiesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Room_EntitiesEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit Room_EntitiesEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_Room_EntitiesEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 49,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull Room_EntitiesEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class DamageBreakdown final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DamageBreakdown) */ {
 public:
  inline DamageBreakdown() : DamageBreakdown(nullptr) {}
  ~DamageBreakdown() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DamageBreakdown* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DamageBreakdown));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DamageBreakdown(::google::protobuf::internal::ConstantInitialized);

  inline DamageBreakdown(const DamageBreakdown& from) : DamageBreakdown(nullptr, from) {}
  inline DamageBreakdown(DamageBreakdown&& from) noexcept
      : DamageBreakdown(nullptr, ::std::move(from)) {}
  inline DamageBreakdown& operator=(const DamageBreakdown& from) {
    CopyFrom(from);
    return *this;
  }
  inline DamageBreakdown& operator=(DamageBreakdown&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DamageBreakdown& default_instance() {
    return *reinterpret_cast<const DamageBreakdown*>(
        &_DamageBreakdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(DamageBreakdown& a, DamageBreakdown& b) { a.Swap(&b); }
  inline void Swap(DamageBreakdown* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DamageBreakdown* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DamageBreakdown* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DamageBreakdown>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DamageBreakdown& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DamageBreakdown& from) { DamageBreakdown::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DamageBreakdown* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DamageBreakdown"; }

  explicit DamageBreakdown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DamageBreakdown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DamageBreakdown& from);
  DamageBreakdown(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DamageBreakdown&& from) noexcept
      : DamageBreakdown(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentsFieldNumber = 1,
    kAbilityUsedFieldNumber = 2,
    kTotalDamageFieldNumber = 3,
  };
  // repeated .dnd5e.api.v1alpha1.DamageComponent components = 1 [json_name = "components"];
  int components_size() const;
  private:
  int _internal_components_size() const;

  public:
  void clear_components() ;
  ::dnd5e::api::v1alpha1::DamageComponent* PROTOBUF_NONNULL mutable_components(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>* PROTOBUF_NONNULL mutable_components();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>& _internal_components() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>* PROTOBUF_NONNULL _internal_mutable_components();
  public:
  const ::dnd5e::api::v1alpha1::DamageComponent& components(int index) const;
  ::dnd5e::api::v1alpha1::DamageComponent* PROTOBUF_NONNULL add_components();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>& components() const;
  // string ability_used = 2 [json_name = "abilityUsed"];
  void clear_ability_used() ;
  const ::std::string& ability_used() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_ability_used(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_ability_used();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_ability_used();
  void set_allocated_ability_used(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_ability_used() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_ability_used(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_ability_used();

  public:
  // int32 total_damage = 3 [json_name = "totalDamage"];
  void clear_total_damage() ;
  ::int32_t total_damage() const;
  void set_total_damage(::int32_t value);

  private:
  ::int32_t _internal_total_damage() const;
  void _internal_set_total_damage(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DamageBreakdown)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DamageBreakdown& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::DamageComponent > components_;
    ::google::protobuf::internal::ArenaStringPtr ability_used_;
    ::int32_t total_damage_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DamageBreakdown_class_data_;
// -------------------------------------------------------------------

class CombatState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CombatState) */ {
 public:
  inline CombatState() : CombatState(nullptr) {}
  ~CombatState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CombatState* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CombatState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CombatState(::google::protobuf::internal::ConstantInitialized);

  inline CombatState(const CombatState& from) : CombatState(nullptr, from) {}
  inline CombatState(CombatState&& from) noexcept
      : CombatState(nullptr, ::std::move(from)) {}
  inline CombatState& operator=(const CombatState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombatState& operator=(CombatState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombatState& default_instance() {
    return *reinterpret_cast<const CombatState*>(
        &_CombatState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(CombatState& a, CombatState& b) { a.Swap(&b); }
  inline void Swap(CombatState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombatState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombatState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CombatState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CombatState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CombatState& from) { CombatState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CombatState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CombatState"; }

  explicit CombatState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CombatState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CombatState& from);
  CombatState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CombatState&& from) noexcept
      : CombatState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTurnOrderFieldNumber = 3,
    kEncounterIdFieldNumber = 1,
    kCurrentTurnFieldNumber = 5,
    kRoundFieldNumber = 2,
    kActiveIndexFieldNumber = 4,
    kCombatStartedFieldNumber = 6,
    kCombatEndedFieldNumber = 7,
  };
  // repeated .dnd5e.api.v1alpha1.InitiativeEntry turn_order = 3 [json_name = "turnOrder"];
  int turn_order_size() const;
  private:
  int _internal_turn_order_size() const;

  public:
  void clear_turn_order() ;
  ::dnd5e::api::v1alpha1::InitiativeEntry* PROTOBUF_NONNULL mutable_turn_order(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>* PROTOBUF_NONNULL mutable_turn_order();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>& _internal_turn_order() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>* PROTOBUF_NONNULL _internal_mutable_turn_order();
  public:
  const ::dnd5e::api::v1alpha1::InitiativeEntry& turn_order(int index) const;
  ::dnd5e::api::v1alpha1::InitiativeEntry* PROTOBUF_NONNULL add_turn_order();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>& turn_order() const;
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // .dnd5e.api.v1alpha1.TurnState current_turn = 5 [json_name = "currentTurn"];
  bool has_current_turn() const;
  void clear_current_turn() ;
  const ::dnd5e::api::v1alpha1::TurnState& current_turn() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE release_current_turn();
  ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NONNULL mutable_current_turn();
  void set_allocated_current_turn(::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_current_turn(::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE unsafe_arena_release_current_turn();

  private:
  const ::dnd5e::api::v1alpha1::TurnState& _internal_current_turn() const;
  ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NONNULL _internal_mutable_current_turn();

  public:
  // int32 round = 2 [json_name = "round"];
  void clear_round() ;
  ::int32_t round() const;
  void set_round(::int32_t value);

  private:
  ::int32_t _internal_round() const;
  void _internal_set_round(::int32_t value);

  public:
  // int32 active_index = 4 [json_name = "activeIndex"];
  void clear_active_index() ;
  ::int32_t active_index() const;
  void set_active_index(::int32_t value);

  private:
  ::int32_t _internal_active_index() const;
  void _internal_set_active_index(::int32_t value);

  public:
  // bool combat_started = 6 [json_name = "combatStarted"];
  void clear_combat_started() ;
  bool combat_started() const;
  void set_combat_started(bool value);

  private:
  bool _internal_combat_started() const;
  void _internal_set_combat_started(bool value);

  public:
  // bool combat_ended = 7 [json_name = "combatEnded"];
  void clear_combat_ended() ;
  bool combat_ended() const;
  void set_combat_ended(bool value);

  private:
  bool _internal_combat_ended() const;
  void _internal_set_combat_ended(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CombatState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   2, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CombatState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::InitiativeEntry > turn_order_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE current_turn_;
    ::int32_t round_;
    ::int32_t active_index_;
    bool combat_started_;
    bool combat_ended_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CombatState_class_data_;
// -------------------------------------------------------------------

class Room final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.Room) */ {
 public:
  inline Room() : Room(nullptr) {}
  ~Room() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Room* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Room));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Room(::google::protobuf::internal::ConstantInitialized);

  inline Room(const Room& from) : Room(nullptr, from) {}
  inline Room(Room&& from) noexcept
      : Room(nullptr, ::std::move(from)) {}
  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room& operator=(Room&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Room& default_instance() {
    return *reinterpret_cast<const Room*>(
        &_Room_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Room& a, Room& b) { a.Swap(&b); }
  inline void Swap(Room* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Room>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Room& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Room& from) { Room::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Room* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.Room"; }

  explicit Room(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Room(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Room& from);
  Room(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Room&& from) noexcept
      : Room(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kGridTypeFieldNumber = 5,
    kHexOrientationFieldNumber = 6,
    kEntitiesFieldNumber = 7,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string type = 2 [json_name = "type"];
  void clear_type() ;
  const ::std::string& type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_type();
  void set_allocated_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_type();

  public:
  // int32 width = 3 [json_name = "width"];
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // int32 height = 4 [json_name = "height"];
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // .api.v1alpha1.GridType grid_type = 5 [json_name = "gridType"];
  void clear_grid_type() ;
  ::api::v1alpha1::GridType grid_type() const;
  void set_grid_type(::api::v1alpha1::GridType value);

  private:
  ::api::v1alpha1::GridType _internal_grid_type() const;
  void _internal_set_grid_type(::api::v1alpha1::GridType value);

  public:
  // optional bool hex_orientation = 6 [json_name = "hexOrientation"];
  bool has_hex_orientation() const;
  void clear_hex_orientation() ;
  bool hex_orientation() const;
  void set_hex_orientation(bool value);

  private:
  bool _internal_hex_orientation() const;
  void _internal_set_hex_orientation(bool value);

  public:
  // map<string, .dnd5e.api.v1alpha1.EntityPlacement> entities = 7 [json_name = "entities"];
  int entities_size() const;
  private:
  int _internal_entities_size() const;

  public:
  void clear_entities() ;
  const ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>& entities() const;
  ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>* PROTOBUF_NONNULL mutable_entities();

  private:
  const ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>& _internal_entities() const;
  ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>* PROTOBUF_NONNULL _internal_mutable_entities();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.Room)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   2, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Room& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::int32_t width_;
    ::int32_t height_;
    int grid_type_;
    bool hex_orientation_;
    ::google::protobuf::internal::MapField<Room_EntitiesEntry_DoNotUse, ::std::string, ::dnd5e::api::v1alpha1::EntityPlacement,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        entities_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Room_class_data_;
// -------------------------------------------------------------------

class EndTurnResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EndTurnResponse) */ {
 public:
  inline EndTurnResponse() : EndTurnResponse(nullptr) {}
  ~EndTurnResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EndTurnResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EndTurnResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EndTurnResponse(::google::protobuf::internal::ConstantInitialized);

  inline EndTurnResponse(const EndTurnResponse& from) : EndTurnResponse(nullptr, from) {}
  inline EndTurnResponse(EndTurnResponse&& from) noexcept
      : EndTurnResponse(nullptr, ::std::move(from)) {}
  inline EndTurnResponse& operator=(const EndTurnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndTurnResponse& operator=(EndTurnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndTurnResponse& default_instance() {
    return *reinterpret_cast<const EndTurnResponse*>(
        &_EndTurnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(EndTurnResponse& a, EndTurnResponse& b) { a.Swap(&b); }
  inline void Swap(EndTurnResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndTurnResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndTurnResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EndTurnResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EndTurnResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EndTurnResponse& from) { EndTurnResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EndTurnResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EndTurnResponse"; }

  explicit EndTurnResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EndTurnResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EndTurnResponse& from);
  EndTurnResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EndTurnResponse&& from) noexcept
      : EndTurnResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCombatStateFieldNumber = 2,
    kTurnChangeFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 3 [json_name = "turnChange"];
  bool has_turn_change() const;
  void clear_turn_change() ;
  const ::dnd5e::api::v1alpha1::TurnChangeEvent& turn_change() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE release_turn_change();
  ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL mutable_turn_change();
  void set_allocated_turn_change(::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_turn_change(::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE unsafe_arena_release_turn_change();

  private:
  const ::dnd5e::api::v1alpha1::TurnChangeEvent& _internal_turn_change() const;
  ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL _internal_mutable_turn_change();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EndTurnResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EndTurnResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE turn_change_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EndTurnResponse_class_data_;
// -------------------------------------------------------------------

class AttackResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AttackResult) */ {
 public:
  inline AttackResult() : AttackResult(nullptr) {}
  ~AttackResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackResult* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackResult(::google::protobuf::internal::ConstantInitialized);

  inline AttackResult(const AttackResult& from) : AttackResult(nullptr, from) {}
  inline AttackResult(AttackResult&& from) noexcept
      : AttackResult(nullptr, ::std::move(from)) {}
  inline AttackResult& operator=(const AttackResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackResult& operator=(AttackResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackResult& default_instance() {
    return *reinterpret_cast<const AttackResult*>(
        &_AttackResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(AttackResult& a, AttackResult& b) { a.Swap(&b); }
  inline void Swap(AttackResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackResult& from) { AttackResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AttackResult"; }

  explicit AttackResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AttackResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AttackResult& from);
  AttackResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AttackResult&& from) noexcept
      : AttackResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDamageTypeFieldNumber = 6,
    kDamageBreakdownFieldNumber = 8,
    kAttackRollFieldNumber = 2,
    kAttackTotalFieldNumber = 3,
    kTargetAcFieldNumber = 4,
    kHitFieldNumber = 1,
    kCriticalFieldNumber = 7,
    kDamageFieldNumber = 5,
  };
  // string damage_type = 6 [json_name = "damageType"];
  void clear_damage_type() ;
  const ::std::string& damage_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_damage_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_damage_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_damage_type();
  void set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_damage_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_damage_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_damage_type();

  public:
  // .dnd5e.api.v1alpha1.DamageBreakdown damage_breakdown = 8 [json_name = "damageBreakdown"];
  bool has_damage_breakdown() const;
  void clear_damage_breakdown() ;
  const ::dnd5e::api::v1alpha1::DamageBreakdown& damage_breakdown() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE release_damage_breakdown();
  ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NONNULL mutable_damage_breakdown();
  void set_allocated_damage_breakdown(::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_damage_breakdown(::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE unsafe_arena_release_damage_breakdown();

  private:
  const ::dnd5e::api::v1alpha1::DamageBreakdown& _internal_damage_breakdown() const;
  ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NONNULL _internal_mutable_damage_breakdown();

  public:
  // int32 attack_roll = 2 [json_name = "attackRoll"];
  void clear_attack_roll() ;
  ::int32_t attack_roll() const;
  void set_attack_roll(::int32_t value);

  private:
  ::int32_t _internal_attack_roll() const;
  void _internal_set_attack_roll(::int32_t value);

  public:
  // int32 attack_total = 3 [json_name = "attackTotal"];
  void clear_attack_total() ;
  ::int32_t attack_total() const;
  void set_attack_total(::int32_t value);

  private:
  ::int32_t _internal_attack_total() const;
  void _internal_set_attack_total(::int32_t value);

  public:
  // int32 target_ac = 4 [json_name = "targetAc"];
  void clear_target_ac() ;
  ::int32_t target_ac() const;
  void set_target_ac(::int32_t value);

  private:
  ::int32_t _internal_target_ac() const;
  void _internal_set_target_ac(::int32_t value);

  public:
  // bool hit = 1 [json_name = "hit"];
  void clear_hit() ;
  bool hit() const;
  void set_hit(bool value);

  private:
  bool _internal_hit() const;
  void _internal_set_hit(bool value);

  public:
  // bool critical = 7 [json_name = "critical"];
  void clear_critical() ;
  bool critical() const;
  void set_critical(bool value);

  private:
  bool _internal_critical() const;
  void _internal_set_critical(bool value);

  public:
  // int32 damage = 5 [json_name = "damage"];
  void clear_damage() ;
  ::int32_t damage() const;
  void set_damage(::int32_t value);

  private:
  ::int32_t _internal_damage() const;
  void _internal_set_damage(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AttackResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   1, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AttackResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr damage_type_;
    ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE damage_breakdown_;
    ::int32_t attack_roll_;
    ::int32_t attack_total_;
    ::int32_t target_ac_;
    bool hit_;
    bool critical_;
    ::int32_t damage_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AttackResult_class_data_;
// -------------------------------------------------------------------

class MoveCharacterResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MoveCharacterResponse) */ {
 public:
  inline MoveCharacterResponse() : MoveCharacterResponse(nullptr) {}
  ~MoveCharacterResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MoveCharacterResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MoveCharacterResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveCharacterResponse(::google::protobuf::internal::ConstantInitialized);

  inline MoveCharacterResponse(const MoveCharacterResponse& from) : MoveCharacterResponse(nullptr, from) {}
  inline MoveCharacterResponse(MoveCharacterResponse&& from) noexcept
      : MoveCharacterResponse(nullptr, ::std::move(from)) {}
  inline MoveCharacterResponse& operator=(const MoveCharacterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveCharacterResponse& operator=(MoveCharacterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveCharacterResponse& default_instance() {
    return *reinterpret_cast<const MoveCharacterResponse*>(
        &_MoveCharacterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(MoveCharacterResponse& a, MoveCharacterResponse& b) { a.Swap(&b); }
  inline void Swap(MoveCharacterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveCharacterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveCharacterResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MoveCharacterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveCharacterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveCharacterResponse& from) { MoveCharacterResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MoveCharacterResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MoveCharacterResponse"; }

  explicit MoveCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MoveCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MoveCharacterResponse& from);
  MoveCharacterResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MoveCharacterResponse&& from) noexcept
      : MoveCharacterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStopReasonFieldNumber = 5,
    kErrorFieldNumber = 2,
    kFinalPositionFieldNumber = 3,
    kUpdatedRoomFieldNumber = 6,
    kSuccessFieldNumber = 1,
    kMovementRemainingFieldNumber = 4,
  };
  // string stop_reason = 5 [json_name = "stopReason"];
  void clear_stop_reason() ;
  const ::std::string& stop_reason() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_stop_reason(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_stop_reason();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_stop_reason();
  void set_allocated_stop_reason(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_stop_reason() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_stop_reason(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_stop_reason();

  public:
  // .dnd5e.api.v1alpha1.MovementError error = 2 [json_name = "error"];
  bool has_error() const;
  void clear_error() ;
  const ::dnd5e::api::v1alpha1::MovementError& error() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE release_error();
  ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NONNULL mutable_error();
  void set_allocated_error(::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_error(::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE unsafe_arena_release_error();

  private:
  const ::dnd5e::api::v1alpha1::MovementError& _internal_error() const;
  ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
  bool has_final_position() const;
  void clear_final_position() ;
  const ::api::v1alpha1::Position& final_position() const;
  [[nodiscard]] ::api::v1alpha1::Position* PROTOBUF_NULLABLE release_final_position();
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_final_position();
  void set_allocated_final_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_final_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  ::api::v1alpha1::Position* PROTOBUF_NULLABLE unsafe_arena_release_final_position();

  private:
  const ::api::v1alpha1::Position& _internal_final_position() const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL _internal_mutable_final_position();

  public:
  // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
  bool has_updated_room() const;
  void clear_updated_room() ;
  const ::dnd5e::api::v1alpha1::Room& updated_room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_updated_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_updated_room();
  void set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_updated_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_updated_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_updated_room();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // int32 movement_remaining = 4 [json_name = "movementRemaining"];
  void clear_movement_remaining() ;
  ::int32_t movement_remaining() const;
  void set_movement_remaining(::int32_t value);

  private:
  ::int32_t _internal_movement_remaining() const;
  void _internal_set_movement_remaining(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MoveCharacterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   3, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MoveCharacterResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr stop_reason_;
    ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE error_;
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE final_position_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE updated_room_;
    bool success_;
    ::int32_t movement_remaining_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MoveCharacterResponse_class_data_;
// -------------------------------------------------------------------

class GetCombatStateResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetCombatStateResponse) */ {
 public:
  inline GetCombatStateResponse() : GetCombatStateResponse(nullptr) {}
  ~GetCombatStateResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCombatStateResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCombatStateResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCombatStateResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetCombatStateResponse(const GetCombatStateResponse& from) : GetCombatStateResponse(nullptr, from) {}
  inline GetCombatStateResponse(GetCombatStateResponse&& from) noexcept
      : GetCombatStateResponse(nullptr, ::std::move(from)) {}
  inline GetCombatStateResponse& operator=(const GetCombatStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCombatStateResponse& operator=(GetCombatStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCombatStateResponse& default_instance() {
    return *reinterpret_cast<const GetCombatStateResponse*>(
        &_GetCombatStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(GetCombatStateResponse& a, GetCombatStateResponse& b) { a.Swap(&b); }
  inline void Swap(GetCombatStateResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCombatStateResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCombatStateResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCombatStateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCombatStateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCombatStateResponse& from) { GetCombatStateResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCombatStateResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetCombatStateResponse"; }

  explicit GetCombatStateResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCombatStateResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCombatStateResponse& from);
  GetCombatStateResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCombatStateResponse&& from) noexcept
      : GetCombatStateResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoomFieldNumber = 1,
    kCombatStateFieldNumber = 2,
  };
  // .dnd5e.api.v1alpha1.Room room = 1 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetCombatStateResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCombatStateResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCombatStateResponse_class_data_;
// -------------------------------------------------------------------

class DungeonStartResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DungeonStartResponse) */ {
 public:
  inline DungeonStartResponse() : DungeonStartResponse(nullptr) {}
  ~DungeonStartResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DungeonStartResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DungeonStartResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DungeonStartResponse(::google::protobuf::internal::ConstantInitialized);

  inline DungeonStartResponse(const DungeonStartResponse& from) : DungeonStartResponse(nullptr, from) {}
  inline DungeonStartResponse(DungeonStartResponse&& from) noexcept
      : DungeonStartResponse(nullptr, ::std::move(from)) {}
  inline DungeonStartResponse& operator=(const DungeonStartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonStartResponse& operator=(DungeonStartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonStartResponse& default_instance() {
    return *reinterpret_cast<const DungeonStartResponse*>(
        &_DungeonStartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(DungeonStartResponse& a, DungeonStartResponse& b) { a.Swap(&b); }
  inline void Swap(DungeonStartResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonStartResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonStartResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DungeonStartResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DungeonStartResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DungeonStartResponse& from) { DungeonStartResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DungeonStartResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DungeonStartResponse"; }

  explicit DungeonStartResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DungeonStartResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DungeonStartResponse& from);
  DungeonStartResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DungeonStartResponse&& from) noexcept
      : DungeonStartResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kRoomFieldNumber = 2,
    kCombatStateFieldNumber = 3,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 3 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DungeonStartResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DungeonStartResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DungeonStartResponse_class_data_;
// -------------------------------------------------------------------

class AttackResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AttackResponse) */ {
 public:
  inline AttackResponse() : AttackResponse(nullptr) {}
  ~AttackResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackResponse(::google::protobuf::internal::ConstantInitialized);

  inline AttackResponse(const AttackResponse& from) : AttackResponse(nullptr, from) {}
  inline AttackResponse(AttackResponse&& from) noexcept
      : AttackResponse(nullptr, ::std::move(from)) {}
  inline AttackResponse& operator=(const AttackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackResponse& operator=(AttackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackResponse& default_instance() {
    return *reinterpret_cast<const AttackResponse*>(
        &_AttackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(AttackResponse& a, AttackResponse& b) { a.Swap(&b); }
  inline void Swap(AttackResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackResponse& from) { AttackResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AttackResponse"; }

  explicit AttackResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AttackResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AttackResponse& from);
  AttackResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AttackResponse&& from) noexcept
      : AttackResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 2,
    kResultFieldNumber = 3,
    kCombatStateFieldNumber = 4,
    kUpdatedRoomFieldNumber = 5,
    kSuccessFieldNumber = 1,
  };
  // string error = 2 [json_name = "error"];
  void clear_error() ;
  const ::std::string& error() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
  bool has_result() const;
  void clear_result() ;
  const ::dnd5e::api::v1alpha1::AttackResult& result() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE release_result();
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::dnd5e::api::v1alpha1::AttackResult& _internal_result() const;
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // .dnd5e.api.v1alpha1.Room updated_room = 5 [json_name = "updatedRoom"];
  bool has_updated_room() const;
  void clear_updated_room() ;
  const ::dnd5e::api::v1alpha1::Room& updated_room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_updated_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_updated_room();
  void set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_updated_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_updated_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_updated_room();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AttackResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   3, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AttackResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE result_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE updated_room_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AttackResponse_class_data_;
// -------------------------------------------------------------------

class ActivateFeatureResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ActivateFeatureResponse) */ {
 public:
  inline ActivateFeatureResponse() : ActivateFeatureResponse(nullptr) {}
  ~ActivateFeatureResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActivateFeatureResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActivateFeatureResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActivateFeatureResponse(::google::protobuf::internal::ConstantInitialized);

  inline ActivateFeatureResponse(const ActivateFeatureResponse& from) : ActivateFeatureResponse(nullptr, from) {}
  inline ActivateFeatureResponse(ActivateFeatureResponse&& from) noexcept
      : ActivateFeatureResponse(nullptr, ::std::move(from)) {}
  inline ActivateFeatureResponse& operator=(const ActivateFeatureResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivateFeatureResponse& operator=(ActivateFeatureResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivateFeatureResponse& default_instance() {
    return *reinterpret_cast<const ActivateFeatureResponse*>(
        &_ActivateFeatureResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(ActivateFeatureResponse& a, ActivateFeatureResponse& b) { a.Swap(&b); }
  inline void Swap(ActivateFeatureResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivateFeatureResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivateFeatureResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActivateFeatureResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActivateFeatureResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActivateFeatureResponse& from) { ActivateFeatureResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActivateFeatureResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ActivateFeatureResponse"; }

  explicit ActivateFeatureResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ActivateFeatureResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ActivateFeatureResponse& from);
  ActivateFeatureResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ActivateFeatureResponse&& from) noexcept
      : ActivateFeatureResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kUpdatedCharacterFieldNumber = 3,
    kUpdatedCombatStateFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string message = 2 [json_name = "message"];
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // .dnd5e.api.v1alpha1.Character updated_character = 3 [json_name = "updatedCharacter"];
  bool has_updated_character() const;
  void clear_updated_character() ;
  const ::dnd5e::api::v1alpha1::Character& updated_character() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_updated_character();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_updated_character();
  void set_allocated_updated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_updated_character();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_updated_character() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_updated_character();

  public:
  // .dnd5e.api.v1alpha1.CombatState updated_combat_state = 4 [json_name = "updatedCombatState"];
  bool has_updated_combat_state() const;
  void clear_updated_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& updated_combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_updated_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_updated_combat_state();
  void set_allocated_updated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_updated_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_updated_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_updated_combat_state();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ActivateFeatureResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ActivateFeatureResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE updated_character_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE updated_combat_state_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ActivateFeatureResponse_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EntityPlacement

// string entity_id = 1 [json_name = "entityId"];
inline void EntityPlacement::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& EntityPlacement::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EntityPlacement::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL EntityPlacement::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
  return _s;
}
inline const ::std::string& EntityPlacement::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void EntityPlacement::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EntityPlacement::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EntityPlacement::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void EntityPlacement::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
}

// string entity_type = 2 [json_name = "entityType"];
inline void EntityPlacement::clear_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& EntityPlacement::entity_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.entity_type)
  return _internal_entity_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EntityPlacement::set_entity_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.entity_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.entity_type)
}
inline ::std::string* PROTOBUF_NONNULL EntityPlacement::mutable_entity_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_entity_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EntityPlacement.entity_type)
  return _s;
}
inline const ::std::string& EntityPlacement::_internal_entity_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_type_.Get();
}
inline void EntityPlacement::_internal_set_entity_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EntityPlacement::_internal_mutable_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EntityPlacement::release_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EntityPlacement.entity_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.entity_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_type_.Set("", GetArena());
  }
  return released;
}
inline void EntityPlacement::set_allocated_entity_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.entity_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_type_.IsDefault()) {
    _impl_.entity_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EntityPlacement.entity_type)
}

// .api.v1alpha1.Position position = 3 [json_name = "position"];
inline bool EntityPlacement::has_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::api::v1alpha1::Position& EntityPlacement::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::api::v1alpha1::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::v1alpha1::Position&>(::api::v1alpha1::_Position_default_instance_);
}
inline const ::api::v1alpha1::Position& EntityPlacement::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.position)
  return _internal_position();
}
inline void EntityPlacement::unsafe_arena_set_allocated_position(
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EntityPlacement.position)
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE EntityPlacement::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::api::v1alpha1::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE EntityPlacement::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EntityPlacement.position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::api::v1alpha1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL EntityPlacement::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::api::v1alpha1::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(p);
  }
  return _impl_.position_;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL EntityPlacement::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::api::v1alpha1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EntityPlacement.position)
  return _msg;
}
inline void EntityPlacement::set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EntityPlacement.position)
}

// int32 size = 4 [json_name = "size"];
inline void EntityPlacement::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t EntityPlacement::size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.size)
  return _internal_size();
}
inline void EntityPlacement::set_size(::int32_t value) {
  _internal_set_size(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.size)
}
inline ::int32_t EntityPlacement::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void EntityPlacement::_internal_set_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// bool blocks_movement = 5 [json_name = "blocksMovement"];
inline void EntityPlacement::clear_blocks_movement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_movement_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool EntityPlacement::blocks_movement() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.blocks_movement)
  return _internal_blocks_movement();
}
inline void EntityPlacement::set_blocks_movement(bool value) {
  _internal_set_blocks_movement(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.blocks_movement)
}
inline bool EntityPlacement::_internal_blocks_movement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blocks_movement_;
}
inline void EntityPlacement::_internal_set_blocks_movement(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_movement_ = value;
}

// bool blocks_line_of_sight = 6 [json_name = "blocksLineOfSight"];
inline void EntityPlacement::clear_blocks_line_of_sight() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_line_of_sight_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool EntityPlacement::blocks_line_of_sight() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.blocks_line_of_sight)
  return _internal_blocks_line_of_sight();
}
inline void EntityPlacement::set_blocks_line_of_sight(bool value) {
  _internal_set_blocks_line_of_sight(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.blocks_line_of_sight)
}
inline bool EntityPlacement::_internal_blocks_line_of_sight() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blocks_line_of_sight_;
}
inline void EntityPlacement::_internal_set_blocks_line_of_sight(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_line_of_sight_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Room

// string id = 1 [json_name = "id"];
inline void Room::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& Room::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Room::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.id)
}
inline ::std::string* PROTOBUF_NONNULL Room::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Room.id)
  return _s;
}
inline const ::std::string& Room::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Room::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Room::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Room::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Room.id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void Room::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Room.id)
}

// string type = 2 [json_name = "type"];
inline void Room::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& Room::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Room::set_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.type)
}
inline ::std::string* PROTOBUF_NONNULL Room::mutable_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Room.type)
  return _s;
}
inline const ::std::string& Room::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void Room::_internal_set_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Room::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Room::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Room.type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.type_.Set("", GetArena());
  }
  return released;
}
inline void Room::set_allocated_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Room.type)
}

// int32 width = 3 [json_name = "width"];
inline void Room::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t Room::width() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.width)
  return _internal_width();
}
inline void Room::set_width(::int32_t value) {
  _internal_set_width(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.width)
}
inline ::int32_t Room::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void Room::_internal_set_width(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// int32 height = 4 [json_name = "height"];
inline void Room::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t Room::height() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.height)
  return _internal_height();
}
inline void Room::set_height(::int32_t value) {
  _internal_set_height(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.height)
}
inline ::int32_t Room::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void Room::_internal_set_height(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// .api.v1alpha1.GridType grid_type = 5 [json_name = "gridType"];
inline void Room::clear_grid_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::api::v1alpha1::GridType Room::grid_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.grid_type)
  return _internal_grid_type();
}
inline void Room::set_grid_type(::api::v1alpha1::GridType value) {
  _internal_set_grid_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.grid_type)
}
inline ::api::v1alpha1::GridType Room::_internal_grid_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::api::v1alpha1::GridType>(_impl_.grid_type_);
}
inline void Room::_internal_set_grid_type(::api::v1alpha1::GridType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_type_ = value;
}

// optional bool hex_orientation = 6 [json_name = "hexOrientation"];
inline bool Room::has_hex_orientation() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  return value;
}
inline void Room::clear_hex_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hex_orientation_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool Room::hex_orientation() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.hex_orientation)
  return _internal_hex_orientation();
}
inline void Room::set_hex_orientation(bool value) {
  _internal_set_hex_orientation(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.hex_orientation)
}
inline bool Room::_internal_hex_orientation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hex_orientation_;
}
inline void Room::_internal_set_hex_orientation(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hex_orientation_ = value;
}

// map<string, .dnd5e.api.v1alpha1.EntityPlacement> entities = 7 [json_name = "entities"];
inline int Room::_internal_entities_size() const {
  return _internal_entities().size();
}
inline int Room::entities_size() const {
  return _internal_entities_size();
}
inline void Room::clear_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entities_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>& Room::_internal_entities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entities_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>& Room::entities() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:dnd5e.api.v1alpha1.Room.entities)
  return _internal_entities();
}
inline ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>* PROTOBUF_NONNULL Room::_internal_mutable_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entities_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>* PROTOBUF_NONNULL Room::mutable_entities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_mutable_map:dnd5e.api.v1alpha1.Room.entities)
  return _internal_mutable_entities();
}

// -------------------------------------------------------------------

// DungeonStartRequest

// repeated string character_ids = 1 [json_name = "characterIds"];
inline int DungeonStartRequest::_internal_character_ids_size() const {
  return _internal_character_ids().size();
}
inline int DungeonStartRequest::character_ids_size() const {
  return _internal_character_ids_size();
}
inline void DungeonStartRequest::clear_character_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_ids_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartRequest::add_character_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_character_ids()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  return _s;
}
inline const ::std::string& DungeonStartRequest::character_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  return _internal_character_ids().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartRequest::mutable_character_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  return _internal_mutable_character_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void DungeonStartRequest::set_character_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_character_ids()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
}
template <typename Arg_, typename... Args_>
inline void DungeonStartRequest::add_character_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_character_ids(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& DungeonStartRequest::character_ids()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  return _internal_character_ids();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
DungeonStartRequest::mutable_character_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_character_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DungeonStartRequest::_internal_character_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
DungeonStartRequest::_internal_mutable_character_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.character_ids_;
}

// -------------------------------------------------------------------

// DungeonStartResponse

// string encounter_id = 1 [json_name = "encounterId"];
inline void DungeonStartResponse::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& DungeonStartResponse::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DungeonStartResponse::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartResponse::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
  return _s;
}
inline const ::std::string& DungeonStartResponse::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void DungeonStartResponse::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartResponse::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DungeonStartResponse::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void DungeonStartResponse::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
}

// .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
inline bool DungeonStartResponse::has_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void DungeonStartResponse::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::Room& DungeonStartResponse::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& DungeonStartResponse::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.room)
  return _internal_room();
}
inline void DungeonStartResponse::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE DungeonStartResponse::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE DungeonStartResponse::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonStartResponse.room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL DungeonStartResponse::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL DungeonStartResponse::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartResponse.room)
  return _msg;
}
inline void DungeonStartResponse::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.room)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 3 [json_name = "combatState"];
inline bool DungeonStartResponse::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void DungeonStartResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& DungeonStartResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& DungeonStartResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)
  return _internal_combat_state();
}
inline void DungeonStartResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE DungeonStartResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE DungeonStartResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL DungeonStartResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL DungeonStartResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)
  return _msg;
}
inline void DungeonStartResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)
}

// -------------------------------------------------------------------

// InitiativeEntry

// string entity_id = 1 [json_name = "entityId"];
inline void InitiativeEntry::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& InitiativeEntry::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InitiativeEntry::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL InitiativeEntry::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
  return _s;
}
inline const ::std::string& InitiativeEntry::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void InitiativeEntry::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InitiativeEntry::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InitiativeEntry::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void InitiativeEntry::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
}

// string entity_type = 2 [json_name = "entityType"];
inline void InitiativeEntry::clear_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& InitiativeEntry::entity_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
  return _internal_entity_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InitiativeEntry::set_entity_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.entity_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
}
inline ::std::string* PROTOBUF_NONNULL InitiativeEntry::mutable_entity_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_entity_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
  return _s;
}
inline const ::std::string& InitiativeEntry::_internal_entity_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_type_.Get();
}
inline void InitiativeEntry::_internal_set_entity_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InitiativeEntry::_internal_mutable_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InitiativeEntry::release_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.entity_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_type_.Set("", GetArena());
  }
  return released;
}
inline void InitiativeEntry::set_allocated_entity_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.entity_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_type_.IsDefault()) {
    _impl_.entity_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
}

// int32 initiative = 3 [json_name = "initiative"];
inline void InitiativeEntry::clear_initiative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiative_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t InitiativeEntry::initiative() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.initiative)
  return _internal_initiative();
}
inline void InitiativeEntry::set_initiative(::int32_t value) {
  _internal_set_initiative(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.initiative)
}
inline ::int32_t InitiativeEntry::_internal_initiative() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initiative_;
}
inline void InitiativeEntry::_internal_set_initiative(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiative_ = value;
}

// int32 modifier = 4 [json_name = "modifier"];
inline void InitiativeEntry::clear_modifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modifier_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t InitiativeEntry::modifier() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.modifier)
  return _internal_modifier();
}
inline void InitiativeEntry::set_modifier(::int32_t value) {
  _internal_set_modifier(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.modifier)
}
inline ::int32_t InitiativeEntry::_internal_modifier() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.modifier_;
}
inline void InitiativeEntry::_internal_set_modifier(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modifier_ = value;
}

// bool has_acted = 5 [json_name = "hasActed"];
inline void InitiativeEntry::clear_has_acted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_acted_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool InitiativeEntry::has_acted() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.has_acted)
  return _internal_has_acted();
}
inline void InitiativeEntry::set_has_acted(bool value) {
  _internal_set_has_acted(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.has_acted)
}
inline bool InitiativeEntry::_internal_has_acted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_acted_;
}
inline void InitiativeEntry::_internal_set_has_acted(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_acted_ = value;
}

// -------------------------------------------------------------------

// TurnState

// string entity_id = 1 [json_name = "entityId"];
inline void TurnState::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& TurnState::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TurnState::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL TurnState::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnState.entity_id)
  return _s;
}
inline const ::std::string& TurnState::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void TurnState::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TurnState::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TurnState::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnState.entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void TurnState::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnState.entity_id)
}

// int32 movement_used = 2 [json_name = "movementUsed"];
inline void TurnState::clear_movement_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_used_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t TurnState::movement_used() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.movement_used)
  return _internal_movement_used();
}
inline void TurnState::set_movement_used(::int32_t value) {
  _internal_set_movement_used(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.movement_used)
}
inline ::int32_t TurnState::_internal_movement_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movement_used_;
}
inline void TurnState::_internal_set_movement_used(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_used_ = value;
}

// int32 movement_max = 3 [json_name = "movementMax"];
inline void TurnState::clear_movement_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_max_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t TurnState::movement_max() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.movement_max)
  return _internal_movement_max();
}
inline void TurnState::set_movement_max(::int32_t value) {
  _internal_set_movement_max(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.movement_max)
}
inline ::int32_t TurnState::_internal_movement_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movement_max_;
}
inline void TurnState::_internal_set_movement_max(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_max_ = value;
}

// bool action_used = 4 [json_name = "actionUsed"];
inline void TurnState::clear_action_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_used_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool TurnState::action_used() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.action_used)
  return _internal_action_used();
}
inline void TurnState::set_action_used(bool value) {
  _internal_set_action_used(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.action_used)
}
inline bool TurnState::_internal_action_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_used_;
}
inline void TurnState::_internal_set_action_used(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_used_ = value;
}

// bool bonus_action_used = 5 [json_name = "bonusActionUsed"];
inline void TurnState::clear_bonus_action_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonus_action_used_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool TurnState::bonus_action_used() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.bonus_action_used)
  return _internal_bonus_action_used();
}
inline void TurnState::set_bonus_action_used(bool value) {
  _internal_set_bonus_action_used(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.bonus_action_used)
}
inline bool TurnState::_internal_bonus_action_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bonus_action_used_;
}
inline void TurnState::_internal_set_bonus_action_used(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonus_action_used_ = value;
}

// bool reaction_available = 6 [json_name = "reactionAvailable"];
inline void TurnState::clear_reaction_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reaction_available_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline bool TurnState::reaction_available() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.reaction_available)
  return _internal_reaction_available();
}
inline void TurnState::set_reaction_available(bool value) {
  _internal_set_reaction_available(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.reaction_available)
}
inline bool TurnState::_internal_reaction_available() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reaction_available_;
}
inline void TurnState::_internal_set_reaction_available(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reaction_available_ = value;
}

// .api.v1alpha1.Position position = 7 [json_name = "position"];
inline bool TurnState::has_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::api::v1alpha1::Position& TurnState::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::api::v1alpha1::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::v1alpha1::Position&>(::api::v1alpha1::_Position_default_instance_);
}
inline const ::api::v1alpha1::Position& TurnState::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.position)
  return _internal_position();
}
inline void TurnState::unsafe_arena_set_allocated_position(
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.TurnState.position)
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE TurnState::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::api::v1alpha1::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE TurnState::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnState.position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::api::v1alpha1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL TurnState::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::api::v1alpha1::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(p);
  }
  return _impl_.position_;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL TurnState::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::api::v1alpha1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnState.position)
  return _msg;
}
inline void TurnState::set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnState.position)
}

// -------------------------------------------------------------------

// CombatState

// string encounter_id = 1 [json_name = "encounterId"];
inline void CombatState::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& CombatState::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CombatState::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL CombatState::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatState.encounter_id)
  return _s;
}
inline const ::std::string& CombatState::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void CombatState::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CombatState::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CombatState::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatState.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void CombatState::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatState.encounter_id)
}

// int32 round = 2 [json_name = "round"];
inline void CombatState::clear_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t CombatState::round() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.round)
  return _internal_round();
}
inline void CombatState::set_round(::int32_t value) {
  _internal_set_round(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.round)
}
inline ::int32_t CombatState::_internal_round() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.round_;
}
inline void CombatState::_internal_set_round(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = value;
}

// repeated .dnd5e.api.v1alpha1.InitiativeEntry turn_order = 3 [json_name = "turnOrder"];
inline int CombatState::_internal_turn_order_size() const {
  return _internal_turn_order().size();
}
inline int CombatState::turn_order_size() const {
  return _internal_turn_order_size();
}
inline void CombatState::clear_turn_order() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.turn_order_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::InitiativeEntry* PROTOBUF_NONNULL CombatState::mutable_turn_order(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatState.turn_order)
  return _internal_mutable_turn_order()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>* PROTOBUF_NONNULL CombatState::mutable_turn_order()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.CombatState.turn_order)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_turn_order();
}
inline const ::dnd5e::api::v1alpha1::InitiativeEntry& CombatState::turn_order(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.turn_order)
  return _internal_turn_order().Get(index);
}
inline ::dnd5e::api::v1alpha1::InitiativeEntry* PROTOBUF_NONNULL CombatState::add_turn_order()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::InitiativeEntry* _add =
      _internal_mutable_turn_order()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.CombatState.turn_order)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>& CombatState::turn_order() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.CombatState.turn_order)
  return _internal_turn_order();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>&
CombatState::_internal_turn_order() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.turn_order_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>* PROTOBUF_NONNULL
CombatState::_internal_mutable_turn_order() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.turn_order_;
}

// int32 active_index = 4 [json_name = "activeIndex"];
inline void CombatState::clear_active_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_index_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int32_t CombatState::active_index() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.active_index)
  return _internal_active_index();
}
inline void CombatState::set_active_index(::int32_t value) {
  _internal_set_active_index(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.active_index)
}
inline ::int32_t CombatState::_internal_active_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.active_index_;
}
inline void CombatState::_internal_set_active_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_index_ = value;
}

// .dnd5e.api.v1alpha1.TurnState current_turn = 5 [json_name = "currentTurn"];
inline bool CombatState::has_current_turn() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.current_turn_ != nullptr);
  return value;
}
inline void CombatState::clear_current_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_turn_ != nullptr) _impl_.current_turn_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::TurnState& CombatState::_internal_current_turn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::TurnState* p = _impl_.current_turn_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::TurnState&>(::dnd5e::api::v1alpha1::_TurnState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::TurnState& CombatState::current_turn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.current_turn)
  return _internal_current_turn();
}
inline void CombatState::unsafe_arena_set_allocated_current_turn(
    ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.current_turn_);
  }
  _impl_.current_turn_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CombatState.current_turn)
}
inline ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE CombatState::release_current_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::TurnState* released = _impl_.current_turn_;
  _impl_.current_turn_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE CombatState::unsafe_arena_release_current_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatState.current_turn)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::TurnState* temp = _impl_.current_turn_;
  _impl_.current_turn_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NONNULL CombatState::_internal_mutable_current_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_turn_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::TurnState>(GetArena());
    _impl_.current_turn_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnState*>(p);
  }
  return _impl_.current_turn_;
}
inline ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NONNULL CombatState::mutable_current_turn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::TurnState* _msg = _internal_mutable_current_turn();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatState.current_turn)
  return _msg;
}
inline void CombatState::set_allocated_current_turn(::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.current_turn_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.current_turn_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatState.current_turn)
}

// bool combat_started = 6 [json_name = "combatStarted"];
inline void CombatState::clear_combat_started() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combat_started_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool CombatState::combat_started() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.combat_started)
  return _internal_combat_started();
}
inline void CombatState::set_combat_started(bool value) {
  _internal_set_combat_started(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.combat_started)
}
inline bool CombatState::_internal_combat_started() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.combat_started_;
}
inline void CombatState::_internal_set_combat_started(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combat_started_ = value;
}

// bool combat_ended = 7 [json_name = "combatEnded"];
inline void CombatState::clear_combat_ended() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combat_ended_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline bool CombatState::combat_ended() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.combat_ended)
  return _internal_combat_ended();
}
inline void CombatState::set_combat_ended(bool value) {
  _internal_set_combat_ended(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.combat_ended)
}
inline bool CombatState::_internal_combat_ended() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.combat_ended_;
}
inline void CombatState::_internal_set_combat_ended(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combat_ended_ = value;
}

// -------------------------------------------------------------------

// GetCombatStateRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void GetCombatStateRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& GetCombatStateRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetCombatStateRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL GetCombatStateRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
  return _s;
}
inline const ::std::string& GetCombatStateRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void GetCombatStateRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetCombatStateRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetCombatStateRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void GetCombatStateRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
}

// -------------------------------------------------------------------

// GetCombatStateResponse

// .dnd5e.api.v1alpha1.Room room = 1 [json_name = "room"];
inline bool GetCombatStateResponse::has_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void GetCombatStateResponse::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::dnd5e::api::v1alpha1::Room& GetCombatStateResponse::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& GetCombatStateResponse::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCombatStateResponse.room)
  return _internal_room();
}
inline void GetCombatStateResponse::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetCombatStateResponse.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE GetCombatStateResponse::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE GetCombatStateResponse::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCombatStateResponse.room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL GetCombatStateResponse::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL GetCombatStateResponse::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCombatStateResponse.room)
  return _msg;
}
inline void GetCombatStateResponse::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCombatStateResponse.room)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
inline bool GetCombatStateResponse::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void GetCombatStateResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& GetCombatStateResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& GetCombatStateResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)
  return _internal_combat_state();
}
inline void GetCombatStateResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE GetCombatStateResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE GetCombatStateResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL GetCombatStateResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL GetCombatStateResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)
  return _msg;
}
inline void GetCombatStateResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)
}

// -------------------------------------------------------------------

// MoveCharacterRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void MoveCharacterRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& MoveCharacterRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MoveCharacterRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
  return _s;
}
inline const ::std::string& MoveCharacterRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void MoveCharacterRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MoveCharacterRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void MoveCharacterRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
}

// string entity_id = 2 [json_name = "entityId"];
inline void MoveCharacterRequest::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& MoveCharacterRequest::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MoveCharacterRequest::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterRequest::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
  return _s;
}
inline const ::std::string& MoveCharacterRequest::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void MoveCharacterRequest::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterRequest::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MoveCharacterRequest::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void MoveCharacterRequest::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
}

// repeated .api.v1alpha1.Position path = 3 [json_name = "path"];
inline int MoveCharacterRequest::_internal_path_size() const {
  return _internal_path().size();
}
inline int MoveCharacterRequest::path_size() const {
  return _internal_path_size();
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MoveCharacterRequest::mutable_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterRequest.path)
  return _internal_mutable_path()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL MoveCharacterRequest::mutable_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.MoveCharacterRequest.path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_path();
}
inline const ::api::v1alpha1::Position& MoveCharacterRequest::path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterRequest.path)
  return _internal_path().Get(index);
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MoveCharacterRequest::add_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::api::v1alpha1::Position* _add =
      _internal_mutable_path()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.MoveCharacterRequest.path)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>& MoveCharacterRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.MoveCharacterRequest.path)
  return _internal_path();
}
inline const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>&
MoveCharacterRequest::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_;
}
inline ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL
MoveCharacterRequest::_internal_mutable_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.path_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MovementError

// .dnd5e.api.v1alpha1.MovementError.ErrorCode code = 1 [json_name = "code"];
inline void MovementError::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::MovementError_ErrorCode MovementError::code() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MovementError.code)
  return _internal_code();
}
inline void MovementError::set_code(::dnd5e::api::v1alpha1::MovementError_ErrorCode value) {
  _internal_set_code(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MovementError.code)
}
inline ::dnd5e::api::v1alpha1::MovementError_ErrorCode MovementError::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::MovementError_ErrorCode>(_impl_.code_);
}
inline void MovementError::_internal_set_code(::dnd5e::api::v1alpha1::MovementError_ErrorCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = value;
}

// string message = 2 [json_name = "message"];
inline void MovementError::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& MovementError::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MovementError.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MovementError::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MovementError.message)
}
inline ::std::string* PROTOBUF_NONNULL MovementError::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MovementError.message)
  return _s;
}
inline const ::std::string& MovementError::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void MovementError::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MovementError::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MovementError::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MovementError.message)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void MovementError::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MovementError.message)
}

// map<string, string> details = 3 [json_name = "details"];
inline int MovementError::_internal_details_size() const {
  return _internal_details().size();
}
inline int MovementError::details_size() const {
  return _internal_details_size();
}
inline void MovementError::clear_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::google::protobuf::Map<::std::string, ::std::string>& MovementError::_internal_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.details_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::std::string>& MovementError::details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:dnd5e.api.v1alpha1.MovementError.details)
  return _internal_details();
}
inline ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL MovementError::_internal_mutable_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.details_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL MovementError::mutable_details()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_map:dnd5e.api.v1alpha1.MovementError.details)
  return _internal_mutable_details();
}

// -------------------------------------------------------------------

// MoveCharacterResponse

// bool success = 1 [json_name = "success"];
inline void MoveCharacterResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool MoveCharacterResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.success)
  return _internal_success();
}
inline void MoveCharacterResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterResponse.success)
}
inline bool MoveCharacterResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void MoveCharacterResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// .dnd5e.api.v1alpha1.MovementError error = 2 [json_name = "error"];
inline bool MoveCharacterResponse::has_error() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline void MoveCharacterResponse::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::MovementError& MoveCharacterResponse::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::MovementError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::MovementError&>(::dnd5e::api::v1alpha1::_MovementError_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::MovementError& MoveCharacterResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.error)
  return _internal_error();
}
inline void MoveCharacterResponse::unsafe_arena_set_allocated_error(
    ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::dnd5e::api::v1alpha1::MovementError*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.error)
}
inline ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE MoveCharacterResponse::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::MovementError* released = _impl_.error_;
  _impl_.error_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE MoveCharacterResponse::unsafe_arena_release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterResponse.error)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::MovementError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NONNULL MoveCharacterResponse::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::MovementError>(GetArena());
    _impl_.error_ = reinterpret_cast<::dnd5e::api::v1alpha1::MovementError*>(p);
  }
  return _impl_.error_;
}
inline ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NONNULL MoveCharacterResponse::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::MovementError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterResponse.error)
  return _msg;
}
inline void MoveCharacterResponse::set_allocated_error(::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.error_ = reinterpret_cast<::dnd5e::api::v1alpha1::MovementError*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.error)
}

// .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
inline bool MoveCharacterResponse::has_final_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.final_position_ != nullptr);
  return value;
}
inline const ::api::v1alpha1::Position& MoveCharacterResponse::_internal_final_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::api::v1alpha1::Position* p = _impl_.final_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::v1alpha1::Position&>(::api::v1alpha1::_Position_default_instance_);
}
inline const ::api::v1alpha1::Position& MoveCharacterResponse::final_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.final_position)
  return _internal_final_position();
}
inline void MoveCharacterResponse::unsafe_arena_set_allocated_final_position(
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.final_position_);
  }
  _impl_.final_position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.final_position)
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE MoveCharacterResponse::release_final_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::api::v1alpha1::Position* released = _impl_.final_position_;
  _impl_.final_position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE MoveCharacterResponse::unsafe_arena_release_final_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterResponse.final_position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::api::v1alpha1::Position* temp = _impl_.final_position_;
  _impl_.final_position_ = nullptr;
  return temp;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MoveCharacterResponse::_internal_mutable_final_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.final_position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::api::v1alpha1::Position>(GetArena());
    _impl_.final_position_ = reinterpret_cast<::api::v1alpha1::Position*>(p);
  }
  return _impl_.final_position_;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MoveCharacterResponse::mutable_final_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::api::v1alpha1::Position* _msg = _internal_mutable_final_position();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterResponse.final_position)
  return _msg;
}
inline void MoveCharacterResponse::set_allocated_final_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.final_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.final_position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.final_position)
}

// int32 movement_remaining = 4 [json_name = "movementRemaining"];
inline void MoveCharacterResponse::clear_movement_remaining() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_remaining_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::int32_t MoveCharacterResponse::movement_remaining() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.movement_remaining)
  return _internal_movement_remaining();
}
inline void MoveCharacterResponse::set_movement_remaining(::int32_t value) {
  _internal_set_movement_remaining(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterResponse.movement_remaining)
}
inline ::int32_t MoveCharacterResponse::_internal_movement_remaining() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movement_remaining_;
}
inline void MoveCharacterResponse::_internal_set_movement_remaining(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_remaining_ = value;
}

// string stop_reason = 5 [json_name = "stopReason"];
inline void MoveCharacterResponse::clear_stop_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_reason_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& MoveCharacterResponse::stop_reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.stop_reason)
  return _internal_stop_reason();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MoveCharacterResponse::set_stop_reason(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.stop_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterResponse.stop_reason)
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterResponse::mutable_stop_reason()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_stop_reason();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterResponse.stop_reason)
  return _s;
}
inline const ::std::string& MoveCharacterResponse::_internal_stop_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_reason_.Get();
}
inline void MoveCharacterResponse::_internal_set_stop_reason(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_reason_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterResponse::_internal_mutable_stop_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.stop_reason_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MoveCharacterResponse::release_stop_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterResponse.stop_reason)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.stop_reason_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stop_reason_.Set("", GetArena());
  }
  return released;
}
inline void MoveCharacterResponse::set_allocated_stop_reason(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.stop_reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stop_reason_.IsDefault()) {
    _impl_.stop_reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.stop_reason)
}

// .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
inline bool MoveCharacterResponse::has_updated_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.updated_room_ != nullptr);
  return value;
}
inline void MoveCharacterResponse::clear_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ != nullptr) _impl_.updated_room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::dnd5e::api::v1alpha1::Room& MoveCharacterResponse::_internal_updated_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.updated_room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& MoveCharacterResponse::updated_room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)
  return _internal_updated_room();
}
inline void MoveCharacterResponse::unsafe_arena_set_allocated_updated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }
  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE MoveCharacterResponse::release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE MoveCharacterResponse::unsafe_arena_release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL MoveCharacterResponse::_internal_mutable_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.updated_room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL MoveCharacterResponse::mutable_updated_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_updated_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)
  return _msg;
}
inline void MoveCharacterResponse::set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)
}

// -------------------------------------------------------------------

// EndTurnRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void EndTurnRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& EndTurnRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EndTurnRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL EndTurnRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
  return _s;
}
inline const ::std::string& EndTurnRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void EndTurnRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EndTurnRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EndTurnRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void EndTurnRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
}

// string entity_id = 2 [json_name = "entityId"];
inline void EndTurnRequest::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& EndTurnRequest::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EndTurnRequest::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL EndTurnRequest::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
  return _s;
}
inline const ::std::string& EndTurnRequest::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void EndTurnRequest::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EndTurnRequest::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EndTurnRequest::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void EndTurnRequest::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
}

// -------------------------------------------------------------------

// TurnChangeEvent

// string previous_entity_id = 1 [json_name = "previousEntityId"];
inline void TurnChangeEvent::clear_previous_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.previous_entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& TurnChangeEvent::previous_entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
  return _internal_previous_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TurnChangeEvent::set_previous_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.previous_entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
}
inline ::std::string* PROTOBUF_NONNULL TurnChangeEvent::mutable_previous_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_previous_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
  return _s;
}
inline const ::std::string& TurnChangeEvent::_internal_previous_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.previous_entity_id_.Get();
}
inline void TurnChangeEvent::_internal_set_previous_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.previous_entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TurnChangeEvent::_internal_mutable_previous_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.previous_entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TurnChangeEvent::release_previous_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.previous_entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.previous_entity_id_.Set("", GetArena());
  }
  return released;
}
inline void TurnChangeEvent::set_allocated_previous_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.previous_entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.previous_entity_id_.IsDefault()) {
    _impl_.previous_entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
}

// string next_entity_id = 2 [json_name = "nextEntityId"];
inline void TurnChangeEvent::clear_next_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& TurnChangeEvent::next_entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
  return _internal_next_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TurnChangeEvent::set_next_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.next_entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
}
inline ::std::string* PROTOBUF_NONNULL TurnChangeEvent::mutable_next_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_next_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
  return _s;
}
inline const ::std::string& TurnChangeEvent::_internal_next_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_entity_id_.Get();
}
inline void TurnChangeEvent::_internal_set_next_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TurnChangeEvent::_internal_mutable_next_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TurnChangeEvent::release_next_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.next_entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.next_entity_id_.Set("", GetArena());
  }
  return released;
}
inline void TurnChangeEvent::set_allocated_next_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.next_entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_entity_id_.IsDefault()) {
    _impl_.next_entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
}

// int32 round = 3 [json_name = "round"];
inline void TurnChangeEvent::clear_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t TurnChangeEvent::round() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnChangeEvent.round)
  return _internal_round();
}
inline void TurnChangeEvent::set_round(::int32_t value) {
  _internal_set_round(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnChangeEvent.round)
}
inline ::int32_t TurnChangeEvent::_internal_round() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.round_;
}
inline void TurnChangeEvent::_internal_set_round(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = value;
}

// bool new_round = 4 [json_name = "newRound"];
inline void TurnChangeEvent::clear_new_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_round_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool TurnChangeEvent::new_round() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnChangeEvent.new_round)
  return _internal_new_round();
}
inline void TurnChangeEvent::set_new_round(bool value) {
  _internal_set_new_round(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnChangeEvent.new_round)
}
inline bool TurnChangeEvent::_internal_new_round() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_round_;
}
inline void TurnChangeEvent::_internal_set_new_round(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_round_ = value;
}

// -------------------------------------------------------------------

// EndTurnResponse

// bool success = 1 [json_name = "success"];
inline void EndTurnResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool EndTurnResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnResponse.success)
  return _internal_success();
}
inline void EndTurnResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EndTurnResponse.success)
}
inline bool EndTurnResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void EndTurnResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
inline bool EndTurnResponse::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void EndTurnResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& EndTurnResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& EndTurnResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)
  return _internal_combat_state();
}
inline void EndTurnResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE EndTurnResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE EndTurnResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL EndTurnResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL EndTurnResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)
  return _msg;
}
inline void EndTurnResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)
}

// .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 3 [json_name = "turnChange"];
inline bool EndTurnResponse::has_turn_change() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.turn_change_ != nullptr);
  return value;
}
inline void EndTurnResponse::clear_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.turn_change_ != nullptr) _impl_.turn_change_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::TurnChangeEvent& EndTurnResponse::_internal_turn_change() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::TurnChangeEvent* p = _impl_.turn_change_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::TurnChangeEvent&>(::dnd5e::api::v1alpha1::_TurnChangeEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::TurnChangeEvent& EndTurnResponse::turn_change() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)
  return _internal_turn_change();
}
inline void EndTurnResponse::unsafe_arena_set_allocated_turn_change(
    ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.turn_change_);
  }
  _impl_.turn_change_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnChangeEvent*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE EndTurnResponse::release_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* released = _impl_.turn_change_;
  _impl_.turn_change_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE EndTurnResponse::unsafe_arena_release_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* temp = _impl_.turn_change_;
  _impl_.turn_change_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL EndTurnResponse::_internal_mutable_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.turn_change_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::TurnChangeEvent>(GetArena());
    _impl_.turn_change_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnChangeEvent*>(p);
  }
  return _impl_.turn_change_;
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL EndTurnResponse::mutable_turn_change()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* _msg = _internal_mutable_turn_change();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)
  return _msg;
}
inline void EndTurnResponse::set_allocated_turn_change(::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.turn_change_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.turn_change_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnChangeEvent*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)
}

// -------------------------------------------------------------------

// AttackRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void AttackRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& AttackRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
  return _s;
}
inline const ::std::string& AttackRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void AttackRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
}

// string attacker_id = 2 [json_name = "attackerId"];
inline void AttackRequest::clear_attacker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attacker_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& AttackRequest::attacker_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
  return _internal_attacker_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackRequest::set_attacker_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.attacker_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::mutable_attacker_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_attacker_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
  return _s;
}
inline const ::std::string& AttackRequest::_internal_attacker_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attacker_id_.Get();
}
inline void AttackRequest::_internal_set_attacker_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attacker_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::_internal_mutable_attacker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.attacker_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackRequest::release_attacker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.attacker_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.attacker_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackRequest::set_allocated_attacker_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.attacker_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.attacker_id_.IsDefault()) {
    _impl_.attacker_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
}

// string target_id = 3 [json_name = "targetId"];
inline void AttackRequest::clear_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& AttackRequest::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackRequest::set_target_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.target_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::mutable_target_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackRequest.target_id)
  return _s;
}
inline const ::std::string& AttackRequest::_internal_target_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_id_.Get();
}
inline void AttackRequest::_internal_set_target_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::_internal_mutable_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackRequest::release_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackRequest.target_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.target_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.target_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackRequest::set_allocated_target_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.target_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_id_.IsDefault()) {
    _impl_.target_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackRequest.target_id)
}

// string weapon_id = 4 [json_name = "weaponId"];
inline void AttackRequest::clear_weapon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapon_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& AttackRequest::weapon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
  return _internal_weapon_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackRequest::set_weapon_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.weapon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::mutable_weapon_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_weapon_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
  return _s;
}
inline const ::std::string& AttackRequest::_internal_weapon_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.weapon_id_.Get();
}
inline void AttackRequest::_internal_set_weapon_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapon_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::_internal_mutable_weapon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.weapon_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackRequest::release_weapon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.weapon_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.weapon_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackRequest::set_allocated_weapon_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.weapon_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.weapon_id_.IsDefault()) {
    _impl_.weapon_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
}

// -------------------------------------------------------------------

// RerollEvent

// int32 die_index = 1 [json_name = "dieIndex"];
inline void RerollEvent::clear_die_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.die_index_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t RerollEvent::die_index() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RerollEvent.die_index)
  return _internal_die_index();
}
inline void RerollEvent::set_die_index(::int32_t value) {
  _internal_set_die_index(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RerollEvent.die_index)
}
inline ::int32_t RerollEvent::_internal_die_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.die_index_;
}
inline void RerollEvent::_internal_set_die_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.die_index_ = value;
}

// int32 before = 2 [json_name = "before"];
inline void RerollEvent::clear_before() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.before_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t RerollEvent::before() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RerollEvent.before)
  return _internal_before();
}
inline void RerollEvent::set_before(::int32_t value) {
  _internal_set_before(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RerollEvent.before)
}
inline ::int32_t RerollEvent::_internal_before() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.before_;
}
inline void RerollEvent::_internal_set_before(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.before_ = value;
}

// int32 after = 3 [json_name = "after"];
inline void RerollEvent::clear_after() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.after_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t RerollEvent::after() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RerollEvent.after)
  return _internal_after();
}
inline void RerollEvent::set_after(::int32_t value) {
  _internal_set_after(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RerollEvent.after)
}
inline ::int32_t RerollEvent::_internal_after() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.after_;
}
inline void RerollEvent::_internal_set_after(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.after_ = value;
}

// string reason = 4 [json_name = "reason"];
inline void RerollEvent::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& RerollEvent::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RerollEvent.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RerollEvent::set_reason(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RerollEvent.reason)
}
inline ::std::string* PROTOBUF_NONNULL RerollEvent::mutable_reason()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RerollEvent.reason)
  return _s;
}
inline const ::std::string& RerollEvent::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void RerollEvent::_internal_set_reason(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RerollEvent::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RerollEvent::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RerollEvent.reason)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.reason_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reason_.Set("", GetArena());
  }
  return released;
}
inline void RerollEvent::set_allocated_reason(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RerollEvent.reason)
}

// -------------------------------------------------------------------

// DamageComponent

// string source = 1 [json_name = "source", deprecated = true];
inline void DamageComponent::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& DamageComponent::source() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DamageComponent::set_source(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.source)
}
inline ::std::string* PROTOBUF_NONNULL DamageComponent::mutable_source()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageComponent.source)
  return _s;
}
inline const ::std::string& DamageComponent::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_.Get();
}
inline void DamageComponent::_internal_set_source(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DamageComponent::_internal_mutable_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.source_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DamageComponent::release_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DamageComponent.source)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.source_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.source_.Set("", GetArena());
  }
  return released;
}
inline void DamageComponent::set_allocated_source(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.source_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DamageComponent.source)
}

// repeated int32 original_dice_rolls = 2 [json_name = "originalDiceRolls"];
inline int DamageComponent::_internal_original_dice_rolls_size() const {
  return _internal_original_dice_rolls().size();
}
inline int DamageComponent::original_dice_rolls_size() const {
  return _internal_original_dice_rolls_size();
}
inline void DamageComponent::clear_original_dice_rolls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.original_dice_rolls_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t DamageComponent::original_dice_rolls(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.original_dice_rolls)
  return _internal_original_dice_rolls().Get(index);
}
inline void DamageComponent::set_original_dice_rolls(int index, ::int32_t value) {
  _internal_mutable_original_dice_rolls()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.original_dice_rolls)
}
inline void DamageComponent::add_original_dice_rolls(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_original_dice_rolls()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DamageComponent.original_dice_rolls)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& DamageComponent::original_dice_rolls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DamageComponent.original_dice_rolls)
  return _internal_original_dice_rolls();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL DamageComponent::mutable_original_dice_rolls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DamageComponent.original_dice_rolls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_original_dice_rolls();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
DamageComponent::_internal_original_dice_rolls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.original_dice_rolls_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
DamageComponent::_internal_mutable_original_dice_rolls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.original_dice_rolls_;
}

// repeated int32 final_dice_rolls = 3 [json_name = "finalDiceRolls"];
inline int DamageComponent::_internal_final_dice_rolls_size() const {
  return _internal_final_dice_rolls().size();
}
inline int DamageComponent::final_dice_rolls_size() const {
  return _internal_final_dice_rolls_size();
}
inline void DamageComponent::clear_final_dice_rolls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_dice_rolls_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t DamageComponent::final_dice_rolls(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.final_dice_rolls)
  return _internal_final_dice_rolls().Get(index);
}
inline void DamageComponent::set_final_dice_rolls(int index, ::int32_t value) {
  _internal_mutable_final_dice_rolls()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.final_dice_rolls)
}
inline void DamageComponent::add_final_dice_rolls(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_final_dice_rolls()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DamageComponent.final_dice_rolls)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& DamageComponent::final_dice_rolls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DamageComponent.final_dice_rolls)
  return _internal_final_dice_rolls();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL DamageComponent::mutable_final_dice_rolls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DamageComponent.final_dice_rolls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_final_dice_rolls();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
DamageComponent::_internal_final_dice_rolls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.final_dice_rolls_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
DamageComponent::_internal_mutable_final_dice_rolls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.final_dice_rolls_;
}

// repeated .dnd5e.api.v1alpha1.RerollEvent rerolls = 4 [json_name = "rerolls"];
inline int DamageComponent::_internal_rerolls_size() const {
  return _internal_rerolls().size();
}
inline int DamageComponent::rerolls_size() const {
  return _internal_rerolls_size();
}
inline void DamageComponent::clear_rerolls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rerolls_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::RerollEvent* PROTOBUF_NONNULL DamageComponent::mutable_rerolls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageComponent.rerolls)
  return _internal_mutable_rerolls()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>* PROTOBUF_NONNULL DamageComponent::mutable_rerolls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DamageComponent.rerolls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_rerolls();
}
inline const ::dnd5e::api::v1alpha1::RerollEvent& DamageComponent::rerolls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.rerolls)
  return _internal_rerolls().Get(index);
}
inline ::dnd5e::api::v1alpha1::RerollEvent* PROTOBUF_NONNULL DamageComponent::add_rerolls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::RerollEvent* _add =
      _internal_mutable_rerolls()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DamageComponent.rerolls)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>& DamageComponent::rerolls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DamageComponent.rerolls)
  return _internal_rerolls();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>&
DamageComponent::_internal_rerolls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rerolls_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>* PROTOBUF_NONNULL
DamageComponent::_internal_mutable_rerolls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.rerolls_;
}

// int32 flat_bonus = 5 [json_name = "flatBonus"];
inline void DamageComponent::clear_flat_bonus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flat_bonus_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::int32_t DamageComponent::flat_bonus() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.flat_bonus)
  return _internal_flat_bonus();
}
inline void DamageComponent::set_flat_bonus(::int32_t value) {
  _internal_set_flat_bonus(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.flat_bonus)
}
inline ::int32_t DamageComponent::_internal_flat_bonus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.flat_bonus_;
}
inline void DamageComponent::_internal_set_flat_bonus(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flat_bonus_ = value;
}

// string damage_type = 6 [json_name = "damageType"];
inline void DamageComponent::clear_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::std::string& DamageComponent::damage_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.damage_type)
  return _internal_damage_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DamageComponent::set_damage_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  _impl_.damage_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.damage_type)
}
inline ::std::string* PROTOBUF_NONNULL DamageComponent::mutable_damage_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::std::string* _s = _internal_mutable_damage_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageComponent.damage_type)
  return _s;
}
inline const ::std::string& DamageComponent::_internal_damage_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_type_.Get();
}
inline void DamageComponent::_internal_set_damage_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DamageComponent::_internal_mutable_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.damage_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DamageComponent::release_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DamageComponent.damage_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000010U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  auto* released = _impl_.damage_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  return released;
}
inline void DamageComponent::set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  _impl_.damage_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.damage_type_.IsDefault()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DamageComponent.damage_type)
}

// bool is_critical = 7 [json_name = "isCritical"];
inline void DamageComponent::clear_is_critical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_critical_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline bool DamageComponent::is_critical() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.is_critical)
  return _internal_is_critical();
}
inline void DamageComponent::set_is_critical(bool value) {
  _internal_set_is_critical(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.is_critical)
}
inline bool DamageComponent::_internal_is_critical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_critical_;
}
inline void DamageComponent::_internal_set_is_critical(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_critical_ = value;
}

// .dnd5e.api.v1alpha1.SourceRef source_ref = 8 [json_name = "sourceRef"];
inline bool DamageComponent::has_source_ref() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.source_ref_ != nullptr);
  return value;
}
inline const ::dnd5e::api::v1alpha1::SourceRef& DamageComponent::_internal_source_ref() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::SourceRef* p = _impl_.source_ref_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::SourceRef&>(::dnd5e::api::v1alpha1::_SourceRef_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SourceRef& DamageComponent::source_ref() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.source_ref)
  return _internal_source_ref();
}
inline void DamageComponent::unsafe_arena_set_allocated_source_ref(
    ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_ref_);
  }
  _impl_.source_ref_ = reinterpret_cast<::dnd5e::api::v1alpha1::SourceRef*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.DamageComponent.source_ref)
}
inline ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE DamageComponent::release_source_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::SourceRef* released = _impl_.source_ref_;
  _impl_.source_ref_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE DamageComponent::unsafe_arena_release_source_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DamageComponent.source_ref)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::SourceRef* temp = _impl_.source_ref_;
  _impl_.source_ref_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NONNULL DamageComponent::_internal_mutable_source_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_ref_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SourceRef>(GetArena());
    _impl_.source_ref_ = reinterpret_cast<::dnd5e::api::v1alpha1::SourceRef*>(p);
  }
  return _impl_.source_ref_;
}
inline ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NONNULL DamageComponent::mutable_source_ref()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::SourceRef* _msg = _internal_mutable_source_ref();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageComponent.source_ref)
  return _msg;
}
inline void DamageComponent::set_allocated_source_ref(::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_ref_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.source_ref_ = reinterpret_cast<::dnd5e::api::v1alpha1::SourceRef*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DamageComponent.source_ref)
}

// -------------------------------------------------------------------

// DamageBreakdown

// repeated .dnd5e.api.v1alpha1.DamageComponent components = 1 [json_name = "components"];
inline int DamageBreakdown::_internal_components_size() const {
  return _internal_components().size();
}
inline int DamageBreakdown::components_size() const {
  return _internal_components_size();
}
inline void DamageBreakdown::clear_components() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.components_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::DamageComponent* PROTOBUF_NONNULL DamageBreakdown::mutable_components(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageBreakdown.components)
  return _internal_mutable_components()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>* PROTOBUF_NONNULL DamageBreakdown::mutable_components()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DamageBreakdown.components)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_components();
}
inline const ::dnd5e::api::v1alpha1::DamageComponent& DamageBreakdown::components(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageBreakdown.components)
  return _internal_components().Get(index);
}
inline ::dnd5e::api::v1alpha1::DamageComponent* PROTOBUF_NONNULL DamageBreakdown::add_components()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::DamageComponent* _add =
      _internal_mutable_components()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DamageBreakdown.components)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>& DamageBreakdown::components() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DamageBreakdown.components)
  return _internal_components();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>&
DamageBreakdown::_internal_components() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.components_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>* PROTOBUF_NONNULL
DamageBreakdown::_internal_mutable_components() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.components_;
}

// string ability_used = 2 [json_name = "abilityUsed"];
inline void DamageBreakdown::clear_ability_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ability_used_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& DamageBreakdown::ability_used() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageBreakdown.ability_used)
  return _internal_ability_used();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DamageBreakdown::set_ability_used(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.ability_used_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageBreakdown.ability_used)
}
inline ::std::string* PROTOBUF_NONNULL DamageBreakdown::mutable_ability_used()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_ability_used();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageBreakdown.ability_used)
  return _s;
}
inline const ::std::string& DamageBreakdown::_internal_ability_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ability_used_.Get();
}
inline void DamageBreakdown::_internal_set_ability_used(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ability_used_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DamageBreakdown::_internal_mutable_ability_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ability_used_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DamageBreakdown::release_ability_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DamageBreakdown.ability_used)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.ability_used_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.ability_used_.Set("", GetArena());
  }
  return released;
}
inline void DamageBreakdown::set_allocated_ability_used(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.ability_used_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ability_used_.IsDefault()) {
    _impl_.ability_used_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DamageBreakdown.ability_used)
}

// int32 total_damage = 3 [json_name = "totalDamage"];
inline void DamageBreakdown::clear_total_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_damage_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t DamageBreakdown::total_damage() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageBreakdown.total_damage)
  return _internal_total_damage();
}
inline void DamageBreakdown::set_total_damage(::int32_t value) {
  _internal_set_total_damage(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageBreakdown.total_damage)
}
inline ::int32_t DamageBreakdown::_internal_total_damage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_damage_;
}
inline void DamageBreakdown::_internal_set_total_damage(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_damage_ = value;
}

// -------------------------------------------------------------------

// AttackResult

// bool hit = 1 [json_name = "hit"];
inline void AttackResult::clear_hit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hit_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool AttackResult::hit() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.hit)
  return _internal_hit();
}
inline void AttackResult::set_hit(bool value) {
  _internal_set_hit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.hit)
}
inline bool AttackResult::_internal_hit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hit_;
}
inline void AttackResult::_internal_set_hit(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hit_ = value;
}

// int32 attack_roll = 2 [json_name = "attackRoll"];
inline void AttackResult::clear_attack_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_roll_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t AttackResult::attack_roll() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.attack_roll)
  return _internal_attack_roll();
}
inline void AttackResult::set_attack_roll(::int32_t value) {
  _internal_set_attack_roll(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.attack_roll)
}
inline ::int32_t AttackResult::_internal_attack_roll() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attack_roll_;
}
inline void AttackResult::_internal_set_attack_roll(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_roll_ = value;
}

// int32 attack_total = 3 [json_name = "attackTotal"];
inline void AttackResult::clear_attack_total() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_total_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t AttackResult::attack_total() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.attack_total)
  return _internal_attack_total();
}
inline void AttackResult::set_attack_total(::int32_t value) {
  _internal_set_attack_total(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.attack_total)
}
inline ::int32_t AttackResult::_internal_attack_total() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attack_total_;
}
inline void AttackResult::_internal_set_attack_total(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_total_ = value;
}

// int32 target_ac = 4 [json_name = "targetAc"];
inline void AttackResult::clear_target_ac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ac_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int32_t AttackResult::target_ac() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.target_ac)
  return _internal_target_ac();
}
inline void AttackResult::set_target_ac(::int32_t value) {
  _internal_set_target_ac(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.target_ac)
}
inline ::int32_t AttackResult::_internal_target_ac() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_ac_;
}
inline void AttackResult::_internal_set_target_ac(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ac_ = value;
}

// int32 damage = 5 [json_name = "damage"];
inline void AttackResult::clear_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline ::int32_t AttackResult::damage() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.damage)
  return _internal_damage();
}
inline void AttackResult::set_damage(::int32_t value) {
  _internal_set_damage(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.damage)
}
inline ::int32_t AttackResult::_internal_damage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_;
}
inline void AttackResult::_internal_set_damage(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = value;
}

// string damage_type = 6 [json_name = "damageType"];
inline void AttackResult::clear_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& AttackResult::damage_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.damage_type)
  return _internal_damage_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackResult::set_damage_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.damage_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.damage_type)
}
inline ::std::string* PROTOBUF_NONNULL AttackResult::mutable_damage_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_damage_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResult.damage_type)
  return _s;
}
inline const ::std::string& AttackResult::_internal_damage_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_type_.Get();
}
inline void AttackResult::_internal_set_damage_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackResult::_internal_mutable_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.damage_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackResult::release_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResult.damage_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.damage_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  return released;
}
inline void AttackResult::set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.damage_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.damage_type_.IsDefault()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResult.damage_type)
}

// bool critical = 7 [json_name = "critical"];
inline void AttackResult::clear_critical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline bool AttackResult::critical() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.critical)
  return _internal_critical();
}
inline void AttackResult::set_critical(bool value) {
  _internal_set_critical(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.critical)
}
inline bool AttackResult::_internal_critical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.critical_;
}
inline void AttackResult::_internal_set_critical(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_ = value;
}

// .dnd5e.api.v1alpha1.DamageBreakdown damage_breakdown = 8 [json_name = "damageBreakdown"];
inline bool AttackResult::has_damage_breakdown() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.damage_breakdown_ != nullptr);
  return value;
}
inline void AttackResult::clear_damage_breakdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.damage_breakdown_ != nullptr) _impl_.damage_breakdown_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::DamageBreakdown& AttackResult::_internal_damage_breakdown() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::DamageBreakdown* p = _impl_.damage_breakdown_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::DamageBreakdown&>(::dnd5e::api::v1alpha1::_DamageBreakdown_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::DamageBreakdown& AttackResult::damage_breakdown() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.damage_breakdown)
  return _internal_damage_breakdown();
}
inline void AttackResult::unsafe_arena_set_allocated_damage_breakdown(
    ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.damage_breakdown_);
  }
  _impl_.damage_breakdown_ = reinterpret_cast<::dnd5e::api::v1alpha1::DamageBreakdown*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResult.damage_breakdown)
}
inline ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE AttackResult::release_damage_breakdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::DamageBreakdown* released = _impl_.damage_breakdown_;
  _impl_.damage_breakdown_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE AttackResult::unsafe_arena_release_damage_breakdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResult.damage_breakdown)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::DamageBreakdown* temp = _impl_.damage_breakdown_;
  _impl_.damage_breakdown_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NONNULL AttackResult::_internal_mutable_damage_breakdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.damage_breakdown_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::DamageBreakdown>(GetArena());
    _impl_.damage_breakdown_ = reinterpret_cast<::dnd5e::api::v1alpha1::DamageBreakdown*>(p);
  }
  return _impl_.damage_breakdown_;
}
inline ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NONNULL AttackResult::mutable_damage_breakdown()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::DamageBreakdown* _msg = _internal_mutable_damage_breakdown();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResult.damage_breakdown)
  return _msg;
}
inline void AttackResult::set_allocated_damage_breakdown(::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.damage_breakdown_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.damage_breakdown_ = reinterpret_cast<::dnd5e::api::v1alpha1::DamageBreakdown*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResult.damage_breakdown)
}

// -------------------------------------------------------------------

// AttackResponse

// bool success = 1 [json_name = "success"];
inline void AttackResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool AttackResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.success)
  return _internal_success();
}
inline void AttackResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResponse.success)
}
inline bool AttackResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void AttackResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string error = 2 [json_name = "error"];
inline void AttackResponse::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& AttackResponse::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackResponse::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResponse.error)
}
inline ::std::string* PROTOBUF_NONNULL AttackResponse::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.error)
  return _s;
}
inline const ::std::string& AttackResponse::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void AttackResponse::_internal_set_error(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackResponse::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackResponse::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.error)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void AttackResponse::set_allocated_error(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.error)
}

// .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
inline bool AttackResponse::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void AttackResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::AttackResult& AttackResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::AttackResult* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::AttackResult&>(::dnd5e::api::v1alpha1::_AttackResult_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AttackResult& AttackResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.result)
  return _internal_result();
}
inline void AttackResponse::unsafe_arena_set_allocated_result(
    ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResult*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResponse.result)
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE AttackResponse::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::AttackResult* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE AttackResponse::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::AttackResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL AttackResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AttackResult>(GetArena());
    _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResult*>(p);
  }
  return _impl_.result_;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL AttackResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::AttackResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.result)
  return _msg;
}
inline void AttackResponse::set_allocated_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.result)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
inline bool AttackResponse::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void AttackResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& AttackResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& AttackResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.combat_state)
  return _internal_combat_state();
}
inline void AttackResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE AttackResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE AttackResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL AttackResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL AttackResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.combat_state)
  return _msg;
}
inline void AttackResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.combat_state)
}

// .dnd5e.api.v1alpha1.Room updated_room = 5 [json_name = "updatedRoom"];
inline bool AttackResponse::has_updated_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.updated_room_ != nullptr);
  return value;
}
inline void AttackResponse::clear_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ != nullptr) _impl_.updated_room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::dnd5e::api::v1alpha1::Room& AttackResponse::_internal_updated_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.updated_room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& AttackResponse::updated_room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.updated_room)
  return _internal_updated_room();
}
inline void AttackResponse::unsafe_arena_set_allocated_updated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }
  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResponse.updated_room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE AttackResponse::release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE AttackResponse::unsafe_arena_release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.updated_room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL AttackResponse::_internal_mutable_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.updated_room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL AttackResponse::mutable_updated_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_updated_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.updated_room)
  return _msg;
}
inline void AttackResponse::set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.updated_room)
}

// -------------------------------------------------------------------

// ActivateFeatureRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void ActivateFeatureRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ActivateFeatureRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActivateFeatureRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ActivateFeatureRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ActivateFeatureRequest.encounter_id)
  return _s;
}
inline const ::std::string& ActivateFeatureRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void ActivateFeatureRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ActivateFeatureRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ActivateFeatureRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void ActivateFeatureRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureRequest.encounter_id)
}

// string character_id = 2 [json_name = "characterId"];
inline void ActivateFeatureRequest::clear_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& ActivateFeatureRequest::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActivateFeatureRequest::set_character_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ActivateFeatureRequest.character_id)
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureRequest::mutable_character_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ActivateFeatureRequest.character_id)
  return _s;
}
inline const ::std::string& ActivateFeatureRequest::_internal_character_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_id_.Get();
}
inline void ActivateFeatureRequest::_internal_set_character_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureRequest::_internal_mutable_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.character_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ActivateFeatureRequest::release_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ActivateFeatureRequest.character_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.character_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.character_id_.Set("", GetArena());
  }
  return released;
}
inline void ActivateFeatureRequest::set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.character_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureRequest.character_id)
}

// string feature_id = 3 [json_name = "featureId"];
inline void ActivateFeatureRequest::clear_feature_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& ActivateFeatureRequest::feature_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureRequest.feature_id)
  return _internal_feature_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActivateFeatureRequest::set_feature_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.feature_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ActivateFeatureRequest.feature_id)
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureRequest::mutable_feature_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_feature_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ActivateFeatureRequest.feature_id)
  return _s;
}
inline const ::std::string& ActivateFeatureRequest::_internal_feature_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.feature_id_.Get();
}
inline void ActivateFeatureRequest::_internal_set_feature_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureRequest::_internal_mutable_feature_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.feature_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ActivateFeatureRequest::release_feature_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ActivateFeatureRequest.feature_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.feature_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.feature_id_.Set("", GetArena());
  }
  return released;
}
inline void ActivateFeatureRequest::set_allocated_feature_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.feature_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.feature_id_.IsDefault()) {
    _impl_.feature_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureRequest.feature_id)
}

// -------------------------------------------------------------------

// ActivateFeatureResponse

// bool success = 1 [json_name = "success"];
inline void ActivateFeatureResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool ActivateFeatureResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureResponse.success)
  return _internal_success();
}
inline void ActivateFeatureResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ActivateFeatureResponse.success)
}
inline bool ActivateFeatureResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ActivateFeatureResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string message = 2 [json_name = "message"];
inline void ActivateFeatureResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ActivateFeatureResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActivateFeatureResponse::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ActivateFeatureResponse.message)
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureResponse::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ActivateFeatureResponse.message)
  return _s;
}
inline const ::std::string& ActivateFeatureResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void ActivateFeatureResponse::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ActivateFeatureResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ActivateFeatureResponse.message)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void ActivateFeatureResponse::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureResponse.message)
}

// .dnd5e.api.v1alpha1.Character updated_character = 3 [json_name = "updatedCharacter"];
inline bool ActivateFeatureResponse::has_updated_character() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.updated_character_ != nullptr);
  return value;
}
inline const ::dnd5e::api::v1alpha1::Character& ActivateFeatureResponse::_internal_updated_character() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.updated_character_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& ActivateFeatureResponse::updated_character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_character)
  return _internal_updated_character();
}
inline void ActivateFeatureResponse::unsafe_arena_set_allocated_updated_character(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_character_);
  }
  _impl_.updated_character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_character)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE ActivateFeatureResponse::release_updated_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::Character* released = _impl_.updated_character_;
  _impl_.updated_character_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE ActivateFeatureResponse::unsafe_arena_release_updated_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_character)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.updated_character_;
  _impl_.updated_character_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL ActivateFeatureResponse::_internal_mutable_updated_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_character_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.updated_character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.updated_character_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL ActivateFeatureResponse::mutable_updated_character()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_updated_character();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_character)
  return _msg;
}
inline void ActivateFeatureResponse::set_allocated_updated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.updated_character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_character)
}

// .dnd5e.api.v1alpha1.CombatState updated_combat_state = 4 [json_name = "updatedCombatState"];
inline bool ActivateFeatureResponse::has_updated_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.updated_combat_state_ != nullptr);
  return value;
}
inline void ActivateFeatureResponse::clear_updated_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_combat_state_ != nullptr) _impl_.updated_combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& ActivateFeatureResponse::_internal_updated_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.updated_combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& ActivateFeatureResponse::updated_combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_combat_state)
  return _internal_updated_combat_state();
}
inline void ActivateFeatureResponse::unsafe_arena_set_allocated_updated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_combat_state_);
  }
  _impl_.updated_combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE ActivateFeatureResponse::release_updated_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.updated_combat_state_;
  _impl_.updated_combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE ActivateFeatureResponse::unsafe_arena_release_updated_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.updated_combat_state_;
  _impl_.updated_combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL ActivateFeatureResponse::_internal_mutable_updated_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.updated_combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.updated_combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL ActivateFeatureResponse::mutable_updated_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_updated_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_combat_state)
  return _msg;
}
inline void ActivateFeatureResponse::set_allocated_updated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.updated_combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_combat_state)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::MovementError_ErrorCode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::MovementError_ErrorCode>() {
  return ::dnd5e::api::v1alpha1::MovementError_ErrorCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_2epb_2eh
