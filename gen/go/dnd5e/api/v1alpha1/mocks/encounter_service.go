// Code generated by MockGen. DO NOT EDIT.
// Source: gen/go/dnd5e/api/v1alpha1/encounter_grpc.pb.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	v1alpha1 "github.com/KirkDiggler/rpg-api-protos/gen/go/dnd5e/api/v1alpha1"
	gomock "github.com/golang/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockEncounterServiceClient is a mock of EncounterServiceClient interface.
type MockEncounterServiceClient struct {
	ctrl     *gomock.Controller
	recorder *MockEncounterServiceClientMockRecorder
}

// MockEncounterServiceClientMockRecorder is the mock recorder for MockEncounterServiceClient.
type MockEncounterServiceClientMockRecorder struct {
	mock *MockEncounterServiceClient
}

// NewMockEncounterServiceClient creates a new mock instance.
func NewMockEncounterServiceClient(ctrl *gomock.Controller) *MockEncounterServiceClient {
	mock := &MockEncounterServiceClient{ctrl: ctrl}
	mock.recorder = &MockEncounterServiceClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEncounterServiceClient) EXPECT() *MockEncounterServiceClientMockRecorder {
	return m.recorder
}

// DungeonStart mocks base method.
func (m *MockEncounterServiceClient) DungeonStart(ctx context.Context, in *v1alpha1.DungeonStartRequest, opts ...grpc.CallOption) (*v1alpha1.DungeonStartResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DungeonStart", varargs...)
	ret0, _ := ret[0].(*v1alpha1.DungeonStartResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DungeonStart indicates an expected call of DungeonStart.
func (mr *MockEncounterServiceClientMockRecorder) DungeonStart(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DungeonStart", reflect.TypeOf((*MockEncounterServiceClient)(nil).DungeonStart), varargs...)
}

// MockEncounterServiceServer is a mock of EncounterServiceServer interface.
type MockEncounterServiceServer struct {
	ctrl     *gomock.Controller
	recorder *MockEncounterServiceServerMockRecorder
}

// MockEncounterServiceServerMockRecorder is the mock recorder for MockEncounterServiceServer.
type MockEncounterServiceServerMockRecorder struct {
	mock *MockEncounterServiceServer
}

// NewMockEncounterServiceServer creates a new mock instance.
func NewMockEncounterServiceServer(ctrl *gomock.Controller) *MockEncounterServiceServer {
	mock := &MockEncounterServiceServer{ctrl: ctrl}
	mock.recorder = &MockEncounterServiceServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEncounterServiceServer) EXPECT() *MockEncounterServiceServerMockRecorder {
	return m.recorder
}

// DungeonStart mocks base method.
func (m *MockEncounterServiceServer) DungeonStart(arg0 context.Context, arg1 *v1alpha1.DungeonStartRequest) (*v1alpha1.DungeonStartResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DungeonStart", arg0, arg1)
	ret0, _ := ret[0].(*v1alpha1.DungeonStartResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DungeonStart indicates an expected call of DungeonStart.
func (mr *MockEncounterServiceServerMockRecorder) DungeonStart(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DungeonStart", reflect.TypeOf((*MockEncounterServiceServer)(nil).DungeonStart), arg0, arg1)
}

// MockUnsafeEncounterServiceServer is a mock of UnsafeEncounterServiceServer interface.
type MockUnsafeEncounterServiceServer struct {
	ctrl     *gomock.Controller
	recorder *MockUnsafeEncounterServiceServerMockRecorder
}

// MockUnsafeEncounterServiceServerMockRecorder is the mock recorder for MockUnsafeEncounterServiceServer.
type MockUnsafeEncounterServiceServerMockRecorder struct {
	mock *MockUnsafeEncounterServiceServer
}

// NewMockUnsafeEncounterServiceServer creates a new mock instance.
func NewMockUnsafeEncounterServiceServer(ctrl *gomock.Controller) *MockUnsafeEncounterServiceServer {
	mock := &MockUnsafeEncounterServiceServer{ctrl: ctrl}
	mock.recorder = &MockUnsafeEncounterServiceServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeEncounterServiceServer) EXPECT() *MockUnsafeEncounterServiceServerMockRecorder {
	return m.recorder
}

// mustEmbedUnimplementedEncounterServiceServer mocks base method.
func (m *MockUnsafeEncounterServiceServer) mustEmbedUnimplementedEncounterServiceServer() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "mustEmbedUnimplementedEncounterServiceServer")
}

// mustEmbedUnimplementedEncounterServiceServer indicates an expected call of mustEmbedUnimplementedEncounterServiceServer.
func (mr *MockUnsafeEncounterServiceServerMockRecorder) mustEmbedUnimplementedEncounterServiceServer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedEncounterServiceServer", reflect.TypeOf((*MockUnsafeEncounterServiceServer)(nil).mustEmbedUnimplementedEncounterServiceServer))
}
