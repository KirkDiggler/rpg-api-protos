// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: dnd5e/api/v1alpha1/enums.proto
// Protobuf C++ Version: 6.32.0

#ifndef dnd5e_2fapi_2fv1alpha1_2fenums_2eproto_2epb_2eh
#define dnd5e_2fapi_2fv1alpha1_2fenums_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6032000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dnd5e_2fapi_2fv1alpha1_2fenums_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_dnd5e_2fapi_2fv1alpha1_2fenums_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_dnd5e_2fapi_2fv1alpha1_2fenums_2eproto;
}  // extern "C"
namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum Ability : int;
extern const uint32_t Ability_internal_data_[];
enum Alignment : int;
extern const uint32_t Alignment_internal_data_[];
enum Armor : int;
extern const uint32_t Armor_internal_data_[];
enum Background : int;
extern const uint32_t Background_internal_data_[];
enum Class : int;
extern const uint32_t Class_internal_data_[];
enum EquipmentType : int;
extern const uint32_t EquipmentType_internal_data_[];
enum FightingStyle : int;
extern const uint32_t FightingStyle_internal_data_[];
enum Language : int;
extern const uint32_t Language_internal_data_[];
enum Race : int;
extern const uint32_t Race_internal_data_[];
enum Skill : int;
extern const uint32_t Skill_internal_data_[];
enum Subclass : int;
extern const uint32_t Subclass_internal_data_[];
enum Subrace : int;
extern const uint32_t Subrace_internal_data_[];
enum Tool : int;
extern const uint32_t Tool_internal_data_[];
enum Weapon : int;
extern const uint32_t Weapon_internal_data_[];
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Ability_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Ability>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Alignment_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Alignment>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Armor_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Armor>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Background_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Background>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Class_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Class>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::EquipmentType_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::EquipmentType>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::FightingStyle_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::FightingStyle>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Language_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Language>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Race_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Race>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Skill_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Skill>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Subclass_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Subclass>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Subrace_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Subrace>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Tool_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Tool>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Weapon_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Weapon>;
}  // namespace protobuf
}  // namespace google

namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum Race : int {
  RACE_UNSPECIFIED = 0,
  RACE_HUMAN = 1,
  RACE_ELF = 2,
  RACE_DWARF = 3,
  RACE_HALFLING = 4,
  RACE_DRAGONBORN = 5,
  RACE_GNOME = 6,
  RACE_HALF_ELF = 7,
  RACE_HALF_ORC = 8,
  RACE_TIEFLING = 9,
  Race_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Race_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Race_internal_data_[];
inline constexpr Race Race_MIN =
    static_cast<Race>(0);
inline constexpr Race Race_MAX =
    static_cast<Race>(9);
inline bool Race_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int Race_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Race_descriptor();
template <typename T>
const ::std::string& Race_Name(T value) {
  static_assert(::std::is_same<T, Race>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Race_Name().");
  return Race_Name(static_cast<Race>(value));
}
template <>
inline const ::std::string& Race_Name(Race value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Race_descriptor, 0, 9>(
      static_cast<int>(value));
}
inline bool Race_Parse(
    ::absl::string_view name, Race* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Race>(Race_descriptor(), name,
                                           value);
}
enum Subrace : int {
  SUBRACE_UNSPECIFIED = 0,
  SUBRACE_HIGH_ELF = 1,
  SUBRACE_WOOD_ELF = 2,
  SUBRACE_DARK_ELF = 3,
  SUBRACE_HILL_DWARF = 4,
  SUBRACE_MOUNTAIN_DWARF = 5,
  SUBRACE_LIGHTFOOT_HALFLING = 6,
  SUBRACE_STOUT_HALFLING = 7,
  SUBRACE_FOREST_GNOME = 8,
  SUBRACE_ROCK_GNOME = 9,
  Subrace_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Subrace_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Subrace_internal_data_[];
inline constexpr Subrace Subrace_MIN =
    static_cast<Subrace>(0);
inline constexpr Subrace Subrace_MAX =
    static_cast<Subrace>(9);
inline bool Subrace_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int Subrace_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Subrace_descriptor();
template <typename T>
const ::std::string& Subrace_Name(T value) {
  static_assert(::std::is_same<T, Subrace>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Subrace_Name().");
  return Subrace_Name(static_cast<Subrace>(value));
}
template <>
inline const ::std::string& Subrace_Name(Subrace value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Subrace_descriptor, 0, 9>(
      static_cast<int>(value));
}
inline bool Subrace_Parse(
    ::absl::string_view name, Subrace* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Subrace>(Subrace_descriptor(), name,
                                           value);
}
enum Class : int {
  CLASS_UNSPECIFIED = 0,
  CLASS_BARBARIAN = 1,
  CLASS_BARD = 2,
  CLASS_CLERIC = 3,
  CLASS_DRUID = 4,
  CLASS_FIGHTER = 5,
  CLASS_MONK = 6,
  CLASS_PALADIN = 7,
  CLASS_RANGER = 8,
  CLASS_ROGUE = 9,
  CLASS_SORCERER = 10,
  CLASS_WARLOCK = 11,
  CLASS_WIZARD = 12,
  Class_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Class_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Class_internal_data_[];
inline constexpr Class Class_MIN =
    static_cast<Class>(0);
inline constexpr Class Class_MAX =
    static_cast<Class>(12);
inline bool Class_IsValid(int value) {
  return 0 <= value && value <= 12;
}
inline constexpr int Class_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Class_descriptor();
template <typename T>
const ::std::string& Class_Name(T value) {
  static_assert(::std::is_same<T, Class>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Class_Name().");
  return Class_Name(static_cast<Class>(value));
}
template <>
inline const ::std::string& Class_Name(Class value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Class_descriptor, 0, 12>(
      static_cast<int>(value));
}
inline bool Class_Parse(
    ::absl::string_view name, Class* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Class>(Class_descriptor(), name,
                                           value);
}
enum Subclass : int {
  SUBCLASS_UNSPECIFIED = 0,
  SUBCLASS_CHAMPION = 1,
  SUBCLASS_BATTLE_MASTER = 2,
  SUBCLASS_ELDRITCH_KNIGHT = 3,
  SUBCLASS_BERSERKER = 4,
  SUBCLASS_TOTEM = 5,
  SUBCLASS_ANCESTRAL = 6,
  SUBCLASS_LORE = 7,
  SUBCLASS_VALOR = 8,
  SUBCLASS_GLAMOUR = 9,
  SUBCLASS_LIFE_DOMAIN = 10,
  SUBCLASS_DEATH_DOMAIN = 11,
  SUBCLASS_TRICKERY_DOMAIN = 12,
  SUBCLASS_NATURE_DOMAIN = 13,
  SUBCLASS_WAR_DOMAIN = 14,
  SUBCLASS_LIGHT_DOMAIN = 15,
  SUBCLASS_TEMPEST_DOMAIN = 16,
  SUBCLASS_KNOWLEDGE_DOMAIN = 17,
  SUBCLASS_CIRCLE_LAND = 18,
  SUBCLASS_CIRCLE_MOON = 19,
  SUBCLASS_CIRCLE_DREAMS = 20,
  SUBCLASS_OPEN_HAND = 21,
  SUBCLASS_SHADOW = 22,
  SUBCLASS_FOUR_ELEMENTS = 23,
  SUBCLASS_DEVOTION = 24,
  SUBCLASS_ANCIENTS = 25,
  SUBCLASS_OATHBREAKER = 26,
  SUBCLASS_VENGEANCE = 27,
  SUBCLASS_HUNTER = 28,
  SUBCLASS_GLOOM_STALKER = 29,
  SUBCLASS_BEASTMASTER = 30,
  SUBCLASS_THIEF = 31,
  SUBCLASS_ASSASSIN = 32,
  SUBCLASS_ARCANE_TRICKSTER = 33,
  SUBCLASS_DRACONIC_BLOODLINE = 34,
  SUBCLASS_WILD_MAGIC = 35,
  SUBCLASS_DIVINE_SOUL = 36,
  SUBCLASS_ARCHFEY = 37,
  SUBCLASS_FIEND = 38,
  SUBCLASS_GREAT_OLD_ONE = 39,
  SUBCLASS_HEXBLADE = 40,
  SUBCLASS_ABJURATION = 41,
  SUBCLASS_CONJURATION = 42,
  SUBCLASS_DIVINATION = 43,
  SUBCLASS_ENCHANTMENT = 44,
  SUBCLASS_EVOCATION = 45,
  SUBCLASS_NECROMANCY = 46,
  SUBCLASS_TRANSMUTATION = 47,
  Subclass_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Subclass_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Subclass_internal_data_[];
inline constexpr Subclass Subclass_MIN =
    static_cast<Subclass>(0);
inline constexpr Subclass Subclass_MAX =
    static_cast<Subclass>(47);
inline bool Subclass_IsValid(int value) {
  return 0 <= value && value <= 47;
}
inline constexpr int Subclass_ARRAYSIZE = 47 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Subclass_descriptor();
template <typename T>
const ::std::string& Subclass_Name(T value) {
  static_assert(::std::is_same<T, Subclass>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Subclass_Name().");
  return Subclass_Name(static_cast<Subclass>(value));
}
template <>
inline const ::std::string& Subclass_Name(Subclass value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Subclass_descriptor, 0, 47>(
      static_cast<int>(value));
}
inline bool Subclass_Parse(
    ::absl::string_view name, Subclass* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Subclass>(Subclass_descriptor(), name,
                                           value);
}
enum Ability : int {
  ABILITY_UNSPECIFIED = 0,
  ABILITY_STRENGTH = 1,
  ABILITY_DEXTERITY = 2,
  ABILITY_CONSTITUTION = 3,
  ABILITY_INTELLIGENCE = 4,
  ABILITY_WISDOM = 5,
  ABILITY_CHARISMA = 6,
  Ability_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Ability_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Ability_internal_data_[];
inline constexpr Ability Ability_MIN =
    static_cast<Ability>(0);
inline constexpr Ability Ability_MAX =
    static_cast<Ability>(6);
inline bool Ability_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int Ability_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Ability_descriptor();
template <typename T>
const ::std::string& Ability_Name(T value) {
  static_assert(::std::is_same<T, Ability>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Ability_Name().");
  return Ability_Name(static_cast<Ability>(value));
}
template <>
inline const ::std::string& Ability_Name(Ability value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Ability_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool Ability_Parse(
    ::absl::string_view name, Ability* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ability>(Ability_descriptor(), name,
                                           value);
}
enum Skill : int {
  SKILL_UNSPECIFIED = 0,
  SKILL_ACROBATICS = 1,
  SKILL_ANIMAL_HANDLING = 2,
  SKILL_ARCANA = 3,
  SKILL_ATHLETICS = 4,
  SKILL_DECEPTION = 5,
  SKILL_HISTORY = 6,
  SKILL_INSIGHT = 7,
  SKILL_INTIMIDATION = 8,
  SKILL_INVESTIGATION = 9,
  SKILL_MEDICINE = 10,
  SKILL_NATURE = 11,
  SKILL_PERCEPTION = 12,
  SKILL_PERFORMANCE = 13,
  SKILL_PERSUASION = 14,
  SKILL_RELIGION = 15,
  SKILL_SLEIGHT_OF_HAND = 16,
  SKILL_STEALTH = 17,
  SKILL_SURVIVAL = 18,
  Skill_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Skill_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Skill_internal_data_[];
inline constexpr Skill Skill_MIN =
    static_cast<Skill>(0);
inline constexpr Skill Skill_MAX =
    static_cast<Skill>(18);
inline bool Skill_IsValid(int value) {
  return 0 <= value && value <= 18;
}
inline constexpr int Skill_ARRAYSIZE = 18 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Skill_descriptor();
template <typename T>
const ::std::string& Skill_Name(T value) {
  static_assert(::std::is_same<T, Skill>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Skill_Name().");
  return Skill_Name(static_cast<Skill>(value));
}
template <>
inline const ::std::string& Skill_Name(Skill value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Skill_descriptor, 0, 18>(
      static_cast<int>(value));
}
inline bool Skill_Parse(
    ::absl::string_view name, Skill* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Skill>(Skill_descriptor(), name,
                                           value);
}
enum Alignment : int {
  ALIGNMENT_UNSPECIFIED = 0,
  ALIGNMENT_LAWFUL_GOOD = 1,
  ALIGNMENT_NEUTRAL_GOOD = 2,
  ALIGNMENT_CHAOTIC_GOOD = 3,
  ALIGNMENT_LAWFUL_NEUTRAL = 4,
  ALIGNMENT_TRUE_NEUTRAL = 5,
  ALIGNMENT_CHAOTIC_NEUTRAL = 6,
  ALIGNMENT_LAWFUL_EVIL = 7,
  ALIGNMENT_NEUTRAL_EVIL = 8,
  ALIGNMENT_CHAOTIC_EVIL = 9,
  Alignment_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Alignment_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Alignment_internal_data_[];
inline constexpr Alignment Alignment_MIN =
    static_cast<Alignment>(0);
inline constexpr Alignment Alignment_MAX =
    static_cast<Alignment>(9);
inline bool Alignment_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int Alignment_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Alignment_descriptor();
template <typename T>
const ::std::string& Alignment_Name(T value) {
  static_assert(::std::is_same<T, Alignment>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Alignment_Name().");
  return Alignment_Name(static_cast<Alignment>(value));
}
template <>
inline const ::std::string& Alignment_Name(Alignment value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Alignment_descriptor, 0, 9>(
      static_cast<int>(value));
}
inline bool Alignment_Parse(
    ::absl::string_view name, Alignment* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alignment>(Alignment_descriptor(), name,
                                           value);
}
enum Background : int {
  BACKGROUND_UNSPECIFIED = 0,
  BACKGROUND_ACOLYTE = 1,
  BACKGROUND_CHARLATAN = 2,
  BACKGROUND_CRIMINAL = 3,
  BACKGROUND_ENTERTAINER = 4,
  BACKGROUND_FOLK_HERO = 5,
  BACKGROUND_GUILD_ARTISAN = 6,
  BACKGROUND_HERMIT = 7,
  BACKGROUND_NOBLE = 8,
  BACKGROUND_OUTLANDER = 9,
  BACKGROUND_SAGE = 10,
  BACKGROUND_SAILOR = 11,
  BACKGROUND_SOLDIER = 12,
  BACKGROUND_URCHIN = 13,
  Background_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Background_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Background_internal_data_[];
inline constexpr Background Background_MIN =
    static_cast<Background>(0);
inline constexpr Background Background_MAX =
    static_cast<Background>(13);
inline bool Background_IsValid(int value) {
  return 0 <= value && value <= 13;
}
inline constexpr int Background_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Background_descriptor();
template <typename T>
const ::std::string& Background_Name(T value) {
  static_assert(::std::is_same<T, Background>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Background_Name().");
  return Background_Name(static_cast<Background>(value));
}
template <>
inline const ::std::string& Background_Name(Background value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Background_descriptor, 0, 13>(
      static_cast<int>(value));
}
inline bool Background_Parse(
    ::absl::string_view name, Background* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Background>(Background_descriptor(), name,
                                           value);
}
enum Language : int {
  LANGUAGE_UNSPECIFIED = 0,
  LANGUAGE_COMMON = 1,
  LANGUAGE_DWARVISH = 2,
  LANGUAGE_ELVISH = 3,
  LANGUAGE_GIANT = 4,
  LANGUAGE_GNOMISH = 5,
  LANGUAGE_GOBLIN = 6,
  LANGUAGE_HALFLING = 7,
  LANGUAGE_ORC = 8,
  LANGUAGE_ABYSSAL = 9,
  LANGUAGE_CELESTIAL = 10,
  LANGUAGE_DRACONIC = 11,
  LANGUAGE_DEEP_SPEECH = 12,
  LANGUAGE_INFERNAL = 13,
  LANGUAGE_PRIMORDIAL = 14,
  LANGUAGE_SYLVAN = 15,
  LANGUAGE_UNDERCOMMON = 16,
  Language_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Language_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Language_internal_data_[];
inline constexpr Language Language_MIN =
    static_cast<Language>(0);
inline constexpr Language Language_MAX =
    static_cast<Language>(16);
inline bool Language_IsValid(int value) {
  return 0 <= value && value <= 16;
}
inline constexpr int Language_ARRAYSIZE = 16 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Language_descriptor();
template <typename T>
const ::std::string& Language_Name(T value) {
  static_assert(::std::is_same<T, Language>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Language_Name().");
  return Language_Name(static_cast<Language>(value));
}
template <>
inline const ::std::string& Language_Name(Language value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Language_descriptor, 0, 16>(
      static_cast<int>(value));
}
inline bool Language_Parse(
    ::absl::string_view name, Language* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Language>(Language_descriptor(), name,
                                           value);
}
enum EquipmentType : int {
  EQUIPMENT_TYPE_UNSPECIFIED = 0,
  EQUIPMENT_TYPE_SIMPLE_MELEE_WEAPON = 1,
  EQUIPMENT_TYPE_SIMPLE_RANGED_WEAPON = 2,
  EQUIPMENT_TYPE_MARTIAL_MELEE_WEAPON = 3,
  EQUIPMENT_TYPE_MARTIAL_RANGED_WEAPON = 4,
  EQUIPMENT_TYPE_LIGHT_ARMOR = 5,
  EQUIPMENT_TYPE_MEDIUM_ARMOR = 6,
  EQUIPMENT_TYPE_HEAVY_ARMOR = 7,
  EQUIPMENT_TYPE_SHIELD = 8,
  EQUIPMENT_TYPE_ADVENTURING_GEAR = 9,
  EQUIPMENT_TYPE_TOOLS = 10,
  EQUIPMENT_TYPE_ARTISAN_TOOLS = 11,
  EQUIPMENT_TYPE_GAMING_SET = 12,
  EQUIPMENT_TYPE_MUSICAL_INSTRUMENT = 13,
  EQUIPMENT_TYPE_VEHICLE = 14,
  EquipmentType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EquipmentType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EquipmentType_internal_data_[];
inline constexpr EquipmentType EquipmentType_MIN =
    static_cast<EquipmentType>(0);
inline constexpr EquipmentType EquipmentType_MAX =
    static_cast<EquipmentType>(14);
inline bool EquipmentType_IsValid(int value) {
  return 0 <= value && value <= 14;
}
inline constexpr int EquipmentType_ARRAYSIZE = 14 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EquipmentType_descriptor();
template <typename T>
const ::std::string& EquipmentType_Name(T value) {
  static_assert(::std::is_same<T, EquipmentType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EquipmentType_Name().");
  return EquipmentType_Name(static_cast<EquipmentType>(value));
}
template <>
inline const ::std::string& EquipmentType_Name(EquipmentType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EquipmentType_descriptor, 0, 14>(
      static_cast<int>(value));
}
inline bool EquipmentType_Parse(
    ::absl::string_view name, EquipmentType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EquipmentType>(EquipmentType_descriptor(), name,
                                           value);
}
enum Weapon : int {
  WEAPON_UNSPECIFIED = 0,
  WEAPON_CLUB = 1,
  WEAPON_DAGGER = 2,
  WEAPON_GREATCLUB = 3,
  WEAPON_HANDAXE = 4,
  WEAPON_JAVELIN = 5,
  WEAPON_LIGHT_HAMMER = 6,
  WEAPON_MACE = 7,
  WEAPON_QUARTERSTAFF = 8,
  WEAPON_SICKLE = 9,
  WEAPON_SPEAR = 10,
  WEAPON_LIGHT_CROSSBOW = 11,
  WEAPON_DART = 12,
  WEAPON_SHORTBOW = 13,
  WEAPON_SLING = 14,
  WEAPON_BATTLEAXE = 15,
  WEAPON_FLAIL = 16,
  WEAPON_GLAIVE = 17,
  WEAPON_GREATAXE = 18,
  WEAPON_GREATSWORD = 19,
  WEAPON_HALBERD = 20,
  WEAPON_LANCE = 21,
  WEAPON_LONGSWORD = 22,
  WEAPON_MAUL = 23,
  WEAPON_MORNINGSTAR = 24,
  WEAPON_PIKE = 25,
  WEAPON_RAPIER = 26,
  WEAPON_SCIMITAR = 27,
  WEAPON_SHORTSWORD = 28,
  WEAPON_TRIDENT = 29,
  WEAPON_WAR_PICK = 30,
  WEAPON_WARHAMMER = 31,
  WEAPON_WHIP = 32,
  WEAPON_BLOWGUN = 33,
  WEAPON_HAND_CROSSBOW = 34,
  WEAPON_HEAVY_CROSSBOW = 35,
  WEAPON_LONGBOW = 36,
  WEAPON_NET = 37,
  WEAPON_ARROWS_20 = 38,
  WEAPON_BOLTS_20 = 39,
  WEAPON_ANY_SIMPLE = 40,
  WEAPON_ANY_MARTIAL = 41,
  WEAPON_ANY = 42,
  Weapon_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Weapon_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Weapon_internal_data_[];
inline constexpr Weapon Weapon_MIN =
    static_cast<Weapon>(0);
inline constexpr Weapon Weapon_MAX =
    static_cast<Weapon>(42);
inline bool Weapon_IsValid(int value) {
  return 0 <= value && value <= 42;
}
inline constexpr int Weapon_ARRAYSIZE = 42 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Weapon_descriptor();
template <typename T>
const ::std::string& Weapon_Name(T value) {
  static_assert(::std::is_same<T, Weapon>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Weapon_Name().");
  return Weapon_Name(static_cast<Weapon>(value));
}
template <>
inline const ::std::string& Weapon_Name(Weapon value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Weapon_descriptor, 0, 42>(
      static_cast<int>(value));
}
inline bool Weapon_Parse(
    ::absl::string_view name, Weapon* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Weapon>(Weapon_descriptor(), name,
                                           value);
}
enum Armor : int {
  ARMOR_UNSPECIFIED = 0,
  ARMOR_PADDED = 1,
  ARMOR_LEATHER = 2,
  ARMOR_STUDDED_LEATHER = 3,
  ARMOR_HIDE = 4,
  ARMOR_CHAIN_SHIRT = 5,
  ARMOR_SCALE_MAIL = 6,
  ARMOR_BREASTPLATE = 7,
  ARMOR_HALF_PLATE = 8,
  ARMOR_RING_MAIL = 9,
  ARMOR_CHAIN_MAIL = 10,
  ARMOR_SPLINT = 11,
  ARMOR_PLATE = 12,
  ARMOR_SHIELD = 13,
  Armor_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Armor_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Armor_internal_data_[];
inline constexpr Armor Armor_MIN =
    static_cast<Armor>(0);
inline constexpr Armor Armor_MAX =
    static_cast<Armor>(13);
inline bool Armor_IsValid(int value) {
  return 0 <= value && value <= 13;
}
inline constexpr int Armor_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Armor_descriptor();
template <typename T>
const ::std::string& Armor_Name(T value) {
  static_assert(::std::is_same<T, Armor>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Armor_Name().");
  return Armor_Name(static_cast<Armor>(value));
}
template <>
inline const ::std::string& Armor_Name(Armor value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Armor_descriptor, 0, 13>(
      static_cast<int>(value));
}
inline bool Armor_Parse(
    ::absl::string_view name, Armor* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Armor>(Armor_descriptor(), name,
                                           value);
}
enum FightingStyle : int {
  FIGHTING_STYLE_UNSPECIFIED = 0,
  FIGHTING_STYLE_ARCHERY = 1,
  FIGHTING_STYLE_DEFENSE = 2,
  FIGHTING_STYLE_DUELING = 3,
  FIGHTING_STYLE_GREAT_WEAPON_FIGHTING = 4,
  FIGHTING_STYLE_PROTECTION = 5,
  FIGHTING_STYLE_TWO_WEAPON_FIGHTING = 6,
  FightingStyle_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  FightingStyle_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t FightingStyle_internal_data_[];
inline constexpr FightingStyle FightingStyle_MIN =
    static_cast<FightingStyle>(0);
inline constexpr FightingStyle FightingStyle_MAX =
    static_cast<FightingStyle>(6);
inline bool FightingStyle_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int FightingStyle_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL FightingStyle_descriptor();
template <typename T>
const ::std::string& FightingStyle_Name(T value) {
  static_assert(::std::is_same<T, FightingStyle>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to FightingStyle_Name().");
  return FightingStyle_Name(static_cast<FightingStyle>(value));
}
template <>
inline const ::std::string& FightingStyle_Name(FightingStyle value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FightingStyle_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool FightingStyle_Parse(
    ::absl::string_view name, FightingStyle* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<FightingStyle>(FightingStyle_descriptor(), name,
                                           value);
}
enum Tool : int {
  TOOL_UNSPECIFIED = 0,
  TOOL_ALCHEMIST_SUPPLIES = 1,
  TOOL_BREWER_SUPPLIES = 2,
  TOOL_CALLIGRAPHER_SUPPLIES = 3,
  TOOL_CARPENTER_TOOLS = 4,
  TOOL_CARTOGRAPHER_TOOLS = 5,
  TOOL_COBBLER_TOOLS = 6,
  TOOL_COOK_UTENSILS = 7,
  TOOL_GLASSBLOWER_TOOLS = 8,
  TOOL_JEWELER_TOOLS = 9,
  TOOL_LEATHERWORKER_TOOLS = 10,
  TOOL_MASON_TOOLS = 11,
  TOOL_PAINTER_SUPPLIES = 12,
  TOOL_POTTER_TOOLS = 13,
  TOOL_SMITH_TOOLS = 14,
  TOOL_TINKER_TOOLS = 15,
  TOOL_WEAVER_TOOLS = 16,
  TOOL_WOODCARVER_TOOLS = 17,
  TOOL_DICE_SET = 18,
  TOOL_DRAGONCHESS_SET = 19,
  TOOL_PLAYING_CARD_SET = 20,
  TOOL_THREE_DRAGON_ANTE = 21,
  TOOL_BAGPIPES = 22,
  TOOL_DRUM = 23,
  TOOL_DULCIMER = 24,
  TOOL_FLUTE = 25,
  TOOL_LUTE = 26,
  TOOL_LYRE = 27,
  TOOL_HORN = 28,
  TOOL_PAN_FLUTE = 29,
  TOOL_SHAWM = 30,
  TOOL_VIOL = 31,
  TOOL_DISGUISE_KIT = 32,
  TOOL_FORGERY_KIT = 33,
  TOOL_HERBALISM_KIT = 34,
  TOOL_NAVIGATOR_TOOLS = 35,
  TOOL_POISONER_KIT = 36,
  TOOL_THIEVES_TOOLS = 37,
  TOOL_VEHICLES_LAND = 38,
  TOOL_VEHICLES_WATER = 39,
  Tool_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Tool_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Tool_internal_data_[];
inline constexpr Tool Tool_MIN =
    static_cast<Tool>(0);
inline constexpr Tool Tool_MAX =
    static_cast<Tool>(39);
inline bool Tool_IsValid(int value) {
  return 0 <= value && value <= 39;
}
inline constexpr int Tool_ARRAYSIZE = 39 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Tool_descriptor();
template <typename T>
const ::std::string& Tool_Name(T value) {
  static_assert(::std::is_same<T, Tool>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Tool_Name().");
  return Tool_Name(static_cast<Tool>(value));
}
template <>
inline const ::std::string& Tool_Name(Tool value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Tool_descriptor, 0, 39>(
      static_cast<int>(value));
}
inline bool Tool_Parse(
    ::absl::string_view name, Tool* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Tool>(Tool_descriptor(), name,
                                           value);
}

// ===================================================================



// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Race> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Race>() {
  return ::dnd5e::api::v1alpha1::Race_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Subrace> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Subrace>() {
  return ::dnd5e::api::v1alpha1::Subrace_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Class> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Class>() {
  return ::dnd5e::api::v1alpha1::Class_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Subclass> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Subclass>() {
  return ::dnd5e::api::v1alpha1::Subclass_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Ability> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Ability>() {
  return ::dnd5e::api::v1alpha1::Ability_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Skill> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Skill>() {
  return ::dnd5e::api::v1alpha1::Skill_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Alignment> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Alignment>() {
  return ::dnd5e::api::v1alpha1::Alignment_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Background> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Background>() {
  return ::dnd5e::api::v1alpha1::Background_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Language> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Language>() {
  return ::dnd5e::api::v1alpha1::Language_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::EquipmentType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::EquipmentType>() {
  return ::dnd5e::api::v1alpha1::EquipmentType_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Weapon> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Weapon>() {
  return ::dnd5e::api::v1alpha1::Weapon_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Armor> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Armor>() {
  return ::dnd5e::api::v1alpha1::Armor_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::FightingStyle> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::FightingStyle>() {
  return ::dnd5e::api::v1alpha1::FightingStyle_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Tool> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Tool>() {
  return ::dnd5e::api::v1alpha1::Tool_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // dnd5e_2fapi_2fv1alpha1_2fenums_2eproto_2epb_2eh
