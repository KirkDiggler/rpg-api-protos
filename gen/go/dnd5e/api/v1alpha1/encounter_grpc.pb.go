// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: dnd5e/api/v1alpha1/encounter.proto

package apiv1alpha1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	EncounterService_CreateEncounter_FullMethodName       = "/dnd5e.api.v1alpha1.EncounterService/CreateEncounter"
	EncounterService_JoinEncounter_FullMethodName         = "/dnd5e.api.v1alpha1.EncounterService/JoinEncounter"
	EncounterService_SetReady_FullMethodName              = "/dnd5e.api.v1alpha1.EncounterService/SetReady"
	EncounterService_StartCombat_FullMethodName           = "/dnd5e.api.v1alpha1.EncounterService/StartCombat"
	EncounterService_LeaveEncounter_FullMethodName        = "/dnd5e.api.v1alpha1.EncounterService/LeaveEncounter"
	EncounterService_StreamEncounterEvents_FullMethodName = "/dnd5e.api.v1alpha1.EncounterService/StreamEncounterEvents"
	EncounterService_DungeonStart_FullMethodName          = "/dnd5e.api.v1alpha1.EncounterService/DungeonStart"
	EncounterService_OpenDoor_FullMethodName              = "/dnd5e.api.v1alpha1.EncounterService/OpenDoor"
	EncounterService_GetCombatState_FullMethodName        = "/dnd5e.api.v1alpha1.EncounterService/GetCombatState"
	EncounterService_GetEncounterState_FullMethodName     = "/dnd5e.api.v1alpha1.EncounterService/GetEncounterState"
	EncounterService_GetEncounterHistory_FullMethodName   = "/dnd5e.api.v1alpha1.EncounterService/GetEncounterHistory"
	EncounterService_MoveCharacter_FullMethodName         = "/dnd5e.api.v1alpha1.EncounterService/MoveCharacter"
	EncounterService_EndTurn_FullMethodName               = "/dnd5e.api.v1alpha1.EncounterService/EndTurn"
	EncounterService_Attack_FullMethodName                = "/dnd5e.api.v1alpha1.EncounterService/Attack"
	EncounterService_ActivateFeature_FullMethodName       = "/dnd5e.api.v1alpha1.EncounterService/ActivateFeature"
)

// EncounterServiceClient is the client API for EncounterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// EncounterService manages D&D 5e encounters
type EncounterServiceClient interface {
	// CreateEncounter creates a new encounter lobby with a join code
	CreateEncounter(ctx context.Context, in *CreateEncounterRequest, opts ...grpc.CallOption) (*CreateEncounterResponse, error)
	// JoinEncounter joins an existing encounter via join code
	JoinEncounter(ctx context.Context, in *JoinEncounterRequest, opts ...grpc.CallOption) (*JoinEncounterResponse, error)
	// SetReady marks a player as ready to start combat
	SetReady(ctx context.Context, in *SetReadyRequest, opts ...grpc.CallOption) (*SetReadyResponse, error)
	// StartCombat begins combat (host only, all players must be ready)
	StartCombat(ctx context.Context, in *StartCombatRequest, opts ...grpc.CallOption) (*StartCombatResponse, error)
	// LeaveEncounter removes a player from the encounter
	LeaveEncounter(ctx context.Context, in *LeaveEncounterRequest, opts ...grpc.CallOption) (*LeaveEncounterResponse, error)
	// StreamEncounterEvents subscribes to real-time encounter events
	StreamEncounterEvents(ctx context.Context, in *StreamEncounterEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[EncounterEvent], error)
	// Deprecated: Do not use.
	// Deprecated: Use CreateEncounter + StartCombat instead.
	// Single-player now uses the multiplayer flow (party of one).
	DungeonStart(ctx context.Context, in *DungeonStartRequest, opts ...grpc.CallOption) (*DungeonStartResponse, error)
	// OpenDoor opens a door to reveal and enter the next room
	OpenDoor(ctx context.Context, in *OpenDoorRequest, opts ...grpc.CallOption) (*OpenDoorResponse, error)
	// GetCombatState retrieves current state (for reconnection/refresh)
	// Deprecated: Use GetEncounterState for full snapshot with event sync
	GetCombatState(ctx context.Context, in *GetCombatStateRequest, opts ...grpc.CallOption) (*GetCombatStateResponse, error)
	// GetEncounterState retrieves full encounter snapshot for load-then-stream pattern
	// Returns complete state including last_event_id for client-side event filtering
	GetEncounterState(ctx context.Context, in *GetEncounterStateRequest, opts ...grpc.CallOption) (*GetEncounterStateResponse, error)
	// GetEncounterHistory retrieves historical events for late join/reconnect
	// Returns events up to the specified event ID for event log population
	GetEncounterHistory(ctx context.Context, in *GetEncounterHistoryRequest, opts ...grpc.CallOption) (*GetEncounterHistoryResponse, error)
	// MoveCharacter validates and executes movement along a path
	MoveCharacter(ctx context.Context, in *MoveCharacterRequest, opts ...grpc.CallOption) (*MoveCharacterResponse, error)
	// EndTurn ends the current entity's turn
	EndTurn(ctx context.Context, in *EndTurnRequest, opts ...grpc.CallOption) (*EndTurnResponse, error)
	// Attack executes a melee or ranged attack
	Attack(ctx context.Context, in *AttackRequest, opts ...grpc.CallOption) (*AttackResponse, error)
	// ActivateFeature activates a combat feature (e.g., Rage, Second Wind)
	ActivateFeature(ctx context.Context, in *ActivateFeatureRequest, opts ...grpc.CallOption) (*ActivateFeatureResponse, error)
}

type encounterServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEncounterServiceClient(cc grpc.ClientConnInterface) EncounterServiceClient {
	return &encounterServiceClient{cc}
}

func (c *encounterServiceClient) CreateEncounter(ctx context.Context, in *CreateEncounterRequest, opts ...grpc.CallOption) (*CreateEncounterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateEncounterResponse)
	err := c.cc.Invoke(ctx, EncounterService_CreateEncounter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) JoinEncounter(ctx context.Context, in *JoinEncounterRequest, opts ...grpc.CallOption) (*JoinEncounterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinEncounterResponse)
	err := c.cc.Invoke(ctx, EncounterService_JoinEncounter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) SetReady(ctx context.Context, in *SetReadyRequest, opts ...grpc.CallOption) (*SetReadyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetReadyResponse)
	err := c.cc.Invoke(ctx, EncounterService_SetReady_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) StartCombat(ctx context.Context, in *StartCombatRequest, opts ...grpc.CallOption) (*StartCombatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartCombatResponse)
	err := c.cc.Invoke(ctx, EncounterService_StartCombat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) LeaveEncounter(ctx context.Context, in *LeaveEncounterRequest, opts ...grpc.CallOption) (*LeaveEncounterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeaveEncounterResponse)
	err := c.cc.Invoke(ctx, EncounterService_LeaveEncounter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) StreamEncounterEvents(ctx context.Context, in *StreamEncounterEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[EncounterEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EncounterService_ServiceDesc.Streams[0], EncounterService_StreamEncounterEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamEncounterEventsRequest, EncounterEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EncounterService_StreamEncounterEventsClient = grpc.ServerStreamingClient[EncounterEvent]

// Deprecated: Do not use.
func (c *encounterServiceClient) DungeonStart(ctx context.Context, in *DungeonStartRequest, opts ...grpc.CallOption) (*DungeonStartResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DungeonStartResponse)
	err := c.cc.Invoke(ctx, EncounterService_DungeonStart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) OpenDoor(ctx context.Context, in *OpenDoorRequest, opts ...grpc.CallOption) (*OpenDoorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenDoorResponse)
	err := c.cc.Invoke(ctx, EncounterService_OpenDoor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) GetCombatState(ctx context.Context, in *GetCombatStateRequest, opts ...grpc.CallOption) (*GetCombatStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCombatStateResponse)
	err := c.cc.Invoke(ctx, EncounterService_GetCombatState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) GetEncounterState(ctx context.Context, in *GetEncounterStateRequest, opts ...grpc.CallOption) (*GetEncounterStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEncounterStateResponse)
	err := c.cc.Invoke(ctx, EncounterService_GetEncounterState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) GetEncounterHistory(ctx context.Context, in *GetEncounterHistoryRequest, opts ...grpc.CallOption) (*GetEncounterHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEncounterHistoryResponse)
	err := c.cc.Invoke(ctx, EncounterService_GetEncounterHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) MoveCharacter(ctx context.Context, in *MoveCharacterRequest, opts ...grpc.CallOption) (*MoveCharacterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MoveCharacterResponse)
	err := c.cc.Invoke(ctx, EncounterService_MoveCharacter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) EndTurn(ctx context.Context, in *EndTurnRequest, opts ...grpc.CallOption) (*EndTurnResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndTurnResponse)
	err := c.cc.Invoke(ctx, EncounterService_EndTurn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) Attack(ctx context.Context, in *AttackRequest, opts ...grpc.CallOption) (*AttackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AttackResponse)
	err := c.cc.Invoke(ctx, EncounterService_Attack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *encounterServiceClient) ActivateFeature(ctx context.Context, in *ActivateFeatureRequest, opts ...grpc.CallOption) (*ActivateFeatureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActivateFeatureResponse)
	err := c.cc.Invoke(ctx, EncounterService_ActivateFeature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EncounterServiceServer is the server API for EncounterService service.
// All implementations should embed UnimplementedEncounterServiceServer
// for forward compatibility.
//
// EncounterService manages D&D 5e encounters
type EncounterServiceServer interface {
	// CreateEncounter creates a new encounter lobby with a join code
	CreateEncounter(context.Context, *CreateEncounterRequest) (*CreateEncounterResponse, error)
	// JoinEncounter joins an existing encounter via join code
	JoinEncounter(context.Context, *JoinEncounterRequest) (*JoinEncounterResponse, error)
	// SetReady marks a player as ready to start combat
	SetReady(context.Context, *SetReadyRequest) (*SetReadyResponse, error)
	// StartCombat begins combat (host only, all players must be ready)
	StartCombat(context.Context, *StartCombatRequest) (*StartCombatResponse, error)
	// LeaveEncounter removes a player from the encounter
	LeaveEncounter(context.Context, *LeaveEncounterRequest) (*LeaveEncounterResponse, error)
	// StreamEncounterEvents subscribes to real-time encounter events
	StreamEncounterEvents(*StreamEncounterEventsRequest, grpc.ServerStreamingServer[EncounterEvent]) error
	// Deprecated: Do not use.
	// Deprecated: Use CreateEncounter + StartCombat instead.
	// Single-player now uses the multiplayer flow (party of one).
	DungeonStart(context.Context, *DungeonStartRequest) (*DungeonStartResponse, error)
	// OpenDoor opens a door to reveal and enter the next room
	OpenDoor(context.Context, *OpenDoorRequest) (*OpenDoorResponse, error)
	// GetCombatState retrieves current state (for reconnection/refresh)
	// Deprecated: Use GetEncounterState for full snapshot with event sync
	GetCombatState(context.Context, *GetCombatStateRequest) (*GetCombatStateResponse, error)
	// GetEncounterState retrieves full encounter snapshot for load-then-stream pattern
	// Returns complete state including last_event_id for client-side event filtering
	GetEncounterState(context.Context, *GetEncounterStateRequest) (*GetEncounterStateResponse, error)
	// GetEncounterHistory retrieves historical events for late join/reconnect
	// Returns events up to the specified event ID for event log population
	GetEncounterHistory(context.Context, *GetEncounterHistoryRequest) (*GetEncounterHistoryResponse, error)
	// MoveCharacter validates and executes movement along a path
	MoveCharacter(context.Context, *MoveCharacterRequest) (*MoveCharacterResponse, error)
	// EndTurn ends the current entity's turn
	EndTurn(context.Context, *EndTurnRequest) (*EndTurnResponse, error)
	// Attack executes a melee or ranged attack
	Attack(context.Context, *AttackRequest) (*AttackResponse, error)
	// ActivateFeature activates a combat feature (e.g., Rage, Second Wind)
	ActivateFeature(context.Context, *ActivateFeatureRequest) (*ActivateFeatureResponse, error)
}

// UnimplementedEncounterServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEncounterServiceServer struct{}

func (UnimplementedEncounterServiceServer) CreateEncounter(context.Context, *CreateEncounterRequest) (*CreateEncounterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateEncounter not implemented")
}
func (UnimplementedEncounterServiceServer) JoinEncounter(context.Context, *JoinEncounterRequest) (*JoinEncounterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method JoinEncounter not implemented")
}
func (UnimplementedEncounterServiceServer) SetReady(context.Context, *SetReadyRequest) (*SetReadyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetReady not implemented")
}
func (UnimplementedEncounterServiceServer) StartCombat(context.Context, *StartCombatRequest) (*StartCombatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartCombat not implemented")
}
func (UnimplementedEncounterServiceServer) LeaveEncounter(context.Context, *LeaveEncounterRequest) (*LeaveEncounterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LeaveEncounter not implemented")
}
func (UnimplementedEncounterServiceServer) StreamEncounterEvents(*StreamEncounterEventsRequest, grpc.ServerStreamingServer[EncounterEvent]) error {
	return status.Error(codes.Unimplemented, "method StreamEncounterEvents not implemented")
}
func (UnimplementedEncounterServiceServer) DungeonStart(context.Context, *DungeonStartRequest) (*DungeonStartResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DungeonStart not implemented")
}
func (UnimplementedEncounterServiceServer) OpenDoor(context.Context, *OpenDoorRequest) (*OpenDoorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method OpenDoor not implemented")
}
func (UnimplementedEncounterServiceServer) GetCombatState(context.Context, *GetCombatStateRequest) (*GetCombatStateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCombatState not implemented")
}
func (UnimplementedEncounterServiceServer) GetEncounterState(context.Context, *GetEncounterStateRequest) (*GetEncounterStateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEncounterState not implemented")
}
func (UnimplementedEncounterServiceServer) GetEncounterHistory(context.Context, *GetEncounterHistoryRequest) (*GetEncounterHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEncounterHistory not implemented")
}
func (UnimplementedEncounterServiceServer) MoveCharacter(context.Context, *MoveCharacterRequest) (*MoveCharacterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MoveCharacter not implemented")
}
func (UnimplementedEncounterServiceServer) EndTurn(context.Context, *EndTurnRequest) (*EndTurnResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EndTurn not implemented")
}
func (UnimplementedEncounterServiceServer) Attack(context.Context, *AttackRequest) (*AttackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Attack not implemented")
}
func (UnimplementedEncounterServiceServer) ActivateFeature(context.Context, *ActivateFeatureRequest) (*ActivateFeatureResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ActivateFeature not implemented")
}
func (UnimplementedEncounterServiceServer) testEmbeddedByValue() {}

// UnsafeEncounterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EncounterServiceServer will
// result in compilation errors.
type UnsafeEncounterServiceServer interface {
	mustEmbedUnimplementedEncounterServiceServer()
}

func RegisterEncounterServiceServer(s grpc.ServiceRegistrar, srv EncounterServiceServer) {
	// If the following call panics, it indicates UnimplementedEncounterServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EncounterService_ServiceDesc, srv)
}

func _EncounterService_CreateEncounter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEncounterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).CreateEncounter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_CreateEncounter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).CreateEncounter(ctx, req.(*CreateEncounterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_JoinEncounter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinEncounterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).JoinEncounter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_JoinEncounter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).JoinEncounter(ctx, req.(*JoinEncounterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_SetReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).SetReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_SetReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).SetReady(ctx, req.(*SetReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_StartCombat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartCombatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).StartCombat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_StartCombat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).StartCombat(ctx, req.(*StartCombatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_LeaveEncounter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveEncounterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).LeaveEncounter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_LeaveEncounter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).LeaveEncounter(ctx, req.(*LeaveEncounterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_StreamEncounterEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamEncounterEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EncounterServiceServer).StreamEncounterEvents(m, &grpc.GenericServerStream[StreamEncounterEventsRequest, EncounterEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EncounterService_StreamEncounterEventsServer = grpc.ServerStreamingServer[EncounterEvent]

func _EncounterService_DungeonStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DungeonStartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).DungeonStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_DungeonStart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).DungeonStart(ctx, req.(*DungeonStartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_OpenDoor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenDoorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).OpenDoor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_OpenDoor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).OpenDoor(ctx, req.(*OpenDoorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_GetCombatState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCombatStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).GetCombatState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_GetCombatState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).GetCombatState(ctx, req.(*GetCombatStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_GetEncounterState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEncounterStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).GetEncounterState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_GetEncounterState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).GetEncounterState(ctx, req.(*GetEncounterStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_GetEncounterHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEncounterHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).GetEncounterHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_GetEncounterHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).GetEncounterHistory(ctx, req.(*GetEncounterHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_MoveCharacter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveCharacterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).MoveCharacter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_MoveCharacter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).MoveCharacter(ctx, req.(*MoveCharacterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_EndTurn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndTurnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).EndTurn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_EndTurn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).EndTurn(ctx, req.(*EndTurnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_Attack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).Attack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_Attack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).Attack(ctx, req.(*AttackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EncounterService_ActivateFeature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateFeatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EncounterServiceServer).ActivateFeature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EncounterService_ActivateFeature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EncounterServiceServer).ActivateFeature(ctx, req.(*ActivateFeatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EncounterService_ServiceDesc is the grpc.ServiceDesc for EncounterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EncounterService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dnd5e.api.v1alpha1.EncounterService",
	HandlerType: (*EncounterServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEncounter",
			Handler:    _EncounterService_CreateEncounter_Handler,
		},
		{
			MethodName: "JoinEncounter",
			Handler:    _EncounterService_JoinEncounter_Handler,
		},
		{
			MethodName: "SetReady",
			Handler:    _EncounterService_SetReady_Handler,
		},
		{
			MethodName: "StartCombat",
			Handler:    _EncounterService_StartCombat_Handler,
		},
		{
			MethodName: "LeaveEncounter",
			Handler:    _EncounterService_LeaveEncounter_Handler,
		},
		{
			MethodName: "DungeonStart",
			Handler:    _EncounterService_DungeonStart_Handler,
		},
		{
			MethodName: "OpenDoor",
			Handler:    _EncounterService_OpenDoor_Handler,
		},
		{
			MethodName: "GetCombatState",
			Handler:    _EncounterService_GetCombatState_Handler,
		},
		{
			MethodName: "GetEncounterState",
			Handler:    _EncounterService_GetEncounterState_Handler,
		},
		{
			MethodName: "GetEncounterHistory",
			Handler:    _EncounterService_GetEncounterHistory_Handler,
		},
		{
			MethodName: "MoveCharacter",
			Handler:    _EncounterService_MoveCharacter_Handler,
		},
		{
			MethodName: "EndTurn",
			Handler:    _EncounterService_EndTurn_Handler,
		},
		{
			MethodName: "Attack",
			Handler:    _EncounterService_Attack_Handler,
		},
		{
			MethodName: "ActivateFeature",
			Handler:    _EncounterService_ActivateFeature_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamEncounterEvents",
			Handler:       _EncounterService_StreamEncounterEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dnd5e/api/v1alpha1/encounter.proto",
}
