// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: dnd5e/api/v1alpha1/enums.proto
// Protobuf C++ Version: 6.33.2

#ifndef dnd5e_2fapi_2fv1alpha1_2fenums_2eproto_2epb_2eh
#define dnd5e_2fapi_2fv1alpha1_2fenums_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dnd5e_2fapi_2fv1alpha1_2fenums_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_dnd5e_2fapi_2fv1alpha1_2fenums_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_dnd5e_2fapi_2fv1alpha1_2fenums_2eproto;
}  // extern "C"
namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum Ability : int;
extern const uint32_t Ability_internal_data_[];
enum ActionType : int;
extern const uint32_t ActionType_internal_data_[];
enum Alignment : int;
extern const uint32_t Alignment_internal_data_[];
enum Ammunition : int;
extern const uint32_t Ammunition_internal_data_[];
enum Armor : int;
extern const uint32_t Armor_internal_data_[];
enum ArmorCategory : int;
extern const uint32_t ArmorCategory_internal_data_[];
enum ArmorProficiencyCategory : int;
extern const uint32_t ArmorProficiencyCategory_internal_data_[];
enum AttackHand : int;
extern const uint32_t AttackHand_internal_data_[];
enum Background : int;
extern const uint32_t Background_internal_data_[];
enum Class : int;
extern const uint32_t Class_internal_data_[];
enum ConditionId : int;
extern const uint32_t ConditionId_internal_data_[];
enum DamageType : int;
extern const uint32_t DamageType_internal_data_[];
enum DungeonDifficulty : int;
extern const uint32_t DungeonDifficulty_internal_data_[];
enum DungeonLength : int;
extern const uint32_t DungeonLength_internal_data_[];
enum DungeonState : int;
extern const uint32_t DungeonState_internal_data_[];
enum DungeonTheme : int;
extern const uint32_t DungeonTheme_internal_data_[];
enum EntitySize : int;
extern const uint32_t EntitySize_internal_data_[];
enum EntityType : int;
extern const uint32_t EntityType_internal_data_[];
enum EquipmentCategory : int;
extern const uint32_t EquipmentCategory_internal_data_[];
enum EquipmentType : int;
extern const uint32_t EquipmentType_internal_data_[];
enum FeatureId : int;
extern const uint32_t FeatureId_internal_data_[];
enum FightingStyle : int;
extern const uint32_t FightingStyle_internal_data_[];
enum GearCategory : int;
extern const uint32_t GearCategory_internal_data_[];
enum Language : int;
extern const uint32_t Language_internal_data_[];
enum MonsterActionType : int;
extern const uint32_t MonsterActionType_internal_data_[];
enum MonsterTraitId : int;
extern const uint32_t MonsterTraitId_internal_data_[];
enum MonsterType : int;
extern const uint32_t MonsterType_internal_data_[];
enum ObstacleType : int;
extern const uint32_t ObstacleType_internal_data_[];
enum Pack : int;
extern const uint32_t Pack_internal_data_[];
enum Race : int;
extern const uint32_t Race_internal_data_[];
enum Skill : int;
extern const uint32_t Skill_internal_data_[];
enum Spell : int;
extern const uint32_t Spell_internal_data_[];
enum Subclass : int;
extern const uint32_t Subclass_internal_data_[];
enum Subrace : int;
extern const uint32_t Subrace_internal_data_[];
enum Tool : int;
extern const uint32_t Tool_internal_data_[];
enum ToolCategory : int;
extern const uint32_t ToolCategory_internal_data_[];
enum ToolProficiencyCategory : int;
extern const uint32_t ToolProficiencyCategory_internal_data_[];
enum Trait : int;
extern const uint32_t Trait_internal_data_[];
enum Weapon : int;
extern const uint32_t Weapon_internal_data_[];
enum WeaponCategory : int;
extern const uint32_t WeaponCategory_internal_data_[];
enum WeaponProficiencyCategory : int;
extern const uint32_t WeaponProficiencyCategory_internal_data_[];
enum WeaponProperty : int;
extern const uint32_t WeaponProperty_internal_data_[];
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Ability_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Ability>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::ActionType_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::ActionType>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Alignment_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Alignment>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Ammunition_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Ammunition>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Armor_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Armor>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::ArmorCategory_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::ArmorCategory>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::ArmorProficiencyCategory_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::ArmorProficiencyCategory>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::AttackHand_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::AttackHand>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Background_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Background>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Class_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Class>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::ConditionId_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::ConditionId>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::DamageType_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::DamageType>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::DungeonDifficulty_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::DungeonDifficulty>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::DungeonLength_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::DungeonLength>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::DungeonState_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::DungeonState>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::DungeonTheme_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::DungeonTheme>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::EntitySize_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::EntitySize>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::EntityType_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::EntityType>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::EquipmentCategory_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::EquipmentCategory>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::EquipmentType_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::EquipmentType>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::FeatureId_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::FeatureId>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::FightingStyle_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::FightingStyle>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::GearCategory_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::GearCategory>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Language_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Language>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::MonsterActionType_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::MonsterActionType>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::MonsterTraitId_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::MonsterTraitId>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::MonsterType_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::MonsterType>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::ObstacleType_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::ObstacleType>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Pack_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Pack>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Race_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Race>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Skill_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Skill>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Spell_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Spell>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Subclass_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Subclass>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Subrace_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Subrace>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Tool_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Tool>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::ToolCategory_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::ToolCategory>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::ToolProficiencyCategory_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::ToolProficiencyCategory>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Trait_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Trait>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Weapon_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Weapon>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::WeaponCategory_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::WeaponCategory>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::WeaponProficiencyCategory_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::WeaponProficiencyCategory>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::WeaponProperty_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::WeaponProperty>;
}  // namespace protobuf
}  // namespace google

namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum Race : int {
  RACE_UNSPECIFIED = 0,
  RACE_HUMAN = 1,
  RACE_ELF = 2,
  RACE_DWARF = 3,
  RACE_HALFLING = 4,
  RACE_DRAGONBORN = 5,
  RACE_GNOME = 6,
  RACE_HALF_ELF = 7,
  RACE_HALF_ORC = 8,
  RACE_TIEFLING = 9,
  Race_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Race_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Race_internal_data_[];
inline constexpr Race Race_MIN =
    static_cast<Race>(0);
inline constexpr Race Race_MAX =
    static_cast<Race>(9);
inline bool Race_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int Race_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Race_descriptor();
template <typename T>
const ::std::string& Race_Name(T value) {
  static_assert(::std::is_same<T, Race>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Race_Name().");
  return Race_Name(static_cast<Race>(value));
}
template <>
inline const ::std::string& Race_Name(Race value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Race_descriptor, 0, 9>(
      static_cast<int>(value));
}
inline bool Race_Parse(
    ::absl::string_view name, Race* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Race>(Race_descriptor(), name,
                                           value);
}
enum Subrace : int {
  SUBRACE_UNSPECIFIED = 0,
  SUBRACE_HIGH_ELF = 1,
  SUBRACE_WOOD_ELF = 2,
  SUBRACE_DARK_ELF = 3,
  SUBRACE_HILL_DWARF = 4,
  SUBRACE_MOUNTAIN_DWARF = 5,
  SUBRACE_LIGHTFOOT_HALFLING = 6,
  SUBRACE_STOUT_HALFLING = 7,
  SUBRACE_FOREST_GNOME = 8,
  SUBRACE_ROCK_GNOME = 9,
  Subrace_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Subrace_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Subrace_internal_data_[];
inline constexpr Subrace Subrace_MIN =
    static_cast<Subrace>(0);
inline constexpr Subrace Subrace_MAX =
    static_cast<Subrace>(9);
inline bool Subrace_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int Subrace_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Subrace_descriptor();
template <typename T>
const ::std::string& Subrace_Name(T value) {
  static_assert(::std::is_same<T, Subrace>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Subrace_Name().");
  return Subrace_Name(static_cast<Subrace>(value));
}
template <>
inline const ::std::string& Subrace_Name(Subrace value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Subrace_descriptor, 0, 9>(
      static_cast<int>(value));
}
inline bool Subrace_Parse(
    ::absl::string_view name, Subrace* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Subrace>(Subrace_descriptor(), name,
                                           value);
}
enum Class : int {
  CLASS_UNSPECIFIED = 0,
  CLASS_BARBARIAN = 1,
  CLASS_BARD = 2,
  CLASS_CLERIC = 3,
  CLASS_DRUID = 4,
  CLASS_FIGHTER = 5,
  CLASS_MONK = 6,
  CLASS_PALADIN = 7,
  CLASS_RANGER = 8,
  CLASS_ROGUE = 9,
  CLASS_SORCERER = 10,
  CLASS_WARLOCK = 11,
  CLASS_WIZARD = 12,
  Class_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Class_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Class_internal_data_[];
inline constexpr Class Class_MIN =
    static_cast<Class>(0);
inline constexpr Class Class_MAX =
    static_cast<Class>(12);
inline bool Class_IsValid(int value) {
  return 0 <= value && value <= 12;
}
inline constexpr int Class_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Class_descriptor();
template <typename T>
const ::std::string& Class_Name(T value) {
  static_assert(::std::is_same<T, Class>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Class_Name().");
  return Class_Name(static_cast<Class>(value));
}
template <>
inline const ::std::string& Class_Name(Class value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Class_descriptor, 0, 12>(
      static_cast<int>(value));
}
inline bool Class_Parse(
    ::absl::string_view name, Class* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Class>(Class_descriptor(), name,
                                           value);
}
enum Subclass : int {
  SUBCLASS_UNSPECIFIED = 0,
  SUBCLASS_CHAMPION = 1,
  SUBCLASS_BATTLE_MASTER = 2,
  SUBCLASS_ELDRITCH_KNIGHT = 3,
  SUBCLASS_BERSERKER = 4,
  SUBCLASS_TOTEM = 5,
  SUBCLASS_ANCESTRAL = 6,
  SUBCLASS_LORE = 7,
  SUBCLASS_VALOR = 8,
  SUBCLASS_GLAMOUR = 9,
  SUBCLASS_LIFE_DOMAIN = 10,
  SUBCLASS_DEATH_DOMAIN = 11,
  SUBCLASS_TRICKERY_DOMAIN = 12,
  SUBCLASS_NATURE_DOMAIN = 13,
  SUBCLASS_WAR_DOMAIN = 14,
  SUBCLASS_LIGHT_DOMAIN = 15,
  SUBCLASS_TEMPEST_DOMAIN = 16,
  SUBCLASS_KNOWLEDGE_DOMAIN = 17,
  SUBCLASS_CIRCLE_LAND = 18,
  SUBCLASS_CIRCLE_MOON = 19,
  SUBCLASS_CIRCLE_DREAMS = 20,
  SUBCLASS_OPEN_HAND = 21,
  SUBCLASS_SHADOW = 22,
  SUBCLASS_FOUR_ELEMENTS = 23,
  SUBCLASS_DEVOTION = 24,
  SUBCLASS_ANCIENTS = 25,
  SUBCLASS_OATHBREAKER = 26,
  SUBCLASS_VENGEANCE = 27,
  SUBCLASS_HUNTER = 28,
  SUBCLASS_GLOOM_STALKER = 29,
  SUBCLASS_BEASTMASTER = 30,
  SUBCLASS_THIEF = 31,
  SUBCLASS_ASSASSIN = 32,
  SUBCLASS_ARCANE_TRICKSTER = 33,
  SUBCLASS_DRACONIC_BLOODLINE = 34,
  SUBCLASS_WILD_MAGIC = 35,
  SUBCLASS_DIVINE_SOUL = 36,
  SUBCLASS_ARCHFEY = 37,
  SUBCLASS_FIEND = 38,
  SUBCLASS_GREAT_OLD_ONE = 39,
  SUBCLASS_HEXBLADE = 40,
  SUBCLASS_ABJURATION = 41,
  SUBCLASS_CONJURATION = 42,
  SUBCLASS_DIVINATION = 43,
  SUBCLASS_ENCHANTMENT = 44,
  SUBCLASS_EVOCATION = 45,
  SUBCLASS_NECROMANCY = 46,
  SUBCLASS_TRANSMUTATION = 47,
  Subclass_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Subclass_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Subclass_internal_data_[];
inline constexpr Subclass Subclass_MIN =
    static_cast<Subclass>(0);
inline constexpr Subclass Subclass_MAX =
    static_cast<Subclass>(47);
inline bool Subclass_IsValid(int value) {
  return 0 <= value && value <= 47;
}
inline constexpr int Subclass_ARRAYSIZE = 47 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Subclass_descriptor();
template <typename T>
const ::std::string& Subclass_Name(T value) {
  static_assert(::std::is_same<T, Subclass>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Subclass_Name().");
  return Subclass_Name(static_cast<Subclass>(value));
}
template <>
inline const ::std::string& Subclass_Name(Subclass value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Subclass_descriptor, 0, 47>(
      static_cast<int>(value));
}
inline bool Subclass_Parse(
    ::absl::string_view name, Subclass* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Subclass>(Subclass_descriptor(), name,
                                           value);
}
enum Ability : int {
  ABILITY_UNSPECIFIED = 0,
  ABILITY_STRENGTH = 1,
  ABILITY_DEXTERITY = 2,
  ABILITY_CONSTITUTION = 3,
  ABILITY_INTELLIGENCE = 4,
  ABILITY_WISDOM = 5,
  ABILITY_CHARISMA = 6,
  Ability_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Ability_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Ability_internal_data_[];
inline constexpr Ability Ability_MIN =
    static_cast<Ability>(0);
inline constexpr Ability Ability_MAX =
    static_cast<Ability>(6);
inline bool Ability_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int Ability_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Ability_descriptor();
template <typename T>
const ::std::string& Ability_Name(T value) {
  static_assert(::std::is_same<T, Ability>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Ability_Name().");
  return Ability_Name(static_cast<Ability>(value));
}
template <>
inline const ::std::string& Ability_Name(Ability value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Ability_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool Ability_Parse(
    ::absl::string_view name, Ability* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ability>(Ability_descriptor(), name,
                                           value);
}
enum Skill : int {
  SKILL_UNSPECIFIED = 0,
  SKILL_ACROBATICS = 1,
  SKILL_ANIMAL_HANDLING = 2,
  SKILL_ARCANA = 3,
  SKILL_ATHLETICS = 4,
  SKILL_DECEPTION = 5,
  SKILL_HISTORY = 6,
  SKILL_INSIGHT = 7,
  SKILL_INTIMIDATION = 8,
  SKILL_INVESTIGATION = 9,
  SKILL_MEDICINE = 10,
  SKILL_NATURE = 11,
  SKILL_PERCEPTION = 12,
  SKILL_PERFORMANCE = 13,
  SKILL_PERSUASION = 14,
  SKILL_RELIGION = 15,
  SKILL_SLEIGHT_OF_HAND = 16,
  SKILL_STEALTH = 17,
  SKILL_SURVIVAL = 18,
  Skill_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Skill_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Skill_internal_data_[];
inline constexpr Skill Skill_MIN =
    static_cast<Skill>(0);
inline constexpr Skill Skill_MAX =
    static_cast<Skill>(18);
inline bool Skill_IsValid(int value) {
  return 0 <= value && value <= 18;
}
inline constexpr int Skill_ARRAYSIZE = 18 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Skill_descriptor();
template <typename T>
const ::std::string& Skill_Name(T value) {
  static_assert(::std::is_same<T, Skill>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Skill_Name().");
  return Skill_Name(static_cast<Skill>(value));
}
template <>
inline const ::std::string& Skill_Name(Skill value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Skill_descriptor, 0, 18>(
      static_cast<int>(value));
}
inline bool Skill_Parse(
    ::absl::string_view name, Skill* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Skill>(Skill_descriptor(), name,
                                           value);
}
enum Alignment : int {
  ALIGNMENT_UNSPECIFIED = 0,
  ALIGNMENT_LAWFUL_GOOD = 1,
  ALIGNMENT_NEUTRAL_GOOD = 2,
  ALIGNMENT_CHAOTIC_GOOD = 3,
  ALIGNMENT_LAWFUL_NEUTRAL = 4,
  ALIGNMENT_TRUE_NEUTRAL = 5,
  ALIGNMENT_CHAOTIC_NEUTRAL = 6,
  ALIGNMENT_LAWFUL_EVIL = 7,
  ALIGNMENT_NEUTRAL_EVIL = 8,
  ALIGNMENT_CHAOTIC_EVIL = 9,
  Alignment_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Alignment_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Alignment_internal_data_[];
inline constexpr Alignment Alignment_MIN =
    static_cast<Alignment>(0);
inline constexpr Alignment Alignment_MAX =
    static_cast<Alignment>(9);
inline bool Alignment_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int Alignment_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Alignment_descriptor();
template <typename T>
const ::std::string& Alignment_Name(T value) {
  static_assert(::std::is_same<T, Alignment>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Alignment_Name().");
  return Alignment_Name(static_cast<Alignment>(value));
}
template <>
inline const ::std::string& Alignment_Name(Alignment value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Alignment_descriptor, 0, 9>(
      static_cast<int>(value));
}
inline bool Alignment_Parse(
    ::absl::string_view name, Alignment* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alignment>(Alignment_descriptor(), name,
                                           value);
}
enum Background : int {
  BACKGROUND_UNSPECIFIED = 0,
  BACKGROUND_ACOLYTE = 1,
  BACKGROUND_CHARLATAN = 2,
  BACKGROUND_CRIMINAL = 3,
  BACKGROUND_ENTERTAINER = 4,
  BACKGROUND_FOLK_HERO = 5,
  BACKGROUND_GUILD_ARTISAN = 6,
  BACKGROUND_HERMIT = 7,
  BACKGROUND_NOBLE = 8,
  BACKGROUND_OUTLANDER = 9,
  BACKGROUND_SAGE = 10,
  BACKGROUND_SAILOR = 11,
  BACKGROUND_SOLDIER = 12,
  BACKGROUND_URCHIN = 13,
  Background_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Background_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Background_internal_data_[];
inline constexpr Background Background_MIN =
    static_cast<Background>(0);
inline constexpr Background Background_MAX =
    static_cast<Background>(13);
inline bool Background_IsValid(int value) {
  return 0 <= value && value <= 13;
}
inline constexpr int Background_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Background_descriptor();
template <typename T>
const ::std::string& Background_Name(T value) {
  static_assert(::std::is_same<T, Background>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Background_Name().");
  return Background_Name(static_cast<Background>(value));
}
template <>
inline const ::std::string& Background_Name(Background value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Background_descriptor, 0, 13>(
      static_cast<int>(value));
}
inline bool Background_Parse(
    ::absl::string_view name, Background* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Background>(Background_descriptor(), name,
                                           value);
}
enum Language : int {
  LANGUAGE_UNSPECIFIED = 0,
  LANGUAGE_COMMON = 1,
  LANGUAGE_DWARVISH = 2,
  LANGUAGE_ELVISH = 3,
  LANGUAGE_GIANT = 4,
  LANGUAGE_GNOMISH = 5,
  LANGUAGE_GOBLIN = 6,
  LANGUAGE_HALFLING = 7,
  LANGUAGE_ORC = 8,
  LANGUAGE_ABYSSAL = 9,
  LANGUAGE_CELESTIAL = 10,
  LANGUAGE_DRACONIC = 11,
  LANGUAGE_DEEP_SPEECH = 12,
  LANGUAGE_INFERNAL = 13,
  LANGUAGE_PRIMORDIAL = 14,
  LANGUAGE_SYLVAN = 15,
  LANGUAGE_UNDERCOMMON = 16,
  Language_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Language_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Language_internal_data_[];
inline constexpr Language Language_MIN =
    static_cast<Language>(0);
inline constexpr Language Language_MAX =
    static_cast<Language>(16);
inline bool Language_IsValid(int value) {
  return 0 <= value && value <= 16;
}
inline constexpr int Language_ARRAYSIZE = 16 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Language_descriptor();
template <typename T>
const ::std::string& Language_Name(T value) {
  static_assert(::std::is_same<T, Language>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Language_Name().");
  return Language_Name(static_cast<Language>(value));
}
template <>
inline const ::std::string& Language_Name(Language value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Language_descriptor, 0, 16>(
      static_cast<int>(value));
}
inline bool Language_Parse(
    ::absl::string_view name, Language* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Language>(Language_descriptor(), name,
                                           value);
}
enum EquipmentType : int {
  EQUIPMENT_TYPE_UNSPECIFIED = 0,
  EQUIPMENT_TYPE_SIMPLE_MELEE_WEAPON = 1,
  EQUIPMENT_TYPE_SIMPLE_RANGED_WEAPON = 2,
  EQUIPMENT_TYPE_MARTIAL_MELEE_WEAPON = 3,
  EQUIPMENT_TYPE_MARTIAL_RANGED_WEAPON = 4,
  EQUIPMENT_TYPE_LIGHT_ARMOR = 5,
  EQUIPMENT_TYPE_MEDIUM_ARMOR = 6,
  EQUIPMENT_TYPE_HEAVY_ARMOR = 7,
  EQUIPMENT_TYPE_SHIELD = 8,
  EQUIPMENT_TYPE_ADVENTURING_GEAR = 9,
  EQUIPMENT_TYPE_TOOLS = 10,
  EQUIPMENT_TYPE_ARTISAN_TOOLS = 11,
  EQUIPMENT_TYPE_GAMING_SET = 12,
  EQUIPMENT_TYPE_MUSICAL_INSTRUMENT = 13,
  EQUIPMENT_TYPE_VEHICLE = 14,
  EquipmentType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EquipmentType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EquipmentType_internal_data_[];
inline constexpr EquipmentType EquipmentType_MIN =
    static_cast<EquipmentType>(0);
inline constexpr EquipmentType EquipmentType_MAX =
    static_cast<EquipmentType>(14);
inline bool EquipmentType_IsValid(int value) {
  return 0 <= value && value <= 14;
}
inline constexpr int EquipmentType_ARRAYSIZE = 14 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EquipmentType_descriptor();
template <typename T>
const ::std::string& EquipmentType_Name(T value) {
  static_assert(::std::is_same<T, EquipmentType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EquipmentType_Name().");
  return EquipmentType_Name(static_cast<EquipmentType>(value));
}
template <>
inline const ::std::string& EquipmentType_Name(EquipmentType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EquipmentType_descriptor, 0, 14>(
      static_cast<int>(value));
}
inline bool EquipmentType_Parse(
    ::absl::string_view name, EquipmentType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EquipmentType>(EquipmentType_descriptor(), name,
                                           value);
}
enum Weapon : int {
  WEAPON_UNSPECIFIED = 0,
  WEAPON_CLUB = 1,
  WEAPON_DAGGER = 2,
  WEAPON_GREATCLUB = 3,
  WEAPON_HANDAXE = 4,
  WEAPON_JAVELIN = 5,
  WEAPON_LIGHT_HAMMER = 6,
  WEAPON_MACE = 7,
  WEAPON_QUARTERSTAFF = 8,
  WEAPON_SICKLE = 9,
  WEAPON_SPEAR = 10,
  WEAPON_LIGHT_CROSSBOW = 11,
  WEAPON_DART = 12,
  WEAPON_SHORTBOW = 13,
  WEAPON_SLING = 14,
  WEAPON_BATTLEAXE = 15,
  WEAPON_FLAIL = 16,
  WEAPON_GLAIVE = 17,
  WEAPON_GREATAXE = 18,
  WEAPON_GREATSWORD = 19,
  WEAPON_HALBERD = 20,
  WEAPON_LANCE = 21,
  WEAPON_LONGSWORD = 22,
  WEAPON_MAUL = 23,
  WEAPON_MORNINGSTAR = 24,
  WEAPON_PIKE = 25,
  WEAPON_RAPIER = 26,
  WEAPON_SCIMITAR = 27,
  WEAPON_SHORTSWORD = 28,
  WEAPON_TRIDENT = 29,
  WEAPON_WAR_PICK = 30,
  WEAPON_WARHAMMER = 31,
  WEAPON_WHIP = 32,
  WEAPON_BLOWGUN = 33,
  WEAPON_HAND_CROSSBOW = 34,
  WEAPON_HEAVY_CROSSBOW = 35,
  WEAPON_LONGBOW = 36,
  WEAPON_NET = 37,
  WEAPON_ARROWS_20 = 38,
  WEAPON_BOLTS_20 = 39,
  WEAPON_ANY_SIMPLE = 40,
  WEAPON_ANY_MARTIAL = 41,
  WEAPON_ANY = 42,
  Weapon_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Weapon_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Weapon_internal_data_[];
inline constexpr Weapon Weapon_MIN =
    static_cast<Weapon>(0);
inline constexpr Weapon Weapon_MAX =
    static_cast<Weapon>(42);
inline bool Weapon_IsValid(int value) {
  return 0 <= value && value <= 42;
}
inline constexpr int Weapon_ARRAYSIZE = 42 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Weapon_descriptor();
template <typename T>
const ::std::string& Weapon_Name(T value) {
  static_assert(::std::is_same<T, Weapon>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Weapon_Name().");
  return Weapon_Name(static_cast<Weapon>(value));
}
template <>
inline const ::std::string& Weapon_Name(Weapon value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Weapon_descriptor, 0, 42>(
      static_cast<int>(value));
}
inline bool Weapon_Parse(
    ::absl::string_view name, Weapon* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Weapon>(Weapon_descriptor(), name,
                                           value);
}
enum Armor : int {
  ARMOR_UNSPECIFIED = 0,
  ARMOR_PADDED = 1,
  ARMOR_LEATHER = 2,
  ARMOR_STUDDED_LEATHER = 3,
  ARMOR_HIDE = 4,
  ARMOR_CHAIN_SHIRT = 5,
  ARMOR_SCALE_MAIL = 6,
  ARMOR_BREASTPLATE = 7,
  ARMOR_HALF_PLATE = 8,
  ARMOR_RING_MAIL = 9,
  ARMOR_CHAIN_MAIL = 10,
  ARMOR_SPLINT = 11,
  ARMOR_PLATE = 12,
  ARMOR_SHIELD = 13,
  Armor_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Armor_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Armor_internal_data_[];
inline constexpr Armor Armor_MIN =
    static_cast<Armor>(0);
inline constexpr Armor Armor_MAX =
    static_cast<Armor>(13);
inline bool Armor_IsValid(int value) {
  return 0 <= value && value <= 13;
}
inline constexpr int Armor_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Armor_descriptor();
template <typename T>
const ::std::string& Armor_Name(T value) {
  static_assert(::std::is_same<T, Armor>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Armor_Name().");
  return Armor_Name(static_cast<Armor>(value));
}
template <>
inline const ::std::string& Armor_Name(Armor value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Armor_descriptor, 0, 13>(
      static_cast<int>(value));
}
inline bool Armor_Parse(
    ::absl::string_view name, Armor* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Armor>(Armor_descriptor(), name,
                                           value);
}
enum FightingStyle : int {
  FIGHTING_STYLE_UNSPECIFIED = 0,
  FIGHTING_STYLE_ARCHERY = 1,
  FIGHTING_STYLE_DEFENSE = 2,
  FIGHTING_STYLE_DUELING = 3,
  FIGHTING_STYLE_GREAT_WEAPON_FIGHTING = 4,
  FIGHTING_STYLE_PROTECTION = 5,
  FIGHTING_STYLE_TWO_WEAPON_FIGHTING = 6,
  FightingStyle_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  FightingStyle_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t FightingStyle_internal_data_[];
inline constexpr FightingStyle FightingStyle_MIN =
    static_cast<FightingStyle>(0);
inline constexpr FightingStyle FightingStyle_MAX =
    static_cast<FightingStyle>(6);
inline bool FightingStyle_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int FightingStyle_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL FightingStyle_descriptor();
template <typename T>
const ::std::string& FightingStyle_Name(T value) {
  static_assert(::std::is_same<T, FightingStyle>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to FightingStyle_Name().");
  return FightingStyle_Name(static_cast<FightingStyle>(value));
}
template <>
inline const ::std::string& FightingStyle_Name(FightingStyle value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FightingStyle_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool FightingStyle_Parse(
    ::absl::string_view name, FightingStyle* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<FightingStyle>(FightingStyle_descriptor(), name,
                                           value);
}
enum Tool : int {
  TOOL_UNSPECIFIED = 0,
  TOOL_ALCHEMIST_SUPPLIES = 1,
  TOOL_BREWER_SUPPLIES = 2,
  TOOL_CALLIGRAPHER_SUPPLIES = 3,
  TOOL_CARPENTER_TOOLS = 4,
  TOOL_CARTOGRAPHER_TOOLS = 5,
  TOOL_COBBLER_TOOLS = 6,
  TOOL_COOK_UTENSILS = 7,
  TOOL_GLASSBLOWER_TOOLS = 8,
  TOOL_JEWELER_TOOLS = 9,
  TOOL_LEATHERWORKER_TOOLS = 10,
  TOOL_MASON_TOOLS = 11,
  TOOL_PAINTER_SUPPLIES = 12,
  TOOL_POTTER_TOOLS = 13,
  TOOL_SMITH_TOOLS = 14,
  TOOL_TINKER_TOOLS = 15,
  TOOL_WEAVER_TOOLS = 16,
  TOOL_WOODCARVER_TOOLS = 17,
  TOOL_DICE_SET = 18,
  TOOL_DRAGONCHESS_SET = 19,
  TOOL_PLAYING_CARD_SET = 20,
  TOOL_THREE_DRAGON_ANTE = 21,
  TOOL_BAGPIPES = 22,
  TOOL_DRUM = 23,
  TOOL_DULCIMER = 24,
  TOOL_FLUTE = 25,
  TOOL_LUTE = 26,
  TOOL_LYRE = 27,
  TOOL_HORN = 28,
  TOOL_PAN_FLUTE = 29,
  TOOL_SHAWM = 30,
  TOOL_VIOL = 31,
  TOOL_DISGUISE_KIT = 32,
  TOOL_FORGERY_KIT = 33,
  TOOL_HERBALISM_KIT = 34,
  TOOL_NAVIGATOR_TOOLS = 35,
  TOOL_POISONER_KIT = 36,
  TOOL_THIEVES_TOOLS = 37,
  TOOL_VEHICLES_LAND = 38,
  TOOL_VEHICLES_WATER = 39,
  Tool_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Tool_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Tool_internal_data_[];
inline constexpr Tool Tool_MIN =
    static_cast<Tool>(0);
inline constexpr Tool Tool_MAX =
    static_cast<Tool>(39);
inline bool Tool_IsValid(int value) {
  return 0 <= value && value <= 39;
}
inline constexpr int Tool_ARRAYSIZE = 39 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Tool_descriptor();
template <typename T>
const ::std::string& Tool_Name(T value) {
  static_assert(::std::is_same<T, Tool>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Tool_Name().");
  return Tool_Name(static_cast<Tool>(value));
}
template <>
inline const ::std::string& Tool_Name(Tool value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Tool_descriptor, 0, 39>(
      static_cast<int>(value));
}
inline bool Tool_Parse(
    ::absl::string_view name, Tool* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Tool>(Tool_descriptor(), name,
                                           value);
}
enum Pack : int {
  PACK_UNSPECIFIED = 0,
  PACK_BURGLARS = 1,
  PACK_DIPLOMATS = 2,
  PACK_DUNGEONEERS = 3,
  PACK_ENTERTAINERS = 4,
  PACK_EXPLORERS = 5,
  PACK_PRIESTS = 6,
  PACK_SCHOLARS = 7,
  Pack_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Pack_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Pack_internal_data_[];
inline constexpr Pack Pack_MIN =
    static_cast<Pack>(0);
inline constexpr Pack Pack_MAX =
    static_cast<Pack>(7);
inline bool Pack_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int Pack_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Pack_descriptor();
template <typename T>
const ::std::string& Pack_Name(T value) {
  static_assert(::std::is_same<T, Pack>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Pack_Name().");
  return Pack_Name(static_cast<Pack>(value));
}
template <>
inline const ::std::string& Pack_Name(Pack value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Pack_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool Pack_Parse(
    ::absl::string_view name, Pack* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Pack>(Pack_descriptor(), name,
                                           value);
}
enum Ammunition : int {
  AMMUNITION_UNSPECIFIED = 0,
  AMMUNITION_ARROWS_20 = 1,
  AMMUNITION_BOLTS_20 = 2,
  AMMUNITION_BLOWGUN_NEEDLES_50 = 3,
  AMMUNITION_SLING_BULLETS_20 = 4,
  Ammunition_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Ammunition_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Ammunition_internal_data_[];
inline constexpr Ammunition Ammunition_MIN =
    static_cast<Ammunition>(0);
inline constexpr Ammunition Ammunition_MAX =
    static_cast<Ammunition>(4);
inline bool Ammunition_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int Ammunition_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Ammunition_descriptor();
template <typename T>
const ::std::string& Ammunition_Name(T value) {
  static_assert(::std::is_same<T, Ammunition>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Ammunition_Name().");
  return Ammunition_Name(static_cast<Ammunition>(value));
}
template <>
inline const ::std::string& Ammunition_Name(Ammunition value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Ammunition_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool Ammunition_Parse(
    ::absl::string_view name, Ammunition* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ammunition>(Ammunition_descriptor(), name,
                                           value);
}
enum Spell : int {
  SPELL_UNSPECIFIED = 0,
  SPELL_FIRE_BOLT = 1,
  SPELL_RAY_OF_FROST = 2,
  SPELL_SHOCKING_GRASP = 3,
  SPELL_ACID_SPLASH = 4,
  SPELL_POISON_SPRAY = 5,
  SPELL_CHILL_TOUCH = 6,
  SPELL_SACRED_FLAME = 7,
  SPELL_TOLL_THE_DEAD = 8,
  SPELL_WORD_OF_RADIANCE = 9,
  SPELL_ELDRITCH_BLAST = 10,
  SPELL_FROSTBITE = 11,
  SPELL_PRIMAL_SAVAGERY = 12,
  SPELL_THORNWHIP = 13,
  SPELL_MAGE_HAND = 14,
  SPELL_MINOR_ILLUSION = 15,
  SPELL_PRESTIDIGITATION = 16,
  SPELL_LIGHT = 17,
  SPELL_GUIDANCE = 18,
  SPELL_RESISTANCE = 19,
  SPELL_THAUMATURGY = 20,
  SPELL_SPARE_THE_DYING = 21,
  SPELL_MAGIC_MISSILE = 22,
  SPELL_BURNING_HANDS = 23,
  SPELL_CHROMATIC_ORB = 24,
  SPELL_THUNDERWAVE = 25,
  SPELL_ICE_KNIFE = 26,
  SPELL_WITCH_BOLT = 27,
  SPELL_GUIDING_BOLT = 28,
  SPELL_INFLICT_WOUNDS = 29,
  SPELL_HAIL_OF_THORNS = 30,
  SPELL_ENSNARING_STRIKE = 31,
  SPELL_HELLISH_REBUKE = 32,
  SPELL_ARMS_OF_HADAR = 33,
  SPELL_HEX = 34,
  SPELL_SEARING_SMITE = 35,
  SPELL_THUNDEROUS_SMITE = 36,
  SPELL_WRATHFUL_SMITE = 37,
  SPELL_SHIELD = 38,
  SPELL_SLEEP = 39,
  SPELL_CHARM_PERSON = 40,
  SPELL_DETECT_MAGIC = 41,
  SPELL_IDENTIFY = 42,
  SPELL_CURE_WOUNDS = 43,
  SPELL_HEALING_WORD = 44,
  SPELL_BLESS = 45,
  SPELL_BANE = 46,
  SPELL_SHIELD_OF_FAITH = 47,
  SPELL_SCORCHING_RAY = 48,
  SPELL_SHATTER = 49,
  SPELL_AGANAZZARS_SCORCHER = 50,
  SPELL_CLOUD_OF_DAGGERS = 51,
  SPELL_MELFS_ACID_ARROW = 52,
  SPELL_MOONBEAM = 53,
  SPELL_SPIRITUAL_WEAPON = 54,
  SPELL_FLAMING_SPHERE = 55,
  SPELL_FIREBALL = 56,
  SPELL_LIGHTNING_BOLT = 57,
  SPELL_CALL_LIGHTNING = 58,
  SPELL_VAMPIRIC_TOUCH = 59,
  Spell_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Spell_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Spell_internal_data_[];
inline constexpr Spell Spell_MIN =
    static_cast<Spell>(0);
inline constexpr Spell Spell_MAX =
    static_cast<Spell>(59);
inline bool Spell_IsValid(int value) {
  return 0 <= value && value <= 59;
}
inline constexpr int Spell_ARRAYSIZE = 59 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Spell_descriptor();
template <typename T>
const ::std::string& Spell_Name(T value) {
  static_assert(::std::is_same<T, Spell>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Spell_Name().");
  return Spell_Name(static_cast<Spell>(value));
}
template <>
inline const ::std::string& Spell_Name(Spell value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Spell_descriptor, 0, 59>(
      static_cast<int>(value));
}
inline bool Spell_Parse(
    ::absl::string_view name, Spell* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Spell>(Spell_descriptor(), name,
                                           value);
}
enum DamageType : int {
  DAMAGE_TYPE_UNSPECIFIED = 0,
  DAMAGE_TYPE_BLUDGEONING = 1,
  DAMAGE_TYPE_PIERCING = 2,
  DAMAGE_TYPE_SLASHING = 3,
  DAMAGE_TYPE_FIRE = 4,
  DAMAGE_TYPE_COLD = 5,
  DAMAGE_TYPE_LIGHTNING = 6,
  DAMAGE_TYPE_THUNDER = 7,
  DAMAGE_TYPE_ACID = 8,
  DAMAGE_TYPE_POISON = 9,
  DAMAGE_TYPE_NECROTIC = 10,
  DAMAGE_TYPE_RADIANT = 11,
  DAMAGE_TYPE_PSYCHIC = 12,
  DAMAGE_TYPE_FORCE = 13,
  DamageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DamageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DamageType_internal_data_[];
inline constexpr DamageType DamageType_MIN =
    static_cast<DamageType>(0);
inline constexpr DamageType DamageType_MAX =
    static_cast<DamageType>(13);
inline bool DamageType_IsValid(int value) {
  return 0 <= value && value <= 13;
}
inline constexpr int DamageType_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DamageType_descriptor();
template <typename T>
const ::std::string& DamageType_Name(T value) {
  static_assert(::std::is_same<T, DamageType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DamageType_Name().");
  return DamageType_Name(static_cast<DamageType>(value));
}
template <>
inline const ::std::string& DamageType_Name(DamageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DamageType_descriptor, 0, 13>(
      static_cast<int>(value));
}
inline bool DamageType_Parse(
    ::absl::string_view name, DamageType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DamageType>(DamageType_descriptor(), name,
                                           value);
}
enum Trait : int {
  TRAIT_UNSPECIFIED = 0,
  TRAIT_DARKVISION = 1,
  TRAIT_DWARVEN_RESILIENCE = 2,
  TRAIT_STONECUNNING = 3,
  TRAIT_DWARVEN_COMBAT_TRAINING = 4,
  TRAIT_TOOL_PROFICIENCY = 5,
  TRAIT_KEEN_SENSES = 6,
  TRAIT_FEY_ANCESTRY = 7,
  TRAIT_TRANCE = 8,
  TRAIT_ELF_WEAPON_TRAINING = 9,
  TRAIT_CANTRIP = 10,
  TRAIT_EXTRA_LANGUAGE = 11,
  TRAIT_LUCKY = 12,
  TRAIT_BRAVE = 13,
  TRAIT_HALFLING_NIMBLENESS = 14,
  TRAIT_DRACONIC_ANCESTRY = 15,
  TRAIT_BREATH_WEAPON = 16,
  TRAIT_DAMAGE_RESISTANCE = 17,
  TRAIT_GNOME_CUNNING = 18,
  TRAIT_NATURAL_ILLUSIONIST = 19,
  TRAIT_SPEAK_WITH_SMALL_BEASTS = 20,
  TRAIT_ARTIFICERS_LORE = 21,
  TRAIT_TINKER = 22,
  TRAIT_SKILL_VERSATILITY = 23,
  TRAIT_SAVAGE_ATTACKS = 24,
  TRAIT_RELENTLESS_ENDURANCE = 25,
  TRAIT_HELLISH_RESISTANCE = 26,
  TRAIT_INFERNAL_LEGACY = 27,
  TRAIT_FIGHTING_STYLE_ARCHERY = 28,
  TRAIT_FIGHTING_STYLE_DEFENSE = 29,
  TRAIT_FIGHTING_STYLE_DUELING = 30,
  TRAIT_FIGHTING_STYLE_GREAT_WEAPON_FIGHTING = 31,
  TRAIT_FIGHTING_STYLE_PROTECTION = 32,
  TRAIT_FIGHTING_STYLE_TWO_WEAPON_FIGHTING = 33,
  Trait_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Trait_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Trait_internal_data_[];
inline constexpr Trait Trait_MIN =
    static_cast<Trait>(0);
inline constexpr Trait Trait_MAX =
    static_cast<Trait>(33);
inline bool Trait_IsValid(int value) {
  return 0 <= value && value <= 33;
}
inline constexpr int Trait_ARRAYSIZE = 33 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Trait_descriptor();
template <typename T>
const ::std::string& Trait_Name(T value) {
  static_assert(::std::is_same<T, Trait>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Trait_Name().");
  return Trait_Name(static_cast<Trait>(value));
}
template <>
inline const ::std::string& Trait_Name(Trait value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Trait_descriptor, 0, 33>(
      static_cast<int>(value));
}
inline bool Trait_Parse(
    ::absl::string_view name, Trait* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Trait>(Trait_descriptor(), name,
                                           value);
}
enum WeaponProperty : int {
  WEAPON_PROPERTY_UNSPECIFIED = 0,
  WEAPON_PROPERTY_LIGHT = 1,
  WEAPON_PROPERTY_FINESSE = 2,
  WEAPON_PROPERTY_THROWN = 3,
  WEAPON_PROPERTY_TWO_HANDED = 4,
  WEAPON_PROPERTY_VERSATILE = 5,
  WEAPON_PROPERTY_AMMUNITION = 6,
  WEAPON_PROPERTY_LOADING = 7,
  WEAPON_PROPERTY_HEAVY = 8,
  WEAPON_PROPERTY_REACH = 9,
  WEAPON_PROPERTY_SPECIAL = 10,
  WeaponProperty_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  WeaponProperty_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t WeaponProperty_internal_data_[];
inline constexpr WeaponProperty WeaponProperty_MIN =
    static_cast<WeaponProperty>(0);
inline constexpr WeaponProperty WeaponProperty_MAX =
    static_cast<WeaponProperty>(10);
inline bool WeaponProperty_IsValid(int value) {
  return 0 <= value && value <= 10;
}
inline constexpr int WeaponProperty_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL WeaponProperty_descriptor();
template <typename T>
const ::std::string& WeaponProperty_Name(T value) {
  static_assert(::std::is_same<T, WeaponProperty>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to WeaponProperty_Name().");
  return WeaponProperty_Name(static_cast<WeaponProperty>(value));
}
template <>
inline const ::std::string& WeaponProperty_Name(WeaponProperty value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WeaponProperty_descriptor, 0, 10>(
      static_cast<int>(value));
}
inline bool WeaponProperty_Parse(
    ::absl::string_view name, WeaponProperty* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<WeaponProperty>(WeaponProperty_descriptor(), name,
                                           value);
}
enum ArmorProficiencyCategory : int {
  ARMOR_PROFICIENCY_CATEGORY_UNSPECIFIED = 0,
  ARMOR_PROFICIENCY_CATEGORY_LIGHT = 1,
  ARMOR_PROFICIENCY_CATEGORY_MEDIUM = 2,
  ARMOR_PROFICIENCY_CATEGORY_HEAVY = 3,
  ARMOR_PROFICIENCY_CATEGORY_SHIELDS = 4,
  ArmorProficiencyCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ArmorProficiencyCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ArmorProficiencyCategory_internal_data_[];
inline constexpr ArmorProficiencyCategory ArmorProficiencyCategory_MIN =
    static_cast<ArmorProficiencyCategory>(0);
inline constexpr ArmorProficiencyCategory ArmorProficiencyCategory_MAX =
    static_cast<ArmorProficiencyCategory>(4);
inline bool ArmorProficiencyCategory_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int ArmorProficiencyCategory_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ArmorProficiencyCategory_descriptor();
template <typename T>
const ::std::string& ArmorProficiencyCategory_Name(T value) {
  static_assert(::std::is_same<T, ArmorProficiencyCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ArmorProficiencyCategory_Name().");
  return ArmorProficiencyCategory_Name(static_cast<ArmorProficiencyCategory>(value));
}
template <>
inline const ::std::string& ArmorProficiencyCategory_Name(ArmorProficiencyCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ArmorProficiencyCategory_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool ArmorProficiencyCategory_Parse(
    ::absl::string_view name, ArmorProficiencyCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ArmorProficiencyCategory>(ArmorProficiencyCategory_descriptor(), name,
                                           value);
}
enum WeaponProficiencyCategory : int {
  WEAPON_PROFICIENCY_CATEGORY_UNSPECIFIED = 0,
  WEAPON_PROFICIENCY_CATEGORY_SIMPLE = 1,
  WEAPON_PROFICIENCY_CATEGORY_MARTIAL = 2,
  WEAPON_PROFICIENCY_CATEGORY_SPECIFIC = 3,
  WeaponProficiencyCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  WeaponProficiencyCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t WeaponProficiencyCategory_internal_data_[];
inline constexpr WeaponProficiencyCategory WeaponProficiencyCategory_MIN =
    static_cast<WeaponProficiencyCategory>(0);
inline constexpr WeaponProficiencyCategory WeaponProficiencyCategory_MAX =
    static_cast<WeaponProficiencyCategory>(3);
inline bool WeaponProficiencyCategory_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int WeaponProficiencyCategory_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL WeaponProficiencyCategory_descriptor();
template <typename T>
const ::std::string& WeaponProficiencyCategory_Name(T value) {
  static_assert(::std::is_same<T, WeaponProficiencyCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to WeaponProficiencyCategory_Name().");
  return WeaponProficiencyCategory_Name(static_cast<WeaponProficiencyCategory>(value));
}
template <>
inline const ::std::string& WeaponProficiencyCategory_Name(WeaponProficiencyCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WeaponProficiencyCategory_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool WeaponProficiencyCategory_Parse(
    ::absl::string_view name, WeaponProficiencyCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<WeaponProficiencyCategory>(WeaponProficiencyCategory_descriptor(), name,
                                           value);
}
enum ToolProficiencyCategory : int {
  TOOL_PROFICIENCY_CATEGORY_UNSPECIFIED = 0,
  TOOL_PROFICIENCY_CATEGORY_ARTISANS_TOOLS = 1,
  TOOL_PROFICIENCY_CATEGORY_GAMING_SET = 2,
  TOOL_PROFICIENCY_CATEGORY_MUSICAL_INSTRUMENT = 3,
  TOOL_PROFICIENCY_CATEGORY_SPECIFIC = 4,
  ToolProficiencyCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ToolProficiencyCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ToolProficiencyCategory_internal_data_[];
inline constexpr ToolProficiencyCategory ToolProficiencyCategory_MIN =
    static_cast<ToolProficiencyCategory>(0);
inline constexpr ToolProficiencyCategory ToolProficiencyCategory_MAX =
    static_cast<ToolProficiencyCategory>(4);
inline bool ToolProficiencyCategory_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int ToolProficiencyCategory_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ToolProficiencyCategory_descriptor();
template <typename T>
const ::std::string& ToolProficiencyCategory_Name(T value) {
  static_assert(::std::is_same<T, ToolProficiencyCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ToolProficiencyCategory_Name().");
  return ToolProficiencyCategory_Name(static_cast<ToolProficiencyCategory>(value));
}
template <>
inline const ::std::string& ToolProficiencyCategory_Name(ToolProficiencyCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ToolProficiencyCategory_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool ToolProficiencyCategory_Parse(
    ::absl::string_view name, ToolProficiencyCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ToolProficiencyCategory>(ToolProficiencyCategory_descriptor(), name,
                                           value);
}
enum WeaponCategory : int {
  WEAPON_CATEGORY_UNSPECIFIED = 0,
  WEAPON_CATEGORY_SIMPLE = 1,
  WEAPON_CATEGORY_MARTIAL = 2,
  WEAPON_CATEGORY_IMPROVISED = 3,
  WeaponCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  WeaponCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t WeaponCategory_internal_data_[];
inline constexpr WeaponCategory WeaponCategory_MIN =
    static_cast<WeaponCategory>(0);
inline constexpr WeaponCategory WeaponCategory_MAX =
    static_cast<WeaponCategory>(3);
inline bool WeaponCategory_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int WeaponCategory_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL WeaponCategory_descriptor();
template <typename T>
const ::std::string& WeaponCategory_Name(T value) {
  static_assert(::std::is_same<T, WeaponCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to WeaponCategory_Name().");
  return WeaponCategory_Name(static_cast<WeaponCategory>(value));
}
template <>
inline const ::std::string& WeaponCategory_Name(WeaponCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WeaponCategory_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool WeaponCategory_Parse(
    ::absl::string_view name, WeaponCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<WeaponCategory>(WeaponCategory_descriptor(), name,
                                           value);
}
enum ArmorCategory : int {
  ARMOR_CATEGORY_UNSPECIFIED = 0,
  ARMOR_CATEGORY_LIGHT = 1,
  ARMOR_CATEGORY_MEDIUM = 2,
  ARMOR_CATEGORY_HEAVY = 3,
  ARMOR_CATEGORY_SHIELD = 4,
  ArmorCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ArmorCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ArmorCategory_internal_data_[];
inline constexpr ArmorCategory ArmorCategory_MIN =
    static_cast<ArmorCategory>(0);
inline constexpr ArmorCategory ArmorCategory_MAX =
    static_cast<ArmorCategory>(4);
inline bool ArmorCategory_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int ArmorCategory_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ArmorCategory_descriptor();
template <typename T>
const ::std::string& ArmorCategory_Name(T value) {
  static_assert(::std::is_same<T, ArmorCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ArmorCategory_Name().");
  return ArmorCategory_Name(static_cast<ArmorCategory>(value));
}
template <>
inline const ::std::string& ArmorCategory_Name(ArmorCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ArmorCategory_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool ArmorCategory_Parse(
    ::absl::string_view name, ArmorCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ArmorCategory>(ArmorCategory_descriptor(), name,
                                           value);
}
enum ToolCategory : int {
  TOOL_CATEGORY_UNSPECIFIED = 0,
  TOOL_CATEGORY_ARTISAN = 1,
  TOOL_CATEGORY_GAMING = 2,
  TOOL_CATEGORY_MUSICAL = 3,
  TOOL_CATEGORY_OTHER = 4,
  ToolCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ToolCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ToolCategory_internal_data_[];
inline constexpr ToolCategory ToolCategory_MIN =
    static_cast<ToolCategory>(0);
inline constexpr ToolCategory ToolCategory_MAX =
    static_cast<ToolCategory>(4);
inline bool ToolCategory_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int ToolCategory_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ToolCategory_descriptor();
template <typename T>
const ::std::string& ToolCategory_Name(T value) {
  static_assert(::std::is_same<T, ToolCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ToolCategory_Name().");
  return ToolCategory_Name(static_cast<ToolCategory>(value));
}
template <>
inline const ::std::string& ToolCategory_Name(ToolCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ToolCategory_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool ToolCategory_Parse(
    ::absl::string_view name, ToolCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ToolCategory>(ToolCategory_descriptor(), name,
                                           value);
}
enum EquipmentCategory : int {
  EQUIPMENT_CATEGORY_UNSPECIFIED = 0,
  EQUIPMENT_CATEGORY_SIMPLE_WEAPON = 1,
  EQUIPMENT_CATEGORY_MARTIAL_WEAPON = 2,
  EQUIPMENT_CATEGORY_LIGHT_ARMOR = 3,
  EQUIPMENT_CATEGORY_MEDIUM_ARMOR = 4,
  EQUIPMENT_CATEGORY_HEAVY_ARMOR = 5,
  EQUIPMENT_CATEGORY_SHIELD = 6,
  EQUIPMENT_CATEGORY_ADVENTURING_GEAR = 7,
  EQUIPMENT_CATEGORY_TOOLS = 8,
  EQUIPMENT_CATEGORY_ARTISAN_TOOLS = 9,
  EQUIPMENT_CATEGORY_GAMING_SET = 10,
  EQUIPMENT_CATEGORY_MUSICAL_INSTRUMENT = 11,
  EQUIPMENT_CATEGORY_VEHICLE = 12,
  EQUIPMENT_CATEGORY_AMMUNITION = 13,
  EquipmentCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EquipmentCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EquipmentCategory_internal_data_[];
inline constexpr EquipmentCategory EquipmentCategory_MIN =
    static_cast<EquipmentCategory>(0);
inline constexpr EquipmentCategory EquipmentCategory_MAX =
    static_cast<EquipmentCategory>(13);
inline bool EquipmentCategory_IsValid(int value) {
  return 0 <= value && value <= 13;
}
inline constexpr int EquipmentCategory_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EquipmentCategory_descriptor();
template <typename T>
const ::std::string& EquipmentCategory_Name(T value) {
  static_assert(::std::is_same<T, EquipmentCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EquipmentCategory_Name().");
  return EquipmentCategory_Name(static_cast<EquipmentCategory>(value));
}
template <>
inline const ::std::string& EquipmentCategory_Name(EquipmentCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EquipmentCategory_descriptor, 0, 13>(
      static_cast<int>(value));
}
inline bool EquipmentCategory_Parse(
    ::absl::string_view name, EquipmentCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EquipmentCategory>(EquipmentCategory_descriptor(), name,
                                           value);
}
enum GearCategory : int {
  GEAR_CATEGORY_UNSPECIFIED = 0,
  GEAR_CATEGORY_ADVENTURING_GEAR = 1,
  GEAR_CATEGORY_TOOLS = 2,
  GEAR_CATEGORY_ARTISAN_TOOLS = 3,
  GEAR_CATEGORY_GAMING_SET = 4,
  GEAR_CATEGORY_MUSICAL_INSTRUMENT = 5,
  GEAR_CATEGORY_VEHICLE = 6,
  GEAR_CATEGORY_MOUNT = 7,
  GEAR_CATEGORY_CONTAINER = 8,
  GearCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GearCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GearCategory_internal_data_[];
inline constexpr GearCategory GearCategory_MIN =
    static_cast<GearCategory>(0);
inline constexpr GearCategory GearCategory_MAX =
    static_cast<GearCategory>(8);
inline bool GearCategory_IsValid(int value) {
  return 0 <= value && value <= 8;
}
inline constexpr int GearCategory_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GearCategory_descriptor();
template <typename T>
const ::std::string& GearCategory_Name(T value) {
  static_assert(::std::is_same<T, GearCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GearCategory_Name().");
  return GearCategory_Name(static_cast<GearCategory>(value));
}
template <>
inline const ::std::string& GearCategory_Name(GearCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GearCategory_descriptor, 0, 8>(
      static_cast<int>(value));
}
inline bool GearCategory_Parse(
    ::absl::string_view name, GearCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GearCategory>(GearCategory_descriptor(), name,
                                           value);
}
enum ConditionId : int {
  CONDITION_ID_UNSPECIFIED = 0,
  CONDITION_ID_RAGING = 1,
  CONDITION_ID_BRUTAL_CRITICAL = 2,
  CONDITION_ID_FIGHTING_STYLE_DUELING = 3,
  CONDITION_ID_FIGHTING_STYLE_TWO_WEAPON_FIGHTING = 4,
  CONDITION_ID_SNEAK_ATTACK = 5,
  CONDITION_ID_DIVINE_SMITE = 6,
  CONDITION_ID_FIGHTING_STYLE_GREAT_WEAPON_FIGHTING = 7,
  CONDITION_ID_FIGHTING_STYLE_ARCHERY = 8,
  CONDITION_ID_FIGHTING_STYLE_DEFENSE = 9,
  CONDITION_ID_FIGHTING_STYLE_PROTECTION = 10,
  CONDITION_ID_UNARMORED_DEFENSE = 11,
  CONDITION_ID_IMPROVED_CRITICAL = 12,
  CONDITION_ID_MARTIAL_ARTS = 13,
  CONDITION_ID_UNARMORED_MOVEMENT = 14,
  ConditionId_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ConditionId_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ConditionId_internal_data_[];
inline constexpr ConditionId ConditionId_MIN =
    static_cast<ConditionId>(0);
inline constexpr ConditionId ConditionId_MAX =
    static_cast<ConditionId>(14);
inline bool ConditionId_IsValid(int value) {
  return 0 <= value && value <= 14;
}
inline constexpr int ConditionId_ARRAYSIZE = 14 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ConditionId_descriptor();
template <typename T>
const ::std::string& ConditionId_Name(T value) {
  static_assert(::std::is_same<T, ConditionId>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ConditionId_Name().");
  return ConditionId_Name(static_cast<ConditionId>(value));
}
template <>
inline const ::std::string& ConditionId_Name(ConditionId value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ConditionId_descriptor, 0, 14>(
      static_cast<int>(value));
}
inline bool ConditionId_Parse(
    ::absl::string_view name, ConditionId* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionId>(ConditionId_descriptor(), name,
                                           value);
}
enum FeatureId : int {
  FEATURE_ID_UNSPECIFIED = 0,
  FEATURE_ID_BREATH_WEAPON = 1,
  FEATURE_ID_HELLISH_REBUKE = 2,
  FEATURE_ID_RADIANCE_OF_DAWN = 3,
  FEATURE_ID_WRATH_OF_THE_STORM = 4,
  FEATURE_ID_DESTRUCTIVE_WRATH = 5,
  FEATURE_ID_DEFLECT_MISSILES = 6,
  FEATURE_ID_FLURRY_OF_BLOWS = 7,
  FEATURE_ID_PATIENT_DEFENSE = 8,
  FEATURE_ID_STEP_OF_THE_WIND = 9,
  FEATURE_ID_STARRY_FORM_ARCHER = 10,
  FEATURE_ID_RAGE = 11,
  FEATURE_ID_RECKLESS_ATTACK = 12,
  FEATURE_ID_SECOND_WIND = 13,
  FEATURE_ID_ACTION_SURGE = 14,
  FEATURE_ID_SNEAK_ATTACK = 15,
  FEATURE_ID_DIVINE_SMITE = 16,
  FeatureId_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  FeatureId_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t FeatureId_internal_data_[];
inline constexpr FeatureId FeatureId_MIN =
    static_cast<FeatureId>(0);
inline constexpr FeatureId FeatureId_MAX =
    static_cast<FeatureId>(16);
inline bool FeatureId_IsValid(int value) {
  return 0 <= value && value <= 16;
}
inline constexpr int FeatureId_ARRAYSIZE = 16 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL FeatureId_descriptor();
template <typename T>
const ::std::string& FeatureId_Name(T value) {
  static_assert(::std::is_same<T, FeatureId>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to FeatureId_Name().");
  return FeatureId_Name(static_cast<FeatureId>(value));
}
template <>
inline const ::std::string& FeatureId_Name(FeatureId value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FeatureId_descriptor, 0, 16>(
      static_cast<int>(value));
}
inline bool FeatureId_Parse(
    ::absl::string_view name, FeatureId* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<FeatureId>(FeatureId_descriptor(), name,
                                           value);
}
enum MonsterTraitId : int {
  MONSTER_TRAIT_ID_UNSPECIFIED = 0,
  MONSTER_TRAIT_ID_VULNERABILITY = 1,
  MONSTER_TRAIT_ID_RESISTANCE = 2,
  MONSTER_TRAIT_ID_IMMUNITY = 3,
  MONSTER_TRAIT_ID_PACK_TACTICS = 4,
  MONSTER_TRAIT_ID_UNDEAD_FORTITUDE = 5,
  MonsterTraitId_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MonsterTraitId_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MonsterTraitId_internal_data_[];
inline constexpr MonsterTraitId MonsterTraitId_MIN =
    static_cast<MonsterTraitId>(0);
inline constexpr MonsterTraitId MonsterTraitId_MAX =
    static_cast<MonsterTraitId>(5);
inline bool MonsterTraitId_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int MonsterTraitId_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MonsterTraitId_descriptor();
template <typename T>
const ::std::string& MonsterTraitId_Name(T value) {
  static_assert(::std::is_same<T, MonsterTraitId>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to MonsterTraitId_Name().");
  return MonsterTraitId_Name(static_cast<MonsterTraitId>(value));
}
template <>
inline const ::std::string& MonsterTraitId_Name(MonsterTraitId value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MonsterTraitId_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool MonsterTraitId_Parse(
    ::absl::string_view name, MonsterTraitId* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MonsterTraitId>(MonsterTraitId_descriptor(), name,
                                           value);
}
enum ActionType : int {
  ACTION_TYPE_UNSPECIFIED = 0,
  ACTION_TYPE_ACTION = 1,
  ACTION_TYPE_BONUS_ACTION = 2,
  ACTION_TYPE_REACTION = 3,
  ACTION_TYPE_FREE = 4,
  ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ActionType_internal_data_[];
inline constexpr ActionType ActionType_MIN =
    static_cast<ActionType>(0);
inline constexpr ActionType ActionType_MAX =
    static_cast<ActionType>(4);
inline bool ActionType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int ActionType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ActionType_descriptor();
template <typename T>
const ::std::string& ActionType_Name(T value) {
  static_assert(::std::is_same<T, ActionType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ActionType_Name().");
  return ActionType_Name(static_cast<ActionType>(value));
}
template <>
inline const ::std::string& ActionType_Name(ActionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ActionType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool ActionType_Parse(
    ::absl::string_view name, ActionType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionType>(ActionType_descriptor(), name,
                                           value);
}
enum MonsterActionType : int {
  MONSTER_ACTION_TYPE_UNSPECIFIED = 0,
  MONSTER_ACTION_TYPE_MELEE_ATTACK = 1,
  MONSTER_ACTION_TYPE_RANGED_ATTACK = 2,
  MONSTER_ACTION_TYPE_SPELL = 3,
  MONSTER_ACTION_TYPE_HEAL = 4,
  MONSTER_ACTION_TYPE_MOVEMENT = 5,
  MONSTER_ACTION_TYPE_STEALTH = 6,
  MONSTER_ACTION_TYPE_DEFEND = 7,
  MonsterActionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MonsterActionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MonsterActionType_internal_data_[];
inline constexpr MonsterActionType MonsterActionType_MIN =
    static_cast<MonsterActionType>(0);
inline constexpr MonsterActionType MonsterActionType_MAX =
    static_cast<MonsterActionType>(7);
inline bool MonsterActionType_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int MonsterActionType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MonsterActionType_descriptor();
template <typename T>
const ::std::string& MonsterActionType_Name(T value) {
  static_assert(::std::is_same<T, MonsterActionType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to MonsterActionType_Name().");
  return MonsterActionType_Name(static_cast<MonsterActionType>(value));
}
template <>
inline const ::std::string& MonsterActionType_Name(MonsterActionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MonsterActionType_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool MonsterActionType_Parse(
    ::absl::string_view name, MonsterActionType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MonsterActionType>(MonsterActionType_descriptor(), name,
                                           value);
}
enum MonsterType : int {
  MONSTER_TYPE_UNSPECIFIED = 0,
  MONSTER_TYPE_SKELETON = 1,
  MONSTER_TYPE_ZOMBIE = 2,
  MONSTER_TYPE_SKELETON_ARCHER = 3,
  MONSTER_TYPE_SKELETON_CAPTAIN = 4,
  MONSTER_TYPE_GHOUL = 5,
  MONSTER_TYPE_GIANT_RAT = 10,
  MONSTER_TYPE_GIANT_SPIDER = 11,
  MONSTER_TYPE_GIANT_WOLF_SPIDER = 12,
  MONSTER_TYPE_WOLF = 13,
  MONSTER_TYPE_BROWN_BEAR = 14,
  MONSTER_TYPE_BANDIT = 20,
  MONSTER_TYPE_BANDIT_ARCHER = 21,
  MONSTER_TYPE_BANDIT_CAPTAIN = 22,
  MONSTER_TYPE_THUG = 23,
  MONSTER_TYPE_GOBLIN = 24,
  MonsterType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MonsterType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MonsterType_internal_data_[];
inline constexpr MonsterType MonsterType_MIN =
    static_cast<MonsterType>(0);
inline constexpr MonsterType MonsterType_MAX =
    static_cast<MonsterType>(24);
inline bool MonsterType_IsValid(int value) {
  return 0 <= value && value <= 24 && ((32537663u >> value) & 1) != 0;
}
inline constexpr int MonsterType_ARRAYSIZE = 24 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MonsterType_descriptor();
template <typename T>
const ::std::string& MonsterType_Name(T value) {
  static_assert(::std::is_same<T, MonsterType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to MonsterType_Name().");
  return MonsterType_Name(static_cast<MonsterType>(value));
}
template <>
inline const ::std::string& MonsterType_Name(MonsterType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MonsterType_descriptor, 0, 24>(
      static_cast<int>(value));
}
inline bool MonsterType_Parse(
    ::absl::string_view name, MonsterType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MonsterType>(MonsterType_descriptor(), name,
                                           value);
}
enum DungeonTheme : int {
  DUNGEON_THEME_UNSPECIFIED = 0,
  DUNGEON_THEME_CRYPT = 1,
  DUNGEON_THEME_CAVE = 2,
  DUNGEON_THEME_RUINS = 3,
  DungeonTheme_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DungeonTheme_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DungeonTheme_internal_data_[];
inline constexpr DungeonTheme DungeonTheme_MIN =
    static_cast<DungeonTheme>(0);
inline constexpr DungeonTheme DungeonTheme_MAX =
    static_cast<DungeonTheme>(3);
inline bool DungeonTheme_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int DungeonTheme_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DungeonTheme_descriptor();
template <typename T>
const ::std::string& DungeonTheme_Name(T value) {
  static_assert(::std::is_same<T, DungeonTheme>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DungeonTheme_Name().");
  return DungeonTheme_Name(static_cast<DungeonTheme>(value));
}
template <>
inline const ::std::string& DungeonTheme_Name(DungeonTheme value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DungeonTheme_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool DungeonTheme_Parse(
    ::absl::string_view name, DungeonTheme* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DungeonTheme>(DungeonTheme_descriptor(), name,
                                           value);
}
enum DungeonDifficulty : int {
  DUNGEON_DIFFICULTY_UNSPECIFIED = 0,
  DUNGEON_DIFFICULTY_EASY = 1,
  DUNGEON_DIFFICULTY_MEDIUM = 2,
  DUNGEON_DIFFICULTY_HARD = 3,
  DungeonDifficulty_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DungeonDifficulty_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DungeonDifficulty_internal_data_[];
inline constexpr DungeonDifficulty DungeonDifficulty_MIN =
    static_cast<DungeonDifficulty>(0);
inline constexpr DungeonDifficulty DungeonDifficulty_MAX =
    static_cast<DungeonDifficulty>(3);
inline bool DungeonDifficulty_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int DungeonDifficulty_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DungeonDifficulty_descriptor();
template <typename T>
const ::std::string& DungeonDifficulty_Name(T value) {
  static_assert(::std::is_same<T, DungeonDifficulty>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DungeonDifficulty_Name().");
  return DungeonDifficulty_Name(static_cast<DungeonDifficulty>(value));
}
template <>
inline const ::std::string& DungeonDifficulty_Name(DungeonDifficulty value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DungeonDifficulty_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool DungeonDifficulty_Parse(
    ::absl::string_view name, DungeonDifficulty* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DungeonDifficulty>(DungeonDifficulty_descriptor(), name,
                                           value);
}
enum DungeonLength : int {
  DUNGEON_LENGTH_UNSPECIFIED = 0,
  DUNGEON_LENGTH_SHORT = 1,
  DUNGEON_LENGTH_MEDIUM = 2,
  DUNGEON_LENGTH_LONG = 3,
  DungeonLength_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DungeonLength_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DungeonLength_internal_data_[];
inline constexpr DungeonLength DungeonLength_MIN =
    static_cast<DungeonLength>(0);
inline constexpr DungeonLength DungeonLength_MAX =
    static_cast<DungeonLength>(3);
inline bool DungeonLength_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int DungeonLength_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DungeonLength_descriptor();
template <typename T>
const ::std::string& DungeonLength_Name(T value) {
  static_assert(::std::is_same<T, DungeonLength>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DungeonLength_Name().");
  return DungeonLength_Name(static_cast<DungeonLength>(value));
}
template <>
inline const ::std::string& DungeonLength_Name(DungeonLength value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DungeonLength_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool DungeonLength_Parse(
    ::absl::string_view name, DungeonLength* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DungeonLength>(DungeonLength_descriptor(), name,
                                           value);
}
enum DungeonState : int {
  DUNGEON_STATE_UNSPECIFIED = 0,
  DUNGEON_STATE_ACTIVE = 1,
  DUNGEON_STATE_VICTORIOUS = 2,
  DUNGEON_STATE_FAILED = 3,
  DUNGEON_STATE_ABANDONED = 4,
  DungeonState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DungeonState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DungeonState_internal_data_[];
inline constexpr DungeonState DungeonState_MIN =
    static_cast<DungeonState>(0);
inline constexpr DungeonState DungeonState_MAX =
    static_cast<DungeonState>(4);
inline bool DungeonState_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int DungeonState_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DungeonState_descriptor();
template <typename T>
const ::std::string& DungeonState_Name(T value) {
  static_assert(::std::is_same<T, DungeonState>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DungeonState_Name().");
  return DungeonState_Name(static_cast<DungeonState>(value));
}
template <>
inline const ::std::string& DungeonState_Name(DungeonState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DungeonState_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool DungeonState_Parse(
    ::absl::string_view name, DungeonState* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DungeonState>(DungeonState_descriptor(), name,
                                           value);
}
enum AttackHand : int {
  ATTACK_HAND_UNSPECIFIED = 0,
  ATTACK_HAND_MAIN = 1,
  ATTACK_HAND_OFF = 2,
  AttackHand_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  AttackHand_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t AttackHand_internal_data_[];
inline constexpr AttackHand AttackHand_MIN =
    static_cast<AttackHand>(0);
inline constexpr AttackHand AttackHand_MAX =
    static_cast<AttackHand>(2);
inline bool AttackHand_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int AttackHand_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AttackHand_descriptor();
template <typename T>
const ::std::string& AttackHand_Name(T value) {
  static_assert(::std::is_same<T, AttackHand>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AttackHand_Name().");
  return AttackHand_Name(static_cast<AttackHand>(value));
}
template <>
inline const ::std::string& AttackHand_Name(AttackHand value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AttackHand_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool AttackHand_Parse(
    ::absl::string_view name, AttackHand* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<AttackHand>(AttackHand_descriptor(), name,
                                           value);
}
enum EntityType : int {
  ENTITY_TYPE_UNSPECIFIED = 0,
  ENTITY_TYPE_CHARACTER = 1,
  ENTITY_TYPE_MONSTER = 2,
  ENTITY_TYPE_OBSTACLE = 3,
  EntityType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EntityType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EntityType_internal_data_[];
inline constexpr EntityType EntityType_MIN =
    static_cast<EntityType>(0);
inline constexpr EntityType EntityType_MAX =
    static_cast<EntityType>(3);
inline bool EntityType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int EntityType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EntityType_descriptor();
template <typename T>
const ::std::string& EntityType_Name(T value) {
  static_assert(::std::is_same<T, EntityType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EntityType_Name().");
  return EntityType_Name(static_cast<EntityType>(value));
}
template <>
inline const ::std::string& EntityType_Name(EntityType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EntityType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool EntityType_Parse(
    ::absl::string_view name, EntityType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityType>(EntityType_descriptor(), name,
                                           value);
}
enum EntitySize : int {
  ENTITY_SIZE_UNSPECIFIED = 0,
  ENTITY_SIZE_TINY = 1,
  ENTITY_SIZE_SMALL = 2,
  ENTITY_SIZE_MEDIUM = 3,
  ENTITY_SIZE_LARGE = 4,
  ENTITY_SIZE_HUGE = 5,
  ENTITY_SIZE_GARGANTUAN = 6,
  EntitySize_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EntitySize_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EntitySize_internal_data_[];
inline constexpr EntitySize EntitySize_MIN =
    static_cast<EntitySize>(0);
inline constexpr EntitySize EntitySize_MAX =
    static_cast<EntitySize>(6);
inline bool EntitySize_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int EntitySize_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EntitySize_descriptor();
template <typename T>
const ::std::string& EntitySize_Name(T value) {
  static_assert(::std::is_same<T, EntitySize>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EntitySize_Name().");
  return EntitySize_Name(static_cast<EntitySize>(value));
}
template <>
inline const ::std::string& EntitySize_Name(EntitySize value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EntitySize_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool EntitySize_Parse(
    ::absl::string_view name, EntitySize* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntitySize>(EntitySize_descriptor(), name,
                                           value);
}
enum ObstacleType : int {
  OBSTACLE_TYPE_UNSPECIFIED = 0,
  OBSTACLE_TYPE_STALAGMITE = 1,
  OBSTACLE_TYPE_BOULDER = 2,
  OBSTACLE_TYPE_PILLAR = 20,
  OBSTACLE_TYPE_STATUE = 21,
  OBSTACLE_TYPE_SARCOPHAGUS = 40,
  OBSTACLE_TYPE_ALTAR = 41,
  OBSTACLE_TYPE_BRAZIER = 42,
  OBSTACLE_TYPE_CRATE = 60,
  OBSTACLE_TYPE_BARREL = 61,
  OBSTACLE_TYPE_TABLE = 62,
  ObstacleType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ObstacleType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ObstacleType_internal_data_[];
inline constexpr ObstacleType ObstacleType_MIN =
    static_cast<ObstacleType>(0);
inline constexpr ObstacleType ObstacleType_MAX =
    static_cast<ObstacleType>(62);
inline bool ObstacleType_IsValid(int value) {
  return 0 <= value && value <= 62 && ((8070458228832468999u >> value) & 1) != 0;
}
inline constexpr int ObstacleType_ARRAYSIZE = 62 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ObstacleType_descriptor();
template <typename T>
const ::std::string& ObstacleType_Name(T value) {
  static_assert(::std::is_same<T, ObstacleType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ObstacleType_Name().");
  return ::google::protobuf::internal::NameOfEnum(ObstacleType_descriptor(), value);
}
inline bool ObstacleType_Parse(
    ::absl::string_view name, ObstacleType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObstacleType>(ObstacleType_descriptor(), name,
                                           value);
}

// ===================================================================



// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Race> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Race>() {
  return ::dnd5e::api::v1alpha1::Race_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Subrace> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Subrace>() {
  return ::dnd5e::api::v1alpha1::Subrace_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Class> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Class>() {
  return ::dnd5e::api::v1alpha1::Class_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Subclass> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Subclass>() {
  return ::dnd5e::api::v1alpha1::Subclass_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Ability> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Ability>() {
  return ::dnd5e::api::v1alpha1::Ability_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Skill> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Skill>() {
  return ::dnd5e::api::v1alpha1::Skill_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Alignment> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Alignment>() {
  return ::dnd5e::api::v1alpha1::Alignment_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Background> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Background>() {
  return ::dnd5e::api::v1alpha1::Background_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Language> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Language>() {
  return ::dnd5e::api::v1alpha1::Language_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::EquipmentType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::EquipmentType>() {
  return ::dnd5e::api::v1alpha1::EquipmentType_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Weapon> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Weapon>() {
  return ::dnd5e::api::v1alpha1::Weapon_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Armor> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Armor>() {
  return ::dnd5e::api::v1alpha1::Armor_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::FightingStyle> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::FightingStyle>() {
  return ::dnd5e::api::v1alpha1::FightingStyle_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Tool> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Tool>() {
  return ::dnd5e::api::v1alpha1::Tool_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Pack> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Pack>() {
  return ::dnd5e::api::v1alpha1::Pack_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Ammunition> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Ammunition>() {
  return ::dnd5e::api::v1alpha1::Ammunition_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Spell> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Spell>() {
  return ::dnd5e::api::v1alpha1::Spell_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::DamageType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::DamageType>() {
  return ::dnd5e::api::v1alpha1::DamageType_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Trait> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Trait>() {
  return ::dnd5e::api::v1alpha1::Trait_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::WeaponProperty> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::WeaponProperty>() {
  return ::dnd5e::api::v1alpha1::WeaponProperty_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::ArmorProficiencyCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::ArmorProficiencyCategory>() {
  return ::dnd5e::api::v1alpha1::ArmorProficiencyCategory_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::WeaponProficiencyCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::WeaponProficiencyCategory>() {
  return ::dnd5e::api::v1alpha1::WeaponProficiencyCategory_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::ToolProficiencyCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::ToolProficiencyCategory>() {
  return ::dnd5e::api::v1alpha1::ToolProficiencyCategory_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::WeaponCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::WeaponCategory>() {
  return ::dnd5e::api::v1alpha1::WeaponCategory_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::ArmorCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::ArmorCategory>() {
  return ::dnd5e::api::v1alpha1::ArmorCategory_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::ToolCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::ToolCategory>() {
  return ::dnd5e::api::v1alpha1::ToolCategory_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::EquipmentCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::EquipmentCategory>() {
  return ::dnd5e::api::v1alpha1::EquipmentCategory_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::GearCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::GearCategory>() {
  return ::dnd5e::api::v1alpha1::GearCategory_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::ConditionId> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::ConditionId>() {
  return ::dnd5e::api::v1alpha1::ConditionId_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::FeatureId> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::FeatureId>() {
  return ::dnd5e::api::v1alpha1::FeatureId_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::MonsterTraitId> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::MonsterTraitId>() {
  return ::dnd5e::api::v1alpha1::MonsterTraitId_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::ActionType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::ActionType>() {
  return ::dnd5e::api::v1alpha1::ActionType_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::MonsterActionType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::MonsterActionType>() {
  return ::dnd5e::api::v1alpha1::MonsterActionType_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::MonsterType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::MonsterType>() {
  return ::dnd5e::api::v1alpha1::MonsterType_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::DungeonTheme> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::DungeonTheme>() {
  return ::dnd5e::api::v1alpha1::DungeonTheme_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::DungeonDifficulty> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::DungeonDifficulty>() {
  return ::dnd5e::api::v1alpha1::DungeonDifficulty_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::DungeonLength> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::DungeonLength>() {
  return ::dnd5e::api::v1alpha1::DungeonLength_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::DungeonState> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::DungeonState>() {
  return ::dnd5e::api::v1alpha1::DungeonState_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::AttackHand> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::AttackHand>() {
  return ::dnd5e::api::v1alpha1::AttackHand_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::EntityType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::EntityType>() {
  return ::dnd5e::api::v1alpha1::EntityType_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::EntitySize> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::EntitySize>() {
  return ::dnd5e::api::v1alpha1::EntitySize_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::ObstacleType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::ObstacleType>() {
  return ::dnd5e::api::v1alpha1::ObstacleType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // dnd5e_2fapi_2fv1alpha1_2fenums_2eproto_2epb_2eh
