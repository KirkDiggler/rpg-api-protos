syntax = "proto3";

package dnd5e.api.v1alpha1;

import "api/v1alpha1/room_common.proto";
import "dnd5e/api/v1alpha1/character.proto";
import "dnd5e/api/v1alpha1/common.proto";
import "dnd5e/api/v1alpha1/enums.proto";

option go_package = "github.com/KirkDiggler/rpg-api-protos/gen/go/dnd5e/api/v1alpha1;v1alpha1";
option java_multiple_files = true;
option java_package = "com.kirkdiggler.rpg.api.dnd5e.v1alpha1";

// Note: Using Position from api.v1alpha1.room_common

// EntityPlacement represents where an entity is positioned
// Matches toolkit's EntityPlacement structure exactly
message EntityPlacement {
  // Unique identifier for the entity
  string entity_id = 1;
  // Type of entity - determines where to look up additional details
  EntityType entity_type = 2;
  // Position in the room
  .api.v1alpha1.Position position = 3;
  // D&D 5e size category
  EntitySize size = 4;
  // Whether this entity blocks movement through its space
  bool blocks_movement = 5;
  // Whether this entity blocks line of sight
  bool blocks_line_of_sight = 6;

  // Visual type based on entity_type:
  // - CHARACTER: not set (uses shader colors from CharacterState)
  // - MONSTER: monster_type
  // - OBSTACLE: obstacle_type
  oneof visual_type {
    MonsterType monster_type = 7;
    ObstacleType obstacle_type = 8;
    // HazardType hazard_type = 9;  // Future
  }
}

// Room represents a spatial area where encounters take place
// Matches toolkit's RoomData structure exactly for direct field mapping
message Room {
  // Unique identifier for the room
  string id = 1;
  // Type of room (e.g., "dungeon", "tavern", "outdoor")
  string type = 2;
  // Width of the room in grid units
  int32 width = 3;
  // Height of the room in grid units
  int32 height = 4;
  // Grid system used in this room
  .api.v1alpha1.GridType grid_type = 5;
  // Hex orientation: true for pointy-top, false for flat-top
  // Only used when grid_type is HEX, defaults to true (pointy-top) for D&D 5e compatibility
  // Uses optional to distinguish between explicit false and unset (which defaults to true)
  optional bool hex_orientation = 6;
  // Entities placed in the room - map of entity ID to their placement data
  // Matches toolkit's map[string]EntityPlacement structure
  map<string, EntityPlacement> entities = 7;
  // Wall segments in the room (perimeter + internal tactical walls)
  repeated .api.v1alpha1.Wall walls = 8;
  // Room origin in dungeon-absolute coordinates
  // Used to position floor hexes in the unified coordinate system
  // First room has origin (0,0,0), subsequent rooms are offset based on door alignment
  .api.v1alpha1.Position origin = 9;
}

// DoorInfo represents a connection point between rooms in a dungeon
message DoorInfo {
  // Unique identifier for this door/connection
  string connection_id = 1;
  // Position of the door within the current room
  .api.v1alpha1.Position position = 2;
  // Physical description hint (e.g., "heavy stone door", "narrow crevice")
  string physical_hint = 3;
  // Whether the door is currently open (revealed)
  bool is_open = 4;
  // ID of the room this door leads to (only set if is_open is true)
  string leads_to_room_id = 5;
}

// DungeonStartRequest initiates a dungeon encounter with configurable options
message DungeonStartRequest {
  // IDs of the characters entering the dungeon
  repeated string character_ids = 1;
  // Theme of the dungeon (defaults to CRYPT if unspecified)
  DungeonTheme theme = 2;
  // Difficulty scaling for encounters (defaults to MEDIUM if unspecified)
  DungeonDifficulty difficulty = 3;
  // Number of rooms in the dungeon (defaults to SHORT if unspecified)
  DungeonLength length = 4;
}

// DungeonStartResponse contains the generated dungeon with the first room ready
message DungeonStartResponse {
  // Unique identifier for this dungeon run
  string dungeon_id = 1;
  // Unique identifier for the current encounter (room)
  string encounter_id = 2;
  // The generated room with all entities placed (including characters)
  Room room = 3;
  // Combat state with initiative already rolled
  CombatState combat_state = 4;
  // If monsters won initiative and acted before first player
  repeated MonsterTurnResult monster_turns = 5;
  // Doors/connections visible from the current room
  repeated DoorInfo doors = 6;
  // Current state of the dungeon run
  DungeonState dungeon_state = 7;
}

// OpenDoorRequest attempts to open a door and reveal the next room
message OpenDoorRequest {
  // The dungeon run this door belongs to
  string dungeon_id = 1;
  // The connection/door ID to open
  string connection_id = 2;
}

// OpenDoorResponse contains the revealed room and updated dungeon state
message OpenDoorResponse {
  // Whether the door was successfully opened
  bool success = 1;
  // Error message if failed (e.g., "door is locked", "already open")
  string error = 2;
  // Unique identifier for the new encounter (room)
  string encounter_id = 3;
  // The revealed room with entities placed
  Room room = 4;
  // Combat state with initiative rolled for the new room
  CombatState combat_state = 5;
  // If monsters won initiative and acted before first player
  repeated MonsterTurnResult monster_turns = 6;
  // Doors visible from the newly revealed room
  repeated DoorInfo doors = 7;
  // Updated dungeon state (may transition to VICTORIOUS if boss room cleared)
  DungeonState dungeon_state = 8;
}

// ============================================================================
// COMBAT STATE (automatically started by DungeonStart)
// ============================================================================

// InitiativeEntry represents one combatant in turn order
message InitiativeEntry {
  string entity_id = 1;
  string entity_type = 2; // "character", "monster", "npc"
  int32 initiative = 3; // Total initiative value (roll + modifier)
  int32 modifier = 4; // DEX modifier used
  bool has_acted = 5; // Has this entity acted this round?
}

// TurnState tracks resources available during a turn
message TurnState {
  string entity_id = 1;
  int32 movement_used = 2 [deprecated = true]; // Use action_economy.movement_remaining
  int32 movement_max = 3 [deprecated = true]; // Use action_economy.movement_max
  bool action_used = 4 [deprecated = true]; // Use action_economy.standard_action_available
  bool bonus_action_used = 5 [deprecated = true]; // Use action_economy.bonus_action_available
  bool reaction_available = 6 [deprecated = true]; // Use action_economy.reaction_available
  .api.v1alpha1.Position position = 7;

  // New action economy system - tracks all combat resources
  ActionEconomy action_economy = 8;
}

// ActionEconomy tracks all combat resources available during a turn
// This replaces the individual boolean/int fields in TurnState
message ActionEconomy {
  // Movement capacity in feet (base speed, DASH adds to it)
  int32 movement_remaining = 1;
  // Maximum movement for this turn (base + any bonuses like DASH)
  int32 movement_max = 2;

  // Attack capacity granted by ATTACK ability
  // Starts at 0, ATTACK grants 1 (or more with Extra Attack)
  int32 attacks_remaining = 3;

  // Standard action availability (consumed by ATTACK, DASH, DODGE, etc.)
  bool standard_action_available = 4;
  // Bonus action availability (consumed by off-hand attack, Flurry of Blows, etc.)
  bool bonus_action_available = 5;
  // Reaction availability (consumed by opportunity attacks, etc.)
  bool reaction_available = 6;

  // Off-hand attack capacity (granted by two-weapon fighting after main attack)
  int32 off_hand_attacks_remaining = 7;
  // Flurry strikes remaining (granted by Flurry of Blows)
  int32 flurry_strikes_remaining = 8;

  // Whether disengage is active (no opportunity attacks this turn)
  bool disengage_active = 9;
  // Whether dodge is active (attacks against have disadvantage)
  bool dodge_active = 10;
}

// AvailableAbility represents a combat ability with its current availability status
// Used by UI to render ability buttons with proper enabled/disabled state
message AvailableAbility {
  // Which ability this represents
  CombatAbilityId ability_id = 1;
  // Display name for UI
  string name = 2;
  // Whether the ability can be activated right now
  bool can_use = 3;
  // Explanation if can_use is false (e.g., "no actions remaining")
  string reason = 4;
}

// AvailableAction represents an executable action with its current availability status
// Used by UI to render action buttons based on granted capacity
message AvailableAction {
  // Which action this represents
  ActionId action_id = 1;
  // Display name for UI
  string name = 2;
  // Whether the action can be executed right now
  bool can_use = 3;
  // Explanation if can_use is false (e.g., "no attacks remaining")
  string reason = 4;
}

// CombatState represents the complete state of combat
message CombatState {
  string encounter_id = 1;
  int32 round = 2;
  repeated InitiativeEntry turn_order = 3;
  int32 active_index = 4; // Index in turn_order of current actor
  TurnState current_turn = 5;
  bool combat_started = 6;
  bool combat_ended = 7;
}

// GetCombatStateRequest retrieves current state (for reconnection/refresh)
message GetCombatStateRequest {
  string encounter_id = 1;
}

// GetCombatStateResponse returns the current state
message GetCombatStateResponse {
  Room room = 1;
  CombatState combat_state = 2;
}

// GetEncounterStateRequest retrieves the full encounter snapshot
// Used for the load-then-stream pattern to sync state before processing events
message GetEncounterStateRequest {
  string encounter_id = 1;
  string player_id = 2;
}

// MonsterCombatState contains monster HP information for rendering
// Entity positions are in Room.entities, this provides combat stats
message MonsterCombatState {
  string monster_id = 1;
  string monster_name = 2;
  int32 current_hit_points = 3;
  int32 max_hit_points = 4;
  MonsterType monster_type = 5; // For UI texture selection
}

// GetEncounterStateResponse returns a full snapshot of the encounter
// Includes everything needed to render the current state without events
message GetEncounterStateResponse {
  // Encounter metadata
  string encounter_id = 1;
  EncounterState state = 2;

  // Lobby state (populated in WAITING state)
  repeated PartyMember party = 3;
  string join_code = 4;
  string host_id = 5;

  // Combat state (populated in ACTIVE state)
  CombatState combat_state = 6;
  Room room = 7;
  repeated MonsterCombatState monsters = 8;

  // Event synchronization
  // ULID of the most recent event - used for client-side filtering
  // Client should ignore events with event_id <= last_event_id
  string last_event_id = 9;

  // Dungeon state (populated in ACTIVE state for dungeon encounters)
  repeated DoorInfo doors = 10;
  string dungeon_id = 11;
}

// GetEncounterHistoryRequest retrieves historical events for an encounter
// Used by late joiners to populate event log before streaming new events
message GetEncounterHistoryRequest {
  string encounter_id = 1;
  // Get events up to this ID (from GetEncounterState.last_event_id)
  // If empty, returns all events
  string up_to_event_id = 2;
  // Maximum events to return (0 = no limit)
  // Events are returned in chronological order
  int32 limit = 3;
}

// GetEncounterHistoryResponse returns historical encounter events
message GetEncounterHistoryResponse {
  // Events in chronological order
  repeated EncounterEvent events = 1;
  // True if more events exist beyond the limit
  bool has_more = 2;
  // ID of the last event returned (for pagination)
  string last_event_id = 3;
}

// ============================================================================
// MOVEMENT
// ============================================================================

// MoveCharacterRequest requests movement along a path
// The server validates each step for traps, AoO, obstacles, etc.
message MoveCharacterRequest {
  string encounter_id = 1;
  string entity_id = 2;
  repeated .api.v1alpha1.Position path = 3; // Each step in order
}

// MovementError provides detailed movement failure information
message MovementError {
  enum ErrorCode {
    ERROR_CODE_UNSPECIFIED = 0;
    ERROR_CODE_INVALID_POSITION = 1;
    ERROR_CODE_INSUFFICIENT_MOVEMENT = 2;
    ERROR_CODE_PATH_BLOCKED = 3;
    ERROR_CODE_POSITION_OCCUPIED = 4;
    ERROR_CODE_OUT_OF_BOUNDS = 5;
    ERROR_CODE_NOT_YOUR_TURN = 6;
  }
  ErrorCode code = 1;
  string message = 2;
  map<string, string> details = 3;
}

// MoveCharacterResponse returns movement result
message MoveCharacterResponse {
  bool success = 1;
  MovementError error = 2;

  // Where movement ended (may differ from requested path if interrupted)
  .api.v1alpha1.Position final_position = 3;
  int32 movement_remaining = 4;

  // Simple string describing why movement stopped
  // Examples: "completed", "trap triggered", "blocked by wall"
  string stop_reason = 5;

  Room updated_room = 6; // Updated room with new positions and state
}

// FUTURE: GetMovementOptions RPC for server-side movement validation
// For now, client calculates valid moves locally

// ============================================================================
// TURN MANAGEMENT
// ============================================================================

// EndTurnRequest ends the current entity's turn
message EndTurnRequest {
  string encounter_id = 1;
  string entity_id = 2; // Must match current turn
}

// TurnChangeEvent describes a turn transition
message TurnChangeEvent {
  string previous_entity_id = 1;
  string next_entity_id = 2;
  int32 round = 3;
  bool new_round = 4; // True if this starts a new round
}

// EndTurnResponse returns the updated state after turn end
message EndTurnResponse {
  bool success = 1;
  CombatState combat_state = 2;
  TurnChangeEvent turn_change = 3;

  // Monster turns that occurred after player ended turn
  repeated MonsterTurnResult monster_turns = 4;

  // Set if combat ended (victory or TPK)
  optional EncounterResult encounter_result = 5;
}

// ============================================================================
// COMBAT ACTIONS
// ============================================================================

// AttackRequest represents a melee or ranged attack
message AttackRequest {
  string encounter_id = 1;
  string attacker_id = 2;
  string target_id = 3;
  string weapon_id = 4; // Optional, uses default weapon if not specified
  AttackHand attack_hand = 5; // Which hand is attacking (for two-weapon fighting)
}

// ============================================================================
// DAMAGE BREAKDOWN
// ============================================================================

// RerollEvent tracks a single die reroll (Great Weapon Fighting, Halfling Lucky, etc.)
message RerollEvent {
  int32 die_index = 1; // Which die was rerolled (0-based index in original_dice_rolls)
  int32 before = 2; // Value before reroll
  int32 after = 3; // Value after reroll
  string reason = 4; // Feature that caused reroll (e.g., "great_weapon_fighting")
}

// DamageComponent represents damage from a single source
message DamageComponent {
  // DEPRECATED: Use source_ref instead
  string source = 1 [deprecated = true]; // Type of damage source ("weapon", "ability", "rage", etc.)
  repeated int32 original_dice_rolls = 2; // Dice values as first rolled
  repeated int32 final_dice_rolls = 3; // Dice values after all rerolls
  repeated RerollEvent rerolls = 4; // History of rerolls
  int32 flat_bonus = 5; // Flat modifier (0 if none)
  string damage_type = 6; // "slashing", "fire", "radiant", etc.
  bool is_critical = 7; // Was this component doubled for crit?

  // Type-safe source reference
  SourceRef source_ref = 8;

  // Multiplier for this component (default 1.0)
  // Used for vulnerability (2.0), resistance (0.5), or immunity (0.0)
  // When set, this component represents a damage multiplier, not additive damage
  // UI should display as "Ã—2" rather than "+X"
  optional float multiplier = 9;
}

// DamageBreakdown provides complete damage breakdown by source
message DamageBreakdown {
  repeated DamageComponent components = 1; // All damage sources
  string ability_used = 2; // "STR" or "DEX"
  int32 total_damage = 3; // Sum of all components
}

// AttackResult contains the outcome of an attack
message AttackResult {
  bool hit = 1;
  int32 attack_roll = 2;
  int32 attack_total = 3; // roll + modifiers
  int32 target_ac = 4;
  int32 damage = 5;
  string damage_type = 6; // "slashing", "piercing", etc.
  bool critical = 7;
  DamageBreakdown damage_breakdown = 8; // Detailed damage breakdown (optional)
}

// GrantedAction represents an action granted during combat
// Example: Two-weapon fighting grants an off-hand strike after main-hand attack
message GrantedAction {
  string id = 1; // Unique identifier for this granted action
  string type = 2; // Action type (e.g., "off-hand-strike")
  string name = 3; // Display name for UI
  string reason = 4; // Why granted (e.g., "dual-wielding light weapons")
  string weapon_id = 5; // Associated weapon (if applicable)
}

// AttackResponse returns the attack outcome
message AttackResponse {
  bool success = 1;
  string error = 2;
  AttackResult result = 3;
  CombatState combat_state = 4;
  Room updated_room = 5; // Updated if entities are defeated/removed
  GrantedAction granted_action = 6; // Action granted from this attack (e.g., off-hand strike)
}

// ============================================================================
// TWO-LEVEL ACTION ECONOMY
// ============================================================================

// ActivateCombatAbilityRequest activates a combat ability (ATTACK, DASH, DODGE, etc.)
// This consumes action economy resources and grants capacity to execute actions
message ActivateCombatAbilityRequest {
  string encounter_id = 1;
  string entity_id = 2;
  CombatAbilityId ability_id = 3;

  // Optional target for abilities that need one (HELP)
  string target_id = 4;
}

// ActivateCombatAbilityResponse returns the result of ability activation
message ActivateCombatAbilityResponse {
  bool success = 1;
  string error = 2;

  // Updated action economy after activation
  ActionEconomy action_economy = 3;

  // What capacity was granted (for UI feedback)
  // e.g., "Granted 2 attacks" for Fighter with Extra Attack
  string granted_capacity = 4;

  // Full combat state update
  CombatState combat_state = 5;

  // Current availability of all combat abilities after this activation
  // UI should refresh ability buttons based on this list
  repeated AvailableAbility available_abilities = 6;

  // Current availability of all actions after this activation
  // UI should refresh action buttons based on this list
  repeated AvailableAction available_actions = 7;
}

// StrikeInput contains parameters for executing a strike action
message StrikeInput {
  string target_id = 1;
  string weapon_id = 2; // Optional, uses equipped weapon if not specified
}

// MoveInput contains parameters for executing a move action
message MoveInput {
  repeated .api.v1alpha1.Position path = 1; // Each step in order
}

// ExecuteActionRequest executes an action that consumes granted capacity
message ExecuteActionRequest {
  string encounter_id = 1;
  string entity_id = 2;
  ActionId action_id = 3;

  // Action-specific input
  oneof input {
    StrikeInput strike = 10;
    MoveInput move = 11;
  }
}

// MoveResult contains the outcome of a move action
message MoveResult {
  .api.v1alpha1.Position final_position = 1;
  int32 movement_used = 2;
  string stop_reason = 3; // "completed", "trap triggered", etc.
}

// ExecuteActionResponse returns the result of action execution
message ExecuteActionResponse {
  bool success = 1;
  string error = 2;

  // Updated action economy after execution
  ActionEconomy action_economy = 3;

  // Action-specific result
  oneof result {
    AttackResult strike_result = 10;
    MoveResult move_result = 11;
  }

  // Full state updates
  CombatState combat_state = 4;
  Room updated_room = 5;

  // For strike actions: was an off-hand attack granted?
  GrantedAction granted_action = 6;

  // Current availability of all combat abilities after this action
  // UI should refresh ability buttons based on this list
  repeated AvailableAbility available_abilities = 7;

  // Current availability of all actions after this action
  // UI should refresh action buttons based on this list
  repeated AvailableAction available_actions = 8;
}

// ============================================================================
// MONSTER TURN RESULTS
// ============================================================================

// EncounterEndReason indicates why combat ended
enum EncounterEndReason {
  ENCOUNTER_END_REASON_UNSPECIFIED = 0;
  ENCOUNTER_END_REASON_VICTORY = 1; // All monsters defeated
  ENCOUNTER_END_REASON_DEFEAT = 2; // All players defeated (TPK)
}

// EncounterState represents the lifecycle state of an encounter
enum EncounterState {
  ENCOUNTER_STATE_UNSPECIFIED = 0;
  ENCOUNTER_STATE_WAITING = 1; // Lobby, waiting for players to join
  ENCOUNTER_STATE_ACTIVE = 2; // Combat in progress
  ENCOUNTER_STATE_PAUSED = 3; // Paused due to player disconnect
  ENCOUNTER_STATE_COMPLETED = 4; // Finished (victory or defeat)
}

// EncounterResult signals that combat has ended
message EncounterResult {
  EncounterEndReason reason = 1;
}

// HealResult contains the outcome of a healing action
message HealResult {
  int32 amount_healed = 1; // HP restored
  int32 new_hp = 2; // Current HP after healing
  int32 max_hp = 3; // Maximum HP (for context)
}

// MonsterExecutedAction records a single action taken by a monster
message MonsterExecutedAction {
  string action_id = 1; // Which action was used
  MonsterActionType action_type = 2; // Category (melee_attack, heal, etc.)
  string target_id = 3; // Who was targeted (if applicable)
  bool success = 4; // Did the action succeed?

  // Action-specific details
  oneof details {
    AttackResult attack_result = 5; // Reuse existing AttackResult
    HealResult heal_result = 6;
  }
}

// MonsterTurnResult encapsulates everything a monster did on its turn
message MonsterTurnResult {
  string monster_id = 1;
  string monster_name = 2; // Self-contained for streaming
  repeated MonsterExecutedAction actions = 3; // All actions taken
  repeated .api.v1alpha1.Position movement_path = 4; // Positions traversed
}

// ============================================================================
// FEATURE ACTIVATION
// ============================================================================

// ActivateFeatureRequest activates a combat feature (e.g., Rage, Second Wind)
message ActivateFeatureRequest {
  string encounter_id = 1;
  string character_id = 2;
  FeatureId feature_id = 3; // Which feature to activate
}

// ActivateFeatureResponse returns the result of feature activation
message ActivateFeatureResponse {
  bool success = 1;
  string message = 2;
  Character updated_character = 3;
  CombatState updated_combat_state = 4;
}

// ============================================================================
// MULTIPLAYER LOBBY MANAGEMENT
// ============================================================================

// PartyMember represents a player and their character in the encounter
message PartyMember {
  string player_id = 1;
  Character character = 2;
  bool is_host = 3;
  bool is_ready = 4;
  bool is_connected = 5;
}

// CreateEncounterRequest creates a new multiplayer encounter (lobby)
message CreateEncounterRequest {
  repeated string character_ids = 1; // Host's character(s)
}

// CreateEncounterResponse returns the created encounter with join code
message CreateEncounterResponse {
  string encounter_id = 1;
  string join_code = 2; // 6-char code for others to join (e.g., "ABC123")
  Room room = 3; // Generated room
}

// JoinEncounterRequest joins an existing encounter via join code
message JoinEncounterRequest {
  string join_code = 1;
  repeated string character_ids = 2; // Joining player's character(s)
}

// JoinEncounterResponse returns the current encounter state
message JoinEncounterResponse {
  string encounter_id = 1;
  Room room = 2;
  repeated PartyMember party = 3; // Everyone currently in lobby
  EncounterState state = 4;
}

// SetReadyRequest marks a player as ready to start combat
message SetReadyRequest {
  string encounter_id = 1;
  string player_id = 2;
  bool is_ready = 3;
}

// SetReadyResponse confirms the ready status change
message SetReadyResponse {
  bool success = 1;
}

// StartCombatRequest initiates combat (host only, all players must be ready)
message StartCombatRequest {
  string encounter_id = 1;
  // Dungeon configuration (host sets these in lobby)
  DungeonTheme theme = 2;
  DungeonDifficulty difficulty = 3;
  DungeonLength length = 4;
}

// StartCombatResponse returns the initial combat state
message StartCombatResponse {
  CombatState combat_state = 1;
  Room room = 2; // Room with entity positions for rendering
  // If monsters won initiative and acted before first player
  repeated MonsterTurnResult monster_turns = 3;
  // Doors/connections visible from the starting room
  repeated DoorInfo doors = 4;
  // Unique identifier for this dungeon run (needed for OpenDoor)
  string dungeon_id = 5;
}

// LeaveEncounterRequest removes a player from the encounter
message LeaveEncounterRequest {
  string encounter_id = 1;
  string player_id = 2;
}

// LeaveEncounterResponse confirms the player left
message LeaveEncounterResponse {
  bool success = 1;
}

// ============================================================================
// EVENT STREAMING
// ============================================================================

// StreamEncounterEventsRequest subscribes to real-time encounter events
message StreamEncounterEventsRequest {
  string encounter_id = 1;
  string player_id = 2; // Who's subscribing
}

// EncounterEvent is the main event wrapper sent via stream
message EncounterEvent {
  string event_id = 1; // Unique ID for deduplication
  int64 timestamp = 2; // Server timestamp

  oneof event {
    // Lobby events
    PlayerJoinedEvent player_joined = 10;
    PlayerLeftEvent player_left = 11;
    PlayerReadyEvent player_ready = 12;
    CombatStartedEvent combat_started = 13;

    // Combat events (legacy)
    MovementCompletedEvent movement_completed = 20;
    AttackResolvedEvent attack_resolved = 21;
    FeatureActivatedEvent feature_activated = 22;
    TurnEndedEvent turn_ended = 23;
    MonsterTurnCompletedEvent monster_turn_completed = 24;
    CombatEndedEvent combat_ended = 25;

    // Combat events (new action economy)
    CombatAbilityActivatedEvent combat_ability_activated = 26;
    ActionExecutedEvent action_executed = 27;

    // Connection events
    PlayerDisconnectedEvent player_disconnected = 30;
    PlayerReconnectedEvent player_reconnected = 31;
    CombatPausedEvent combat_paused = 32;
    CombatResumedEvent combat_resumed = 33;

    // Dungeon events
    RoomRevealedEvent room_revealed = 40;
    DungeonVictoryEvent dungeon_victory = 41;
    DungeonFailureEvent dungeon_failure = 42;
  }
}

// ============================================================================
// LOBBY EVENTS
// ============================================================================

// PlayerJoinedEvent is sent when a player joins the encounter
message PlayerJoinedEvent {
  PartyMember member = 1;
}

// PlayerLeftEvent is sent when a player leaves the encounter
message PlayerLeftEvent {
  string player_id = 1;
  string character_id = 2;
}

// PlayerReadyEvent is sent when a player changes their ready status
message PlayerReadyEvent {
  string player_id = 1;
  bool is_ready = 2;
}

// CombatStartedEvent is sent when the host starts combat
message CombatStartedEvent {
  CombatState combat_state = 1;
  Room room = 2; // Final room with all entity placements
  repeated PartyMember party = 3; // Full party state at combat start
  repeated MonsterCombatState monsters = 4; // Monster state with types for UI textures
  // Doors/connections visible from the starting room
  repeated DoorInfo doors = 5;
  // Unique identifier for this dungeon run (needed for OpenDoor)
  string dungeon_id = 6;
  // If monsters won initiative and acted before first player
  repeated MonsterTurnResult monster_turns = 7;
}

// ============================================================================
// COMBAT EVENTS
// ============================================================================

// MovementCompletedEvent is sent when an entity finishes moving
message MovementCompletedEvent {
  string entity_id = 1;
  repeated .api.v1alpha1.Position path = 2; // Full path taken for client animation
  .api.v1alpha1.Position final_position = 3;
  int32 movement_remaining = 4;
  string stop_reason = 5; // "completed", "trap triggered", etc.
  Room updated_room = 6;
}

// AttackResolvedEvent is sent when an attack is resolved
message AttackResolvedEvent {
  string attacker_id = 1;
  string target_id = 2;
  AttackResult result = 3;
  Character updated_attacker = 4; // If attacker state changed
  Character updated_target = 5; // New HP, conditions, etc.
  Room updated_room = 6; // If entity was defeated/removed
  GrantedAction granted_action = 7; // Action granted from this attack (e.g., off-hand strike)
}

// FeatureActivatedEvent is sent when a character activates a feature
message FeatureActivatedEvent {
  string character_id = 1;
  string feature_id = 2;
  string message = 3; // e.g., "Thorin enters a rage!"
  Character updated_character = 4;
}

// TurnEndedEvent is sent when a turn ends and a new turn begins
message TurnEndedEvent {
  TurnChangeEvent turn_change = 1;
  CombatState combat_state = 2;
  Room updated_room = 3; // Room with updated entity positions after turn
}

// MonsterTurnCompletedEvent is sent when a monster finishes its turn
message MonsterTurnCompletedEvent {
  MonsterTurnResult monster_turn = 1;
  repeated Character updated_characters = 2; // Characters that took damage
  Room updated_room = 3;
}

// CombatEndedEvent is sent when combat ends (victory or defeat)
message CombatEndedEvent {
  EncounterResult result = 1;
}

// CombatAbilityActivatedEvent is sent when an entity activates a combat ability
message CombatAbilityActivatedEvent {
  string entity_id = 1;
  CombatAbilityId ability_id = 2;
  // What capacity was granted (for UI/log display)
  string granted_capacity = 3;
  // Updated action economy after activation
  ActionEconomy action_economy = 4;
  // Full combat state update
  CombatState combat_state = 5;
}

// ActionExecutedEvent is sent when an entity executes an action
message ActionExecutedEvent {
  string entity_id = 1;
  ActionId action_id = 2;

  // Action-specific result
  oneof result {
    AttackResult strike_result = 10;
    MoveResult move_result = 11;
  }

  // Updated action economy after execution
  ActionEconomy action_economy = 3;

  // State updates
  CombatState combat_state = 4;
  Room updated_room = 5;

  // For attack actions: target and updated state
  string target_id = 6;
  Character updated_target = 7; // If target took damage

  // Was an additional action granted? (e.g., off-hand strike)
  GrantedAction granted_action = 8;
}

// ============================================================================
// CONNECTION EVENTS
// ============================================================================

// PlayerDisconnectedEvent is sent when a player's connection drops
message PlayerDisconnectedEvent {
  string player_id = 1;
  string character_id = 2;
}

// PlayerReconnectedEvent is sent when a disconnected player reconnects
message PlayerReconnectedEvent {
  string player_id = 1;
  PartyMember member = 2; // Full state in case anything changed
}

// CombatPausedEvent is sent when combat is paused due to disconnect
message CombatPausedEvent {
  string reason = 1;
  string disconnected_player_id = 2;
}

// CombatResumedEvent is sent when all players are reconnected
message CombatResumedEvent {
  CombatState combat_state = 1; // Current state when resuming
}

// ============================================================================
// DUNGEON EVENTS
// ============================================================================

// RoomRevealedEvent is sent when a door is opened and a new room is revealed
message RoomRevealedEvent {
  // The dungeon run
  string dungeon_id = 1;
  // The door that was opened
  string connection_id = 2;
  // The newly revealed room with entities
  Room room = 3;
  // Combat state for the new room
  CombatState combat_state = 4;
  // Doors visible from the new room
  repeated DoorInfo doors = 5;
}

// DungeonVictoryEvent is sent when the boss is defeated and the dungeon is complete
message DungeonVictoryEvent {
  // The dungeon run that was completed
  string dungeon_id = 1;
  // Total rooms cleared
  int32 rooms_cleared = 2;
  // Final dungeon state
  DungeonState dungeon_state = 3;
}

// DungeonFailureEvent is sent when the party is defeated (TPK)
message DungeonFailureEvent {
  // The dungeon run that failed
  string dungeon_id = 1;
  // The room where the party was defeated
  string final_room_id = 2;
  // Final dungeon state
  DungeonState dungeon_state = 3;
}

// ============================================================================
// SERVICE DEFINITION
// ============================================================================

// EncounterService manages D&D 5e encounters
service EncounterService {
  // === Lobby Management ===

  // CreateEncounter creates a new encounter lobby with a join code
  rpc CreateEncounter(CreateEncounterRequest) returns (CreateEncounterResponse);

  // JoinEncounter joins an existing encounter via join code
  rpc JoinEncounter(JoinEncounterRequest) returns (JoinEncounterResponse);

  // SetReady marks a player as ready to start combat
  rpc SetReady(SetReadyRequest) returns (SetReadyResponse);

  // StartCombat begins combat (host only, all players must be ready)
  rpc StartCombat(StartCombatRequest) returns (StartCombatResponse);

  // LeaveEncounter removes a player from the encounter
  rpc LeaveEncounter(LeaveEncounterRequest) returns (LeaveEncounterResponse);

  // === Event Stream ===

  // StreamEncounterEvents subscribes to real-time encounter events
  rpc StreamEncounterEvents(StreamEncounterEventsRequest) returns (stream EncounterEvent);

  // === Dungeon Exploration ===

  // Deprecated: Use CreateEncounter + StartCombat instead.
  // Single-player now uses the multiplayer flow (party of one).
  rpc DungeonStart(DungeonStartRequest) returns (DungeonStartResponse) {
    option deprecated = true;
  }

  // OpenDoor opens a door to reveal and enter the next room
  rpc OpenDoor(OpenDoorRequest) returns (OpenDoorResponse);

  // === State Retrieval ===

  // GetCombatState retrieves current state (for reconnection/refresh)
  // Deprecated: Use GetEncounterState for full snapshot with event sync
  rpc GetCombatState(GetCombatStateRequest) returns (GetCombatStateResponse);

  // GetEncounterState retrieves full encounter snapshot for load-then-stream pattern
  // Returns complete state including last_event_id for client-side event filtering
  rpc GetEncounterState(GetEncounterStateRequest) returns (GetEncounterStateResponse);

  // GetEncounterHistory retrieves historical events for late join/reconnect
  // Returns events up to the specified event ID for event log population
  rpc GetEncounterHistory(GetEncounterHistoryRequest) returns (GetEncounterHistoryResponse);

  // === Combat Actions (Legacy) ===

  // Deprecated: Use ExecuteAction with ACTION_ID_MOVE instead.
  // MoveCharacter validates and executes movement along a path
  rpc MoveCharacter(MoveCharacterRequest) returns (MoveCharacterResponse) {
    option deprecated = true;
  }

  // EndTurn ends the current entity's turn
  rpc EndTurn(EndTurnRequest) returns (EndTurnResponse);

  // Deprecated: Use ActivateCombatAbility + ExecuteAction instead.
  // Attack executes a melee or ranged attack
  rpc Attack(AttackRequest) returns (AttackResponse) {
    option deprecated = true;
  }

  // ActivateFeature activates a combat feature (e.g., Rage, Second Wind)
  rpc ActivateFeature(ActivateFeatureRequest) returns (ActivateFeatureResponse);

  // === Combat Actions (Two-Level Action Economy) ===

  // ActivateCombatAbility activates a combat ability (ATTACK, DASH, DODGE, etc.)
  // This consumes action economy resources and grants capacity to execute actions
  rpc ActivateCombatAbility(ActivateCombatAbilityRequest) returns (ActivateCombatAbilityResponse);

  // ExecuteAction executes an action that consumes granted capacity
  // Use after ActivateCombatAbility to perform strikes, moves, etc.
  rpc ExecuteAction(ExecuteActionRequest) returns (ExecuteActionResponse);
}
