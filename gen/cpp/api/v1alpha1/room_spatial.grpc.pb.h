// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: api/v1alpha1/room_spatial.proto
#ifndef GRPC_api_2fv1alpha1_2froom_5fspatial_2eproto__INCLUDED
#define GRPC_api_2fv1alpha1_2froom_5fspatial_2eproto__INCLUDED

#include "api/v1alpha1/room_spatial.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace api {
namespace v1alpha1 {

// Spatial query service for tactical gameplay operations
// Handles line of sight, movement, pathfinding, and area effects
class SpatialService final {
 public:
  static constexpr char const* service_full_name() {
    return "api.v1alpha1.SpatialService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Basic spatial queries (Phase 2)
    virtual ::grpc::Status QueryLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest& request, ::api::v1alpha1::QueryLineOfSightResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryLineOfSightResponse>> AsyncQueryLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryLineOfSightResponse>>(AsyncQueryLineOfSightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryLineOfSightResponse>> PrepareAsyncQueryLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryLineOfSightResponse>>(PrepareAsyncQueryLineOfSightRaw(context, request, cq));
    }
    virtual ::grpc::Status ValidateMovement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest& request, ::api::v1alpha1::ValidateMovementResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::ValidateMovementResponse>> AsyncValidateMovement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::ValidateMovementResponse>>(AsyncValidateMovementRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::ValidateMovementResponse>> PrepareAsyncValidateMovement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::ValidateMovementResponse>>(PrepareAsyncValidateMovementRaw(context, request, cq));
    }
    virtual ::grpc::Status ValidateEntityPlacement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest& request, ::api::v1alpha1::ValidateEntityPlacementResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::ValidateEntityPlacementResponse>> AsyncValidateEntityPlacement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::ValidateEntityPlacementResponse>>(AsyncValidateEntityPlacementRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::ValidateEntityPlacementResponse>> PrepareAsyncValidateEntityPlacement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::ValidateEntityPlacementResponse>>(PrepareAsyncValidateEntityPlacementRaw(context, request, cq));
    }
    virtual ::grpc::Status QueryEntitiesInRange(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest& request, ::api::v1alpha1::QueryEntitiesInRangeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryEntitiesInRangeResponse>> AsyncQueryEntitiesInRange(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryEntitiesInRangeResponse>>(AsyncQueryEntitiesInRangeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryEntitiesInRangeResponse>> PrepareAsyncQueryEntitiesInRange(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryEntitiesInRangeResponse>>(PrepareAsyncQueryEntitiesInRangeRaw(context, request, cq));
    }
    // Advanced spatial queries (Phase 4)
    virtual ::grpc::Status CalculateMovementPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest& request, ::api::v1alpha1::CalculateMovementPathResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::CalculateMovementPathResponse>> AsyncCalculateMovementPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::CalculateMovementPathResponse>>(AsyncCalculateMovementPathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::CalculateMovementPathResponse>> PrepareAsyncCalculateMovementPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::CalculateMovementPathResponse>>(PrepareAsyncCalculateMovementPathRaw(context, request, cq));
    }
    virtual ::grpc::Status QueryAreaOfEffect(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest& request, ::api::v1alpha1::QueryAreaOfEffectResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryAreaOfEffectResponse>> AsyncQueryAreaOfEffect(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryAreaOfEffectResponse>>(AsyncQueryAreaOfEffectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryAreaOfEffectResponse>> PrepareAsyncQueryAreaOfEffect(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryAreaOfEffectResponse>>(PrepareAsyncQueryAreaOfEffectRaw(context, request, cq));
    }
    virtual ::grpc::Status QueryMultiRoomLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest& request, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>> AsyncQueryMultiRoomLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>>(AsyncQueryMultiRoomLineOfSightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>> PrepareAsyncQueryMultiRoomLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>>(PrepareAsyncQueryMultiRoomLineOfSightRaw(context, request, cq));
    }
    virtual ::grpc::Status CalculateMultiRoomPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest& request, ::api::v1alpha1::CalculateMultiRoomPathResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::CalculateMultiRoomPathResponse>> AsyncCalculateMultiRoomPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::CalculateMultiRoomPathResponse>>(AsyncCalculateMultiRoomPathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::CalculateMultiRoomPathResponse>> PrepareAsyncCalculateMultiRoomPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::CalculateMultiRoomPathResponse>>(PrepareAsyncCalculateMultiRoomPathRaw(context, request, cq));
    }
    virtual ::grpc::Status QuerySpatialIndex(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest& request, ::api::v1alpha1::QuerySpatialIndexResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QuerySpatialIndexResponse>> AsyncQuerySpatialIndex(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QuerySpatialIndexResponse>>(AsyncQuerySpatialIndexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QuerySpatialIndexResponse>> PrepareAsyncQuerySpatialIndex(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QuerySpatialIndexResponse>>(PrepareAsyncQuerySpatialIndexRaw(context, request, cq));
    }
    // Spatial optimization and analytics
    virtual ::grpc::Status GetSpatialStats(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest& request, ::api::v1alpha1::GetSpatialStatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::GetSpatialStatsResponse>> AsyncGetSpatialStats(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::GetSpatialStatsResponse>>(AsyncGetSpatialStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::GetSpatialStatsResponse>> PrepareAsyncGetSpatialStats(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::GetSpatialStatsResponse>>(PrepareAsyncGetSpatialStatsRaw(context, request, cq));
    }
    virtual ::grpc::Status InvalidateSpatialCache(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest& request, ::api::v1alpha1::InvalidateSpatialCacheResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::InvalidateSpatialCacheResponse>> AsyncInvalidateSpatialCache(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::InvalidateSpatialCacheResponse>>(AsyncInvalidateSpatialCacheRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::InvalidateSpatialCacheResponse>> PrepareAsyncInvalidateSpatialCache(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::InvalidateSpatialCacheResponse>>(PrepareAsyncInvalidateSpatialCacheRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Basic spatial queries (Phase 2)
      virtual void QueryLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest* request, ::api::v1alpha1::QueryLineOfSightResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void QueryLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest* request, ::api::v1alpha1::QueryLineOfSightResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ValidateMovement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest* request, ::api::v1alpha1::ValidateMovementResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ValidateMovement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest* request, ::api::v1alpha1::ValidateMovementResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ValidateEntityPlacement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest* request, ::api::v1alpha1::ValidateEntityPlacementResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ValidateEntityPlacement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest* request, ::api::v1alpha1::ValidateEntityPlacementResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void QueryEntitiesInRange(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest* request, ::api::v1alpha1::QueryEntitiesInRangeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void QueryEntitiesInRange(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest* request, ::api::v1alpha1::QueryEntitiesInRangeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Advanced spatial queries (Phase 4)
      virtual void CalculateMovementPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest* request, ::api::v1alpha1::CalculateMovementPathResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CalculateMovementPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest* request, ::api::v1alpha1::CalculateMovementPathResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void QueryAreaOfEffect(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest* request, ::api::v1alpha1::QueryAreaOfEffectResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void QueryAreaOfEffect(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest* request, ::api::v1alpha1::QueryAreaOfEffectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void QueryMultiRoomLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* request, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void QueryMultiRoomLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* request, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CalculateMultiRoomPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest* request, ::api::v1alpha1::CalculateMultiRoomPathResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CalculateMultiRoomPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest* request, ::api::v1alpha1::CalculateMultiRoomPathResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void QuerySpatialIndex(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest* request, ::api::v1alpha1::QuerySpatialIndexResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void QuerySpatialIndex(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest* request, ::api::v1alpha1::QuerySpatialIndexResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Spatial optimization and analytics
      virtual void GetSpatialStats(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest* request, ::api::v1alpha1::GetSpatialStatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSpatialStats(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest* request, ::api::v1alpha1::GetSpatialStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void InvalidateSpatialCache(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest* request, ::api::v1alpha1::InvalidateSpatialCacheResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InvalidateSpatialCache(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest* request, ::api::v1alpha1::InvalidateSpatialCacheResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryLineOfSightResponse>* AsyncQueryLineOfSightRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryLineOfSightResponse>* PrepareAsyncQueryLineOfSightRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::ValidateMovementResponse>* AsyncValidateMovementRaw(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::ValidateMovementResponse>* PrepareAsyncValidateMovementRaw(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::ValidateEntityPlacementResponse>* AsyncValidateEntityPlacementRaw(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::ValidateEntityPlacementResponse>* PrepareAsyncValidateEntityPlacementRaw(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryEntitiesInRangeResponse>* AsyncQueryEntitiesInRangeRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryEntitiesInRangeResponse>* PrepareAsyncQueryEntitiesInRangeRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::CalculateMovementPathResponse>* AsyncCalculateMovementPathRaw(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::CalculateMovementPathResponse>* PrepareAsyncCalculateMovementPathRaw(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryAreaOfEffectResponse>* AsyncQueryAreaOfEffectRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryAreaOfEffectResponse>* PrepareAsyncQueryAreaOfEffectRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>* AsyncQueryMultiRoomLineOfSightRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>* PrepareAsyncQueryMultiRoomLineOfSightRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::CalculateMultiRoomPathResponse>* AsyncCalculateMultiRoomPathRaw(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::CalculateMultiRoomPathResponse>* PrepareAsyncCalculateMultiRoomPathRaw(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QuerySpatialIndexResponse>* AsyncQuerySpatialIndexRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::QuerySpatialIndexResponse>* PrepareAsyncQuerySpatialIndexRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::GetSpatialStatsResponse>* AsyncGetSpatialStatsRaw(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::GetSpatialStatsResponse>* PrepareAsyncGetSpatialStatsRaw(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::InvalidateSpatialCacheResponse>* AsyncInvalidateSpatialCacheRaw(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1alpha1::InvalidateSpatialCacheResponse>* PrepareAsyncInvalidateSpatialCacheRaw(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status QueryLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest& request, ::api::v1alpha1::QueryLineOfSightResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryLineOfSightResponse>> AsyncQueryLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryLineOfSightResponse>>(AsyncQueryLineOfSightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryLineOfSightResponse>> PrepareAsyncQueryLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryLineOfSightResponse>>(PrepareAsyncQueryLineOfSightRaw(context, request, cq));
    }
    ::grpc::Status ValidateMovement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest& request, ::api::v1alpha1::ValidateMovementResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::ValidateMovementResponse>> AsyncValidateMovement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::ValidateMovementResponse>>(AsyncValidateMovementRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::ValidateMovementResponse>> PrepareAsyncValidateMovement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::ValidateMovementResponse>>(PrepareAsyncValidateMovementRaw(context, request, cq));
    }
    ::grpc::Status ValidateEntityPlacement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest& request, ::api::v1alpha1::ValidateEntityPlacementResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::ValidateEntityPlacementResponse>> AsyncValidateEntityPlacement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::ValidateEntityPlacementResponse>>(AsyncValidateEntityPlacementRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::ValidateEntityPlacementResponse>> PrepareAsyncValidateEntityPlacement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::ValidateEntityPlacementResponse>>(PrepareAsyncValidateEntityPlacementRaw(context, request, cq));
    }
    ::grpc::Status QueryEntitiesInRange(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest& request, ::api::v1alpha1::QueryEntitiesInRangeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryEntitiesInRangeResponse>> AsyncQueryEntitiesInRange(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryEntitiesInRangeResponse>>(AsyncQueryEntitiesInRangeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryEntitiesInRangeResponse>> PrepareAsyncQueryEntitiesInRange(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryEntitiesInRangeResponse>>(PrepareAsyncQueryEntitiesInRangeRaw(context, request, cq));
    }
    ::grpc::Status CalculateMovementPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest& request, ::api::v1alpha1::CalculateMovementPathResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::CalculateMovementPathResponse>> AsyncCalculateMovementPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::CalculateMovementPathResponse>>(AsyncCalculateMovementPathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::CalculateMovementPathResponse>> PrepareAsyncCalculateMovementPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::CalculateMovementPathResponse>>(PrepareAsyncCalculateMovementPathRaw(context, request, cq));
    }
    ::grpc::Status QueryAreaOfEffect(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest& request, ::api::v1alpha1::QueryAreaOfEffectResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryAreaOfEffectResponse>> AsyncQueryAreaOfEffect(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryAreaOfEffectResponse>>(AsyncQueryAreaOfEffectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryAreaOfEffectResponse>> PrepareAsyncQueryAreaOfEffect(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryAreaOfEffectResponse>>(PrepareAsyncQueryAreaOfEffectRaw(context, request, cq));
    }
    ::grpc::Status QueryMultiRoomLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest& request, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>> AsyncQueryMultiRoomLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>>(AsyncQueryMultiRoomLineOfSightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>> PrepareAsyncQueryMultiRoomLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>>(PrepareAsyncQueryMultiRoomLineOfSightRaw(context, request, cq));
    }
    ::grpc::Status CalculateMultiRoomPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest& request, ::api::v1alpha1::CalculateMultiRoomPathResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::CalculateMultiRoomPathResponse>> AsyncCalculateMultiRoomPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::CalculateMultiRoomPathResponse>>(AsyncCalculateMultiRoomPathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::CalculateMultiRoomPathResponse>> PrepareAsyncCalculateMultiRoomPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::CalculateMultiRoomPathResponse>>(PrepareAsyncCalculateMultiRoomPathRaw(context, request, cq));
    }
    ::grpc::Status QuerySpatialIndex(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest& request, ::api::v1alpha1::QuerySpatialIndexResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QuerySpatialIndexResponse>> AsyncQuerySpatialIndex(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QuerySpatialIndexResponse>>(AsyncQuerySpatialIndexRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QuerySpatialIndexResponse>> PrepareAsyncQuerySpatialIndex(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QuerySpatialIndexResponse>>(PrepareAsyncQuerySpatialIndexRaw(context, request, cq));
    }
    ::grpc::Status GetSpatialStats(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest& request, ::api::v1alpha1::GetSpatialStatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::GetSpatialStatsResponse>> AsyncGetSpatialStats(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::GetSpatialStatsResponse>>(AsyncGetSpatialStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::GetSpatialStatsResponse>> PrepareAsyncGetSpatialStats(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::GetSpatialStatsResponse>>(PrepareAsyncGetSpatialStatsRaw(context, request, cq));
    }
    ::grpc::Status InvalidateSpatialCache(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest& request, ::api::v1alpha1::InvalidateSpatialCacheResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::InvalidateSpatialCacheResponse>> AsyncInvalidateSpatialCache(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::InvalidateSpatialCacheResponse>>(AsyncInvalidateSpatialCacheRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::InvalidateSpatialCacheResponse>> PrepareAsyncInvalidateSpatialCache(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::InvalidateSpatialCacheResponse>>(PrepareAsyncInvalidateSpatialCacheRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void QueryLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest* request, ::api::v1alpha1::QueryLineOfSightResponse* response, std::function<void(::grpc::Status)>) override;
      void QueryLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest* request, ::api::v1alpha1::QueryLineOfSightResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ValidateMovement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest* request, ::api::v1alpha1::ValidateMovementResponse* response, std::function<void(::grpc::Status)>) override;
      void ValidateMovement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest* request, ::api::v1alpha1::ValidateMovementResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ValidateEntityPlacement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest* request, ::api::v1alpha1::ValidateEntityPlacementResponse* response, std::function<void(::grpc::Status)>) override;
      void ValidateEntityPlacement(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest* request, ::api::v1alpha1::ValidateEntityPlacementResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void QueryEntitiesInRange(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest* request, ::api::v1alpha1::QueryEntitiesInRangeResponse* response, std::function<void(::grpc::Status)>) override;
      void QueryEntitiesInRange(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest* request, ::api::v1alpha1::QueryEntitiesInRangeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CalculateMovementPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest* request, ::api::v1alpha1::CalculateMovementPathResponse* response, std::function<void(::grpc::Status)>) override;
      void CalculateMovementPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest* request, ::api::v1alpha1::CalculateMovementPathResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void QueryAreaOfEffect(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest* request, ::api::v1alpha1::QueryAreaOfEffectResponse* response, std::function<void(::grpc::Status)>) override;
      void QueryAreaOfEffect(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest* request, ::api::v1alpha1::QueryAreaOfEffectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void QueryMultiRoomLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* request, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* response, std::function<void(::grpc::Status)>) override;
      void QueryMultiRoomLineOfSight(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* request, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CalculateMultiRoomPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest* request, ::api::v1alpha1::CalculateMultiRoomPathResponse* response, std::function<void(::grpc::Status)>) override;
      void CalculateMultiRoomPath(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest* request, ::api::v1alpha1::CalculateMultiRoomPathResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void QuerySpatialIndex(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest* request, ::api::v1alpha1::QuerySpatialIndexResponse* response, std::function<void(::grpc::Status)>) override;
      void QuerySpatialIndex(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest* request, ::api::v1alpha1::QuerySpatialIndexResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSpatialStats(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest* request, ::api::v1alpha1::GetSpatialStatsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSpatialStats(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest* request, ::api::v1alpha1::GetSpatialStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void InvalidateSpatialCache(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest* request, ::api::v1alpha1::InvalidateSpatialCacheResponse* response, std::function<void(::grpc::Status)>) override;
      void InvalidateSpatialCache(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest* request, ::api::v1alpha1::InvalidateSpatialCacheResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryLineOfSightResponse>* AsyncQueryLineOfSightRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryLineOfSightResponse>* PrepareAsyncQueryLineOfSightRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryLineOfSightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::ValidateMovementResponse>* AsyncValidateMovementRaw(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::ValidateMovementResponse>* PrepareAsyncValidateMovementRaw(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateMovementRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::ValidateEntityPlacementResponse>* AsyncValidateEntityPlacementRaw(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::ValidateEntityPlacementResponse>* PrepareAsyncValidateEntityPlacementRaw(::grpc::ClientContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryEntitiesInRangeResponse>* AsyncQueryEntitiesInRangeRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryEntitiesInRangeResponse>* PrepareAsyncQueryEntitiesInRangeRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::CalculateMovementPathResponse>* AsyncCalculateMovementPathRaw(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::CalculateMovementPathResponse>* PrepareAsyncCalculateMovementPathRaw(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMovementPathRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryAreaOfEffectResponse>* AsyncQueryAreaOfEffectRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryAreaOfEffectResponse>* PrepareAsyncQueryAreaOfEffectRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>* AsyncQueryMultiRoomLineOfSightRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>* PrepareAsyncQueryMultiRoomLineOfSightRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::CalculateMultiRoomPathResponse>* AsyncCalculateMultiRoomPathRaw(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::CalculateMultiRoomPathResponse>* PrepareAsyncCalculateMultiRoomPathRaw(::grpc::ClientContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QuerySpatialIndexResponse>* AsyncQuerySpatialIndexRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::QuerySpatialIndexResponse>* PrepareAsyncQuerySpatialIndexRaw(::grpc::ClientContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::GetSpatialStatsResponse>* AsyncGetSpatialStatsRaw(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::GetSpatialStatsResponse>* PrepareAsyncGetSpatialStatsRaw(::grpc::ClientContext* context, const ::api::v1alpha1::GetSpatialStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::InvalidateSpatialCacheResponse>* AsyncInvalidateSpatialCacheRaw(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1alpha1::InvalidateSpatialCacheResponse>* PrepareAsyncInvalidateSpatialCacheRaw(::grpc::ClientContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_QueryLineOfSight_;
    const ::grpc::internal::RpcMethod rpcmethod_ValidateMovement_;
    const ::grpc::internal::RpcMethod rpcmethod_ValidateEntityPlacement_;
    const ::grpc::internal::RpcMethod rpcmethod_QueryEntitiesInRange_;
    const ::grpc::internal::RpcMethod rpcmethod_CalculateMovementPath_;
    const ::grpc::internal::RpcMethod rpcmethod_QueryAreaOfEffect_;
    const ::grpc::internal::RpcMethod rpcmethod_QueryMultiRoomLineOfSight_;
    const ::grpc::internal::RpcMethod rpcmethod_CalculateMultiRoomPath_;
    const ::grpc::internal::RpcMethod rpcmethod_QuerySpatialIndex_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSpatialStats_;
    const ::grpc::internal::RpcMethod rpcmethod_InvalidateSpatialCache_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Basic spatial queries (Phase 2)
    virtual ::grpc::Status QueryLineOfSight(::grpc::ServerContext* context, const ::api::v1alpha1::QueryLineOfSightRequest* request, ::api::v1alpha1::QueryLineOfSightResponse* response);
    virtual ::grpc::Status ValidateMovement(::grpc::ServerContext* context, const ::api::v1alpha1::ValidateMovementRequest* request, ::api::v1alpha1::ValidateMovementResponse* response);
    virtual ::grpc::Status ValidateEntityPlacement(::grpc::ServerContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest* request, ::api::v1alpha1::ValidateEntityPlacementResponse* response);
    virtual ::grpc::Status QueryEntitiesInRange(::grpc::ServerContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest* request, ::api::v1alpha1::QueryEntitiesInRangeResponse* response);
    // Advanced spatial queries (Phase 4)
    virtual ::grpc::Status CalculateMovementPath(::grpc::ServerContext* context, const ::api::v1alpha1::CalculateMovementPathRequest* request, ::api::v1alpha1::CalculateMovementPathResponse* response);
    virtual ::grpc::Status QueryAreaOfEffect(::grpc::ServerContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest* request, ::api::v1alpha1::QueryAreaOfEffectResponse* response);
    virtual ::grpc::Status QueryMultiRoomLineOfSight(::grpc::ServerContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* request, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* response);
    virtual ::grpc::Status CalculateMultiRoomPath(::grpc::ServerContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest* request, ::api::v1alpha1::CalculateMultiRoomPathResponse* response);
    virtual ::grpc::Status QuerySpatialIndex(::grpc::ServerContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest* request, ::api::v1alpha1::QuerySpatialIndexResponse* response);
    // Spatial optimization and analytics
    virtual ::grpc::Status GetSpatialStats(::grpc::ServerContext* context, const ::api::v1alpha1::GetSpatialStatsRequest* request, ::api::v1alpha1::GetSpatialStatsResponse* response);
    virtual ::grpc::Status InvalidateSpatialCache(::grpc::ServerContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest* request, ::api::v1alpha1::InvalidateSpatialCacheResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_QueryLineOfSight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_QueryLineOfSight() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_QueryLineOfSight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryLineOfSight(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryLineOfSightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryLineOfSight(::grpc::ServerContext* context, ::api::v1alpha1::QueryLineOfSightRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1alpha1::QueryLineOfSightResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ValidateMovement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ValidateMovement() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ValidateMovement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateMovement(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::ValidateMovementRequest* /*request*/, ::api::v1alpha1::ValidateMovementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidateMovement(::grpc::ServerContext* context, ::api::v1alpha1::ValidateMovementRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1alpha1::ValidateMovementResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ValidateEntityPlacement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ValidateEntityPlacement() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ValidateEntityPlacement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateEntityPlacement(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::ValidateEntityPlacementRequest* /*request*/, ::api::v1alpha1::ValidateEntityPlacementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidateEntityPlacement(::grpc::ServerContext* context, ::api::v1alpha1::ValidateEntityPlacementRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1alpha1::ValidateEntityPlacementResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_QueryEntitiesInRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_QueryEntitiesInRange() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_QueryEntitiesInRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryEntitiesInRange(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryEntitiesInRangeRequest* /*request*/, ::api::v1alpha1::QueryEntitiesInRangeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryEntitiesInRange(::grpc::ServerContext* context, ::api::v1alpha1::QueryEntitiesInRangeRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1alpha1::QueryEntitiesInRangeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CalculateMovementPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CalculateMovementPath() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_CalculateMovementPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateMovementPath(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::CalculateMovementPathRequest* /*request*/, ::api::v1alpha1::CalculateMovementPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateMovementPath(::grpc::ServerContext* context, ::api::v1alpha1::CalculateMovementPathRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1alpha1::CalculateMovementPathResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_QueryAreaOfEffect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_QueryAreaOfEffect() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_QueryAreaOfEffect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryAreaOfEffect(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryAreaOfEffectRequest* /*request*/, ::api::v1alpha1::QueryAreaOfEffectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryAreaOfEffect(::grpc::ServerContext* context, ::api::v1alpha1::QueryAreaOfEffectRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1alpha1::QueryAreaOfEffectResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_QueryMultiRoomLineOfSight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_QueryMultiRoomLineOfSight() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_QueryMultiRoomLineOfSight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryMultiRoomLineOfSight(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryMultiRoomLineOfSight(::grpc::ServerContext* context, ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CalculateMultiRoomPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CalculateMultiRoomPath() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_CalculateMultiRoomPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateMultiRoomPath(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::CalculateMultiRoomPathRequest* /*request*/, ::api::v1alpha1::CalculateMultiRoomPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateMultiRoomPath(::grpc::ServerContext* context, ::api::v1alpha1::CalculateMultiRoomPathRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1alpha1::CalculateMultiRoomPathResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_QuerySpatialIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_QuerySpatialIndex() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_QuerySpatialIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QuerySpatialIndex(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QuerySpatialIndexRequest* /*request*/, ::api::v1alpha1::QuerySpatialIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQuerySpatialIndex(::grpc::ServerContext* context, ::api::v1alpha1::QuerySpatialIndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1alpha1::QuerySpatialIndexResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSpatialStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSpatialStats() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetSpatialStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpatialStats(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::GetSpatialStatsRequest* /*request*/, ::api::v1alpha1::GetSpatialStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpatialStats(::grpc::ServerContext* context, ::api::v1alpha1::GetSpatialStatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1alpha1::GetSpatialStatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InvalidateSpatialCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_InvalidateSpatialCache() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_InvalidateSpatialCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvalidateSpatialCache(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::InvalidateSpatialCacheRequest* /*request*/, ::api::v1alpha1::InvalidateSpatialCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInvalidateSpatialCache(::grpc::ServerContext* context, ::api::v1alpha1::InvalidateSpatialCacheRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1alpha1::InvalidateSpatialCacheResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_QueryLineOfSight<WithAsyncMethod_ValidateMovement<WithAsyncMethod_ValidateEntityPlacement<WithAsyncMethod_QueryEntitiesInRange<WithAsyncMethod_CalculateMovementPath<WithAsyncMethod_QueryAreaOfEffect<WithAsyncMethod_QueryMultiRoomLineOfSight<WithAsyncMethod_CalculateMultiRoomPath<WithAsyncMethod_QuerySpatialIndex<WithAsyncMethod_GetSpatialStats<WithAsyncMethod_InvalidateSpatialCache<Service > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_QueryLineOfSight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_QueryLineOfSight() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::QueryLineOfSightRequest, ::api::v1alpha1::QueryLineOfSightResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::api::v1alpha1::QueryLineOfSightRequest* request, ::api::v1alpha1::QueryLineOfSightResponse* response) { return this->QueryLineOfSight(context, request, response); }));}
    void SetMessageAllocatorFor_QueryLineOfSight(
        ::grpc::MessageAllocator< ::api::v1alpha1::QueryLineOfSightRequest, ::api::v1alpha1::QueryLineOfSightResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::QueryLineOfSightRequest, ::api::v1alpha1::QueryLineOfSightResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_QueryLineOfSight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryLineOfSight(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryLineOfSightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryLineOfSight(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1alpha1::QueryLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryLineOfSightResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ValidateMovement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ValidateMovement() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::ValidateMovementRequest, ::api::v1alpha1::ValidateMovementResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::api::v1alpha1::ValidateMovementRequest* request, ::api::v1alpha1::ValidateMovementResponse* response) { return this->ValidateMovement(context, request, response); }));}
    void SetMessageAllocatorFor_ValidateMovement(
        ::grpc::MessageAllocator< ::api::v1alpha1::ValidateMovementRequest, ::api::v1alpha1::ValidateMovementResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::ValidateMovementRequest, ::api::v1alpha1::ValidateMovementResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ValidateMovement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateMovement(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::ValidateMovementRequest* /*request*/, ::api::v1alpha1::ValidateMovementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ValidateMovement(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1alpha1::ValidateMovementRequest* /*request*/, ::api::v1alpha1::ValidateMovementResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ValidateEntityPlacement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ValidateEntityPlacement() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::ValidateEntityPlacementRequest, ::api::v1alpha1::ValidateEntityPlacementResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::api::v1alpha1::ValidateEntityPlacementRequest* request, ::api::v1alpha1::ValidateEntityPlacementResponse* response) { return this->ValidateEntityPlacement(context, request, response); }));}
    void SetMessageAllocatorFor_ValidateEntityPlacement(
        ::grpc::MessageAllocator< ::api::v1alpha1::ValidateEntityPlacementRequest, ::api::v1alpha1::ValidateEntityPlacementResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::ValidateEntityPlacementRequest, ::api::v1alpha1::ValidateEntityPlacementResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ValidateEntityPlacement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateEntityPlacement(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::ValidateEntityPlacementRequest* /*request*/, ::api::v1alpha1::ValidateEntityPlacementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ValidateEntityPlacement(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1alpha1::ValidateEntityPlacementRequest* /*request*/, ::api::v1alpha1::ValidateEntityPlacementResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_QueryEntitiesInRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_QueryEntitiesInRange() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::QueryEntitiesInRangeRequest, ::api::v1alpha1::QueryEntitiesInRangeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::api::v1alpha1::QueryEntitiesInRangeRequest* request, ::api::v1alpha1::QueryEntitiesInRangeResponse* response) { return this->QueryEntitiesInRange(context, request, response); }));}
    void SetMessageAllocatorFor_QueryEntitiesInRange(
        ::grpc::MessageAllocator< ::api::v1alpha1::QueryEntitiesInRangeRequest, ::api::v1alpha1::QueryEntitiesInRangeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::QueryEntitiesInRangeRequest, ::api::v1alpha1::QueryEntitiesInRangeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_QueryEntitiesInRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryEntitiesInRange(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryEntitiesInRangeRequest* /*request*/, ::api::v1alpha1::QueryEntitiesInRangeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryEntitiesInRange(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1alpha1::QueryEntitiesInRangeRequest* /*request*/, ::api::v1alpha1::QueryEntitiesInRangeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CalculateMovementPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CalculateMovementPath() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::CalculateMovementPathRequest, ::api::v1alpha1::CalculateMovementPathResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::api::v1alpha1::CalculateMovementPathRequest* request, ::api::v1alpha1::CalculateMovementPathResponse* response) { return this->CalculateMovementPath(context, request, response); }));}
    void SetMessageAllocatorFor_CalculateMovementPath(
        ::grpc::MessageAllocator< ::api::v1alpha1::CalculateMovementPathRequest, ::api::v1alpha1::CalculateMovementPathResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::CalculateMovementPathRequest, ::api::v1alpha1::CalculateMovementPathResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CalculateMovementPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateMovementPath(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::CalculateMovementPathRequest* /*request*/, ::api::v1alpha1::CalculateMovementPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalculateMovementPath(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1alpha1::CalculateMovementPathRequest* /*request*/, ::api::v1alpha1::CalculateMovementPathResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_QueryAreaOfEffect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_QueryAreaOfEffect() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::QueryAreaOfEffectRequest, ::api::v1alpha1::QueryAreaOfEffectResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::api::v1alpha1::QueryAreaOfEffectRequest* request, ::api::v1alpha1::QueryAreaOfEffectResponse* response) { return this->QueryAreaOfEffect(context, request, response); }));}
    void SetMessageAllocatorFor_QueryAreaOfEffect(
        ::grpc::MessageAllocator< ::api::v1alpha1::QueryAreaOfEffectRequest, ::api::v1alpha1::QueryAreaOfEffectResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::QueryAreaOfEffectRequest, ::api::v1alpha1::QueryAreaOfEffectResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_QueryAreaOfEffect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryAreaOfEffect(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryAreaOfEffectRequest* /*request*/, ::api::v1alpha1::QueryAreaOfEffectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryAreaOfEffect(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1alpha1::QueryAreaOfEffectRequest* /*request*/, ::api::v1alpha1::QueryAreaOfEffectResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_QueryMultiRoomLineOfSight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_QueryMultiRoomLineOfSight() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::QueryMultiRoomLineOfSightRequest, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* request, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* response) { return this->QueryMultiRoomLineOfSight(context, request, response); }));}
    void SetMessageAllocatorFor_QueryMultiRoomLineOfSight(
        ::grpc::MessageAllocator< ::api::v1alpha1::QueryMultiRoomLineOfSightRequest, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::QueryMultiRoomLineOfSightRequest, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_QueryMultiRoomLineOfSight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryMultiRoomLineOfSight(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryMultiRoomLineOfSight(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CalculateMultiRoomPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CalculateMultiRoomPath() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::CalculateMultiRoomPathRequest, ::api::v1alpha1::CalculateMultiRoomPathResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::api::v1alpha1::CalculateMultiRoomPathRequest* request, ::api::v1alpha1::CalculateMultiRoomPathResponse* response) { return this->CalculateMultiRoomPath(context, request, response); }));}
    void SetMessageAllocatorFor_CalculateMultiRoomPath(
        ::grpc::MessageAllocator< ::api::v1alpha1::CalculateMultiRoomPathRequest, ::api::v1alpha1::CalculateMultiRoomPathResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::CalculateMultiRoomPathRequest, ::api::v1alpha1::CalculateMultiRoomPathResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CalculateMultiRoomPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateMultiRoomPath(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::CalculateMultiRoomPathRequest* /*request*/, ::api::v1alpha1::CalculateMultiRoomPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalculateMultiRoomPath(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1alpha1::CalculateMultiRoomPathRequest* /*request*/, ::api::v1alpha1::CalculateMultiRoomPathResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_QuerySpatialIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_QuerySpatialIndex() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::QuerySpatialIndexRequest, ::api::v1alpha1::QuerySpatialIndexResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::api::v1alpha1::QuerySpatialIndexRequest* request, ::api::v1alpha1::QuerySpatialIndexResponse* response) { return this->QuerySpatialIndex(context, request, response); }));}
    void SetMessageAllocatorFor_QuerySpatialIndex(
        ::grpc::MessageAllocator< ::api::v1alpha1::QuerySpatialIndexRequest, ::api::v1alpha1::QuerySpatialIndexResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::QuerySpatialIndexRequest, ::api::v1alpha1::QuerySpatialIndexResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_QuerySpatialIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QuerySpatialIndex(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QuerySpatialIndexRequest* /*request*/, ::api::v1alpha1::QuerySpatialIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QuerySpatialIndex(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1alpha1::QuerySpatialIndexRequest* /*request*/, ::api::v1alpha1::QuerySpatialIndexResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSpatialStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSpatialStats() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::GetSpatialStatsRequest, ::api::v1alpha1::GetSpatialStatsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::api::v1alpha1::GetSpatialStatsRequest* request, ::api::v1alpha1::GetSpatialStatsResponse* response) { return this->GetSpatialStats(context, request, response); }));}
    void SetMessageAllocatorFor_GetSpatialStats(
        ::grpc::MessageAllocator< ::api::v1alpha1::GetSpatialStatsRequest, ::api::v1alpha1::GetSpatialStatsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::GetSpatialStatsRequest, ::api::v1alpha1::GetSpatialStatsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSpatialStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpatialStats(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::GetSpatialStatsRequest* /*request*/, ::api::v1alpha1::GetSpatialStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSpatialStats(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1alpha1::GetSpatialStatsRequest* /*request*/, ::api::v1alpha1::GetSpatialStatsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_InvalidateSpatialCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_InvalidateSpatialCache() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::InvalidateSpatialCacheRequest, ::api::v1alpha1::InvalidateSpatialCacheResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::api::v1alpha1::InvalidateSpatialCacheRequest* request, ::api::v1alpha1::InvalidateSpatialCacheResponse* response) { return this->InvalidateSpatialCache(context, request, response); }));}
    void SetMessageAllocatorFor_InvalidateSpatialCache(
        ::grpc::MessageAllocator< ::api::v1alpha1::InvalidateSpatialCacheRequest, ::api::v1alpha1::InvalidateSpatialCacheResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1alpha1::InvalidateSpatialCacheRequest, ::api::v1alpha1::InvalidateSpatialCacheResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_InvalidateSpatialCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvalidateSpatialCache(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::InvalidateSpatialCacheRequest* /*request*/, ::api::v1alpha1::InvalidateSpatialCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InvalidateSpatialCache(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1alpha1::InvalidateSpatialCacheRequest* /*request*/, ::api::v1alpha1::InvalidateSpatialCacheResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_QueryLineOfSight<WithCallbackMethod_ValidateMovement<WithCallbackMethod_ValidateEntityPlacement<WithCallbackMethod_QueryEntitiesInRange<WithCallbackMethod_CalculateMovementPath<WithCallbackMethod_QueryAreaOfEffect<WithCallbackMethod_QueryMultiRoomLineOfSight<WithCallbackMethod_CalculateMultiRoomPath<WithCallbackMethod_QuerySpatialIndex<WithCallbackMethod_GetSpatialStats<WithCallbackMethod_InvalidateSpatialCache<Service > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_QueryLineOfSight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_QueryLineOfSight() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_QueryLineOfSight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryLineOfSight(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryLineOfSightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ValidateMovement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ValidateMovement() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ValidateMovement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateMovement(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::ValidateMovementRequest* /*request*/, ::api::v1alpha1::ValidateMovementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ValidateEntityPlacement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ValidateEntityPlacement() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ValidateEntityPlacement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateEntityPlacement(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::ValidateEntityPlacementRequest* /*request*/, ::api::v1alpha1::ValidateEntityPlacementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_QueryEntitiesInRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_QueryEntitiesInRange() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_QueryEntitiesInRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryEntitiesInRange(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryEntitiesInRangeRequest* /*request*/, ::api::v1alpha1::QueryEntitiesInRangeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CalculateMovementPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CalculateMovementPath() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_CalculateMovementPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateMovementPath(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::CalculateMovementPathRequest* /*request*/, ::api::v1alpha1::CalculateMovementPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_QueryAreaOfEffect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_QueryAreaOfEffect() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_QueryAreaOfEffect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryAreaOfEffect(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryAreaOfEffectRequest* /*request*/, ::api::v1alpha1::QueryAreaOfEffectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_QueryMultiRoomLineOfSight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_QueryMultiRoomLineOfSight() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_QueryMultiRoomLineOfSight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryMultiRoomLineOfSight(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CalculateMultiRoomPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CalculateMultiRoomPath() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_CalculateMultiRoomPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateMultiRoomPath(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::CalculateMultiRoomPathRequest* /*request*/, ::api::v1alpha1::CalculateMultiRoomPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_QuerySpatialIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_QuerySpatialIndex() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_QuerySpatialIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QuerySpatialIndex(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QuerySpatialIndexRequest* /*request*/, ::api::v1alpha1::QuerySpatialIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSpatialStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSpatialStats() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetSpatialStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpatialStats(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::GetSpatialStatsRequest* /*request*/, ::api::v1alpha1::GetSpatialStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InvalidateSpatialCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_InvalidateSpatialCache() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_InvalidateSpatialCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvalidateSpatialCache(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::InvalidateSpatialCacheRequest* /*request*/, ::api::v1alpha1::InvalidateSpatialCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_QueryLineOfSight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_QueryLineOfSight() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_QueryLineOfSight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryLineOfSight(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryLineOfSightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryLineOfSight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ValidateMovement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ValidateMovement() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ValidateMovement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateMovement(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::ValidateMovementRequest* /*request*/, ::api::v1alpha1::ValidateMovementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidateMovement(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ValidateEntityPlacement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ValidateEntityPlacement() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ValidateEntityPlacement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateEntityPlacement(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::ValidateEntityPlacementRequest* /*request*/, ::api::v1alpha1::ValidateEntityPlacementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidateEntityPlacement(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_QueryEntitiesInRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_QueryEntitiesInRange() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_QueryEntitiesInRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryEntitiesInRange(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryEntitiesInRangeRequest* /*request*/, ::api::v1alpha1::QueryEntitiesInRangeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryEntitiesInRange(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CalculateMovementPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CalculateMovementPath() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_CalculateMovementPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateMovementPath(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::CalculateMovementPathRequest* /*request*/, ::api::v1alpha1::CalculateMovementPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateMovementPath(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_QueryAreaOfEffect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_QueryAreaOfEffect() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_QueryAreaOfEffect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryAreaOfEffect(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryAreaOfEffectRequest* /*request*/, ::api::v1alpha1::QueryAreaOfEffectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryAreaOfEffect(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_QueryMultiRoomLineOfSight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_QueryMultiRoomLineOfSight() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_QueryMultiRoomLineOfSight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryMultiRoomLineOfSight(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryMultiRoomLineOfSight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CalculateMultiRoomPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CalculateMultiRoomPath() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_CalculateMultiRoomPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateMultiRoomPath(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::CalculateMultiRoomPathRequest* /*request*/, ::api::v1alpha1::CalculateMultiRoomPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalculateMultiRoomPath(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_QuerySpatialIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_QuerySpatialIndex() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_QuerySpatialIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QuerySpatialIndex(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QuerySpatialIndexRequest* /*request*/, ::api::v1alpha1::QuerySpatialIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQuerySpatialIndex(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSpatialStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSpatialStats() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetSpatialStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpatialStats(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::GetSpatialStatsRequest* /*request*/, ::api::v1alpha1::GetSpatialStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpatialStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InvalidateSpatialCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InvalidateSpatialCache() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_InvalidateSpatialCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvalidateSpatialCache(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::InvalidateSpatialCacheRequest* /*request*/, ::api::v1alpha1::InvalidateSpatialCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInvalidateSpatialCache(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_QueryLineOfSight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_QueryLineOfSight() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->QueryLineOfSight(context, request, response); }));
    }
    ~WithRawCallbackMethod_QueryLineOfSight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryLineOfSight(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryLineOfSightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryLineOfSight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ValidateMovement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ValidateMovement() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ValidateMovement(context, request, response); }));
    }
    ~WithRawCallbackMethod_ValidateMovement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateMovement(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::ValidateMovementRequest* /*request*/, ::api::v1alpha1::ValidateMovementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ValidateMovement(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ValidateEntityPlacement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ValidateEntityPlacement() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ValidateEntityPlacement(context, request, response); }));
    }
    ~WithRawCallbackMethod_ValidateEntityPlacement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateEntityPlacement(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::ValidateEntityPlacementRequest* /*request*/, ::api::v1alpha1::ValidateEntityPlacementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ValidateEntityPlacement(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_QueryEntitiesInRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_QueryEntitiesInRange() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->QueryEntitiesInRange(context, request, response); }));
    }
    ~WithRawCallbackMethod_QueryEntitiesInRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryEntitiesInRange(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryEntitiesInRangeRequest* /*request*/, ::api::v1alpha1::QueryEntitiesInRangeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryEntitiesInRange(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CalculateMovementPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CalculateMovementPath() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CalculateMovementPath(context, request, response); }));
    }
    ~WithRawCallbackMethod_CalculateMovementPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateMovementPath(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::CalculateMovementPathRequest* /*request*/, ::api::v1alpha1::CalculateMovementPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalculateMovementPath(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_QueryAreaOfEffect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_QueryAreaOfEffect() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->QueryAreaOfEffect(context, request, response); }));
    }
    ~WithRawCallbackMethod_QueryAreaOfEffect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryAreaOfEffect(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryAreaOfEffectRequest* /*request*/, ::api::v1alpha1::QueryAreaOfEffectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryAreaOfEffect(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_QueryMultiRoomLineOfSight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_QueryMultiRoomLineOfSight() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->QueryMultiRoomLineOfSight(context, request, response); }));
    }
    ~WithRawCallbackMethod_QueryMultiRoomLineOfSight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryMultiRoomLineOfSight(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryMultiRoomLineOfSight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CalculateMultiRoomPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CalculateMultiRoomPath() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CalculateMultiRoomPath(context, request, response); }));
    }
    ~WithRawCallbackMethod_CalculateMultiRoomPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalculateMultiRoomPath(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::CalculateMultiRoomPathRequest* /*request*/, ::api::v1alpha1::CalculateMultiRoomPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalculateMultiRoomPath(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_QuerySpatialIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_QuerySpatialIndex() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->QuerySpatialIndex(context, request, response); }));
    }
    ~WithRawCallbackMethod_QuerySpatialIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QuerySpatialIndex(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QuerySpatialIndexRequest* /*request*/, ::api::v1alpha1::QuerySpatialIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QuerySpatialIndex(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSpatialStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSpatialStats() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSpatialStats(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSpatialStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpatialStats(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::GetSpatialStatsRequest* /*request*/, ::api::v1alpha1::GetSpatialStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSpatialStats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_InvalidateSpatialCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_InvalidateSpatialCache() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InvalidateSpatialCache(context, request, response); }));
    }
    ~WithRawCallbackMethod_InvalidateSpatialCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InvalidateSpatialCache(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::InvalidateSpatialCacheRequest* /*request*/, ::api::v1alpha1::InvalidateSpatialCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InvalidateSpatialCache(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_QueryLineOfSight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_QueryLineOfSight() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1alpha1::QueryLineOfSightRequest, ::api::v1alpha1::QueryLineOfSightResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1alpha1::QueryLineOfSightRequest, ::api::v1alpha1::QueryLineOfSightResponse>* streamer) {
                       return this->StreamedQueryLineOfSight(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_QueryLineOfSight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status QueryLineOfSight(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryLineOfSightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQueryLineOfSight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1alpha1::QueryLineOfSightRequest,::api::v1alpha1::QueryLineOfSightResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ValidateMovement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ValidateMovement() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1alpha1::ValidateMovementRequest, ::api::v1alpha1::ValidateMovementResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1alpha1::ValidateMovementRequest, ::api::v1alpha1::ValidateMovementResponse>* streamer) {
                       return this->StreamedValidateMovement(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ValidateMovement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ValidateMovement(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::ValidateMovementRequest* /*request*/, ::api::v1alpha1::ValidateMovementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedValidateMovement(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1alpha1::ValidateMovementRequest,::api::v1alpha1::ValidateMovementResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ValidateEntityPlacement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ValidateEntityPlacement() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1alpha1::ValidateEntityPlacementRequest, ::api::v1alpha1::ValidateEntityPlacementResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1alpha1::ValidateEntityPlacementRequest, ::api::v1alpha1::ValidateEntityPlacementResponse>* streamer) {
                       return this->StreamedValidateEntityPlacement(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ValidateEntityPlacement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ValidateEntityPlacement(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::ValidateEntityPlacementRequest* /*request*/, ::api::v1alpha1::ValidateEntityPlacementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedValidateEntityPlacement(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1alpha1::ValidateEntityPlacementRequest,::api::v1alpha1::ValidateEntityPlacementResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_QueryEntitiesInRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_QueryEntitiesInRange() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1alpha1::QueryEntitiesInRangeRequest, ::api::v1alpha1::QueryEntitiesInRangeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1alpha1::QueryEntitiesInRangeRequest, ::api::v1alpha1::QueryEntitiesInRangeResponse>* streamer) {
                       return this->StreamedQueryEntitiesInRange(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_QueryEntitiesInRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status QueryEntitiesInRange(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryEntitiesInRangeRequest* /*request*/, ::api::v1alpha1::QueryEntitiesInRangeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQueryEntitiesInRange(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1alpha1::QueryEntitiesInRangeRequest,::api::v1alpha1::QueryEntitiesInRangeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CalculateMovementPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CalculateMovementPath() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1alpha1::CalculateMovementPathRequest, ::api::v1alpha1::CalculateMovementPathResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1alpha1::CalculateMovementPathRequest, ::api::v1alpha1::CalculateMovementPathResponse>* streamer) {
                       return this->StreamedCalculateMovementPath(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CalculateMovementPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CalculateMovementPath(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::CalculateMovementPathRequest* /*request*/, ::api::v1alpha1::CalculateMovementPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCalculateMovementPath(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1alpha1::CalculateMovementPathRequest,::api::v1alpha1::CalculateMovementPathResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_QueryAreaOfEffect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_QueryAreaOfEffect() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1alpha1::QueryAreaOfEffectRequest, ::api::v1alpha1::QueryAreaOfEffectResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1alpha1::QueryAreaOfEffectRequest, ::api::v1alpha1::QueryAreaOfEffectResponse>* streamer) {
                       return this->StreamedQueryAreaOfEffect(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_QueryAreaOfEffect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status QueryAreaOfEffect(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryAreaOfEffectRequest* /*request*/, ::api::v1alpha1::QueryAreaOfEffectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQueryAreaOfEffect(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1alpha1::QueryAreaOfEffectRequest,::api::v1alpha1::QueryAreaOfEffectResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_QueryMultiRoomLineOfSight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_QueryMultiRoomLineOfSight() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1alpha1::QueryMultiRoomLineOfSightRequest, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1alpha1::QueryMultiRoomLineOfSightRequest, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse>* streamer) {
                       return this->StreamedQueryMultiRoomLineOfSight(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_QueryMultiRoomLineOfSight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status QueryMultiRoomLineOfSight(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QueryMultiRoomLineOfSightRequest* /*request*/, ::api::v1alpha1::QueryMultiRoomLineOfSightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQueryMultiRoomLineOfSight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1alpha1::QueryMultiRoomLineOfSightRequest,::api::v1alpha1::QueryMultiRoomLineOfSightResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CalculateMultiRoomPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CalculateMultiRoomPath() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1alpha1::CalculateMultiRoomPathRequest, ::api::v1alpha1::CalculateMultiRoomPathResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1alpha1::CalculateMultiRoomPathRequest, ::api::v1alpha1::CalculateMultiRoomPathResponse>* streamer) {
                       return this->StreamedCalculateMultiRoomPath(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CalculateMultiRoomPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CalculateMultiRoomPath(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::CalculateMultiRoomPathRequest* /*request*/, ::api::v1alpha1::CalculateMultiRoomPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCalculateMultiRoomPath(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1alpha1::CalculateMultiRoomPathRequest,::api::v1alpha1::CalculateMultiRoomPathResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_QuerySpatialIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_QuerySpatialIndex() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1alpha1::QuerySpatialIndexRequest, ::api::v1alpha1::QuerySpatialIndexResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1alpha1::QuerySpatialIndexRequest, ::api::v1alpha1::QuerySpatialIndexResponse>* streamer) {
                       return this->StreamedQuerySpatialIndex(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_QuerySpatialIndex() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status QuerySpatialIndex(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::QuerySpatialIndexRequest* /*request*/, ::api::v1alpha1::QuerySpatialIndexResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQuerySpatialIndex(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1alpha1::QuerySpatialIndexRequest,::api::v1alpha1::QuerySpatialIndexResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSpatialStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSpatialStats() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1alpha1::GetSpatialStatsRequest, ::api::v1alpha1::GetSpatialStatsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1alpha1::GetSpatialStatsRequest, ::api::v1alpha1::GetSpatialStatsResponse>* streamer) {
                       return this->StreamedGetSpatialStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSpatialStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSpatialStats(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::GetSpatialStatsRequest* /*request*/, ::api::v1alpha1::GetSpatialStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSpatialStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1alpha1::GetSpatialStatsRequest,::api::v1alpha1::GetSpatialStatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InvalidateSpatialCache : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_InvalidateSpatialCache() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1alpha1::InvalidateSpatialCacheRequest, ::api::v1alpha1::InvalidateSpatialCacheResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1alpha1::InvalidateSpatialCacheRequest, ::api::v1alpha1::InvalidateSpatialCacheResponse>* streamer) {
                       return this->StreamedInvalidateSpatialCache(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_InvalidateSpatialCache() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InvalidateSpatialCache(::grpc::ServerContext* /*context*/, const ::api::v1alpha1::InvalidateSpatialCacheRequest* /*request*/, ::api::v1alpha1::InvalidateSpatialCacheResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInvalidateSpatialCache(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1alpha1::InvalidateSpatialCacheRequest,::api::v1alpha1::InvalidateSpatialCacheResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_QueryLineOfSight<WithStreamedUnaryMethod_ValidateMovement<WithStreamedUnaryMethod_ValidateEntityPlacement<WithStreamedUnaryMethod_QueryEntitiesInRange<WithStreamedUnaryMethod_CalculateMovementPath<WithStreamedUnaryMethod_QueryAreaOfEffect<WithStreamedUnaryMethod_QueryMultiRoomLineOfSight<WithStreamedUnaryMethod_CalculateMultiRoomPath<WithStreamedUnaryMethod_QuerySpatialIndex<WithStreamedUnaryMethod_GetSpatialStats<WithStreamedUnaryMethod_InvalidateSpatialCache<Service > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_QueryLineOfSight<WithStreamedUnaryMethod_ValidateMovement<WithStreamedUnaryMethod_ValidateEntityPlacement<WithStreamedUnaryMethod_QueryEntitiesInRange<WithStreamedUnaryMethod_CalculateMovementPath<WithStreamedUnaryMethod_QueryAreaOfEffect<WithStreamedUnaryMethod_QueryMultiRoomLineOfSight<WithStreamedUnaryMethod_CalculateMultiRoomPath<WithStreamedUnaryMethod_QuerySpatialIndex<WithStreamedUnaryMethod_GetSpatialStats<WithStreamedUnaryMethod_InvalidateSpatialCache<Service > > > > > > > > > > > StreamedService;
};

}  // namespace v1alpha1
}  // namespace api


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_api_2fv1alpha1_2froom_5fspatial_2eproto__INCLUDED
