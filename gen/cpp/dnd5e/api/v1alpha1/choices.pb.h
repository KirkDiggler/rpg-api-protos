// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: dnd5e/api/v1alpha1/choices.proto
// Protobuf C++ Version: 6.33.2

#ifndef dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto_2epb_2eh
#define dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "dnd5e/api/v1alpha1/common.pb.h"
#include "dnd5e/api/v1alpha1/enums.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
}  // extern "C"
namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum ChoiceCategory : int;
extern const uint32_t ChoiceCategory_internal_data_[];
enum ChoiceSource : int;
extern const uint32_t ChoiceSource_internal_data_[];
enum SpellSelectionType : int;
extern const uint32_t SpellSelectionType_internal_data_[];
class Choice;
struct ChoiceDefaultTypeInternal;
extern ChoiceDefaultTypeInternal _Choice_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Choice_class_data_;
class ChoiceData;
struct ChoiceDataDefaultTypeInternal;
extern ChoiceDataDefaultTypeInternal _ChoiceData_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ChoiceData_class_data_;
class ChoiceSubmission;
struct ChoiceSubmissionDefaultTypeInternal;
extern ChoiceSubmissionDefaultTypeInternal _ChoiceSubmission_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ChoiceSubmission_class_data_;
class EquipmentBundle;
struct EquipmentBundleDefaultTypeInternal;
extern EquipmentBundleDefaultTypeInternal _EquipmentBundle_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EquipmentBundle_class_data_;
class EquipmentCategoryChoice;
struct EquipmentCategoryChoiceDefaultTypeInternal;
extern EquipmentCategoryChoiceDefaultTypeInternal _EquipmentCategoryChoice_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EquipmentCategoryChoice_class_data_;
class EquipmentItem;
struct EquipmentItemDefaultTypeInternal;
extern EquipmentItemDefaultTypeInternal _EquipmentItem_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EquipmentItem_class_data_;
class EquipmentOptions;
struct EquipmentOptionsDefaultTypeInternal;
extern EquipmentOptionsDefaultTypeInternal _EquipmentOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EquipmentOptions_class_data_;
class EquipmentSelection;
struct EquipmentSelectionDefaultTypeInternal;
extern EquipmentSelectionDefaultTypeInternal _EquipmentSelection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EquipmentSelection_class_data_;
class EquipmentSelectionItem;
struct EquipmentSelectionItemDefaultTypeInternal;
extern EquipmentSelectionItemDefaultTypeInternal _EquipmentSelectionItem_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EquipmentSelectionItem_class_data_;
class ExpertiseOptions;
struct ExpertiseOptionsDefaultTypeInternal;
extern ExpertiseOptionsDefaultTypeInternal _ExpertiseOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExpertiseOptions_class_data_;
class ExpertiseSelection;
struct ExpertiseSelectionDefaultTypeInternal;
extern ExpertiseSelectionDefaultTypeInternal _ExpertiseSelection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExpertiseSelection_class_data_;
class FightingStyleOptions;
struct FightingStyleOptionsDefaultTypeInternal;
extern FightingStyleOptionsDefaultTypeInternal _FightingStyleOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FightingStyleOptions_class_data_;
class FightingStyleSelection;
struct FightingStyleSelectionDefaultTypeInternal;
extern FightingStyleSelectionDefaultTypeInternal _FightingStyleSelection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FightingStyleSelection_class_data_;
class LanguageOptions;
struct LanguageOptionsDefaultTypeInternal;
extern LanguageOptionsDefaultTypeInternal _LanguageOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LanguageOptions_class_data_;
class LanguageSelection;
struct LanguageSelectionDefaultTypeInternal;
extern LanguageSelectionDefaultTypeInternal _LanguageSelection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LanguageSelection_class_data_;
class SkillOptions;
struct SkillOptionsDefaultTypeInternal;
extern SkillOptionsDefaultTypeInternal _SkillOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SkillOptions_class_data_;
class SkillSelection;
struct SkillSelectionDefaultTypeInternal;
extern SkillSelectionDefaultTypeInternal _SkillSelection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SkillSelection_class_data_;
class SpellOptions;
struct SpellOptionsDefaultTypeInternal;
extern SpellOptionsDefaultTypeInternal _SpellOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SpellOptions_class_data_;
class SpellSelection;
struct SpellSelectionDefaultTypeInternal;
extern SpellSelectionDefaultTypeInternal _SpellSelection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SpellSelection_class_data_;
class ToolOptions;
struct ToolOptionsDefaultTypeInternal;
extern ToolOptionsDefaultTypeInternal _ToolOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ToolOptions_class_data_;
class ToolSelection;
struct ToolSelectionDefaultTypeInternal;
extern ToolSelectionDefaultTypeInternal _ToolSelection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ToolSelection_class_data_;
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::ChoiceCategory_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::ChoiceCategory>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::ChoiceSource_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::ChoiceSource>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::SpellSelectionType_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::SpellSelectionType>;
}  // namespace protobuf
}  // namespace google

namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum SpellSelectionType : int {
  SPELL_SELECTION_TYPE_UNSPECIFIED = 0,
  SPELL_SELECTION_TYPE_SPELLBOOK = 1,
  SPELL_SELECTION_TYPE_KNOWN = 2,
  SPELL_SELECTION_TYPE_PREPARED = 3,
  SpellSelectionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SpellSelectionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SpellSelectionType_internal_data_[];
inline constexpr SpellSelectionType SpellSelectionType_MIN =
    static_cast<SpellSelectionType>(0);
inline constexpr SpellSelectionType SpellSelectionType_MAX =
    static_cast<SpellSelectionType>(3);
inline bool SpellSelectionType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int SpellSelectionType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SpellSelectionType_descriptor();
template <typename T>
const ::std::string& SpellSelectionType_Name(T value) {
  static_assert(::std::is_same<T, SpellSelectionType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SpellSelectionType_Name().");
  return SpellSelectionType_Name(static_cast<SpellSelectionType>(value));
}
template <>
inline const ::std::string& SpellSelectionType_Name(SpellSelectionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SpellSelectionType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool SpellSelectionType_Parse(
    ::absl::string_view name, SpellSelectionType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpellSelectionType>(SpellSelectionType_descriptor(), name,
                                           value);
}
enum ChoiceSource : int {
  CHOICE_SOURCE_UNSPECIFIED = 0,
  CHOICE_SOURCE_PLAYER = 1,
  CHOICE_SOURCE_RACE = 2,
  CHOICE_SOURCE_SUBRACE = 3,
  CHOICE_SOURCE_CLASS = 4,
  CHOICE_SOURCE_BACKGROUND = 5,
  CHOICE_SOURCE_LEVEL_UP = 6,
  ChoiceSource_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ChoiceSource_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ChoiceSource_internal_data_[];
inline constexpr ChoiceSource ChoiceSource_MIN =
    static_cast<ChoiceSource>(0);
inline constexpr ChoiceSource ChoiceSource_MAX =
    static_cast<ChoiceSource>(6);
inline bool ChoiceSource_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int ChoiceSource_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ChoiceSource_descriptor();
template <typename T>
const ::std::string& ChoiceSource_Name(T value) {
  static_assert(::std::is_same<T, ChoiceSource>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ChoiceSource_Name().");
  return ChoiceSource_Name(static_cast<ChoiceSource>(value));
}
template <>
inline const ::std::string& ChoiceSource_Name(ChoiceSource value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChoiceSource_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool ChoiceSource_Parse(
    ::absl::string_view name, ChoiceSource* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChoiceSource>(ChoiceSource_descriptor(), name,
                                           value);
}
enum ChoiceCategory : int {
  CHOICE_CATEGORY_UNSPECIFIED = 0,
  CHOICE_CATEGORY_EQUIPMENT = 1,
  CHOICE_CATEGORY_SKILLS = 2,
  CHOICE_CATEGORY_TOOLS = 3,
  CHOICE_CATEGORY_LANGUAGES = 4,
  CHOICE_CATEGORY_WEAPON_PROFICIENCIES = 5,
  CHOICE_CATEGORY_ARMOR_PROFICIENCIES = 6,
  CHOICE_CATEGORY_SPELLS = 7,
  CHOICE_CATEGORY_FEATS = 8,
  CHOICE_CATEGORY_ABILITY_SCORES = 9,
  CHOICE_CATEGORY_NAME = 10,
  CHOICE_CATEGORY_FIGHTING_STYLE = 11,
  CHOICE_CATEGORY_RACE = 12,
  CHOICE_CATEGORY_CLASS = 13,
  CHOICE_CATEGORY_BACKGROUND = 14,
  CHOICE_CATEGORY_CANTRIPS = 15,
  CHOICE_CATEGORY_EXPERTISE = 16,
  CHOICE_CATEGORY_SUBRACE = 17,
  CHOICE_CATEGORY_TRAITS = 18,
  ChoiceCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ChoiceCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ChoiceCategory_internal_data_[];
inline constexpr ChoiceCategory ChoiceCategory_MIN =
    static_cast<ChoiceCategory>(0);
inline constexpr ChoiceCategory ChoiceCategory_MAX =
    static_cast<ChoiceCategory>(18);
inline bool ChoiceCategory_IsValid(int value) {
  return 0 <= value && value <= 18;
}
inline constexpr int ChoiceCategory_ARRAYSIZE = 18 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ChoiceCategory_descriptor();
template <typename T>
const ::std::string& ChoiceCategory_Name(T value) {
  static_assert(::std::is_same<T, ChoiceCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ChoiceCategory_Name().");
  return ChoiceCategory_Name(static_cast<ChoiceCategory>(value));
}
template <>
inline const ::std::string& ChoiceCategory_Name(ChoiceCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChoiceCategory_descriptor, 0, 18>(
      static_cast<int>(value));
}
inline bool ChoiceCategory_Parse(
    ::absl::string_view name, ChoiceCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChoiceCategory>(ChoiceCategory_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class ToolSelection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ToolSelection) */ {
 public:
  inline ToolSelection() : ToolSelection(nullptr) {}
  ~ToolSelection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ToolSelection* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ToolSelection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ToolSelection(::google::protobuf::internal::ConstantInitialized);

  inline ToolSelection(const ToolSelection& from) : ToolSelection(nullptr, from) {}
  inline ToolSelection(ToolSelection&& from) noexcept
      : ToolSelection(nullptr, ::std::move(from)) {}
  inline ToolSelection& operator=(const ToolSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolSelection& operator=(ToolSelection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolSelection& default_instance() {
    return *reinterpret_cast<const ToolSelection*>(
        &_ToolSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ToolSelection& a, ToolSelection& b) { a.Swap(&b); }
  inline void Swap(ToolSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolSelection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ToolSelection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ToolSelection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ToolSelection& from) { ToolSelection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ToolSelection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ToolSelection"; }

  explicit ToolSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ToolSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ToolSelection& from);
  ToolSelection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ToolSelection&& from) noexcept
      : ToolSelection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kToolsFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.Tool tools = 1 [json_name = "tools"];
  int tools_size() const;
  private:
  int _internal_tools_size() const;

  public:
  void clear_tools() ;
  public:
  ::dnd5e::api::v1alpha1::Tool tools(int index) const;
  void set_tools(int index, ::dnd5e::api::v1alpha1::Tool value);
  void add_tools(::dnd5e::api::v1alpha1::Tool value);
  const ::google::protobuf::RepeatedField<int>& tools() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_tools();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_tools() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_tools();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ToolSelection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ToolSelection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> tools_;
    ::google::protobuf::internal::CachedSize _tools_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ToolSelection_class_data_;
// -------------------------------------------------------------------

class ToolOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ToolOptions) */ {
 public:
  inline ToolOptions() : ToolOptions(nullptr) {}
  ~ToolOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ToolOptions* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ToolOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ToolOptions(::google::protobuf::internal::ConstantInitialized);

  inline ToolOptions(const ToolOptions& from) : ToolOptions(nullptr, from) {}
  inline ToolOptions(ToolOptions&& from) noexcept
      : ToolOptions(nullptr, ::std::move(from)) {}
  inline ToolOptions& operator=(const ToolOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolOptions& operator=(ToolOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolOptions& default_instance() {
    return *reinterpret_cast<const ToolOptions*>(
        &_ToolOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ToolOptions& a, ToolOptions& b) { a.Swap(&b); }
  inline void Swap(ToolOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ToolOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ToolOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ToolOptions& from) { ToolOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ToolOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ToolOptions"; }

  explicit ToolOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ToolOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ToolOptions& from);
  ToolOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ToolOptions&& from) noexcept
      : ToolOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAvailableFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.Tool available = 1 [json_name = "available"];
  int available_size() const;
  private:
  int _internal_available_size() const;

  public:
  void clear_available() ;
  public:
  ::dnd5e::api::v1alpha1::Tool available(int index) const;
  void set_available(int index, ::dnd5e::api::v1alpha1::Tool value);
  void add_available(::dnd5e::api::v1alpha1::Tool value);
  const ::google::protobuf::RepeatedField<int>& available() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_available();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_available() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_available();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ToolOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ToolOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> available_;
    ::google::protobuf::internal::CachedSize _available_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ToolOptions_class_data_;
// -------------------------------------------------------------------

class SpellSelection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.SpellSelection) */ {
 public:
  inline SpellSelection() : SpellSelection(nullptr) {}
  ~SpellSelection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SpellSelection* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SpellSelection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SpellSelection(::google::protobuf::internal::ConstantInitialized);

  inline SpellSelection(const SpellSelection& from) : SpellSelection(nullptr, from) {}
  inline SpellSelection(SpellSelection&& from) noexcept
      : SpellSelection(nullptr, ::std::move(from)) {}
  inline SpellSelection& operator=(const SpellSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpellSelection& operator=(SpellSelection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpellSelection& default_instance() {
    return *reinterpret_cast<const SpellSelection*>(
        &_SpellSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(SpellSelection& a, SpellSelection& b) { a.Swap(&b); }
  inline void Swap(SpellSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpellSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpellSelection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SpellSelection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpellSelection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SpellSelection& from) { SpellSelection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SpellSelection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.SpellSelection"; }

  explicit SpellSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SpellSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SpellSelection& from);
  SpellSelection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SpellSelection&& from) noexcept
      : SpellSelection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSpellsFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.Spell spells = 1 [json_name = "spells"];
  int spells_size() const;
  private:
  int _internal_spells_size() const;

  public:
  void clear_spells() ;
  public:
  ::dnd5e::api::v1alpha1::Spell spells(int index) const;
  void set_spells(int index, ::dnd5e::api::v1alpha1::Spell value);
  void add_spells(::dnd5e::api::v1alpha1::Spell value);
  const ::google::protobuf::RepeatedField<int>& spells() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_spells();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_spells() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_spells();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.SpellSelection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SpellSelection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> spells_;
    ::google::protobuf::internal::CachedSize _spells_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SpellSelection_class_data_;
// -------------------------------------------------------------------

class SpellOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.SpellOptions) */ {
 public:
  inline SpellOptions() : SpellOptions(nullptr) {}
  ~SpellOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SpellOptions* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SpellOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SpellOptions(::google::protobuf::internal::ConstantInitialized);

  inline SpellOptions(const SpellOptions& from) : SpellOptions(nullptr, from) {}
  inline SpellOptions(SpellOptions&& from) noexcept
      : SpellOptions(nullptr, ::std::move(from)) {}
  inline SpellOptions& operator=(const SpellOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpellOptions& operator=(SpellOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpellOptions& default_instance() {
    return *reinterpret_cast<const SpellOptions*>(
        &_SpellOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(SpellOptions& a, SpellOptions& b) { a.Swap(&b); }
  inline void Swap(SpellOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpellOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpellOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SpellOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpellOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SpellOptions& from) { SpellOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SpellOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.SpellOptions"; }

  explicit SpellOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SpellOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SpellOptions& from);
  SpellOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SpellOptions&& from) noexcept
      : SpellOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAvailableFieldNumber = 1,
    kSpellLevelFieldNumber = 2,
    kSelectionTypeFieldNumber = 3,
  };
  // repeated .dnd5e.api.v1alpha1.Spell available = 1 [json_name = "available"];
  int available_size() const;
  private:
  int _internal_available_size() const;

  public:
  void clear_available() ;
  public:
  ::dnd5e::api::v1alpha1::Spell available(int index) const;
  void set_available(int index, ::dnd5e::api::v1alpha1::Spell value);
  void add_available(::dnd5e::api::v1alpha1::Spell value);
  const ::google::protobuf::RepeatedField<int>& available() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_available();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_available() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_available();

  public:
  // int32 spell_level = 2 [json_name = "spellLevel"];
  void clear_spell_level() ;
  ::int32_t spell_level() const;
  void set_spell_level(::int32_t value);

  private:
  ::int32_t _internal_spell_level() const;
  void _internal_set_spell_level(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.SpellSelectionType selection_type = 3 [json_name = "selectionType"];
  void clear_selection_type() ;
  ::dnd5e::api::v1alpha1::SpellSelectionType selection_type() const;
  void set_selection_type(::dnd5e::api::v1alpha1::SpellSelectionType value);

  private:
  ::dnd5e::api::v1alpha1::SpellSelectionType _internal_selection_type() const;
  void _internal_set_selection_type(::dnd5e::api::v1alpha1::SpellSelectionType value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.SpellOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SpellOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> available_;
    ::google::protobuf::internal::CachedSize _available_cached_byte_size_;
    ::int32_t spell_level_;
    int selection_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SpellOptions_class_data_;
// -------------------------------------------------------------------

class SkillSelection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.SkillSelection) */ {
 public:
  inline SkillSelection() : SkillSelection(nullptr) {}
  ~SkillSelection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SkillSelection* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SkillSelection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SkillSelection(::google::protobuf::internal::ConstantInitialized);

  inline SkillSelection(const SkillSelection& from) : SkillSelection(nullptr, from) {}
  inline SkillSelection(SkillSelection&& from) noexcept
      : SkillSelection(nullptr, ::std::move(from)) {}
  inline SkillSelection& operator=(const SkillSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillSelection& operator=(SkillSelection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillSelection& default_instance() {
    return *reinterpret_cast<const SkillSelection*>(
        &_SkillSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SkillSelection& a, SkillSelection& b) { a.Swap(&b); }
  inline void Swap(SkillSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillSelection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SkillSelection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SkillSelection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SkillSelection& from) { SkillSelection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SkillSelection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.SkillSelection"; }

  explicit SkillSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SkillSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SkillSelection& from);
  SkillSelection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SkillSelection&& from) noexcept
      : SkillSelection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkillsFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
  int skills_size() const;
  private:
  int _internal_skills_size() const;

  public:
  void clear_skills() ;
  public:
  ::dnd5e::api::v1alpha1::Skill skills(int index) const;
  void set_skills(int index, ::dnd5e::api::v1alpha1::Skill value);
  void add_skills(::dnd5e::api::v1alpha1::Skill value);
  const ::google::protobuf::RepeatedField<int>& skills() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_skills();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_skills() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_skills();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.SkillSelection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SkillSelection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> skills_;
    ::google::protobuf::internal::CachedSize _skills_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SkillSelection_class_data_;
// -------------------------------------------------------------------

class SkillOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.SkillOptions) */ {
 public:
  inline SkillOptions() : SkillOptions(nullptr) {}
  ~SkillOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SkillOptions* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SkillOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SkillOptions(::google::protobuf::internal::ConstantInitialized);

  inline SkillOptions(const SkillOptions& from) : SkillOptions(nullptr, from) {}
  inline SkillOptions(SkillOptions&& from) noexcept
      : SkillOptions(nullptr, ::std::move(from)) {}
  inline SkillOptions& operator=(const SkillOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillOptions& operator=(SkillOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillOptions& default_instance() {
    return *reinterpret_cast<const SkillOptions*>(
        &_SkillOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(SkillOptions& a, SkillOptions& b) { a.Swap(&b); }
  inline void Swap(SkillOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SkillOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SkillOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SkillOptions& from) { SkillOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SkillOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.SkillOptions"; }

  explicit SkillOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SkillOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SkillOptions& from);
  SkillOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SkillOptions&& from) noexcept
      : SkillOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAvailableFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.Skill available = 1 [json_name = "available"];
  int available_size() const;
  private:
  int _internal_available_size() const;

  public:
  void clear_available() ;
  public:
  ::dnd5e::api::v1alpha1::Skill available(int index) const;
  void set_available(int index, ::dnd5e::api::v1alpha1::Skill value);
  void add_available(::dnd5e::api::v1alpha1::Skill value);
  const ::google::protobuf::RepeatedField<int>& available() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_available();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_available() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_available();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.SkillOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SkillOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> available_;
    ::google::protobuf::internal::CachedSize _available_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SkillOptions_class_data_;
// -------------------------------------------------------------------

class LanguageSelection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.LanguageSelection) */ {
 public:
  inline LanguageSelection() : LanguageSelection(nullptr) {}
  ~LanguageSelection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LanguageSelection* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LanguageSelection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LanguageSelection(::google::protobuf::internal::ConstantInitialized);

  inline LanguageSelection(const LanguageSelection& from) : LanguageSelection(nullptr, from) {}
  inline LanguageSelection(LanguageSelection&& from) noexcept
      : LanguageSelection(nullptr, ::std::move(from)) {}
  inline LanguageSelection& operator=(const LanguageSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline LanguageSelection& operator=(LanguageSelection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LanguageSelection& default_instance() {
    return *reinterpret_cast<const LanguageSelection*>(
        &_LanguageSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(LanguageSelection& a, LanguageSelection& b) { a.Swap(&b); }
  inline void Swap(LanguageSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LanguageSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LanguageSelection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LanguageSelection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LanguageSelection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LanguageSelection& from) { LanguageSelection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LanguageSelection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.LanguageSelection"; }

  explicit LanguageSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LanguageSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LanguageSelection& from);
  LanguageSelection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LanguageSelection&& from) noexcept
      : LanguageSelection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLanguagesFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.Language languages = 1 [json_name = "languages"];
  int languages_size() const;
  private:
  int _internal_languages_size() const;

  public:
  void clear_languages() ;
  public:
  ::dnd5e::api::v1alpha1::Language languages(int index) const;
  void set_languages(int index, ::dnd5e::api::v1alpha1::Language value);
  void add_languages(::dnd5e::api::v1alpha1::Language value);
  const ::google::protobuf::RepeatedField<int>& languages() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_languages();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_languages() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_languages();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.LanguageSelection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LanguageSelection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> languages_;
    ::google::protobuf::internal::CachedSize _languages_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LanguageSelection_class_data_;
// -------------------------------------------------------------------

class LanguageOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.LanguageOptions) */ {
 public:
  inline LanguageOptions() : LanguageOptions(nullptr) {}
  ~LanguageOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LanguageOptions* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LanguageOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LanguageOptions(::google::protobuf::internal::ConstantInitialized);

  inline LanguageOptions(const LanguageOptions& from) : LanguageOptions(nullptr, from) {}
  inline LanguageOptions(LanguageOptions&& from) noexcept
      : LanguageOptions(nullptr, ::std::move(from)) {}
  inline LanguageOptions& operator=(const LanguageOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline LanguageOptions& operator=(LanguageOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LanguageOptions& default_instance() {
    return *reinterpret_cast<const LanguageOptions*>(
        &_LanguageOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(LanguageOptions& a, LanguageOptions& b) { a.Swap(&b); }
  inline void Swap(LanguageOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LanguageOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LanguageOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LanguageOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LanguageOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LanguageOptions& from) { LanguageOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LanguageOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.LanguageOptions"; }

  explicit LanguageOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LanguageOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LanguageOptions& from);
  LanguageOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LanguageOptions&& from) noexcept
      : LanguageOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAvailableFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.Language available = 1 [json_name = "available"];
  int available_size() const;
  private:
  int _internal_available_size() const;

  public:
  void clear_available() ;
  public:
  ::dnd5e::api::v1alpha1::Language available(int index) const;
  void set_available(int index, ::dnd5e::api::v1alpha1::Language value);
  void add_available(::dnd5e::api::v1alpha1::Language value);
  const ::google::protobuf::RepeatedField<int>& available() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_available();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_available() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_available();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.LanguageOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LanguageOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> available_;
    ::google::protobuf::internal::CachedSize _available_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LanguageOptions_class_data_;
// -------------------------------------------------------------------

class FightingStyleSelection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.FightingStyleSelection) */ {
 public:
  inline FightingStyleSelection() : FightingStyleSelection(nullptr) {}
  ~FightingStyleSelection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FightingStyleSelection* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FightingStyleSelection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FightingStyleSelection(::google::protobuf::internal::ConstantInitialized);

  inline FightingStyleSelection(const FightingStyleSelection& from) : FightingStyleSelection(nullptr, from) {}
  inline FightingStyleSelection(FightingStyleSelection&& from) noexcept
      : FightingStyleSelection(nullptr, ::std::move(from)) {}
  inline FightingStyleSelection& operator=(const FightingStyleSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline FightingStyleSelection& operator=(FightingStyleSelection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FightingStyleSelection& default_instance() {
    return *reinterpret_cast<const FightingStyleSelection*>(
        &_FightingStyleSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(FightingStyleSelection& a, FightingStyleSelection& b) { a.Swap(&b); }
  inline void Swap(FightingStyleSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FightingStyleSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FightingStyleSelection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FightingStyleSelection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FightingStyleSelection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FightingStyleSelection& from) { FightingStyleSelection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FightingStyleSelection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.FightingStyleSelection"; }

  explicit FightingStyleSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FightingStyleSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FightingStyleSelection& from);
  FightingStyleSelection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FightingStyleSelection&& from) noexcept
      : FightingStyleSelection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStyleFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.FightingStyle style = 1 [json_name = "style"];
  void clear_style() ;
  ::dnd5e::api::v1alpha1::FightingStyle style() const;
  void set_style(::dnd5e::api::v1alpha1::FightingStyle value);

  private:
  ::dnd5e::api::v1alpha1::FightingStyle _internal_style() const;
  void _internal_set_style(::dnd5e::api::v1alpha1::FightingStyle value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.FightingStyleSelection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FightingStyleSelection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int style_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FightingStyleSelection_class_data_;
// -------------------------------------------------------------------

class FightingStyleOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.FightingStyleOptions) */ {
 public:
  inline FightingStyleOptions() : FightingStyleOptions(nullptr) {}
  ~FightingStyleOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FightingStyleOptions* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FightingStyleOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FightingStyleOptions(::google::protobuf::internal::ConstantInitialized);

  inline FightingStyleOptions(const FightingStyleOptions& from) : FightingStyleOptions(nullptr, from) {}
  inline FightingStyleOptions(FightingStyleOptions&& from) noexcept
      : FightingStyleOptions(nullptr, ::std::move(from)) {}
  inline FightingStyleOptions& operator=(const FightingStyleOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline FightingStyleOptions& operator=(FightingStyleOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FightingStyleOptions& default_instance() {
    return *reinterpret_cast<const FightingStyleOptions*>(
        &_FightingStyleOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(FightingStyleOptions& a, FightingStyleOptions& b) { a.Swap(&b); }
  inline void Swap(FightingStyleOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FightingStyleOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FightingStyleOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FightingStyleOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FightingStyleOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FightingStyleOptions& from) { FightingStyleOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FightingStyleOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.FightingStyleOptions"; }

  explicit FightingStyleOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FightingStyleOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FightingStyleOptions& from);
  FightingStyleOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FightingStyleOptions&& from) noexcept
      : FightingStyleOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAvailableFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.FightingStyle available = 1 [json_name = "available"];
  int available_size() const;
  private:
  int _internal_available_size() const;

  public:
  void clear_available() ;
  public:
  ::dnd5e::api::v1alpha1::FightingStyle available(int index) const;
  void set_available(int index, ::dnd5e::api::v1alpha1::FightingStyle value);
  void add_available(::dnd5e::api::v1alpha1::FightingStyle value);
  const ::google::protobuf::RepeatedField<int>& available() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_available();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_available() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_available();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.FightingStyleOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FightingStyleOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> available_;
    ::google::protobuf::internal::CachedSize _available_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FightingStyleOptions_class_data_;
// -------------------------------------------------------------------

class ExpertiseSelection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ExpertiseSelection) */ {
 public:
  inline ExpertiseSelection() : ExpertiseSelection(nullptr) {}
  ~ExpertiseSelection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExpertiseSelection* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExpertiseSelection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExpertiseSelection(::google::protobuf::internal::ConstantInitialized);

  inline ExpertiseSelection(const ExpertiseSelection& from) : ExpertiseSelection(nullptr, from) {}
  inline ExpertiseSelection(ExpertiseSelection&& from) noexcept
      : ExpertiseSelection(nullptr, ::std::move(from)) {}
  inline ExpertiseSelection& operator=(const ExpertiseSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpertiseSelection& operator=(ExpertiseSelection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpertiseSelection& default_instance() {
    return *reinterpret_cast<const ExpertiseSelection*>(
        &_ExpertiseSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ExpertiseSelection& a, ExpertiseSelection& b) { a.Swap(&b); }
  inline void Swap(ExpertiseSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpertiseSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpertiseSelection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExpertiseSelection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExpertiseSelection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExpertiseSelection& from) { ExpertiseSelection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExpertiseSelection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ExpertiseSelection"; }

  explicit ExpertiseSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ExpertiseSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ExpertiseSelection& from);
  ExpertiseSelection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ExpertiseSelection&& from) noexcept
      : ExpertiseSelection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkillsFieldNumber = 1,
    kToolsFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
  int skills_size() const;
  private:
  int _internal_skills_size() const;

  public:
  void clear_skills() ;
  public:
  ::dnd5e::api::v1alpha1::Skill skills(int index) const;
  void set_skills(int index, ::dnd5e::api::v1alpha1::Skill value);
  void add_skills(::dnd5e::api::v1alpha1::Skill value);
  const ::google::protobuf::RepeatedField<int>& skills() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_skills();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_skills() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_skills();

  public:
  // repeated .dnd5e.api.v1alpha1.Tool tools = 2 [json_name = "tools"];
  int tools_size() const;
  private:
  int _internal_tools_size() const;

  public:
  void clear_tools() ;
  public:
  ::dnd5e::api::v1alpha1::Tool tools(int index) const;
  void set_tools(int index, ::dnd5e::api::v1alpha1::Tool value);
  void add_tools(::dnd5e::api::v1alpha1::Tool value);
  const ::google::protobuf::RepeatedField<int>& tools() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_tools();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_tools() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_tools();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ExpertiseSelection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ExpertiseSelection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> skills_;
    ::google::protobuf::internal::CachedSize _skills_cached_byte_size_;
    ::google::protobuf::RepeatedField<int> tools_;
    ::google::protobuf::internal::CachedSize _tools_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExpertiseSelection_class_data_;
// -------------------------------------------------------------------

class ExpertiseOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ExpertiseOptions) */ {
 public:
  inline ExpertiseOptions() : ExpertiseOptions(nullptr) {}
  ~ExpertiseOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExpertiseOptions* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExpertiseOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExpertiseOptions(::google::protobuf::internal::ConstantInitialized);

  inline ExpertiseOptions(const ExpertiseOptions& from) : ExpertiseOptions(nullptr, from) {}
  inline ExpertiseOptions(ExpertiseOptions&& from) noexcept
      : ExpertiseOptions(nullptr, ::std::move(from)) {}
  inline ExpertiseOptions& operator=(const ExpertiseOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpertiseOptions& operator=(ExpertiseOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpertiseOptions& default_instance() {
    return *reinterpret_cast<const ExpertiseOptions*>(
        &_ExpertiseOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ExpertiseOptions& a, ExpertiseOptions& b) { a.Swap(&b); }
  inline void Swap(ExpertiseOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpertiseOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpertiseOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExpertiseOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExpertiseOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExpertiseOptions& from) { ExpertiseOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExpertiseOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ExpertiseOptions"; }

  explicit ExpertiseOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ExpertiseOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ExpertiseOptions& from);
  ExpertiseOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ExpertiseOptions&& from) noexcept
      : ExpertiseOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAvailableSkillsFieldNumber = 1,
    kAvailableToolsFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.Skill available_skills = 1 [json_name = "availableSkills"];
  int available_skills_size() const;
  private:
  int _internal_available_skills_size() const;

  public:
  void clear_available_skills() ;
  public:
  ::dnd5e::api::v1alpha1::Skill available_skills(int index) const;
  void set_available_skills(int index, ::dnd5e::api::v1alpha1::Skill value);
  void add_available_skills(::dnd5e::api::v1alpha1::Skill value);
  const ::google::protobuf::RepeatedField<int>& available_skills() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_available_skills();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_available_skills() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_available_skills();

  public:
  // repeated .dnd5e.api.v1alpha1.Tool available_tools = 2 [json_name = "availableTools"];
  int available_tools_size() const;
  private:
  int _internal_available_tools_size() const;

  public:
  void clear_available_tools() ;
  public:
  ::dnd5e::api::v1alpha1::Tool available_tools(int index) const;
  void set_available_tools(int index, ::dnd5e::api::v1alpha1::Tool value);
  void add_available_tools(::dnd5e::api::v1alpha1::Tool value);
  const ::google::protobuf::RepeatedField<int>& available_tools() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_available_tools();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_available_tools() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_available_tools();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ExpertiseOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ExpertiseOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> available_skills_;
    ::google::protobuf::internal::CachedSize _available_skills_cached_byte_size_;
    ::google::protobuf::RepeatedField<int> available_tools_;
    ::google::protobuf::internal::CachedSize _available_tools_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExpertiseOptions_class_data_;
// -------------------------------------------------------------------

class EquipmentSelectionItem final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EquipmentSelectionItem) */ {
 public:
  inline EquipmentSelectionItem() : EquipmentSelectionItem(nullptr) {}
  ~EquipmentSelectionItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EquipmentSelectionItem* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EquipmentSelectionItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EquipmentSelectionItem(::google::protobuf::internal::ConstantInitialized);

  inline EquipmentSelectionItem(const EquipmentSelectionItem& from) : EquipmentSelectionItem(nullptr, from) {}
  inline EquipmentSelectionItem(EquipmentSelectionItem&& from) noexcept
      : EquipmentSelectionItem(nullptr, ::std::move(from)) {}
  inline EquipmentSelectionItem& operator=(const EquipmentSelectionItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentSelectionItem& operator=(EquipmentSelectionItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentSelectionItem& default_instance() {
    return *reinterpret_cast<const EquipmentSelectionItem*>(
        &_EquipmentSelectionItem_default_instance_);
  }
  enum EquipmentCase {
    kWeapon = 1,
    kArmor = 2,
    kTool = 3,
    kPack = 4,
    kAmmunition = 5,
    kOtherEquipmentId = 6,
    EQUIPMENT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(EquipmentSelectionItem& a, EquipmentSelectionItem& b) { a.Swap(&b); }
  inline void Swap(EquipmentSelectionItem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentSelectionItem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentSelectionItem* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EquipmentSelectionItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EquipmentSelectionItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EquipmentSelectionItem& from) { EquipmentSelectionItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EquipmentSelectionItem* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EquipmentSelectionItem"; }

  explicit EquipmentSelectionItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EquipmentSelectionItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EquipmentSelectionItem& from);
  EquipmentSelectionItem(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EquipmentSelectionItem&& from) noexcept
      : EquipmentSelectionItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQuantityFieldNumber = 7,
    kWeaponFieldNumber = 1,
    kArmorFieldNumber = 2,
    kToolFieldNumber = 3,
    kPackFieldNumber = 4,
    kAmmunitionFieldNumber = 5,
    kOtherEquipmentIdFieldNumber = 6,
  };
  // int32 quantity = 7 [json_name = "quantity"];
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.Weapon weapon = 1 [json_name = "weapon"];
  bool has_weapon() const;
  void clear_weapon() ;
  ::dnd5e::api::v1alpha1::Weapon weapon() const;
  void set_weapon(::dnd5e::api::v1alpha1::Weapon value);

  private:
  ::dnd5e::api::v1alpha1::Weapon _internal_weapon() const;
  void _internal_set_weapon(::dnd5e::api::v1alpha1::Weapon value);

  public:
  // .dnd5e.api.v1alpha1.Armor armor = 2 [json_name = "armor"];
  bool has_armor() const;
  void clear_armor() ;
  ::dnd5e::api::v1alpha1::Armor armor() const;
  void set_armor(::dnd5e::api::v1alpha1::Armor value);

  private:
  ::dnd5e::api::v1alpha1::Armor _internal_armor() const;
  void _internal_set_armor(::dnd5e::api::v1alpha1::Armor value);

  public:
  // .dnd5e.api.v1alpha1.Tool tool = 3 [json_name = "tool"];
  bool has_tool() const;
  void clear_tool() ;
  ::dnd5e::api::v1alpha1::Tool tool() const;
  void set_tool(::dnd5e::api::v1alpha1::Tool value);

  private:
  ::dnd5e::api::v1alpha1::Tool _internal_tool() const;
  void _internal_set_tool(::dnd5e::api::v1alpha1::Tool value);

  public:
  // .dnd5e.api.v1alpha1.Pack pack = 4 [json_name = "pack"];
  bool has_pack() const;
  void clear_pack() ;
  ::dnd5e::api::v1alpha1::Pack pack() const;
  void set_pack(::dnd5e::api::v1alpha1::Pack value);

  private:
  ::dnd5e::api::v1alpha1::Pack _internal_pack() const;
  void _internal_set_pack(::dnd5e::api::v1alpha1::Pack value);

  public:
  // .dnd5e.api.v1alpha1.Ammunition ammunition = 5 [json_name = "ammunition"];
  bool has_ammunition() const;
  void clear_ammunition() ;
  ::dnd5e::api::v1alpha1::Ammunition ammunition() const;
  void set_ammunition(::dnd5e::api::v1alpha1::Ammunition value);

  private:
  ::dnd5e::api::v1alpha1::Ammunition _internal_ammunition() const;
  void _internal_set_ammunition(::dnd5e::api::v1alpha1::Ammunition value);

  public:
  // string other_equipment_id = 6 [json_name = "otherEquipmentId"];
  bool has_other_equipment_id() const;
  void clear_other_equipment_id() ;
  const ::std::string& other_equipment_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_other_equipment_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_other_equipment_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_other_equipment_id();
  void set_allocated_other_equipment_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_other_equipment_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_other_equipment_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_other_equipment_id();

  public:
  void clear_equipment();
  EquipmentCase equipment_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EquipmentSelectionItem)
 private:
  class _Internal;
  void set_has_weapon();
  void set_has_armor();
  void set_has_tool();
  void set_has_pack();
  void set_has_ammunition();
  void set_has_other_equipment_id();
  inline bool has_equipment() const;
  inline void clear_has_equipment();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 7,
                                   0, 68,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EquipmentSelectionItem& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t quantity_;
    union EquipmentUnion {
      constexpr EquipmentUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int weapon_;
      int armor_;
      int tool_;
      int pack_;
      int ammunition_;
      ::google::protobuf::internal::ArenaStringPtr other_equipment_id_;
    } equipment_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EquipmentSelectionItem_class_data_;
// -------------------------------------------------------------------

class EquipmentItem final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EquipmentItem) */ {
 public:
  inline EquipmentItem() : EquipmentItem(nullptr) {}
  ~EquipmentItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EquipmentItem* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EquipmentItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EquipmentItem(::google::protobuf::internal::ConstantInitialized);

  inline EquipmentItem(const EquipmentItem& from) : EquipmentItem(nullptr, from) {}
  inline EquipmentItem(EquipmentItem&& from) noexcept
      : EquipmentItem(nullptr, ::std::move(from)) {}
  inline EquipmentItem& operator=(const EquipmentItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentItem& operator=(EquipmentItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentItem& default_instance() {
    return *reinterpret_cast<const EquipmentItem*>(
        &_EquipmentItem_default_instance_);
  }
  enum TypeHintCase {
    kWeapon = 3,
    kArmor = 4,
    kTool = 5,
    kPack = 6,
    kAmmunition = 7,
    TYPE_HINT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(EquipmentItem& a, EquipmentItem& b) { a.Swap(&b); }
  inline void Swap(EquipmentItem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentItem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentItem* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EquipmentItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EquipmentItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EquipmentItem& from) { EquipmentItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EquipmentItem* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EquipmentItem"; }

  explicit EquipmentItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EquipmentItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EquipmentItem& from);
  EquipmentItem(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EquipmentItem&& from) noexcept
      : EquipmentItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSelectionIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kWeaponFieldNumber = 3,
    kArmorFieldNumber = 4,
    kToolFieldNumber = 5,
    kPackFieldNumber = 6,
    kAmmunitionFieldNumber = 7,
  };
  // string selection_id = 1 [json_name = "selectionId"];
  void clear_selection_id() ;
  const ::std::string& selection_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_selection_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_selection_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_selection_id();
  void set_allocated_selection_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_selection_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_selection_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_selection_id();

  public:
  // int32 quantity = 2 [json_name = "quantity"];
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.Weapon weapon = 3 [json_name = "weapon"];
  bool has_weapon() const;
  void clear_weapon() ;
  ::dnd5e::api::v1alpha1::Weapon weapon() const;
  void set_weapon(::dnd5e::api::v1alpha1::Weapon value);

  private:
  ::dnd5e::api::v1alpha1::Weapon _internal_weapon() const;
  void _internal_set_weapon(::dnd5e::api::v1alpha1::Weapon value);

  public:
  // .dnd5e.api.v1alpha1.Armor armor = 4 [json_name = "armor"];
  bool has_armor() const;
  void clear_armor() ;
  ::dnd5e::api::v1alpha1::Armor armor() const;
  void set_armor(::dnd5e::api::v1alpha1::Armor value);

  private:
  ::dnd5e::api::v1alpha1::Armor _internal_armor() const;
  void _internal_set_armor(::dnd5e::api::v1alpha1::Armor value);

  public:
  // .dnd5e.api.v1alpha1.Tool tool = 5 [json_name = "tool"];
  bool has_tool() const;
  void clear_tool() ;
  ::dnd5e::api::v1alpha1::Tool tool() const;
  void set_tool(::dnd5e::api::v1alpha1::Tool value);

  private:
  ::dnd5e::api::v1alpha1::Tool _internal_tool() const;
  void _internal_set_tool(::dnd5e::api::v1alpha1::Tool value);

  public:
  // .dnd5e.api.v1alpha1.Pack pack = 6 [json_name = "pack"];
  bool has_pack() const;
  void clear_pack() ;
  ::dnd5e::api::v1alpha1::Pack pack() const;
  void set_pack(::dnd5e::api::v1alpha1::Pack value);

  private:
  ::dnd5e::api::v1alpha1::Pack _internal_pack() const;
  void _internal_set_pack(::dnd5e::api::v1alpha1::Pack value);

  public:
  // .dnd5e.api.v1alpha1.Ammunition ammunition = 7 [json_name = "ammunition"];
  bool has_ammunition() const;
  void clear_ammunition() ;
  ::dnd5e::api::v1alpha1::Ammunition ammunition() const;
  void set_ammunition(::dnd5e::api::v1alpha1::Ammunition value);

  private:
  ::dnd5e::api::v1alpha1::Ammunition _internal_ammunition() const;
  void _internal_set_ammunition(::dnd5e::api::v1alpha1::Ammunition value);

  public:
  void clear_type_hint();
  TypeHintCase type_hint_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EquipmentItem)
 private:
  class _Internal;
  void set_has_weapon();
  void set_has_armor();
  void set_has_tool();
  void set_has_pack();
  void set_has_ammunition();
  inline bool has_type_hint() const;
  inline void clear_has_type_hint();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 7,
                                   0, 53,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EquipmentItem& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr selection_id_;
    ::int32_t quantity_;
    union TypeHintUnion {
      constexpr TypeHintUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int weapon_;
      int armor_;
      int tool_;
      int pack_;
      int ammunition_;
    } type_hint_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EquipmentItem_class_data_;
// -------------------------------------------------------------------

class EquipmentCategoryChoice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EquipmentCategoryChoice) */ {
 public:
  inline EquipmentCategoryChoice() : EquipmentCategoryChoice(nullptr) {}
  ~EquipmentCategoryChoice() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EquipmentCategoryChoice* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EquipmentCategoryChoice));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EquipmentCategoryChoice(::google::protobuf::internal::ConstantInitialized);

  inline EquipmentCategoryChoice(const EquipmentCategoryChoice& from) : EquipmentCategoryChoice(nullptr, from) {}
  inline EquipmentCategoryChoice(EquipmentCategoryChoice&& from) noexcept
      : EquipmentCategoryChoice(nullptr, ::std::move(from)) {}
  inline EquipmentCategoryChoice& operator=(const EquipmentCategoryChoice& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentCategoryChoice& operator=(EquipmentCategoryChoice&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentCategoryChoice& default_instance() {
    return *reinterpret_cast<const EquipmentCategoryChoice*>(
        &_EquipmentCategoryChoice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(EquipmentCategoryChoice& a, EquipmentCategoryChoice& b) { a.Swap(&b); }
  inline void Swap(EquipmentCategoryChoice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentCategoryChoice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentCategoryChoice* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EquipmentCategoryChoice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EquipmentCategoryChoice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EquipmentCategoryChoice& from) { EquipmentCategoryChoice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EquipmentCategoryChoice* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EquipmentCategoryChoice"; }

  explicit EquipmentCategoryChoice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EquipmentCategoryChoice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EquipmentCategoryChoice& from);
  EquipmentCategoryChoice(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EquipmentCategoryChoice&& from) noexcept
      : EquipmentCategoryChoice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWeaponCategoriesFieldNumber = 2,
    kArmorCategoriesFieldNumber = 3,
    kToolCategoriesFieldNumber = 4,
    kLabelFieldNumber = 5,
    kChooseFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.WeaponCategory weapon_categories = 2 [json_name = "weaponCategories"];
  int weapon_categories_size() const;
  private:
  int _internal_weapon_categories_size() const;

  public:
  void clear_weapon_categories() ;
  public:
  ::dnd5e::api::v1alpha1::WeaponCategory weapon_categories(int index) const;
  void set_weapon_categories(int index, ::dnd5e::api::v1alpha1::WeaponCategory value);
  void add_weapon_categories(::dnd5e::api::v1alpha1::WeaponCategory value);
  const ::google::protobuf::RepeatedField<int>& weapon_categories() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_weapon_categories();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_weapon_categories() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_weapon_categories();

  public:
  // repeated .dnd5e.api.v1alpha1.ArmorCategory armor_categories = 3 [json_name = "armorCategories"];
  int armor_categories_size() const;
  private:
  int _internal_armor_categories_size() const;

  public:
  void clear_armor_categories() ;
  public:
  ::dnd5e::api::v1alpha1::ArmorCategory armor_categories(int index) const;
  void set_armor_categories(int index, ::dnd5e::api::v1alpha1::ArmorCategory value);
  void add_armor_categories(::dnd5e::api::v1alpha1::ArmorCategory value);
  const ::google::protobuf::RepeatedField<int>& armor_categories() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_armor_categories();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_armor_categories() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_armor_categories();

  public:
  // repeated .dnd5e.api.v1alpha1.ToolCategory tool_categories = 4 [json_name = "toolCategories"];
  int tool_categories_size() const;
  private:
  int _internal_tool_categories_size() const;

  public:
  void clear_tool_categories() ;
  public:
  ::dnd5e::api::v1alpha1::ToolCategory tool_categories(int index) const;
  void set_tool_categories(int index, ::dnd5e::api::v1alpha1::ToolCategory value);
  void add_tool_categories(::dnd5e::api::v1alpha1::ToolCategory value);
  const ::google::protobuf::RepeatedField<int>& tool_categories() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_tool_categories();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_tool_categories() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_tool_categories();

  public:
  // string label = 5 [json_name = "label"];
  void clear_label() ;
  const ::std::string& label() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_label();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_label();
  void set_allocated_label(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_label() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_label(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_label();

  public:
  // int32 choose = 1 [json_name = "choose"];
  void clear_choose() ;
  ::int32_t choose() const;
  void set_choose(::int32_t value);

  private:
  ::int32_t _internal_choose() const;
  void _internal_set_choose(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EquipmentCategoryChoice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EquipmentCategoryChoice& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> weapon_categories_;
    ::google::protobuf::internal::CachedSize _weapon_categories_cached_byte_size_;
    ::google::protobuf::RepeatedField<int> armor_categories_;
    ::google::protobuf::internal::CachedSize _armor_categories_cached_byte_size_;
    ::google::protobuf::RepeatedField<int> tool_categories_;
    ::google::protobuf::internal::CachedSize _tool_categories_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr label_;
    ::int32_t choose_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EquipmentCategoryChoice_class_data_;
// -------------------------------------------------------------------

class EquipmentSelection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EquipmentSelection) */ {
 public:
  inline EquipmentSelection() : EquipmentSelection(nullptr) {}
  ~EquipmentSelection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EquipmentSelection* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EquipmentSelection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EquipmentSelection(::google::protobuf::internal::ConstantInitialized);

  inline EquipmentSelection(const EquipmentSelection& from) : EquipmentSelection(nullptr, from) {}
  inline EquipmentSelection(EquipmentSelection&& from) noexcept
      : EquipmentSelection(nullptr, ::std::move(from)) {}
  inline EquipmentSelection& operator=(const EquipmentSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentSelection& operator=(EquipmentSelection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentSelection& default_instance() {
    return *reinterpret_cast<const EquipmentSelection*>(
        &_EquipmentSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(EquipmentSelection& a, EquipmentSelection& b) { a.Swap(&b); }
  inline void Swap(EquipmentSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentSelection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EquipmentSelection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EquipmentSelection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EquipmentSelection& from) { EquipmentSelection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EquipmentSelection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EquipmentSelection"; }

  explicit EquipmentSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EquipmentSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EquipmentSelection& from);
  EquipmentSelection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EquipmentSelection&& from) noexcept
      : EquipmentSelection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.EquipmentSelectionItem items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::dnd5e::api::v1alpha1::EquipmentSelectionItem* PROTOBUF_NONNULL mutable_items(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentSelectionItem>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentSelectionItem>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentSelectionItem>* PROTOBUF_NONNULL _internal_mutable_items();
  public:
  const ::dnd5e::api::v1alpha1::EquipmentSelectionItem& items(int index) const;
  ::dnd5e::api::v1alpha1::EquipmentSelectionItem* PROTOBUF_NONNULL add_items();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentSelectionItem>& items() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EquipmentSelection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EquipmentSelection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::EquipmentSelectionItem > items_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EquipmentSelection_class_data_;
// -------------------------------------------------------------------

class EquipmentBundle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EquipmentBundle) */ {
 public:
  inline EquipmentBundle() : EquipmentBundle(nullptr) {}
  ~EquipmentBundle() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EquipmentBundle* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EquipmentBundle));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EquipmentBundle(::google::protobuf::internal::ConstantInitialized);

  inline EquipmentBundle(const EquipmentBundle& from) : EquipmentBundle(nullptr, from) {}
  inline EquipmentBundle(EquipmentBundle&& from) noexcept
      : EquipmentBundle(nullptr, ::std::move(from)) {}
  inline EquipmentBundle& operator=(const EquipmentBundle& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentBundle& operator=(EquipmentBundle&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentBundle& default_instance() {
    return *reinterpret_cast<const EquipmentBundle*>(
        &_EquipmentBundle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(EquipmentBundle& a, EquipmentBundle& b) { a.Swap(&b); }
  inline void Swap(EquipmentBundle* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentBundle* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentBundle* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EquipmentBundle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EquipmentBundle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EquipmentBundle& from) { EquipmentBundle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EquipmentBundle* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EquipmentBundle"; }

  explicit EquipmentBundle(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EquipmentBundle(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EquipmentBundle& from);
  EquipmentBundle(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EquipmentBundle&& from) noexcept
      : EquipmentBundle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 3,
    kCategoryChoicesFieldNumber = 4,
    kIdFieldNumber = 1,
    kLabelFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.EquipmentItem items = 3 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::dnd5e::api::v1alpha1::EquipmentItem* PROTOBUF_NONNULL mutable_items(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentItem>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentItem>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentItem>* PROTOBUF_NONNULL _internal_mutable_items();
  public:
  const ::dnd5e::api::v1alpha1::EquipmentItem& items(int index) const;
  ::dnd5e::api::v1alpha1::EquipmentItem* PROTOBUF_NONNULL add_items();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentItem>& items() const;
  // repeated .dnd5e.api.v1alpha1.EquipmentCategoryChoice category_choices = 4 [json_name = "categoryChoices"];
  int category_choices_size() const;
  private:
  int _internal_category_choices_size() const;

  public:
  void clear_category_choices() ;
  ::dnd5e::api::v1alpha1::EquipmentCategoryChoice* PROTOBUF_NONNULL mutable_category_choices(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentCategoryChoice>* PROTOBUF_NONNULL mutable_category_choices();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentCategoryChoice>& _internal_category_choices() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentCategoryChoice>* PROTOBUF_NONNULL _internal_mutable_category_choices();
  public:
  const ::dnd5e::api::v1alpha1::EquipmentCategoryChoice& category_choices(int index) const;
  ::dnd5e::api::v1alpha1::EquipmentCategoryChoice* PROTOBUF_NONNULL add_category_choices();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentCategoryChoice>& category_choices() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string label = 2 [json_name = "label"];
  void clear_label() ;
  const ::std::string& label() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_label();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_label();
  void set_allocated_label(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_label() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_label(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_label();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EquipmentBundle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 50,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EquipmentBundle& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::EquipmentItem > items_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::EquipmentCategoryChoice > category_choices_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr label_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EquipmentBundle_class_data_;
// -------------------------------------------------------------------

class EquipmentOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EquipmentOptions) */ {
 public:
  inline EquipmentOptions() : EquipmentOptions(nullptr) {}
  ~EquipmentOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EquipmentOptions* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EquipmentOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EquipmentOptions(::google::protobuf::internal::ConstantInitialized);

  inline EquipmentOptions(const EquipmentOptions& from) : EquipmentOptions(nullptr, from) {}
  inline EquipmentOptions(EquipmentOptions&& from) noexcept
      : EquipmentOptions(nullptr, ::std::move(from)) {}
  inline EquipmentOptions& operator=(const EquipmentOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentOptions& operator=(EquipmentOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentOptions& default_instance() {
    return *reinterpret_cast<const EquipmentOptions*>(
        &_EquipmentOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(EquipmentOptions& a, EquipmentOptions& b) { a.Swap(&b); }
  inline void Swap(EquipmentOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EquipmentOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EquipmentOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EquipmentOptions& from) { EquipmentOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EquipmentOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EquipmentOptions"; }

  explicit EquipmentOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EquipmentOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EquipmentOptions& from);
  EquipmentOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EquipmentOptions&& from) noexcept
      : EquipmentOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBundlesFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.EquipmentBundle bundles = 1 [json_name = "bundles"];
  int bundles_size() const;
  private:
  int _internal_bundles_size() const;

  public:
  void clear_bundles() ;
  ::dnd5e::api::v1alpha1::EquipmentBundle* PROTOBUF_NONNULL mutable_bundles(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentBundle>* PROTOBUF_NONNULL mutable_bundles();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentBundle>& _internal_bundles() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentBundle>* PROTOBUF_NONNULL _internal_mutable_bundles();
  public:
  const ::dnd5e::api::v1alpha1::EquipmentBundle& bundles(int index) const;
  ::dnd5e::api::v1alpha1::EquipmentBundle* PROTOBUF_NONNULL add_bundles();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentBundle>& bundles() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EquipmentOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EquipmentOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::EquipmentBundle > bundles_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EquipmentOptions_class_data_;
// -------------------------------------------------------------------

class ChoiceSubmission final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ChoiceSubmission) */ {
 public:
  inline ChoiceSubmission() : ChoiceSubmission(nullptr) {}
  ~ChoiceSubmission() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChoiceSubmission* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChoiceSubmission));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChoiceSubmission(::google::protobuf::internal::ConstantInitialized);

  inline ChoiceSubmission(const ChoiceSubmission& from) : ChoiceSubmission(nullptr, from) {}
  inline ChoiceSubmission(ChoiceSubmission&& from) noexcept
      : ChoiceSubmission(nullptr, ::std::move(from)) {}
  inline ChoiceSubmission& operator=(const ChoiceSubmission& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChoiceSubmission& operator=(ChoiceSubmission&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChoiceSubmission& default_instance() {
    return *reinterpret_cast<const ChoiceSubmission*>(
        &_ChoiceSubmission_default_instance_);
  }
  enum SelectionCase {
    kSkills = 6,
    kEquipment = 7,
    kLanguages = 8,
    kTools = 9,
    kFightingStyle = 10,
    kSpells = 11,
    kExpertise = 12,
    SELECTION_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ChoiceSubmission& a, ChoiceSubmission& b) { a.Swap(&b); }
  inline void Swap(ChoiceSubmission* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChoiceSubmission* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChoiceSubmission* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChoiceSubmission>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChoiceSubmission& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChoiceSubmission& from) { ChoiceSubmission::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChoiceSubmission* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ChoiceSubmission"; }

  explicit ChoiceSubmission(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ChoiceSubmission(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChoiceSubmission& from);
  ChoiceSubmission(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ChoiceSubmission&& from) noexcept
      : ChoiceSubmission(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSelectionIdsFieldNumber = 5,
    kChoiceIdFieldNumber = 1,
    kOptionIdFieldNumber = 4,
    kCategoryFieldNumber = 2,
    kSourceFieldNumber = 3,
    kSkillsFieldNumber = 6,
    kEquipmentFieldNumber = 7,
    kLanguagesFieldNumber = 8,
    kToolsFieldNumber = 9,
    kFightingStyleFieldNumber = 10,
    kSpellsFieldNumber = 11,
    kExpertiseFieldNumber = 12,
  };
  // repeated string selection_ids = 5 [json_name = "selectionIds"];
  int selection_ids_size() const;
  private:
  int _internal_selection_ids_size() const;

  public:
  void clear_selection_ids() ;
  const ::std::string& selection_ids(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_selection_ids(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_selection_ids(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_selection_ids();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_selection_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& selection_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_selection_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_selection_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_selection_ids();

  public:
  // string choice_id = 1 [json_name = "choiceId"];
  void clear_choice_id() ;
  const ::std::string& choice_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_choice_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_choice_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_choice_id();
  void set_allocated_choice_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_choice_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_choice_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_choice_id();

  public:
  // string option_id = 4 [json_name = "optionId"];
  void clear_option_id() ;
  const ::std::string& option_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_option_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_option_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_option_id();
  void set_allocated_option_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_option_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_option_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_option_id();

  public:
  // .dnd5e.api.v1alpha1.ChoiceCategory category = 2 [json_name = "category"];
  void clear_category() ;
  ::dnd5e::api::v1alpha1::ChoiceCategory category() const;
  void set_category(::dnd5e::api::v1alpha1::ChoiceCategory value);

  private:
  ::dnd5e::api::v1alpha1::ChoiceCategory _internal_category() const;
  void _internal_set_category(::dnd5e::api::v1alpha1::ChoiceCategory value);

  public:
  // .dnd5e.api.v1alpha1.ChoiceSource source = 3 [json_name = "source"];
  void clear_source() ;
  ::dnd5e::api::v1alpha1::ChoiceSource source() const;
  void set_source(::dnd5e::api::v1alpha1::ChoiceSource value);

  private:
  ::dnd5e::api::v1alpha1::ChoiceSource _internal_source() const;
  void _internal_set_source(::dnd5e::api::v1alpha1::ChoiceSource value);

  public:
  // .dnd5e.api.v1alpha1.SkillSelection skills = 6 [json_name = "skills"];
  bool has_skills() const;
  private:
  bool _internal_has_skills() const;

  public:
  void clear_skills() ;
  const ::dnd5e::api::v1alpha1::SkillSelection& skills() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE release_skills();
  ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NONNULL mutable_skills();
  void set_allocated_skills(::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_skills(::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE unsafe_arena_release_skills();

  private:
  const ::dnd5e::api::v1alpha1::SkillSelection& _internal_skills() const;
  ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NONNULL _internal_mutable_skills();

  public:
  // .dnd5e.api.v1alpha1.EquipmentSelection equipment = 7 [json_name = "equipment"];
  bool has_equipment() const;
  private:
  bool _internal_has_equipment() const;

  public:
  void clear_equipment() ;
  const ::dnd5e::api::v1alpha1::EquipmentSelection& equipment() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE release_equipment();
  ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NONNULL mutable_equipment();
  void set_allocated_equipment(::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_equipment(::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE unsafe_arena_release_equipment();

  private:
  const ::dnd5e::api::v1alpha1::EquipmentSelection& _internal_equipment() const;
  ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NONNULL _internal_mutable_equipment();

  public:
  // .dnd5e.api.v1alpha1.LanguageSelection languages = 8 [json_name = "languages"];
  bool has_languages() const;
  private:
  bool _internal_has_languages() const;

  public:
  void clear_languages() ;
  const ::dnd5e::api::v1alpha1::LanguageSelection& languages() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE release_languages();
  ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NONNULL mutable_languages();
  void set_allocated_languages(::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_languages(::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE unsafe_arena_release_languages();

  private:
  const ::dnd5e::api::v1alpha1::LanguageSelection& _internal_languages() const;
  ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NONNULL _internal_mutable_languages();

  public:
  // .dnd5e.api.v1alpha1.ToolSelection tools = 9 [json_name = "tools"];
  bool has_tools() const;
  private:
  bool _internal_has_tools() const;

  public:
  void clear_tools() ;
  const ::dnd5e::api::v1alpha1::ToolSelection& tools() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE release_tools();
  ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NONNULL mutable_tools();
  void set_allocated_tools(::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tools(::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE unsafe_arena_release_tools();

  private:
  const ::dnd5e::api::v1alpha1::ToolSelection& _internal_tools() const;
  ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NONNULL _internal_mutable_tools();

  public:
  // .dnd5e.api.v1alpha1.FightingStyleSelection fighting_style = 10 [json_name = "fightingStyle"];
  bool has_fighting_style() const;
  private:
  bool _internal_has_fighting_style() const;

  public:
  void clear_fighting_style() ;
  const ::dnd5e::api::v1alpha1::FightingStyleSelection& fighting_style() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE release_fighting_style();
  ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NONNULL mutable_fighting_style();
  void set_allocated_fighting_style(::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_fighting_style(::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE unsafe_arena_release_fighting_style();

  private:
  const ::dnd5e::api::v1alpha1::FightingStyleSelection& _internal_fighting_style() const;
  ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NONNULL _internal_mutable_fighting_style();

  public:
  // .dnd5e.api.v1alpha1.SpellSelection spells = 11 [json_name = "spells"];
  bool has_spells() const;
  private:
  bool _internal_has_spells() const;

  public:
  void clear_spells() ;
  const ::dnd5e::api::v1alpha1::SpellSelection& spells() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE release_spells();
  ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NONNULL mutable_spells();
  void set_allocated_spells(::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_spells(::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE unsafe_arena_release_spells();

  private:
  const ::dnd5e::api::v1alpha1::SpellSelection& _internal_spells() const;
  ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NONNULL _internal_mutable_spells();

  public:
  // .dnd5e.api.v1alpha1.ExpertiseSelection expertise = 12 [json_name = "expertise"];
  bool has_expertise() const;
  private:
  bool _internal_has_expertise() const;

  public:
  void clear_expertise() ;
  const ::dnd5e::api::v1alpha1::ExpertiseSelection& expertise() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE release_expertise();
  ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NONNULL mutable_expertise();
  void set_allocated_expertise(::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_expertise(::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE unsafe_arena_release_expertise();

  private:
  const ::dnd5e::api::v1alpha1::ExpertiseSelection& _internal_expertise() const;
  ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NONNULL _internal_mutable_expertise();

  public:
  void clear_selection();
  SelectionCase selection_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ChoiceSubmission)
 private:
  class _Internal;
  void set_has_skills();
  void set_has_equipment();
  void set_has_languages();
  void set_has_tools();
  void set_has_fighting_style();
  void set_has_spells();
  void set_has_expertise();
  inline bool has_selection() const;
  inline void clear_has_selection();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 12,
                                   7, 83,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ChoiceSubmission& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> selection_ids_;
    ::google::protobuf::internal::ArenaStringPtr choice_id_;
    ::google::protobuf::internal::ArenaStringPtr option_id_;
    int category_;
    int source_;
    union SelectionUnion {
      constexpr SelectionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE skills_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE equipment_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE languages_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE tools_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE fighting_style_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE spells_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE expertise_;
    } selection_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ChoiceSubmission_class_data_;
// -------------------------------------------------------------------

class ChoiceData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ChoiceData) */ {
 public:
  inline ChoiceData() : ChoiceData(nullptr) {}
  ~ChoiceData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChoiceData* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChoiceData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChoiceData(::google::protobuf::internal::ConstantInitialized);

  inline ChoiceData(const ChoiceData& from) : ChoiceData(nullptr, from) {}
  inline ChoiceData(ChoiceData&& from) noexcept
      : ChoiceData(nullptr, ::std::move(from)) {}
  inline ChoiceData& operator=(const ChoiceData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChoiceData& operator=(ChoiceData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChoiceData& default_instance() {
    return *reinterpret_cast<const ChoiceData*>(
        &_ChoiceData_default_instance_);
  }
  enum SelectionCase {
    kName = 5,
    kSkills = 6,
    kLanguages = 7,
    kAbilityScores = 8,
    kFightingStyle = 9,
    kEquipment = 10,
    kBackground = 11,
    kSpells = 12,
    kTools = 13,
    kExpertise = 14,
    SELECTION_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(ChoiceData& a, ChoiceData& b) { a.Swap(&b); }
  inline void Swap(ChoiceData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChoiceData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChoiceData* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChoiceData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChoiceData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChoiceData& from) { ChoiceData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChoiceData* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ChoiceData"; }

  explicit ChoiceData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ChoiceData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChoiceData& from);
  ChoiceData(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ChoiceData&& from) noexcept
      : ChoiceData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChoiceIdFieldNumber = 3,
    kOptionIdFieldNumber = 4,
    kCategoryFieldNumber = 1,
    kSourceFieldNumber = 2,
    kNameFieldNumber = 5,
    kSkillsFieldNumber = 6,
    kLanguagesFieldNumber = 7,
    kAbilityScoresFieldNumber = 8,
    kFightingStyleFieldNumber = 9,
    kEquipmentFieldNumber = 10,
    kBackgroundFieldNumber = 11,
    kSpellsFieldNumber = 12,
    kToolsFieldNumber = 13,
    kExpertiseFieldNumber = 14,
  };
  // string choice_id = 3 [json_name = "choiceId"];
  void clear_choice_id() ;
  const ::std::string& choice_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_choice_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_choice_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_choice_id();
  void set_allocated_choice_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_choice_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_choice_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_choice_id();

  public:
  // string option_id = 4 [json_name = "optionId"];
  void clear_option_id() ;
  const ::std::string& option_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_option_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_option_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_option_id();
  void set_allocated_option_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_option_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_option_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_option_id();

  public:
  // .dnd5e.api.v1alpha1.ChoiceCategory category = 1 [json_name = "category"];
  void clear_category() ;
  ::dnd5e::api::v1alpha1::ChoiceCategory category() const;
  void set_category(::dnd5e::api::v1alpha1::ChoiceCategory value);

  private:
  ::dnd5e::api::v1alpha1::ChoiceCategory _internal_category() const;
  void _internal_set_category(::dnd5e::api::v1alpha1::ChoiceCategory value);

  public:
  // .dnd5e.api.v1alpha1.ChoiceSource source = 2 [json_name = "source"];
  void clear_source() ;
  ::dnd5e::api::v1alpha1::ChoiceSource source() const;
  void set_source(::dnd5e::api::v1alpha1::ChoiceSource value);

  private:
  ::dnd5e::api::v1alpha1::ChoiceSource _internal_source() const;
  void _internal_set_source(::dnd5e::api::v1alpha1::ChoiceSource value);

  public:
  // string name = 5 [json_name = "name"];
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // .dnd5e.api.v1alpha1.SkillSelection skills = 6 [json_name = "skills"];
  bool has_skills() const;
  private:
  bool _internal_has_skills() const;

  public:
  void clear_skills() ;
  const ::dnd5e::api::v1alpha1::SkillSelection& skills() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE release_skills();
  ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NONNULL mutable_skills();
  void set_allocated_skills(::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_skills(::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE unsafe_arena_release_skills();

  private:
  const ::dnd5e::api::v1alpha1::SkillSelection& _internal_skills() const;
  ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NONNULL _internal_mutable_skills();

  public:
  // .dnd5e.api.v1alpha1.LanguageSelection languages = 7 [json_name = "languages"];
  bool has_languages() const;
  private:
  bool _internal_has_languages() const;

  public:
  void clear_languages() ;
  const ::dnd5e::api::v1alpha1::LanguageSelection& languages() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE release_languages();
  ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NONNULL mutable_languages();
  void set_allocated_languages(::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_languages(::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE unsafe_arena_release_languages();

  private:
  const ::dnd5e::api::v1alpha1::LanguageSelection& _internal_languages() const;
  ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NONNULL _internal_mutable_languages();

  public:
  // .dnd5e.api.v1alpha1.AbilityScores ability_scores = 8 [json_name = "abilityScores"];
  bool has_ability_scores() const;
  private:
  bool _internal_has_ability_scores() const;

  public:
  void clear_ability_scores() ;
  const ::dnd5e::api::v1alpha1::AbilityScores& ability_scores() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE release_ability_scores();
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL mutable_ability_scores();
  void set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE unsafe_arena_release_ability_scores();

  private:
  const ::dnd5e::api::v1alpha1::AbilityScores& _internal_ability_scores() const;
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL _internal_mutable_ability_scores();

  public:
  // .dnd5e.api.v1alpha1.FightingStyleSelection fighting_style = 9 [json_name = "fightingStyle"];
  bool has_fighting_style() const;
  private:
  bool _internal_has_fighting_style() const;

  public:
  void clear_fighting_style() ;
  const ::dnd5e::api::v1alpha1::FightingStyleSelection& fighting_style() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE release_fighting_style();
  ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NONNULL mutable_fighting_style();
  void set_allocated_fighting_style(::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_fighting_style(::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE unsafe_arena_release_fighting_style();

  private:
  const ::dnd5e::api::v1alpha1::FightingStyleSelection& _internal_fighting_style() const;
  ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NONNULL _internal_mutable_fighting_style();

  public:
  // .dnd5e.api.v1alpha1.EquipmentSelection equipment = 10 [json_name = "equipment"];
  bool has_equipment() const;
  private:
  bool _internal_has_equipment() const;

  public:
  void clear_equipment() ;
  const ::dnd5e::api::v1alpha1::EquipmentSelection& equipment() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE release_equipment();
  ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NONNULL mutable_equipment();
  void set_allocated_equipment(::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_equipment(::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE unsafe_arena_release_equipment();

  private:
  const ::dnd5e::api::v1alpha1::EquipmentSelection& _internal_equipment() const;
  ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NONNULL _internal_mutable_equipment();

  public:
  // .dnd5e.api.v1alpha1.Background background = 11 [json_name = "background"];
  bool has_background() const;
  void clear_background() ;
  ::dnd5e::api::v1alpha1::Background background() const;
  void set_background(::dnd5e::api::v1alpha1::Background value);

  private:
  ::dnd5e::api::v1alpha1::Background _internal_background() const;
  void _internal_set_background(::dnd5e::api::v1alpha1::Background value);

  public:
  // .dnd5e.api.v1alpha1.SpellSelection spells = 12 [json_name = "spells"];
  bool has_spells() const;
  private:
  bool _internal_has_spells() const;

  public:
  void clear_spells() ;
  const ::dnd5e::api::v1alpha1::SpellSelection& spells() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE release_spells();
  ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NONNULL mutable_spells();
  void set_allocated_spells(::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_spells(::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE unsafe_arena_release_spells();

  private:
  const ::dnd5e::api::v1alpha1::SpellSelection& _internal_spells() const;
  ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NONNULL _internal_mutable_spells();

  public:
  // .dnd5e.api.v1alpha1.ToolSelection tools = 13 [json_name = "tools"];
  bool has_tools() const;
  private:
  bool _internal_has_tools() const;

  public:
  void clear_tools() ;
  const ::dnd5e::api::v1alpha1::ToolSelection& tools() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE release_tools();
  ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NONNULL mutable_tools();
  void set_allocated_tools(::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tools(::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE unsafe_arena_release_tools();

  private:
  const ::dnd5e::api::v1alpha1::ToolSelection& _internal_tools() const;
  ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NONNULL _internal_mutable_tools();

  public:
  // .dnd5e.api.v1alpha1.ExpertiseSelection expertise = 14 [json_name = "expertise"];
  bool has_expertise() const;
  private:
  bool _internal_has_expertise() const;

  public:
  void clear_expertise() ;
  const ::dnd5e::api::v1alpha1::ExpertiseSelection& expertise() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE release_expertise();
  ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NONNULL mutable_expertise();
  void set_allocated_expertise(::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_expertise(::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE unsafe_arena_release_expertise();

  private:
  const ::dnd5e::api::v1alpha1::ExpertiseSelection& _internal_expertise() const;
  ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NONNULL _internal_mutable_expertise();

  public:
  void clear_selection();
  SelectionCase selection_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ChoiceData)
 private:
  class _Internal;
  void set_has_name();
  void set_has_skills();
  void set_has_languages();
  void set_has_ability_scores();
  void set_has_fighting_style();
  void set_has_equipment();
  void set_has_background();
  void set_has_spells();
  void set_has_tools();
  void set_has_expertise();
  inline bool has_selection() const;
  inline void clear_has_selection();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 14,
                                   8, 68,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ChoiceData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr choice_id_;
    ::google::protobuf::internal::ArenaStringPtr option_id_;
    int category_;
    int source_;
    union SelectionUnion {
      constexpr SelectionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr name_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE skills_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE languages_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE ability_scores_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE fighting_style_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE equipment_;
      int background_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE spells_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE tools_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE expertise_;
    } selection_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ChoiceData_class_data_;
// -------------------------------------------------------------------

class Choice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.Choice) */ {
 public:
  inline Choice() : Choice(nullptr) {}
  ~Choice() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Choice* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Choice));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Choice(::google::protobuf::internal::ConstantInitialized);

  inline Choice(const Choice& from) : Choice(nullptr, from) {}
  inline Choice(Choice&& from) noexcept
      : Choice(nullptr, ::std::move(from)) {}
  inline Choice& operator=(const Choice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Choice& operator=(Choice&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Choice& default_instance() {
    return *reinterpret_cast<const Choice*>(
        &_Choice_default_instance_);
  }
  enum OptionsCase {
    kSkillOptions = 5,
    kEquipmentOptions = 6,
    kLanguageOptions = 7,
    kToolOptions = 8,
    kFightingStyleOptions = 9,
    kSpellOptions = 10,
    kExpertiseOptions = 11,
    OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Choice& a, Choice& b) { a.Swap(&b); }
  inline void Swap(Choice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Choice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Choice* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Choice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Choice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Choice& from) { Choice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Choice* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.Choice"; }

  explicit Choice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Choice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Choice& from);
  Choice(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Choice&& from) noexcept
      : Choice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kChooseCountFieldNumber = 3,
    kChoiceTypeFieldNumber = 4,
    kSkillOptionsFieldNumber = 5,
    kEquipmentOptionsFieldNumber = 6,
    kLanguageOptionsFieldNumber = 7,
    kToolOptionsFieldNumber = 8,
    kFightingStyleOptionsFieldNumber = 9,
    kSpellOptionsFieldNumber = 10,
    kExpertiseOptionsFieldNumber = 11,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // int32 choose_count = 3 [json_name = "chooseCount"];
  void clear_choose_count() ;
  ::int32_t choose_count() const;
  void set_choose_count(::int32_t value);

  private:
  ::int32_t _internal_choose_count() const;
  void _internal_set_choose_count(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.ChoiceCategory choice_type = 4 [json_name = "choiceType"];
  void clear_choice_type() ;
  ::dnd5e::api::v1alpha1::ChoiceCategory choice_type() const;
  void set_choice_type(::dnd5e::api::v1alpha1::ChoiceCategory value);

  private:
  ::dnd5e::api::v1alpha1::ChoiceCategory _internal_choice_type() const;
  void _internal_set_choice_type(::dnd5e::api::v1alpha1::ChoiceCategory value);

  public:
  // .dnd5e.api.v1alpha1.SkillOptions skill_options = 5 [json_name = "skillOptions"];
  bool has_skill_options() const;
  private:
  bool _internal_has_skill_options() const;

  public:
  void clear_skill_options() ;
  const ::dnd5e::api::v1alpha1::SkillOptions& skill_options() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SkillOptions* PROTOBUF_NULLABLE release_skill_options();
  ::dnd5e::api::v1alpha1::SkillOptions* PROTOBUF_NONNULL mutable_skill_options();
  void set_allocated_skill_options(::dnd5e::api::v1alpha1::SkillOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_skill_options(::dnd5e::api::v1alpha1::SkillOptions* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SkillOptions* PROTOBUF_NULLABLE unsafe_arena_release_skill_options();

  private:
  const ::dnd5e::api::v1alpha1::SkillOptions& _internal_skill_options() const;
  ::dnd5e::api::v1alpha1::SkillOptions* PROTOBUF_NONNULL _internal_mutable_skill_options();

  public:
  // .dnd5e.api.v1alpha1.EquipmentOptions equipment_options = 6 [json_name = "equipmentOptions"];
  bool has_equipment_options() const;
  private:
  bool _internal_has_equipment_options() const;

  public:
  void clear_equipment_options() ;
  const ::dnd5e::api::v1alpha1::EquipmentOptions& equipment_options() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::EquipmentOptions* PROTOBUF_NULLABLE release_equipment_options();
  ::dnd5e::api::v1alpha1::EquipmentOptions* PROTOBUF_NONNULL mutable_equipment_options();
  void set_allocated_equipment_options(::dnd5e::api::v1alpha1::EquipmentOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_equipment_options(::dnd5e::api::v1alpha1::EquipmentOptions* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::EquipmentOptions* PROTOBUF_NULLABLE unsafe_arena_release_equipment_options();

  private:
  const ::dnd5e::api::v1alpha1::EquipmentOptions& _internal_equipment_options() const;
  ::dnd5e::api::v1alpha1::EquipmentOptions* PROTOBUF_NONNULL _internal_mutable_equipment_options();

  public:
  // .dnd5e.api.v1alpha1.LanguageOptions language_options = 7 [json_name = "languageOptions"];
  bool has_language_options() const;
  private:
  bool _internal_has_language_options() const;

  public:
  void clear_language_options() ;
  const ::dnd5e::api::v1alpha1::LanguageOptions& language_options() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::LanguageOptions* PROTOBUF_NULLABLE release_language_options();
  ::dnd5e::api::v1alpha1::LanguageOptions* PROTOBUF_NONNULL mutable_language_options();
  void set_allocated_language_options(::dnd5e::api::v1alpha1::LanguageOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_language_options(::dnd5e::api::v1alpha1::LanguageOptions* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::LanguageOptions* PROTOBUF_NULLABLE unsafe_arena_release_language_options();

  private:
  const ::dnd5e::api::v1alpha1::LanguageOptions& _internal_language_options() const;
  ::dnd5e::api::v1alpha1::LanguageOptions* PROTOBUF_NONNULL _internal_mutable_language_options();

  public:
  // .dnd5e.api.v1alpha1.ToolOptions tool_options = 8 [json_name = "toolOptions"];
  bool has_tool_options() const;
  private:
  bool _internal_has_tool_options() const;

  public:
  void clear_tool_options() ;
  const ::dnd5e::api::v1alpha1::ToolOptions& tool_options() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ToolOptions* PROTOBUF_NULLABLE release_tool_options();
  ::dnd5e::api::v1alpha1::ToolOptions* PROTOBUF_NONNULL mutable_tool_options();
  void set_allocated_tool_options(::dnd5e::api::v1alpha1::ToolOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tool_options(::dnd5e::api::v1alpha1::ToolOptions* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ToolOptions* PROTOBUF_NULLABLE unsafe_arena_release_tool_options();

  private:
  const ::dnd5e::api::v1alpha1::ToolOptions& _internal_tool_options() const;
  ::dnd5e::api::v1alpha1::ToolOptions* PROTOBUF_NONNULL _internal_mutable_tool_options();

  public:
  // .dnd5e.api.v1alpha1.FightingStyleOptions fighting_style_options = 9 [json_name = "fightingStyleOptions"];
  bool has_fighting_style_options() const;
  private:
  bool _internal_has_fighting_style_options() const;

  public:
  void clear_fighting_style_options() ;
  const ::dnd5e::api::v1alpha1::FightingStyleOptions& fighting_style_options() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::FightingStyleOptions* PROTOBUF_NULLABLE release_fighting_style_options();
  ::dnd5e::api::v1alpha1::FightingStyleOptions* PROTOBUF_NONNULL mutable_fighting_style_options();
  void set_allocated_fighting_style_options(::dnd5e::api::v1alpha1::FightingStyleOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_fighting_style_options(::dnd5e::api::v1alpha1::FightingStyleOptions* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::FightingStyleOptions* PROTOBUF_NULLABLE unsafe_arena_release_fighting_style_options();

  private:
  const ::dnd5e::api::v1alpha1::FightingStyleOptions& _internal_fighting_style_options() const;
  ::dnd5e::api::v1alpha1::FightingStyleOptions* PROTOBUF_NONNULL _internal_mutable_fighting_style_options();

  public:
  // .dnd5e.api.v1alpha1.SpellOptions spell_options = 10 [json_name = "spellOptions"];
  bool has_spell_options() const;
  private:
  bool _internal_has_spell_options() const;

  public:
  void clear_spell_options() ;
  const ::dnd5e::api::v1alpha1::SpellOptions& spell_options() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SpellOptions* PROTOBUF_NULLABLE release_spell_options();
  ::dnd5e::api::v1alpha1::SpellOptions* PROTOBUF_NONNULL mutable_spell_options();
  void set_allocated_spell_options(::dnd5e::api::v1alpha1::SpellOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_spell_options(::dnd5e::api::v1alpha1::SpellOptions* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SpellOptions* PROTOBUF_NULLABLE unsafe_arena_release_spell_options();

  private:
  const ::dnd5e::api::v1alpha1::SpellOptions& _internal_spell_options() const;
  ::dnd5e::api::v1alpha1::SpellOptions* PROTOBUF_NONNULL _internal_mutable_spell_options();

  public:
  // .dnd5e.api.v1alpha1.ExpertiseOptions expertise_options = 11 [json_name = "expertiseOptions"];
  bool has_expertise_options() const;
  private:
  bool _internal_has_expertise_options() const;

  public:
  void clear_expertise_options() ;
  const ::dnd5e::api::v1alpha1::ExpertiseOptions& expertise_options() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ExpertiseOptions* PROTOBUF_NULLABLE release_expertise_options();
  ::dnd5e::api::v1alpha1::ExpertiseOptions* PROTOBUF_NONNULL mutable_expertise_options();
  void set_allocated_expertise_options(::dnd5e::api::v1alpha1::ExpertiseOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_expertise_options(::dnd5e::api::v1alpha1::ExpertiseOptions* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ExpertiseOptions* PROTOBUF_NULLABLE unsafe_arena_release_expertise_options();

  private:
  const ::dnd5e::api::v1alpha1::ExpertiseOptions& _internal_expertise_options() const;
  ::dnd5e::api::v1alpha1::ExpertiseOptions* PROTOBUF_NONNULL _internal_mutable_expertise_options();

  public:
  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.Choice)
 private:
  class _Internal;
  void set_has_skill_options();
  void set_has_equipment_options();
  void set_has_language_options();
  void set_has_tool_options();
  void set_has_fighting_style_options();
  void set_has_spell_options();
  void set_has_expertise_options();
  inline bool has_options() const;
  inline void clear_has_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 11,
                                   7, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Choice& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::int32_t choose_count_;
    int choice_type_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE skill_options_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE equipment_options_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE language_options_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE tool_options_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE fighting_style_options_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE spell_options_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE expertise_options_;
    } options_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Choice_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Choice

// string id = 1 [json_name = "id"];
inline void Choice::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& Choice::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Choice::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Choice.id)
}
inline ::std::string* PROTOBUF_NONNULL Choice::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.id)
  return _s;
}
inline const ::std::string& Choice::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Choice::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Choice::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Choice::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void Choice::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Choice.id)
}

// string description = 2 [json_name = "description"];
inline void Choice::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& Choice::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Choice::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Choice.description)
}
inline ::std::string* PROTOBUF_NONNULL Choice::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.description)
  return _s;
}
inline const ::std::string& Choice::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void Choice::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Choice::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Choice::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.description)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void Choice::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Choice.description)
}

// int32 choose_count = 3 [json_name = "chooseCount"];
inline void Choice::clear_choose_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choose_count_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t Choice::choose_count() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.choose_count)
  return _internal_choose_count();
}
inline void Choice::set_choose_count(::int32_t value) {
  _internal_set_choose_count(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Choice.choose_count)
}
inline ::int32_t Choice::_internal_choose_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.choose_count_;
}
inline void Choice::_internal_set_choose_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choose_count_ = value;
}

// .dnd5e.api.v1alpha1.ChoiceCategory choice_type = 4 [json_name = "choiceType"];
inline void Choice::clear_choice_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choice_type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::dnd5e::api::v1alpha1::ChoiceCategory Choice::choice_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.choice_type)
  return _internal_choice_type();
}
inline void Choice::set_choice_type(::dnd5e::api::v1alpha1::ChoiceCategory value) {
  _internal_set_choice_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Choice.choice_type)
}
inline ::dnd5e::api::v1alpha1::ChoiceCategory Choice::_internal_choice_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::ChoiceCategory>(_impl_.choice_type_);
}
inline void Choice::_internal_set_choice_type(::dnd5e::api::v1alpha1::ChoiceCategory value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choice_type_ = value;
}

// .dnd5e.api.v1alpha1.SkillOptions skill_options = 5 [json_name = "skillOptions"];
inline bool Choice::has_skill_options() const {
  return options_case() == kSkillOptions;
}
inline bool Choice::_internal_has_skill_options() const {
  return options_case() == kSkillOptions;
}
inline void Choice::set_has_skill_options() {
  _impl_._oneof_case_[0] = kSkillOptions;
}
inline void Choice::clear_skill_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kSkillOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.skill_options_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.skill_options_);
    }
    clear_has_options();
  }
}
inline ::dnd5e::api::v1alpha1::SkillOptions* PROTOBUF_NULLABLE Choice::release_skill_options() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.skill_options)
  if (options_case() == kSkillOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SkillOptions*>(_impl_.options_.skill_options_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.skill_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::SkillOptions& Choice::_internal_skill_options() const {
  return options_case() == kSkillOptions ? static_cast<const ::dnd5e::api::v1alpha1::SkillOptions&>(*reinterpret_cast<::dnd5e::api::v1alpha1::SkillOptions*>(_impl_.options_.skill_options_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::SkillOptions&>(::dnd5e::api::v1alpha1::_SkillOptions_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SkillOptions& Choice::skill_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.skill_options)
  return _internal_skill_options();
}
inline ::dnd5e::api::v1alpha1::SkillOptions* PROTOBUF_NULLABLE Choice::unsafe_arena_release_skill_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.Choice.skill_options)
  if (options_case() == kSkillOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SkillOptions*>(_impl_.options_.skill_options_);
    _impl_.options_.skill_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Choice::unsafe_arena_set_allocated_skill_options(
    ::dnd5e::api::v1alpha1::SkillOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_skill_options();
    _impl_.options_.skill_options_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Choice.skill_options)
}
inline ::dnd5e::api::v1alpha1::SkillOptions* PROTOBUF_NONNULL Choice::_internal_mutable_skill_options() {
  if (options_case() != kSkillOptions) {
    clear_options();
    set_has_skill_options();
    _impl_.options_.skill_options_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SkillOptions>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::SkillOptions*>(_impl_.options_.skill_options_);
}
inline ::dnd5e::api::v1alpha1::SkillOptions* PROTOBUF_NONNULL Choice::mutable_skill_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::SkillOptions* _msg = _internal_mutable_skill_options();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.skill_options)
  return _msg;
}

// .dnd5e.api.v1alpha1.EquipmentOptions equipment_options = 6 [json_name = "equipmentOptions"];
inline bool Choice::has_equipment_options() const {
  return options_case() == kEquipmentOptions;
}
inline bool Choice::_internal_has_equipment_options() const {
  return options_case() == kEquipmentOptions;
}
inline void Choice::set_has_equipment_options() {
  _impl_._oneof_case_[0] = kEquipmentOptions;
}
inline void Choice::clear_equipment_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kEquipmentOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.equipment_options_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.equipment_options_);
    }
    clear_has_options();
  }
}
inline ::dnd5e::api::v1alpha1::EquipmentOptions* PROTOBUF_NULLABLE Choice::release_equipment_options() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.equipment_options)
  if (options_case() == kEquipmentOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentOptions*>(_impl_.options_.equipment_options_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.equipment_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::EquipmentOptions& Choice::_internal_equipment_options() const {
  return options_case() == kEquipmentOptions ? static_cast<const ::dnd5e::api::v1alpha1::EquipmentOptions&>(*reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentOptions*>(_impl_.options_.equipment_options_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::EquipmentOptions&>(::dnd5e::api::v1alpha1::_EquipmentOptions_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::EquipmentOptions& Choice::equipment_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.equipment_options)
  return _internal_equipment_options();
}
inline ::dnd5e::api::v1alpha1::EquipmentOptions* PROTOBUF_NULLABLE Choice::unsafe_arena_release_equipment_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.Choice.equipment_options)
  if (options_case() == kEquipmentOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentOptions*>(_impl_.options_.equipment_options_);
    _impl_.options_.equipment_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Choice::unsafe_arena_set_allocated_equipment_options(
    ::dnd5e::api::v1alpha1::EquipmentOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_equipment_options();
    _impl_.options_.equipment_options_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Choice.equipment_options)
}
inline ::dnd5e::api::v1alpha1::EquipmentOptions* PROTOBUF_NONNULL Choice::_internal_mutable_equipment_options() {
  if (options_case() != kEquipmentOptions) {
    clear_options();
    set_has_equipment_options();
    _impl_.options_.equipment_options_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::EquipmentOptions>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentOptions*>(_impl_.options_.equipment_options_);
}
inline ::dnd5e::api::v1alpha1::EquipmentOptions* PROTOBUF_NONNULL Choice::mutable_equipment_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::EquipmentOptions* _msg = _internal_mutable_equipment_options();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.equipment_options)
  return _msg;
}

// .dnd5e.api.v1alpha1.LanguageOptions language_options = 7 [json_name = "languageOptions"];
inline bool Choice::has_language_options() const {
  return options_case() == kLanguageOptions;
}
inline bool Choice::_internal_has_language_options() const {
  return options_case() == kLanguageOptions;
}
inline void Choice::set_has_language_options() {
  _impl_._oneof_case_[0] = kLanguageOptions;
}
inline void Choice::clear_language_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kLanguageOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.language_options_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.language_options_);
    }
    clear_has_options();
  }
}
inline ::dnd5e::api::v1alpha1::LanguageOptions* PROTOBUF_NULLABLE Choice::release_language_options() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.language_options)
  if (options_case() == kLanguageOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::LanguageOptions*>(_impl_.options_.language_options_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.language_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::LanguageOptions& Choice::_internal_language_options() const {
  return options_case() == kLanguageOptions ? static_cast<const ::dnd5e::api::v1alpha1::LanguageOptions&>(*reinterpret_cast<::dnd5e::api::v1alpha1::LanguageOptions*>(_impl_.options_.language_options_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::LanguageOptions&>(::dnd5e::api::v1alpha1::_LanguageOptions_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::LanguageOptions& Choice::language_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.language_options)
  return _internal_language_options();
}
inline ::dnd5e::api::v1alpha1::LanguageOptions* PROTOBUF_NULLABLE Choice::unsafe_arena_release_language_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.Choice.language_options)
  if (options_case() == kLanguageOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::LanguageOptions*>(_impl_.options_.language_options_);
    _impl_.options_.language_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Choice::unsafe_arena_set_allocated_language_options(
    ::dnd5e::api::v1alpha1::LanguageOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_language_options();
    _impl_.options_.language_options_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Choice.language_options)
}
inline ::dnd5e::api::v1alpha1::LanguageOptions* PROTOBUF_NONNULL Choice::_internal_mutable_language_options() {
  if (options_case() != kLanguageOptions) {
    clear_options();
    set_has_language_options();
    _impl_.options_.language_options_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::LanguageOptions>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::LanguageOptions*>(_impl_.options_.language_options_);
}
inline ::dnd5e::api::v1alpha1::LanguageOptions* PROTOBUF_NONNULL Choice::mutable_language_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::LanguageOptions* _msg = _internal_mutable_language_options();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.language_options)
  return _msg;
}

// .dnd5e.api.v1alpha1.ToolOptions tool_options = 8 [json_name = "toolOptions"];
inline bool Choice::has_tool_options() const {
  return options_case() == kToolOptions;
}
inline bool Choice::_internal_has_tool_options() const {
  return options_case() == kToolOptions;
}
inline void Choice::set_has_tool_options() {
  _impl_._oneof_case_[0] = kToolOptions;
}
inline void Choice::clear_tool_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kToolOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.tool_options_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.tool_options_);
    }
    clear_has_options();
  }
}
inline ::dnd5e::api::v1alpha1::ToolOptions* PROTOBUF_NULLABLE Choice::release_tool_options() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.tool_options)
  if (options_case() == kToolOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ToolOptions*>(_impl_.options_.tool_options_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.tool_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::ToolOptions& Choice::_internal_tool_options() const {
  return options_case() == kToolOptions ? static_cast<const ::dnd5e::api::v1alpha1::ToolOptions&>(*reinterpret_cast<::dnd5e::api::v1alpha1::ToolOptions*>(_impl_.options_.tool_options_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::ToolOptions&>(::dnd5e::api::v1alpha1::_ToolOptions_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ToolOptions& Choice::tool_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.tool_options)
  return _internal_tool_options();
}
inline ::dnd5e::api::v1alpha1::ToolOptions* PROTOBUF_NULLABLE Choice::unsafe_arena_release_tool_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.Choice.tool_options)
  if (options_case() == kToolOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ToolOptions*>(_impl_.options_.tool_options_);
    _impl_.options_.tool_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Choice::unsafe_arena_set_allocated_tool_options(
    ::dnd5e::api::v1alpha1::ToolOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_tool_options();
    _impl_.options_.tool_options_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Choice.tool_options)
}
inline ::dnd5e::api::v1alpha1::ToolOptions* PROTOBUF_NONNULL Choice::_internal_mutable_tool_options() {
  if (options_case() != kToolOptions) {
    clear_options();
    set_has_tool_options();
    _impl_.options_.tool_options_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ToolOptions>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::ToolOptions*>(_impl_.options_.tool_options_);
}
inline ::dnd5e::api::v1alpha1::ToolOptions* PROTOBUF_NONNULL Choice::mutable_tool_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::ToolOptions* _msg = _internal_mutable_tool_options();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.tool_options)
  return _msg;
}

// .dnd5e.api.v1alpha1.FightingStyleOptions fighting_style_options = 9 [json_name = "fightingStyleOptions"];
inline bool Choice::has_fighting_style_options() const {
  return options_case() == kFightingStyleOptions;
}
inline bool Choice::_internal_has_fighting_style_options() const {
  return options_case() == kFightingStyleOptions;
}
inline void Choice::set_has_fighting_style_options() {
  _impl_._oneof_case_[0] = kFightingStyleOptions;
}
inline void Choice::clear_fighting_style_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kFightingStyleOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.fighting_style_options_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.fighting_style_options_);
    }
    clear_has_options();
  }
}
inline ::dnd5e::api::v1alpha1::FightingStyleOptions* PROTOBUF_NULLABLE Choice::release_fighting_style_options() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.fighting_style_options)
  if (options_case() == kFightingStyleOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::FightingStyleOptions*>(_impl_.options_.fighting_style_options_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.fighting_style_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::FightingStyleOptions& Choice::_internal_fighting_style_options() const {
  return options_case() == kFightingStyleOptions ? static_cast<const ::dnd5e::api::v1alpha1::FightingStyleOptions&>(*reinterpret_cast<::dnd5e::api::v1alpha1::FightingStyleOptions*>(_impl_.options_.fighting_style_options_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::FightingStyleOptions&>(::dnd5e::api::v1alpha1::_FightingStyleOptions_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::FightingStyleOptions& Choice::fighting_style_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.fighting_style_options)
  return _internal_fighting_style_options();
}
inline ::dnd5e::api::v1alpha1::FightingStyleOptions* PROTOBUF_NULLABLE Choice::unsafe_arena_release_fighting_style_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.Choice.fighting_style_options)
  if (options_case() == kFightingStyleOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::FightingStyleOptions*>(_impl_.options_.fighting_style_options_);
    _impl_.options_.fighting_style_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Choice::unsafe_arena_set_allocated_fighting_style_options(
    ::dnd5e::api::v1alpha1::FightingStyleOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_fighting_style_options();
    _impl_.options_.fighting_style_options_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Choice.fighting_style_options)
}
inline ::dnd5e::api::v1alpha1::FightingStyleOptions* PROTOBUF_NONNULL Choice::_internal_mutable_fighting_style_options() {
  if (options_case() != kFightingStyleOptions) {
    clear_options();
    set_has_fighting_style_options();
    _impl_.options_.fighting_style_options_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::FightingStyleOptions>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::FightingStyleOptions*>(_impl_.options_.fighting_style_options_);
}
inline ::dnd5e::api::v1alpha1::FightingStyleOptions* PROTOBUF_NONNULL Choice::mutable_fighting_style_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::FightingStyleOptions* _msg = _internal_mutable_fighting_style_options();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.fighting_style_options)
  return _msg;
}

// .dnd5e.api.v1alpha1.SpellOptions spell_options = 10 [json_name = "spellOptions"];
inline bool Choice::has_spell_options() const {
  return options_case() == kSpellOptions;
}
inline bool Choice::_internal_has_spell_options() const {
  return options_case() == kSpellOptions;
}
inline void Choice::set_has_spell_options() {
  _impl_._oneof_case_[0] = kSpellOptions;
}
inline void Choice::clear_spell_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kSpellOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.spell_options_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.spell_options_);
    }
    clear_has_options();
  }
}
inline ::dnd5e::api::v1alpha1::SpellOptions* PROTOBUF_NULLABLE Choice::release_spell_options() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.spell_options)
  if (options_case() == kSpellOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SpellOptions*>(_impl_.options_.spell_options_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.spell_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::SpellOptions& Choice::_internal_spell_options() const {
  return options_case() == kSpellOptions ? static_cast<const ::dnd5e::api::v1alpha1::SpellOptions&>(*reinterpret_cast<::dnd5e::api::v1alpha1::SpellOptions*>(_impl_.options_.spell_options_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::SpellOptions&>(::dnd5e::api::v1alpha1::_SpellOptions_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SpellOptions& Choice::spell_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.spell_options)
  return _internal_spell_options();
}
inline ::dnd5e::api::v1alpha1::SpellOptions* PROTOBUF_NULLABLE Choice::unsafe_arena_release_spell_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.Choice.spell_options)
  if (options_case() == kSpellOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SpellOptions*>(_impl_.options_.spell_options_);
    _impl_.options_.spell_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Choice::unsafe_arena_set_allocated_spell_options(
    ::dnd5e::api::v1alpha1::SpellOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_spell_options();
    _impl_.options_.spell_options_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Choice.spell_options)
}
inline ::dnd5e::api::v1alpha1::SpellOptions* PROTOBUF_NONNULL Choice::_internal_mutable_spell_options() {
  if (options_case() != kSpellOptions) {
    clear_options();
    set_has_spell_options();
    _impl_.options_.spell_options_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SpellOptions>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::SpellOptions*>(_impl_.options_.spell_options_);
}
inline ::dnd5e::api::v1alpha1::SpellOptions* PROTOBUF_NONNULL Choice::mutable_spell_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::SpellOptions* _msg = _internal_mutable_spell_options();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.spell_options)
  return _msg;
}

// .dnd5e.api.v1alpha1.ExpertiseOptions expertise_options = 11 [json_name = "expertiseOptions"];
inline bool Choice::has_expertise_options() const {
  return options_case() == kExpertiseOptions;
}
inline bool Choice::_internal_has_expertise_options() const {
  return options_case() == kExpertiseOptions;
}
inline void Choice::set_has_expertise_options() {
  _impl_._oneof_case_[0] = kExpertiseOptions;
}
inline void Choice::clear_expertise_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kExpertiseOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.expertise_options_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.expertise_options_);
    }
    clear_has_options();
  }
}
inline ::dnd5e::api::v1alpha1::ExpertiseOptions* PROTOBUF_NULLABLE Choice::release_expertise_options() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.expertise_options)
  if (options_case() == kExpertiseOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ExpertiseOptions*>(_impl_.options_.expertise_options_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.expertise_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::ExpertiseOptions& Choice::_internal_expertise_options() const {
  return options_case() == kExpertiseOptions ? static_cast<const ::dnd5e::api::v1alpha1::ExpertiseOptions&>(*reinterpret_cast<::dnd5e::api::v1alpha1::ExpertiseOptions*>(_impl_.options_.expertise_options_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::ExpertiseOptions&>(::dnd5e::api::v1alpha1::_ExpertiseOptions_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ExpertiseOptions& Choice::expertise_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.expertise_options)
  return _internal_expertise_options();
}
inline ::dnd5e::api::v1alpha1::ExpertiseOptions* PROTOBUF_NULLABLE Choice::unsafe_arena_release_expertise_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.Choice.expertise_options)
  if (options_case() == kExpertiseOptions) {
    clear_has_options();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ExpertiseOptions*>(_impl_.options_.expertise_options_);
    _impl_.options_.expertise_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Choice::unsafe_arena_set_allocated_expertise_options(
    ::dnd5e::api::v1alpha1::ExpertiseOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_expertise_options();
    _impl_.options_.expertise_options_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Choice.expertise_options)
}
inline ::dnd5e::api::v1alpha1::ExpertiseOptions* PROTOBUF_NONNULL Choice::_internal_mutable_expertise_options() {
  if (options_case() != kExpertiseOptions) {
    clear_options();
    set_has_expertise_options();
    _impl_.options_.expertise_options_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ExpertiseOptions>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::ExpertiseOptions*>(_impl_.options_.expertise_options_);
}
inline ::dnd5e::api::v1alpha1::ExpertiseOptions* PROTOBUF_NONNULL Choice::mutable_expertise_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::ExpertiseOptions* _msg = _internal_mutable_expertise_options();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.expertise_options)
  return _msg;
}

inline bool Choice::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void Choice::clear_has_options() {
  _impl_._oneof_case_[0] = OPTIONS_NOT_SET;
}
inline Choice::OptionsCase Choice::options_case() const {
  return Choice::OptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SkillOptions

// repeated .dnd5e.api.v1alpha1.Skill available = 1 [json_name = "available"];
inline int SkillOptions::_internal_available_size() const {
  return _internal_available().size();
}
inline int SkillOptions::available_size() const {
  return _internal_available_size();
}
inline void SkillOptions::clear_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::Skill SkillOptions::available(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SkillOptions.available)
  return static_cast<::dnd5e::api::v1alpha1::Skill>(_internal_available().Get(index));
}
inline void SkillOptions::set_available(int index, ::dnd5e::api::v1alpha1::Skill value) {
  _internal_mutable_available()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SkillOptions.available)
}
inline void SkillOptions::add_available(::dnd5e::api::v1alpha1::Skill value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_available()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.SkillOptions.available)
}
inline const ::google::protobuf::RepeatedField<int>& SkillOptions::available() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.SkillOptions.available)
  return _internal_available();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL SkillOptions::mutable_available()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.SkillOptions.available)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_available();
}
inline const ::google::protobuf::RepeatedField<int>& SkillOptions::_internal_available()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.available_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
SkillOptions::_internal_mutable_available() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.available_;
}

// -------------------------------------------------------------------

// EquipmentOptions

// repeated .dnd5e.api.v1alpha1.EquipmentBundle bundles = 1 [json_name = "bundles"];
inline int EquipmentOptions::_internal_bundles_size() const {
  return _internal_bundles().size();
}
inline int EquipmentOptions::bundles_size() const {
  return _internal_bundles_size();
}
inline void EquipmentOptions::clear_bundles() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bundles_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::EquipmentBundle* PROTOBUF_NONNULL EquipmentOptions::mutable_bundles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentOptions.bundles)
  return _internal_mutable_bundles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentBundle>* PROTOBUF_NONNULL EquipmentOptions::mutable_bundles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.EquipmentOptions.bundles)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_bundles();
}
inline const ::dnd5e::api::v1alpha1::EquipmentBundle& EquipmentOptions::bundles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentOptions.bundles)
  return _internal_bundles().Get(index);
}
inline ::dnd5e::api::v1alpha1::EquipmentBundle* PROTOBUF_NONNULL EquipmentOptions::add_bundles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::EquipmentBundle* _add =
      _internal_mutable_bundles()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.EquipmentOptions.bundles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentBundle>& EquipmentOptions::bundles() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.EquipmentOptions.bundles)
  return _internal_bundles();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentBundle>&
EquipmentOptions::_internal_bundles() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bundles_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentBundle>* PROTOBUF_NONNULL
EquipmentOptions::_internal_mutable_bundles() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.bundles_;
}

// -------------------------------------------------------------------

// EquipmentBundle

// string id = 1 [json_name = "id"];
inline void EquipmentBundle::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& EquipmentBundle::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentBundle.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EquipmentBundle::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentBundle.id)
}
inline ::std::string* PROTOBUF_NONNULL EquipmentBundle::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentBundle.id)
  return _s;
}
inline const ::std::string& EquipmentBundle::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void EquipmentBundle::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EquipmentBundle::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EquipmentBundle::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentBundle.id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void EquipmentBundle::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentBundle.id)
}

// string label = 2 [json_name = "label"];
inline void EquipmentBundle::clear_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& EquipmentBundle::label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentBundle.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EquipmentBundle::set_label(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentBundle.label)
}
inline ::std::string* PROTOBUF_NONNULL EquipmentBundle::mutable_label()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentBundle.label)
  return _s;
}
inline const ::std::string& EquipmentBundle::_internal_label() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.label_.Get();
}
inline void EquipmentBundle::_internal_set_label(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EquipmentBundle::_internal_mutable_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.label_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EquipmentBundle::release_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentBundle.label)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.label_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.label_.Set("", GetArena());
  }
  return released;
}
inline void EquipmentBundle::set_allocated_label(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.label_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentBundle.label)
}

// repeated .dnd5e.api.v1alpha1.EquipmentItem items = 3 [json_name = "items"];
inline int EquipmentBundle::_internal_items_size() const {
  return _internal_items().size();
}
inline int EquipmentBundle::items_size() const {
  return _internal_items_size();
}
inline void EquipmentBundle::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::EquipmentItem* PROTOBUF_NONNULL EquipmentBundle::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentBundle.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentItem>* PROTOBUF_NONNULL EquipmentBundle::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.EquipmentBundle.items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_items();
}
inline const ::dnd5e::api::v1alpha1::EquipmentItem& EquipmentBundle::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentBundle.items)
  return _internal_items().Get(index);
}
inline ::dnd5e::api::v1alpha1::EquipmentItem* PROTOBUF_NONNULL EquipmentBundle::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::EquipmentItem* _add =
      _internal_mutable_items()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.EquipmentBundle.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentItem>& EquipmentBundle::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.EquipmentBundle.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentItem>&
EquipmentBundle::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentItem>* PROTOBUF_NONNULL
EquipmentBundle::_internal_mutable_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.items_;
}

// repeated .dnd5e.api.v1alpha1.EquipmentCategoryChoice category_choices = 4 [json_name = "categoryChoices"];
inline int EquipmentBundle::_internal_category_choices_size() const {
  return _internal_category_choices().size();
}
inline int EquipmentBundle::category_choices_size() const {
  return _internal_category_choices_size();
}
inline void EquipmentBundle::clear_category_choices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_choices_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::EquipmentCategoryChoice* PROTOBUF_NONNULL EquipmentBundle::mutable_category_choices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentBundle.category_choices)
  return _internal_mutable_category_choices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentCategoryChoice>* PROTOBUF_NONNULL EquipmentBundle::mutable_category_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.EquipmentBundle.category_choices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_category_choices();
}
inline const ::dnd5e::api::v1alpha1::EquipmentCategoryChoice& EquipmentBundle::category_choices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentBundle.category_choices)
  return _internal_category_choices().Get(index);
}
inline ::dnd5e::api::v1alpha1::EquipmentCategoryChoice* PROTOBUF_NONNULL EquipmentBundle::add_category_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::EquipmentCategoryChoice* _add =
      _internal_mutable_category_choices()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.EquipmentBundle.category_choices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentCategoryChoice>& EquipmentBundle::category_choices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.EquipmentBundle.category_choices)
  return _internal_category_choices();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentCategoryChoice>&
EquipmentBundle::_internal_category_choices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.category_choices_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentCategoryChoice>* PROTOBUF_NONNULL
EquipmentBundle::_internal_mutable_category_choices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.category_choices_;
}

// -------------------------------------------------------------------

// EquipmentItem

// string selection_id = 1 [json_name = "selectionId"];
inline void EquipmentItem::clear_selection_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.selection_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& EquipmentItem::selection_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentItem.selection_id)
  return _internal_selection_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EquipmentItem::set_selection_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.selection_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentItem.selection_id)
}
inline ::std::string* PROTOBUF_NONNULL EquipmentItem::mutable_selection_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_selection_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentItem.selection_id)
  return _s;
}
inline const ::std::string& EquipmentItem::_internal_selection_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.selection_id_.Get();
}
inline void EquipmentItem::_internal_set_selection_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.selection_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EquipmentItem::_internal_mutable_selection_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.selection_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EquipmentItem::release_selection_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentItem.selection_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.selection_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.selection_id_.Set("", GetArena());
  }
  return released;
}
inline void EquipmentItem::set_allocated_selection_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.selection_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.selection_id_.IsDefault()) {
    _impl_.selection_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentItem.selection_id)
}

// int32 quantity = 2 [json_name = "quantity"];
inline void EquipmentItem::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t EquipmentItem::quantity() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentItem.quantity)
  return _internal_quantity();
}
inline void EquipmentItem::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentItem.quantity)
}
inline ::int32_t EquipmentItem::_internal_quantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_;
}
inline void EquipmentItem::_internal_set_quantity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = value;
}

// .dnd5e.api.v1alpha1.Weapon weapon = 3 [json_name = "weapon"];
inline bool EquipmentItem::has_weapon() const {
  return type_hint_case() == kWeapon;
}
inline void EquipmentItem::set_has_weapon() {
  _impl_._oneof_case_[0] = kWeapon;
}
inline void EquipmentItem::clear_weapon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_hint_case() == kWeapon) {
    _impl_.type_hint_.weapon_ = 0;
    clear_has_type_hint();
  }
}
inline ::dnd5e::api::v1alpha1::Weapon EquipmentItem::weapon() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentItem.weapon)
  return _internal_weapon();
}
inline void EquipmentItem::set_weapon(::dnd5e::api::v1alpha1::Weapon value) {
  if (type_hint_case() != kWeapon) {
    clear_type_hint();
    set_has_weapon();
  }
  _impl_.type_hint_.weapon_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentItem.weapon)
}
inline ::dnd5e::api::v1alpha1::Weapon EquipmentItem::_internal_weapon() const {
  if (type_hint_case() == kWeapon) {
    return static_cast<::dnd5e::api::v1alpha1::Weapon>(_impl_.type_hint_.weapon_);
  }
  return static_cast<::dnd5e::api::v1alpha1::Weapon>(0);
}

// .dnd5e.api.v1alpha1.Armor armor = 4 [json_name = "armor"];
inline bool EquipmentItem::has_armor() const {
  return type_hint_case() == kArmor;
}
inline void EquipmentItem::set_has_armor() {
  _impl_._oneof_case_[0] = kArmor;
}
inline void EquipmentItem::clear_armor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_hint_case() == kArmor) {
    _impl_.type_hint_.armor_ = 0;
    clear_has_type_hint();
  }
}
inline ::dnd5e::api::v1alpha1::Armor EquipmentItem::armor() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentItem.armor)
  return _internal_armor();
}
inline void EquipmentItem::set_armor(::dnd5e::api::v1alpha1::Armor value) {
  if (type_hint_case() != kArmor) {
    clear_type_hint();
    set_has_armor();
  }
  _impl_.type_hint_.armor_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentItem.armor)
}
inline ::dnd5e::api::v1alpha1::Armor EquipmentItem::_internal_armor() const {
  if (type_hint_case() == kArmor) {
    return static_cast<::dnd5e::api::v1alpha1::Armor>(_impl_.type_hint_.armor_);
  }
  return static_cast<::dnd5e::api::v1alpha1::Armor>(0);
}

// .dnd5e.api.v1alpha1.Tool tool = 5 [json_name = "tool"];
inline bool EquipmentItem::has_tool() const {
  return type_hint_case() == kTool;
}
inline void EquipmentItem::set_has_tool() {
  _impl_._oneof_case_[0] = kTool;
}
inline void EquipmentItem::clear_tool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_hint_case() == kTool) {
    _impl_.type_hint_.tool_ = 0;
    clear_has_type_hint();
  }
}
inline ::dnd5e::api::v1alpha1::Tool EquipmentItem::tool() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentItem.tool)
  return _internal_tool();
}
inline void EquipmentItem::set_tool(::dnd5e::api::v1alpha1::Tool value) {
  if (type_hint_case() != kTool) {
    clear_type_hint();
    set_has_tool();
  }
  _impl_.type_hint_.tool_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentItem.tool)
}
inline ::dnd5e::api::v1alpha1::Tool EquipmentItem::_internal_tool() const {
  if (type_hint_case() == kTool) {
    return static_cast<::dnd5e::api::v1alpha1::Tool>(_impl_.type_hint_.tool_);
  }
  return static_cast<::dnd5e::api::v1alpha1::Tool>(0);
}

// .dnd5e.api.v1alpha1.Pack pack = 6 [json_name = "pack"];
inline bool EquipmentItem::has_pack() const {
  return type_hint_case() == kPack;
}
inline void EquipmentItem::set_has_pack() {
  _impl_._oneof_case_[0] = kPack;
}
inline void EquipmentItem::clear_pack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_hint_case() == kPack) {
    _impl_.type_hint_.pack_ = 0;
    clear_has_type_hint();
  }
}
inline ::dnd5e::api::v1alpha1::Pack EquipmentItem::pack() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentItem.pack)
  return _internal_pack();
}
inline void EquipmentItem::set_pack(::dnd5e::api::v1alpha1::Pack value) {
  if (type_hint_case() != kPack) {
    clear_type_hint();
    set_has_pack();
  }
  _impl_.type_hint_.pack_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentItem.pack)
}
inline ::dnd5e::api::v1alpha1::Pack EquipmentItem::_internal_pack() const {
  if (type_hint_case() == kPack) {
    return static_cast<::dnd5e::api::v1alpha1::Pack>(_impl_.type_hint_.pack_);
  }
  return static_cast<::dnd5e::api::v1alpha1::Pack>(0);
}

// .dnd5e.api.v1alpha1.Ammunition ammunition = 7 [json_name = "ammunition"];
inline bool EquipmentItem::has_ammunition() const {
  return type_hint_case() == kAmmunition;
}
inline void EquipmentItem::set_has_ammunition() {
  _impl_._oneof_case_[0] = kAmmunition;
}
inline void EquipmentItem::clear_ammunition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_hint_case() == kAmmunition) {
    _impl_.type_hint_.ammunition_ = 0;
    clear_has_type_hint();
  }
}
inline ::dnd5e::api::v1alpha1::Ammunition EquipmentItem::ammunition() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentItem.ammunition)
  return _internal_ammunition();
}
inline void EquipmentItem::set_ammunition(::dnd5e::api::v1alpha1::Ammunition value) {
  if (type_hint_case() != kAmmunition) {
    clear_type_hint();
    set_has_ammunition();
  }
  _impl_.type_hint_.ammunition_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentItem.ammunition)
}
inline ::dnd5e::api::v1alpha1::Ammunition EquipmentItem::_internal_ammunition() const {
  if (type_hint_case() == kAmmunition) {
    return static_cast<::dnd5e::api::v1alpha1::Ammunition>(_impl_.type_hint_.ammunition_);
  }
  return static_cast<::dnd5e::api::v1alpha1::Ammunition>(0);
}

inline bool EquipmentItem::has_type_hint() const {
  return type_hint_case() != TYPE_HINT_NOT_SET;
}
inline void EquipmentItem::clear_has_type_hint() {
  _impl_._oneof_case_[0] = TYPE_HINT_NOT_SET;
}
inline EquipmentItem::TypeHintCase EquipmentItem::type_hint_case() const {
  return EquipmentItem::TypeHintCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EquipmentCategoryChoice

// int32 choose = 1 [json_name = "choose"];
inline void EquipmentCategoryChoice::clear_choose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choose_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int32_t EquipmentCategoryChoice::choose() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentCategoryChoice.choose)
  return _internal_choose();
}
inline void EquipmentCategoryChoice::set_choose(::int32_t value) {
  _internal_set_choose(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentCategoryChoice.choose)
}
inline ::int32_t EquipmentCategoryChoice::_internal_choose() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.choose_;
}
inline void EquipmentCategoryChoice::_internal_set_choose(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choose_ = value;
}

// repeated .dnd5e.api.v1alpha1.WeaponCategory weapon_categories = 2 [json_name = "weaponCategories"];
inline int EquipmentCategoryChoice::_internal_weapon_categories_size() const {
  return _internal_weapon_categories().size();
}
inline int EquipmentCategoryChoice::weapon_categories_size() const {
  return _internal_weapon_categories_size();
}
inline void EquipmentCategoryChoice::clear_weapon_categories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapon_categories_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::WeaponCategory EquipmentCategoryChoice::weapon_categories(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentCategoryChoice.weapon_categories)
  return static_cast<::dnd5e::api::v1alpha1::WeaponCategory>(_internal_weapon_categories().Get(index));
}
inline void EquipmentCategoryChoice::set_weapon_categories(int index, ::dnd5e::api::v1alpha1::WeaponCategory value) {
  _internal_mutable_weapon_categories()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentCategoryChoice.weapon_categories)
}
inline void EquipmentCategoryChoice::add_weapon_categories(::dnd5e::api::v1alpha1::WeaponCategory value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_weapon_categories()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.EquipmentCategoryChoice.weapon_categories)
}
inline const ::google::protobuf::RepeatedField<int>& EquipmentCategoryChoice::weapon_categories() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.EquipmentCategoryChoice.weapon_categories)
  return _internal_weapon_categories();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL EquipmentCategoryChoice::mutable_weapon_categories()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.EquipmentCategoryChoice.weapon_categories)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_weapon_categories();
}
inline const ::google::protobuf::RepeatedField<int>& EquipmentCategoryChoice::_internal_weapon_categories()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.weapon_categories_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
EquipmentCategoryChoice::_internal_mutable_weapon_categories() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.weapon_categories_;
}

// repeated .dnd5e.api.v1alpha1.ArmorCategory armor_categories = 3 [json_name = "armorCategories"];
inline int EquipmentCategoryChoice::_internal_armor_categories_size() const {
  return _internal_armor_categories().size();
}
inline int EquipmentCategoryChoice::armor_categories_size() const {
  return _internal_armor_categories_size();
}
inline void EquipmentCategoryChoice::clear_armor_categories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.armor_categories_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::ArmorCategory EquipmentCategoryChoice::armor_categories(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentCategoryChoice.armor_categories)
  return static_cast<::dnd5e::api::v1alpha1::ArmorCategory>(_internal_armor_categories().Get(index));
}
inline void EquipmentCategoryChoice::set_armor_categories(int index, ::dnd5e::api::v1alpha1::ArmorCategory value) {
  _internal_mutable_armor_categories()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentCategoryChoice.armor_categories)
}
inline void EquipmentCategoryChoice::add_armor_categories(::dnd5e::api::v1alpha1::ArmorCategory value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_armor_categories()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.EquipmentCategoryChoice.armor_categories)
}
inline const ::google::protobuf::RepeatedField<int>& EquipmentCategoryChoice::armor_categories() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.EquipmentCategoryChoice.armor_categories)
  return _internal_armor_categories();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL EquipmentCategoryChoice::mutable_armor_categories()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.EquipmentCategoryChoice.armor_categories)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_armor_categories();
}
inline const ::google::protobuf::RepeatedField<int>& EquipmentCategoryChoice::_internal_armor_categories()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.armor_categories_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
EquipmentCategoryChoice::_internal_mutable_armor_categories() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.armor_categories_;
}

// repeated .dnd5e.api.v1alpha1.ToolCategory tool_categories = 4 [json_name = "toolCategories"];
inline int EquipmentCategoryChoice::_internal_tool_categories_size() const {
  return _internal_tool_categories().size();
}
inline int EquipmentCategoryChoice::tool_categories_size() const {
  return _internal_tool_categories_size();
}
inline void EquipmentCategoryChoice::clear_tool_categories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tool_categories_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::ToolCategory EquipmentCategoryChoice::tool_categories(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentCategoryChoice.tool_categories)
  return static_cast<::dnd5e::api::v1alpha1::ToolCategory>(_internal_tool_categories().Get(index));
}
inline void EquipmentCategoryChoice::set_tool_categories(int index, ::dnd5e::api::v1alpha1::ToolCategory value) {
  _internal_mutable_tool_categories()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentCategoryChoice.tool_categories)
}
inline void EquipmentCategoryChoice::add_tool_categories(::dnd5e::api::v1alpha1::ToolCategory value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_tool_categories()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.EquipmentCategoryChoice.tool_categories)
}
inline const ::google::protobuf::RepeatedField<int>& EquipmentCategoryChoice::tool_categories() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.EquipmentCategoryChoice.tool_categories)
  return _internal_tool_categories();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL EquipmentCategoryChoice::mutable_tool_categories()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.EquipmentCategoryChoice.tool_categories)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tool_categories();
}
inline const ::google::protobuf::RepeatedField<int>& EquipmentCategoryChoice::_internal_tool_categories()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tool_categories_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
EquipmentCategoryChoice::_internal_mutable_tool_categories() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tool_categories_;
}

// string label = 5 [json_name = "label"];
inline void EquipmentCategoryChoice::clear_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& EquipmentCategoryChoice::label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentCategoryChoice.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EquipmentCategoryChoice::set_label(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentCategoryChoice.label)
}
inline ::std::string* PROTOBUF_NONNULL EquipmentCategoryChoice::mutable_label()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentCategoryChoice.label)
  return _s;
}
inline const ::std::string& EquipmentCategoryChoice::_internal_label() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.label_.Get();
}
inline void EquipmentCategoryChoice::_internal_set_label(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EquipmentCategoryChoice::_internal_mutable_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.label_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EquipmentCategoryChoice::release_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentCategoryChoice.label)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.label_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.label_.Set("", GetArena());
  }
  return released;
}
inline void EquipmentCategoryChoice::set_allocated_label(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.label_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentCategoryChoice.label)
}

// -------------------------------------------------------------------

// LanguageOptions

// repeated .dnd5e.api.v1alpha1.Language available = 1 [json_name = "available"];
inline int LanguageOptions::_internal_available_size() const {
  return _internal_available().size();
}
inline int LanguageOptions::available_size() const {
  return _internal_available_size();
}
inline void LanguageOptions::clear_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::Language LanguageOptions::available(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.LanguageOptions.available)
  return static_cast<::dnd5e::api::v1alpha1::Language>(_internal_available().Get(index));
}
inline void LanguageOptions::set_available(int index, ::dnd5e::api::v1alpha1::Language value) {
  _internal_mutable_available()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.LanguageOptions.available)
}
inline void LanguageOptions::add_available(::dnd5e::api::v1alpha1::Language value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_available()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.LanguageOptions.available)
}
inline const ::google::protobuf::RepeatedField<int>& LanguageOptions::available() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.LanguageOptions.available)
  return _internal_available();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL LanguageOptions::mutable_available()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.LanguageOptions.available)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_available();
}
inline const ::google::protobuf::RepeatedField<int>& LanguageOptions::_internal_available()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.available_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
LanguageOptions::_internal_mutable_available() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.available_;
}

// -------------------------------------------------------------------

// ToolOptions

// repeated .dnd5e.api.v1alpha1.Tool available = 1 [json_name = "available"];
inline int ToolOptions::_internal_available_size() const {
  return _internal_available().size();
}
inline int ToolOptions::available_size() const {
  return _internal_available_size();
}
inline void ToolOptions::clear_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::Tool ToolOptions::available(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ToolOptions.available)
  return static_cast<::dnd5e::api::v1alpha1::Tool>(_internal_available().Get(index));
}
inline void ToolOptions::set_available(int index, ::dnd5e::api::v1alpha1::Tool value) {
  _internal_mutable_available()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ToolOptions.available)
}
inline void ToolOptions::add_available(::dnd5e::api::v1alpha1::Tool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_available()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ToolOptions.available)
}
inline const ::google::protobuf::RepeatedField<int>& ToolOptions::available() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ToolOptions.available)
  return _internal_available();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL ToolOptions::mutable_available()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ToolOptions.available)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_available();
}
inline const ::google::protobuf::RepeatedField<int>& ToolOptions::_internal_available()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.available_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
ToolOptions::_internal_mutable_available() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.available_;
}

// -------------------------------------------------------------------

// FightingStyleOptions

// repeated .dnd5e.api.v1alpha1.FightingStyle available = 1 [json_name = "available"];
inline int FightingStyleOptions::_internal_available_size() const {
  return _internal_available().size();
}
inline int FightingStyleOptions::available_size() const {
  return _internal_available_size();
}
inline void FightingStyleOptions::clear_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::FightingStyle FightingStyleOptions::available(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FightingStyleOptions.available)
  return static_cast<::dnd5e::api::v1alpha1::FightingStyle>(_internal_available().Get(index));
}
inline void FightingStyleOptions::set_available(int index, ::dnd5e::api::v1alpha1::FightingStyle value) {
  _internal_mutable_available()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FightingStyleOptions.available)
}
inline void FightingStyleOptions::add_available(::dnd5e::api::v1alpha1::FightingStyle value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_available()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.FightingStyleOptions.available)
}
inline const ::google::protobuf::RepeatedField<int>& FightingStyleOptions::available() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.FightingStyleOptions.available)
  return _internal_available();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL FightingStyleOptions::mutable_available()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.FightingStyleOptions.available)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_available();
}
inline const ::google::protobuf::RepeatedField<int>& FightingStyleOptions::_internal_available()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.available_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
FightingStyleOptions::_internal_mutable_available() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.available_;
}

// -------------------------------------------------------------------

// SpellOptions

// repeated .dnd5e.api.v1alpha1.Spell available = 1 [json_name = "available"];
inline int SpellOptions::_internal_available_size() const {
  return _internal_available().size();
}
inline int SpellOptions::available_size() const {
  return _internal_available_size();
}
inline void SpellOptions::clear_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::Spell SpellOptions::available(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellOptions.available)
  return static_cast<::dnd5e::api::v1alpha1::Spell>(_internal_available().Get(index));
}
inline void SpellOptions::set_available(int index, ::dnd5e::api::v1alpha1::Spell value) {
  _internal_mutable_available()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellOptions.available)
}
inline void SpellOptions::add_available(::dnd5e::api::v1alpha1::Spell value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_available()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.SpellOptions.available)
}
inline const ::google::protobuf::RepeatedField<int>& SpellOptions::available() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.SpellOptions.available)
  return _internal_available();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL SpellOptions::mutable_available()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.SpellOptions.available)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_available();
}
inline const ::google::protobuf::RepeatedField<int>& SpellOptions::_internal_available()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.available_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
SpellOptions::_internal_mutable_available() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.available_;
}

// int32 spell_level = 2 [json_name = "spellLevel"];
inline void SpellOptions::clear_spell_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spell_level_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t SpellOptions::spell_level() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellOptions.spell_level)
  return _internal_spell_level();
}
inline void SpellOptions::set_spell_level(::int32_t value) {
  _internal_set_spell_level(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellOptions.spell_level)
}
inline ::int32_t SpellOptions::_internal_spell_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spell_level_;
}
inline void SpellOptions::_internal_set_spell_level(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spell_level_ = value;
}

// .dnd5e.api.v1alpha1.SpellSelectionType selection_type = 3 [json_name = "selectionType"];
inline void SpellOptions::clear_selection_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.selection_type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::SpellSelectionType SpellOptions::selection_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellOptions.selection_type)
  return _internal_selection_type();
}
inline void SpellOptions::set_selection_type(::dnd5e::api::v1alpha1::SpellSelectionType value) {
  _internal_set_selection_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellOptions.selection_type)
}
inline ::dnd5e::api::v1alpha1::SpellSelectionType SpellOptions::_internal_selection_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::SpellSelectionType>(_impl_.selection_type_);
}
inline void SpellOptions::_internal_set_selection_type(::dnd5e::api::v1alpha1::SpellSelectionType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.selection_type_ = value;
}

// -------------------------------------------------------------------

// ExpertiseOptions

// repeated .dnd5e.api.v1alpha1.Skill available_skills = 1 [json_name = "availableSkills"];
inline int ExpertiseOptions::_internal_available_skills_size() const {
  return _internal_available_skills().size();
}
inline int ExpertiseOptions::available_skills_size() const {
  return _internal_available_skills_size();
}
inline void ExpertiseOptions::clear_available_skills() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_skills_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::Skill ExpertiseOptions::available_skills(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ExpertiseOptions.available_skills)
  return static_cast<::dnd5e::api::v1alpha1::Skill>(_internal_available_skills().Get(index));
}
inline void ExpertiseOptions::set_available_skills(int index, ::dnd5e::api::v1alpha1::Skill value) {
  _internal_mutable_available_skills()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ExpertiseOptions.available_skills)
}
inline void ExpertiseOptions::add_available_skills(::dnd5e::api::v1alpha1::Skill value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_available_skills()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ExpertiseOptions.available_skills)
}
inline const ::google::protobuf::RepeatedField<int>& ExpertiseOptions::available_skills() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ExpertiseOptions.available_skills)
  return _internal_available_skills();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL ExpertiseOptions::mutable_available_skills()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ExpertiseOptions.available_skills)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_available_skills();
}
inline const ::google::protobuf::RepeatedField<int>& ExpertiseOptions::_internal_available_skills()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.available_skills_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
ExpertiseOptions::_internal_mutable_available_skills() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.available_skills_;
}

// repeated .dnd5e.api.v1alpha1.Tool available_tools = 2 [json_name = "availableTools"];
inline int ExpertiseOptions::_internal_available_tools_size() const {
  return _internal_available_tools().size();
}
inline int ExpertiseOptions::available_tools_size() const {
  return _internal_available_tools_size();
}
inline void ExpertiseOptions::clear_available_tools() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_tools_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::Tool ExpertiseOptions::available_tools(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ExpertiseOptions.available_tools)
  return static_cast<::dnd5e::api::v1alpha1::Tool>(_internal_available_tools().Get(index));
}
inline void ExpertiseOptions::set_available_tools(int index, ::dnd5e::api::v1alpha1::Tool value) {
  _internal_mutable_available_tools()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ExpertiseOptions.available_tools)
}
inline void ExpertiseOptions::add_available_tools(::dnd5e::api::v1alpha1::Tool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_available_tools()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ExpertiseOptions.available_tools)
}
inline const ::google::protobuf::RepeatedField<int>& ExpertiseOptions::available_tools() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ExpertiseOptions.available_tools)
  return _internal_available_tools();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL ExpertiseOptions::mutable_available_tools()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ExpertiseOptions.available_tools)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_available_tools();
}
inline const ::google::protobuf::RepeatedField<int>& ExpertiseOptions::_internal_available_tools()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.available_tools_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
ExpertiseOptions::_internal_mutable_available_tools() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.available_tools_;
}

// -------------------------------------------------------------------

// ChoiceSubmission

// string choice_id = 1 [json_name = "choiceId"];
inline void ChoiceSubmission::clear_choice_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choice_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& ChoiceSubmission::choice_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSubmission.choice_id)
  return _internal_choice_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChoiceSubmission::set_choice_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.choice_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceSubmission.choice_id)
}
inline ::std::string* PROTOBUF_NONNULL ChoiceSubmission::mutable_choice_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_choice_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSubmission.choice_id)
  return _s;
}
inline const ::std::string& ChoiceSubmission::_internal_choice_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.choice_id_.Get();
}
inline void ChoiceSubmission::_internal_set_choice_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choice_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChoiceSubmission::_internal_mutable_choice_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.choice_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChoiceSubmission::release_choice_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceSubmission.choice_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.choice_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.choice_id_.Set("", GetArena());
  }
  return released;
}
inline void ChoiceSubmission::set_allocated_choice_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.choice_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.choice_id_.IsDefault()) {
    _impl_.choice_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.choice_id)
}

// .dnd5e.api.v1alpha1.ChoiceCategory category = 2 [json_name = "category"];
inline void ChoiceSubmission::clear_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::dnd5e::api::v1alpha1::ChoiceCategory ChoiceSubmission::category() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSubmission.category)
  return _internal_category();
}
inline void ChoiceSubmission::set_category(::dnd5e::api::v1alpha1::ChoiceCategory value) {
  _internal_set_category(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceSubmission.category)
}
inline ::dnd5e::api::v1alpha1::ChoiceCategory ChoiceSubmission::_internal_category() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::ChoiceCategory>(_impl_.category_);
}
inline void ChoiceSubmission::_internal_set_category(::dnd5e::api::v1alpha1::ChoiceCategory value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_ = value;
}

// .dnd5e.api.v1alpha1.ChoiceSource source = 3 [json_name = "source"];
inline void ChoiceSubmission::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::dnd5e::api::v1alpha1::ChoiceSource ChoiceSubmission::source() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSubmission.source)
  return _internal_source();
}
inline void ChoiceSubmission::set_source(::dnd5e::api::v1alpha1::ChoiceSource value) {
  _internal_set_source(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceSubmission.source)
}
inline ::dnd5e::api::v1alpha1::ChoiceSource ChoiceSubmission::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::ChoiceSource>(_impl_.source_);
}
inline void ChoiceSubmission::_internal_set_source(::dnd5e::api::v1alpha1::ChoiceSource value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = value;
}

// string option_id = 4 [json_name = "optionId"];
inline void ChoiceSubmission::clear_option_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.option_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& ChoiceSubmission::option_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSubmission.option_id)
  return _internal_option_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChoiceSubmission::set_option_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.option_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceSubmission.option_id)
}
inline ::std::string* PROTOBUF_NONNULL ChoiceSubmission::mutable_option_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_option_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSubmission.option_id)
  return _s;
}
inline const ::std::string& ChoiceSubmission::_internal_option_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.option_id_.Get();
}
inline void ChoiceSubmission::_internal_set_option_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.option_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChoiceSubmission::_internal_mutable_option_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.option_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChoiceSubmission::release_option_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceSubmission.option_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.option_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.option_id_.Set("", GetArena());
  }
  return released;
}
inline void ChoiceSubmission::set_allocated_option_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.option_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.option_id_.IsDefault()) {
    _impl_.option_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.option_id)
}

// repeated string selection_ids = 5 [json_name = "selectionIds"];
inline int ChoiceSubmission::_internal_selection_ids_size() const {
  return _internal_selection_ids().size();
}
inline int ChoiceSubmission::selection_ids_size() const {
  return _internal_selection_ids_size();
}
inline void ChoiceSubmission::clear_selection_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.selection_ids_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL ChoiceSubmission::add_selection_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_selection_ids()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.ChoiceSubmission.selection_ids)
  return _s;
}
inline const ::std::string& ChoiceSubmission::selection_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSubmission.selection_ids)
  return _internal_selection_ids().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL ChoiceSubmission::mutable_selection_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSubmission.selection_ids)
  return _internal_mutable_selection_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ChoiceSubmission::set_selection_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_selection_ids()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceSubmission.selection_ids)
}
template <typename Arg_, typename... Args_>
inline void ChoiceSubmission::add_selection_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_selection_ids(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ChoiceSubmission.selection_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& ChoiceSubmission::selection_ids()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ChoiceSubmission.selection_ids)
  return _internal_selection_ids();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ChoiceSubmission::mutable_selection_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ChoiceSubmission.selection_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_selection_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ChoiceSubmission::_internal_selection_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.selection_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ChoiceSubmission::_internal_mutable_selection_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.selection_ids_;
}

// .dnd5e.api.v1alpha1.SkillSelection skills = 6 [json_name = "skills"];
inline bool ChoiceSubmission::has_skills() const {
  return selection_case() == kSkills;
}
inline bool ChoiceSubmission::_internal_has_skills() const {
  return selection_case() == kSkills;
}
inline void ChoiceSubmission::set_has_skills() {
  _impl_._oneof_case_[0] = kSkills;
}
inline void ChoiceSubmission::clear_skills() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kSkills) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.skills_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.skills_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE ChoiceSubmission::release_skills() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceSubmission.skills)
  if (selection_case() == kSkills) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SkillSelection*>(_impl_.selection_.skills_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.skills_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::SkillSelection& ChoiceSubmission::_internal_skills() const {
  return selection_case() == kSkills ? static_cast<const ::dnd5e::api::v1alpha1::SkillSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::SkillSelection*>(_impl_.selection_.skills_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::SkillSelection&>(::dnd5e::api::v1alpha1::_SkillSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SkillSelection& ChoiceSubmission::skills() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSubmission.skills)
  return _internal_skills();
}
inline ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE ChoiceSubmission::unsafe_arena_release_skills() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceSubmission.skills)
  if (selection_case() == kSkills) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SkillSelection*>(_impl_.selection_.skills_);
    _impl_.selection_.skills_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceSubmission::unsafe_arena_set_allocated_skills(
    ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_skills();
    _impl_.selection_.skills_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.skills)
}
inline ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NONNULL ChoiceSubmission::_internal_mutable_skills() {
  if (selection_case() != kSkills) {
    clear_selection();
    set_has_skills();
    _impl_.selection_.skills_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SkillSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::SkillSelection*>(_impl_.selection_.skills_);
}
inline ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NONNULL ChoiceSubmission::mutable_skills()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::SkillSelection* _msg = _internal_mutable_skills();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSubmission.skills)
  return _msg;
}

// .dnd5e.api.v1alpha1.EquipmentSelection equipment = 7 [json_name = "equipment"];
inline bool ChoiceSubmission::has_equipment() const {
  return selection_case() == kEquipment;
}
inline bool ChoiceSubmission::_internal_has_equipment() const {
  return selection_case() == kEquipment;
}
inline void ChoiceSubmission::set_has_equipment() {
  _impl_._oneof_case_[0] = kEquipment;
}
inline void ChoiceSubmission::clear_equipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kEquipment) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.equipment_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.equipment_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE ChoiceSubmission::release_equipment() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceSubmission.equipment)
  if (selection_case() == kEquipment) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSelection*>(_impl_.selection_.equipment_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.equipment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::EquipmentSelection& ChoiceSubmission::_internal_equipment() const {
  return selection_case() == kEquipment ? static_cast<const ::dnd5e::api::v1alpha1::EquipmentSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSelection*>(_impl_.selection_.equipment_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::EquipmentSelection&>(::dnd5e::api::v1alpha1::_EquipmentSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::EquipmentSelection& ChoiceSubmission::equipment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSubmission.equipment)
  return _internal_equipment();
}
inline ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE ChoiceSubmission::unsafe_arena_release_equipment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceSubmission.equipment)
  if (selection_case() == kEquipment) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSelection*>(_impl_.selection_.equipment_);
    _impl_.selection_.equipment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceSubmission::unsafe_arena_set_allocated_equipment(
    ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_equipment();
    _impl_.selection_.equipment_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.equipment)
}
inline ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NONNULL ChoiceSubmission::_internal_mutable_equipment() {
  if (selection_case() != kEquipment) {
    clear_selection();
    set_has_equipment();
    _impl_.selection_.equipment_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::EquipmentSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSelection*>(_impl_.selection_.equipment_);
}
inline ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NONNULL ChoiceSubmission::mutable_equipment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::EquipmentSelection* _msg = _internal_mutable_equipment();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSubmission.equipment)
  return _msg;
}

// .dnd5e.api.v1alpha1.LanguageSelection languages = 8 [json_name = "languages"];
inline bool ChoiceSubmission::has_languages() const {
  return selection_case() == kLanguages;
}
inline bool ChoiceSubmission::_internal_has_languages() const {
  return selection_case() == kLanguages;
}
inline void ChoiceSubmission::set_has_languages() {
  _impl_._oneof_case_[0] = kLanguages;
}
inline void ChoiceSubmission::clear_languages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kLanguages) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.languages_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.languages_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE ChoiceSubmission::release_languages() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceSubmission.languages)
  if (selection_case() == kLanguages) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::LanguageSelection*>(_impl_.selection_.languages_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.languages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::LanguageSelection& ChoiceSubmission::_internal_languages() const {
  return selection_case() == kLanguages ? static_cast<const ::dnd5e::api::v1alpha1::LanguageSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::LanguageSelection*>(_impl_.selection_.languages_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::LanguageSelection&>(::dnd5e::api::v1alpha1::_LanguageSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::LanguageSelection& ChoiceSubmission::languages() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSubmission.languages)
  return _internal_languages();
}
inline ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE ChoiceSubmission::unsafe_arena_release_languages() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceSubmission.languages)
  if (selection_case() == kLanguages) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::LanguageSelection*>(_impl_.selection_.languages_);
    _impl_.selection_.languages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceSubmission::unsafe_arena_set_allocated_languages(
    ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_languages();
    _impl_.selection_.languages_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.languages)
}
inline ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NONNULL ChoiceSubmission::_internal_mutable_languages() {
  if (selection_case() != kLanguages) {
    clear_selection();
    set_has_languages();
    _impl_.selection_.languages_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::LanguageSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::LanguageSelection*>(_impl_.selection_.languages_);
}
inline ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NONNULL ChoiceSubmission::mutable_languages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::LanguageSelection* _msg = _internal_mutable_languages();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSubmission.languages)
  return _msg;
}

// .dnd5e.api.v1alpha1.ToolSelection tools = 9 [json_name = "tools"];
inline bool ChoiceSubmission::has_tools() const {
  return selection_case() == kTools;
}
inline bool ChoiceSubmission::_internal_has_tools() const {
  return selection_case() == kTools;
}
inline void ChoiceSubmission::set_has_tools() {
  _impl_._oneof_case_[0] = kTools;
}
inline void ChoiceSubmission::clear_tools() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kTools) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.tools_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.tools_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE ChoiceSubmission::release_tools() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceSubmission.tools)
  if (selection_case() == kTools) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ToolSelection*>(_impl_.selection_.tools_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.tools_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::ToolSelection& ChoiceSubmission::_internal_tools() const {
  return selection_case() == kTools ? static_cast<const ::dnd5e::api::v1alpha1::ToolSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::ToolSelection*>(_impl_.selection_.tools_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::ToolSelection&>(::dnd5e::api::v1alpha1::_ToolSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ToolSelection& ChoiceSubmission::tools() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSubmission.tools)
  return _internal_tools();
}
inline ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE ChoiceSubmission::unsafe_arena_release_tools() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceSubmission.tools)
  if (selection_case() == kTools) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ToolSelection*>(_impl_.selection_.tools_);
    _impl_.selection_.tools_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceSubmission::unsafe_arena_set_allocated_tools(
    ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_tools();
    _impl_.selection_.tools_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.tools)
}
inline ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NONNULL ChoiceSubmission::_internal_mutable_tools() {
  if (selection_case() != kTools) {
    clear_selection();
    set_has_tools();
    _impl_.selection_.tools_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ToolSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::ToolSelection*>(_impl_.selection_.tools_);
}
inline ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NONNULL ChoiceSubmission::mutable_tools()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::ToolSelection* _msg = _internal_mutable_tools();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSubmission.tools)
  return _msg;
}

// .dnd5e.api.v1alpha1.FightingStyleSelection fighting_style = 10 [json_name = "fightingStyle"];
inline bool ChoiceSubmission::has_fighting_style() const {
  return selection_case() == kFightingStyle;
}
inline bool ChoiceSubmission::_internal_has_fighting_style() const {
  return selection_case() == kFightingStyle;
}
inline void ChoiceSubmission::set_has_fighting_style() {
  _impl_._oneof_case_[0] = kFightingStyle;
}
inline void ChoiceSubmission::clear_fighting_style() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kFightingStyle) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.fighting_style_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.fighting_style_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE ChoiceSubmission::release_fighting_style() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceSubmission.fighting_style)
  if (selection_case() == kFightingStyle) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::FightingStyleSelection*>(_impl_.selection_.fighting_style_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.fighting_style_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::FightingStyleSelection& ChoiceSubmission::_internal_fighting_style() const {
  return selection_case() == kFightingStyle ? static_cast<const ::dnd5e::api::v1alpha1::FightingStyleSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::FightingStyleSelection*>(_impl_.selection_.fighting_style_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::FightingStyleSelection&>(::dnd5e::api::v1alpha1::_FightingStyleSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::FightingStyleSelection& ChoiceSubmission::fighting_style() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSubmission.fighting_style)
  return _internal_fighting_style();
}
inline ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE ChoiceSubmission::unsafe_arena_release_fighting_style() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceSubmission.fighting_style)
  if (selection_case() == kFightingStyle) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::FightingStyleSelection*>(_impl_.selection_.fighting_style_);
    _impl_.selection_.fighting_style_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceSubmission::unsafe_arena_set_allocated_fighting_style(
    ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_fighting_style();
    _impl_.selection_.fighting_style_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.fighting_style)
}
inline ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NONNULL ChoiceSubmission::_internal_mutable_fighting_style() {
  if (selection_case() != kFightingStyle) {
    clear_selection();
    set_has_fighting_style();
    _impl_.selection_.fighting_style_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::FightingStyleSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::FightingStyleSelection*>(_impl_.selection_.fighting_style_);
}
inline ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NONNULL ChoiceSubmission::mutable_fighting_style()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::FightingStyleSelection* _msg = _internal_mutable_fighting_style();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSubmission.fighting_style)
  return _msg;
}

// .dnd5e.api.v1alpha1.SpellSelection spells = 11 [json_name = "spells"];
inline bool ChoiceSubmission::has_spells() const {
  return selection_case() == kSpells;
}
inline bool ChoiceSubmission::_internal_has_spells() const {
  return selection_case() == kSpells;
}
inline void ChoiceSubmission::set_has_spells() {
  _impl_._oneof_case_[0] = kSpells;
}
inline void ChoiceSubmission::clear_spells() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kSpells) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.spells_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.spells_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE ChoiceSubmission::release_spells() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceSubmission.spells)
  if (selection_case() == kSpells) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SpellSelection*>(_impl_.selection_.spells_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.spells_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::SpellSelection& ChoiceSubmission::_internal_spells() const {
  return selection_case() == kSpells ? static_cast<const ::dnd5e::api::v1alpha1::SpellSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::SpellSelection*>(_impl_.selection_.spells_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::SpellSelection&>(::dnd5e::api::v1alpha1::_SpellSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SpellSelection& ChoiceSubmission::spells() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSubmission.spells)
  return _internal_spells();
}
inline ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE ChoiceSubmission::unsafe_arena_release_spells() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceSubmission.spells)
  if (selection_case() == kSpells) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SpellSelection*>(_impl_.selection_.spells_);
    _impl_.selection_.spells_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceSubmission::unsafe_arena_set_allocated_spells(
    ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_spells();
    _impl_.selection_.spells_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.spells)
}
inline ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NONNULL ChoiceSubmission::_internal_mutable_spells() {
  if (selection_case() != kSpells) {
    clear_selection();
    set_has_spells();
    _impl_.selection_.spells_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SpellSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::SpellSelection*>(_impl_.selection_.spells_);
}
inline ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NONNULL ChoiceSubmission::mutable_spells()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::SpellSelection* _msg = _internal_mutable_spells();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSubmission.spells)
  return _msg;
}

// .dnd5e.api.v1alpha1.ExpertiseSelection expertise = 12 [json_name = "expertise"];
inline bool ChoiceSubmission::has_expertise() const {
  return selection_case() == kExpertise;
}
inline bool ChoiceSubmission::_internal_has_expertise() const {
  return selection_case() == kExpertise;
}
inline void ChoiceSubmission::set_has_expertise() {
  _impl_._oneof_case_[0] = kExpertise;
}
inline void ChoiceSubmission::clear_expertise() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kExpertise) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.expertise_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.expertise_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE ChoiceSubmission::release_expertise() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceSubmission.expertise)
  if (selection_case() == kExpertise) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ExpertiseSelection*>(_impl_.selection_.expertise_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.expertise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::ExpertiseSelection& ChoiceSubmission::_internal_expertise() const {
  return selection_case() == kExpertise ? static_cast<const ::dnd5e::api::v1alpha1::ExpertiseSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::ExpertiseSelection*>(_impl_.selection_.expertise_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::ExpertiseSelection&>(::dnd5e::api::v1alpha1::_ExpertiseSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ExpertiseSelection& ChoiceSubmission::expertise() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSubmission.expertise)
  return _internal_expertise();
}
inline ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE ChoiceSubmission::unsafe_arena_release_expertise() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceSubmission.expertise)
  if (selection_case() == kExpertise) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ExpertiseSelection*>(_impl_.selection_.expertise_);
    _impl_.selection_.expertise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceSubmission::unsafe_arena_set_allocated_expertise(
    ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_expertise();
    _impl_.selection_.expertise_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.expertise)
}
inline ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NONNULL ChoiceSubmission::_internal_mutable_expertise() {
  if (selection_case() != kExpertise) {
    clear_selection();
    set_has_expertise();
    _impl_.selection_.expertise_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ExpertiseSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::ExpertiseSelection*>(_impl_.selection_.expertise_);
}
inline ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NONNULL ChoiceSubmission::mutable_expertise()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::ExpertiseSelection* _msg = _internal_mutable_expertise();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSubmission.expertise)
  return _msg;
}

inline bool ChoiceSubmission::has_selection() const {
  return selection_case() != SELECTION_NOT_SET;
}
inline void ChoiceSubmission::clear_has_selection() {
  _impl_._oneof_case_[0] = SELECTION_NOT_SET;
}
inline ChoiceSubmission::SelectionCase ChoiceSubmission::selection_case() const {
  return ChoiceSubmission::SelectionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SkillSelection

// repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
inline int SkillSelection::_internal_skills_size() const {
  return _internal_skills().size();
}
inline int SkillSelection::skills_size() const {
  return _internal_skills_size();
}
inline void SkillSelection::clear_skills() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skills_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::Skill SkillSelection::skills(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SkillSelection.skills)
  return static_cast<::dnd5e::api::v1alpha1::Skill>(_internal_skills().Get(index));
}
inline void SkillSelection::set_skills(int index, ::dnd5e::api::v1alpha1::Skill value) {
  _internal_mutable_skills()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SkillSelection.skills)
}
inline void SkillSelection::add_skills(::dnd5e::api::v1alpha1::Skill value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_skills()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.SkillSelection.skills)
}
inline const ::google::protobuf::RepeatedField<int>& SkillSelection::skills() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.SkillSelection.skills)
  return _internal_skills();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL SkillSelection::mutable_skills()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.SkillSelection.skills)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_skills();
}
inline const ::google::protobuf::RepeatedField<int>& SkillSelection::_internal_skills()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skills_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
SkillSelection::_internal_mutable_skills() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.skills_;
}

// -------------------------------------------------------------------

// EquipmentSelection

// repeated .dnd5e.api.v1alpha1.EquipmentSelectionItem items = 1 [json_name = "items"];
inline int EquipmentSelection::_internal_items_size() const {
  return _internal_items().size();
}
inline int EquipmentSelection::items_size() const {
  return _internal_items_size();
}
inline void EquipmentSelection::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::EquipmentSelectionItem* PROTOBUF_NONNULL EquipmentSelection::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSelection.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentSelectionItem>* PROTOBUF_NONNULL EquipmentSelection::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.EquipmentSelection.items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_items();
}
inline const ::dnd5e::api::v1alpha1::EquipmentSelectionItem& EquipmentSelection::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSelection.items)
  return _internal_items().Get(index);
}
inline ::dnd5e::api::v1alpha1::EquipmentSelectionItem* PROTOBUF_NONNULL EquipmentSelection::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::EquipmentSelectionItem* _add =
      _internal_mutable_items()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.EquipmentSelection.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentSelectionItem>& EquipmentSelection::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.EquipmentSelection.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentSelectionItem>&
EquipmentSelection::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EquipmentSelectionItem>* PROTOBUF_NONNULL
EquipmentSelection::_internal_mutable_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// EquipmentSelectionItem

// .dnd5e.api.v1alpha1.Weapon weapon = 1 [json_name = "weapon"];
inline bool EquipmentSelectionItem::has_weapon() const {
  return equipment_case() == kWeapon;
}
inline void EquipmentSelectionItem::set_has_weapon() {
  _impl_._oneof_case_[0] = kWeapon;
}
inline void EquipmentSelectionItem::clear_weapon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (equipment_case() == kWeapon) {
    _impl_.equipment_.weapon_ = 0;
    clear_has_equipment();
  }
}
inline ::dnd5e::api::v1alpha1::Weapon EquipmentSelectionItem::weapon() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSelectionItem.weapon)
  return _internal_weapon();
}
inline void EquipmentSelectionItem::set_weapon(::dnd5e::api::v1alpha1::Weapon value) {
  if (equipment_case() != kWeapon) {
    clear_equipment();
    set_has_weapon();
  }
  _impl_.equipment_.weapon_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentSelectionItem.weapon)
}
inline ::dnd5e::api::v1alpha1::Weapon EquipmentSelectionItem::_internal_weapon() const {
  if (equipment_case() == kWeapon) {
    return static_cast<::dnd5e::api::v1alpha1::Weapon>(_impl_.equipment_.weapon_);
  }
  return static_cast<::dnd5e::api::v1alpha1::Weapon>(0);
}

// .dnd5e.api.v1alpha1.Armor armor = 2 [json_name = "armor"];
inline bool EquipmentSelectionItem::has_armor() const {
  return equipment_case() == kArmor;
}
inline void EquipmentSelectionItem::set_has_armor() {
  _impl_._oneof_case_[0] = kArmor;
}
inline void EquipmentSelectionItem::clear_armor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (equipment_case() == kArmor) {
    _impl_.equipment_.armor_ = 0;
    clear_has_equipment();
  }
}
inline ::dnd5e::api::v1alpha1::Armor EquipmentSelectionItem::armor() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSelectionItem.armor)
  return _internal_armor();
}
inline void EquipmentSelectionItem::set_armor(::dnd5e::api::v1alpha1::Armor value) {
  if (equipment_case() != kArmor) {
    clear_equipment();
    set_has_armor();
  }
  _impl_.equipment_.armor_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentSelectionItem.armor)
}
inline ::dnd5e::api::v1alpha1::Armor EquipmentSelectionItem::_internal_armor() const {
  if (equipment_case() == kArmor) {
    return static_cast<::dnd5e::api::v1alpha1::Armor>(_impl_.equipment_.armor_);
  }
  return static_cast<::dnd5e::api::v1alpha1::Armor>(0);
}

// .dnd5e.api.v1alpha1.Tool tool = 3 [json_name = "tool"];
inline bool EquipmentSelectionItem::has_tool() const {
  return equipment_case() == kTool;
}
inline void EquipmentSelectionItem::set_has_tool() {
  _impl_._oneof_case_[0] = kTool;
}
inline void EquipmentSelectionItem::clear_tool() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (equipment_case() == kTool) {
    _impl_.equipment_.tool_ = 0;
    clear_has_equipment();
  }
}
inline ::dnd5e::api::v1alpha1::Tool EquipmentSelectionItem::tool() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSelectionItem.tool)
  return _internal_tool();
}
inline void EquipmentSelectionItem::set_tool(::dnd5e::api::v1alpha1::Tool value) {
  if (equipment_case() != kTool) {
    clear_equipment();
    set_has_tool();
  }
  _impl_.equipment_.tool_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentSelectionItem.tool)
}
inline ::dnd5e::api::v1alpha1::Tool EquipmentSelectionItem::_internal_tool() const {
  if (equipment_case() == kTool) {
    return static_cast<::dnd5e::api::v1alpha1::Tool>(_impl_.equipment_.tool_);
  }
  return static_cast<::dnd5e::api::v1alpha1::Tool>(0);
}

// .dnd5e.api.v1alpha1.Pack pack = 4 [json_name = "pack"];
inline bool EquipmentSelectionItem::has_pack() const {
  return equipment_case() == kPack;
}
inline void EquipmentSelectionItem::set_has_pack() {
  _impl_._oneof_case_[0] = kPack;
}
inline void EquipmentSelectionItem::clear_pack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (equipment_case() == kPack) {
    _impl_.equipment_.pack_ = 0;
    clear_has_equipment();
  }
}
inline ::dnd5e::api::v1alpha1::Pack EquipmentSelectionItem::pack() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSelectionItem.pack)
  return _internal_pack();
}
inline void EquipmentSelectionItem::set_pack(::dnd5e::api::v1alpha1::Pack value) {
  if (equipment_case() != kPack) {
    clear_equipment();
    set_has_pack();
  }
  _impl_.equipment_.pack_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentSelectionItem.pack)
}
inline ::dnd5e::api::v1alpha1::Pack EquipmentSelectionItem::_internal_pack() const {
  if (equipment_case() == kPack) {
    return static_cast<::dnd5e::api::v1alpha1::Pack>(_impl_.equipment_.pack_);
  }
  return static_cast<::dnd5e::api::v1alpha1::Pack>(0);
}

// .dnd5e.api.v1alpha1.Ammunition ammunition = 5 [json_name = "ammunition"];
inline bool EquipmentSelectionItem::has_ammunition() const {
  return equipment_case() == kAmmunition;
}
inline void EquipmentSelectionItem::set_has_ammunition() {
  _impl_._oneof_case_[0] = kAmmunition;
}
inline void EquipmentSelectionItem::clear_ammunition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (equipment_case() == kAmmunition) {
    _impl_.equipment_.ammunition_ = 0;
    clear_has_equipment();
  }
}
inline ::dnd5e::api::v1alpha1::Ammunition EquipmentSelectionItem::ammunition() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSelectionItem.ammunition)
  return _internal_ammunition();
}
inline void EquipmentSelectionItem::set_ammunition(::dnd5e::api::v1alpha1::Ammunition value) {
  if (equipment_case() != kAmmunition) {
    clear_equipment();
    set_has_ammunition();
  }
  _impl_.equipment_.ammunition_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentSelectionItem.ammunition)
}
inline ::dnd5e::api::v1alpha1::Ammunition EquipmentSelectionItem::_internal_ammunition() const {
  if (equipment_case() == kAmmunition) {
    return static_cast<::dnd5e::api::v1alpha1::Ammunition>(_impl_.equipment_.ammunition_);
  }
  return static_cast<::dnd5e::api::v1alpha1::Ammunition>(0);
}

// string other_equipment_id = 6 [json_name = "otherEquipmentId"];
inline bool EquipmentSelectionItem::has_other_equipment_id() const {
  return equipment_case() == kOtherEquipmentId;
}
inline void EquipmentSelectionItem::set_has_other_equipment_id() {
  _impl_._oneof_case_[0] = kOtherEquipmentId;
}
inline void EquipmentSelectionItem::clear_other_equipment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (equipment_case() == kOtherEquipmentId) {
    _impl_.equipment_.other_equipment_id_.Destroy();
    clear_has_equipment();
  }
}
inline const ::std::string& EquipmentSelectionItem::other_equipment_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSelectionItem.other_equipment_id)
  return _internal_other_equipment_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EquipmentSelectionItem::set_other_equipment_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (equipment_case() != kOtherEquipmentId) {
    clear_equipment();

    set_has_other_equipment_id();
    _impl_.equipment_.other_equipment_id_.InitDefault();
  }
  _impl_.equipment_.other_equipment_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentSelectionItem.other_equipment_id)
}
inline ::std::string* PROTOBUF_NONNULL EquipmentSelectionItem::mutable_other_equipment_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (equipment_case() != kOtherEquipmentId) {
    clear_equipment();

    set_has_other_equipment_id();
    _impl_.equipment_.other_equipment_id_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_other_equipment_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSelectionItem.other_equipment_id)
  return _s;
}
inline const ::std::string& EquipmentSelectionItem::_internal_other_equipment_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (equipment_case() != kOtherEquipmentId) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.equipment_.other_equipment_id_.Get();
}
inline void EquipmentSelectionItem::_internal_set_other_equipment_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.equipment_.other_equipment_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EquipmentSelectionItem::_internal_mutable_other_equipment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.equipment_.other_equipment_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EquipmentSelectionItem::release_other_equipment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentSelectionItem.other_equipment_id)
  if (equipment_case() != kOtherEquipmentId) {
    return nullptr;
  }
  clear_has_equipment();
  return _impl_.equipment_.other_equipment_id_.Release();
}
inline void EquipmentSelectionItem::set_allocated_other_equipment_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_equipment()) {
    clear_equipment();
  }
  if (value != nullptr) {
    set_has_other_equipment_id();
    _impl_.equipment_.other_equipment_id_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentSelectionItem.other_equipment_id)
}

// int32 quantity = 7 [json_name = "quantity"];
inline void EquipmentSelectionItem::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t EquipmentSelectionItem::quantity() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSelectionItem.quantity)
  return _internal_quantity();
}
inline void EquipmentSelectionItem::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentSelectionItem.quantity)
}
inline ::int32_t EquipmentSelectionItem::_internal_quantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_;
}
inline void EquipmentSelectionItem::_internal_set_quantity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = value;
}

inline bool EquipmentSelectionItem::has_equipment() const {
  return equipment_case() != EQUIPMENT_NOT_SET;
}
inline void EquipmentSelectionItem::clear_has_equipment() {
  _impl_._oneof_case_[0] = EQUIPMENT_NOT_SET;
}
inline EquipmentSelectionItem::EquipmentCase EquipmentSelectionItem::equipment_case() const {
  return EquipmentSelectionItem::EquipmentCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LanguageSelection

// repeated .dnd5e.api.v1alpha1.Language languages = 1 [json_name = "languages"];
inline int LanguageSelection::_internal_languages_size() const {
  return _internal_languages().size();
}
inline int LanguageSelection::languages_size() const {
  return _internal_languages_size();
}
inline void LanguageSelection::clear_languages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.languages_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::Language LanguageSelection::languages(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.LanguageSelection.languages)
  return static_cast<::dnd5e::api::v1alpha1::Language>(_internal_languages().Get(index));
}
inline void LanguageSelection::set_languages(int index, ::dnd5e::api::v1alpha1::Language value) {
  _internal_mutable_languages()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.LanguageSelection.languages)
}
inline void LanguageSelection::add_languages(::dnd5e::api::v1alpha1::Language value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_languages()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.LanguageSelection.languages)
}
inline const ::google::protobuf::RepeatedField<int>& LanguageSelection::languages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.LanguageSelection.languages)
  return _internal_languages();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL LanguageSelection::mutable_languages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.LanguageSelection.languages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_languages();
}
inline const ::google::protobuf::RepeatedField<int>& LanguageSelection::_internal_languages()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.languages_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
LanguageSelection::_internal_mutable_languages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.languages_;
}

// -------------------------------------------------------------------

// ToolSelection

// repeated .dnd5e.api.v1alpha1.Tool tools = 1 [json_name = "tools"];
inline int ToolSelection::_internal_tools_size() const {
  return _internal_tools().size();
}
inline int ToolSelection::tools_size() const {
  return _internal_tools_size();
}
inline void ToolSelection::clear_tools() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tools_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::Tool ToolSelection::tools(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ToolSelection.tools)
  return static_cast<::dnd5e::api::v1alpha1::Tool>(_internal_tools().Get(index));
}
inline void ToolSelection::set_tools(int index, ::dnd5e::api::v1alpha1::Tool value) {
  _internal_mutable_tools()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ToolSelection.tools)
}
inline void ToolSelection::add_tools(::dnd5e::api::v1alpha1::Tool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_tools()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ToolSelection.tools)
}
inline const ::google::protobuf::RepeatedField<int>& ToolSelection::tools() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ToolSelection.tools)
  return _internal_tools();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL ToolSelection::mutable_tools()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ToolSelection.tools)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tools();
}
inline const ::google::protobuf::RepeatedField<int>& ToolSelection::_internal_tools()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tools_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
ToolSelection::_internal_mutable_tools() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tools_;
}

// -------------------------------------------------------------------

// FightingStyleSelection

// .dnd5e.api.v1alpha1.FightingStyle style = 1 [json_name = "style"];
inline void FightingStyleSelection::clear_style() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.style_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::FightingStyle FightingStyleSelection::style() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FightingStyleSelection.style)
  return _internal_style();
}
inline void FightingStyleSelection::set_style(::dnd5e::api::v1alpha1::FightingStyle value) {
  _internal_set_style(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FightingStyleSelection.style)
}
inline ::dnd5e::api::v1alpha1::FightingStyle FightingStyleSelection::_internal_style() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::FightingStyle>(_impl_.style_);
}
inline void FightingStyleSelection::_internal_set_style(::dnd5e::api::v1alpha1::FightingStyle value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.style_ = value;
}

// -------------------------------------------------------------------

// SpellSelection

// repeated .dnd5e.api.v1alpha1.Spell spells = 1 [json_name = "spells"];
inline int SpellSelection::_internal_spells_size() const {
  return _internal_spells().size();
}
inline int SpellSelection::spells_size() const {
  return _internal_spells_size();
}
inline void SpellSelection::clear_spells() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spells_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::Spell SpellSelection::spells(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellSelection.spells)
  return static_cast<::dnd5e::api::v1alpha1::Spell>(_internal_spells().Get(index));
}
inline void SpellSelection::set_spells(int index, ::dnd5e::api::v1alpha1::Spell value) {
  _internal_mutable_spells()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellSelection.spells)
}
inline void SpellSelection::add_spells(::dnd5e::api::v1alpha1::Spell value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_spells()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.SpellSelection.spells)
}
inline const ::google::protobuf::RepeatedField<int>& SpellSelection::spells() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.SpellSelection.spells)
  return _internal_spells();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL SpellSelection::mutable_spells()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.SpellSelection.spells)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_spells();
}
inline const ::google::protobuf::RepeatedField<int>& SpellSelection::_internal_spells()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spells_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
SpellSelection::_internal_mutable_spells() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.spells_;
}

// -------------------------------------------------------------------

// ExpertiseSelection

// repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
inline int ExpertiseSelection::_internal_skills_size() const {
  return _internal_skills().size();
}
inline int ExpertiseSelection::skills_size() const {
  return _internal_skills_size();
}
inline void ExpertiseSelection::clear_skills() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skills_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::Skill ExpertiseSelection::skills(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ExpertiseSelection.skills)
  return static_cast<::dnd5e::api::v1alpha1::Skill>(_internal_skills().Get(index));
}
inline void ExpertiseSelection::set_skills(int index, ::dnd5e::api::v1alpha1::Skill value) {
  _internal_mutable_skills()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ExpertiseSelection.skills)
}
inline void ExpertiseSelection::add_skills(::dnd5e::api::v1alpha1::Skill value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_skills()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ExpertiseSelection.skills)
}
inline const ::google::protobuf::RepeatedField<int>& ExpertiseSelection::skills() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ExpertiseSelection.skills)
  return _internal_skills();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL ExpertiseSelection::mutable_skills()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ExpertiseSelection.skills)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_skills();
}
inline const ::google::protobuf::RepeatedField<int>& ExpertiseSelection::_internal_skills()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skills_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
ExpertiseSelection::_internal_mutable_skills() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.skills_;
}

// repeated .dnd5e.api.v1alpha1.Tool tools = 2 [json_name = "tools"];
inline int ExpertiseSelection::_internal_tools_size() const {
  return _internal_tools().size();
}
inline int ExpertiseSelection::tools_size() const {
  return _internal_tools_size();
}
inline void ExpertiseSelection::clear_tools() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tools_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::Tool ExpertiseSelection::tools(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ExpertiseSelection.tools)
  return static_cast<::dnd5e::api::v1alpha1::Tool>(_internal_tools().Get(index));
}
inline void ExpertiseSelection::set_tools(int index, ::dnd5e::api::v1alpha1::Tool value) {
  _internal_mutable_tools()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ExpertiseSelection.tools)
}
inline void ExpertiseSelection::add_tools(::dnd5e::api::v1alpha1::Tool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_tools()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ExpertiseSelection.tools)
}
inline const ::google::protobuf::RepeatedField<int>& ExpertiseSelection::tools() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ExpertiseSelection.tools)
  return _internal_tools();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL ExpertiseSelection::mutable_tools()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ExpertiseSelection.tools)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tools();
}
inline const ::google::protobuf::RepeatedField<int>& ExpertiseSelection::_internal_tools()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tools_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
ExpertiseSelection::_internal_mutable_tools() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tools_;
}

// -------------------------------------------------------------------

// ChoiceData

// .dnd5e.api.v1alpha1.ChoiceCategory category = 1 [json_name = "category"];
inline void ChoiceData::clear_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::ChoiceCategory ChoiceData::category() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.category)
  return _internal_category();
}
inline void ChoiceData::set_category(::dnd5e::api::v1alpha1::ChoiceCategory value) {
  _internal_set_category(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceData.category)
}
inline ::dnd5e::api::v1alpha1::ChoiceCategory ChoiceData::_internal_category() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::ChoiceCategory>(_impl_.category_);
}
inline void ChoiceData::_internal_set_category(::dnd5e::api::v1alpha1::ChoiceCategory value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_ = value;
}

// .dnd5e.api.v1alpha1.ChoiceSource source = 2 [json_name = "source"];
inline void ChoiceData::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::dnd5e::api::v1alpha1::ChoiceSource ChoiceData::source() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.source)
  return _internal_source();
}
inline void ChoiceData::set_source(::dnd5e::api::v1alpha1::ChoiceSource value) {
  _internal_set_source(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceData.source)
}
inline ::dnd5e::api::v1alpha1::ChoiceSource ChoiceData::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::ChoiceSource>(_impl_.source_);
}
inline void ChoiceData::_internal_set_source(::dnd5e::api::v1alpha1::ChoiceSource value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = value;
}

// string choice_id = 3 [json_name = "choiceId"];
inline void ChoiceData::clear_choice_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choice_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ChoiceData::choice_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.choice_id)
  return _internal_choice_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChoiceData::set_choice_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.choice_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceData.choice_id)
}
inline ::std::string* PROTOBUF_NONNULL ChoiceData::mutable_choice_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_choice_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.choice_id)
  return _s;
}
inline const ::std::string& ChoiceData::_internal_choice_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.choice_id_.Get();
}
inline void ChoiceData::_internal_set_choice_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choice_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChoiceData::_internal_mutable_choice_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.choice_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChoiceData::release_choice_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.choice_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.choice_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.choice_id_.Set("", GetArena());
  }
  return released;
}
inline void ChoiceData::set_allocated_choice_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.choice_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.choice_id_.IsDefault()) {
    _impl_.choice_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.choice_id)
}

// string option_id = 4 [json_name = "optionId"];
inline void ChoiceData::clear_option_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.option_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& ChoiceData::option_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.option_id)
  return _internal_option_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChoiceData::set_option_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.option_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceData.option_id)
}
inline ::std::string* PROTOBUF_NONNULL ChoiceData::mutable_option_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_option_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.option_id)
  return _s;
}
inline const ::std::string& ChoiceData::_internal_option_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.option_id_.Get();
}
inline void ChoiceData::_internal_set_option_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.option_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChoiceData::_internal_mutable_option_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.option_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChoiceData::release_option_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.option_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.option_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.option_id_.Set("", GetArena());
  }
  return released;
}
inline void ChoiceData::set_allocated_option_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.option_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.option_id_.IsDefault()) {
    _impl_.option_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.option_id)
}

// string name = 5 [json_name = "name"];
inline bool ChoiceData::has_name() const {
  return selection_case() == kName;
}
inline void ChoiceData::set_has_name() {
  _impl_._oneof_case_[0] = kName;
}
inline void ChoiceData::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kName) {
    _impl_.selection_.name_.Destroy();
    clear_has_selection();
  }
}
inline const ::std::string& ChoiceData::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChoiceData::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() != kName) {
    clear_selection();

    set_has_name();
    _impl_.selection_.name_.InitDefault();
  }
  _impl_.selection_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceData.name)
}
inline ::std::string* PROTOBUF_NONNULL ChoiceData::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  if (selection_case() != kName) {
    clear_selection();

    set_has_name();
    _impl_.selection_.name_.InitDefault();
  }
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.name)
  return _s;
}
inline const ::std::string& ChoiceData::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (selection_case() != kName) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.selection_.name_.Get();
}
inline void ChoiceData::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.selection_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChoiceData::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.selection_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChoiceData::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.name)
  if (selection_case() != kName) {
    return nullptr;
  }
  clear_has_selection();
  return _impl_.selection_.name_.Release();
}
inline void ChoiceData::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_selection()) {
    clear_selection();
  }
  if (value != nullptr) {
    set_has_name();
    _impl_.selection_.name_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.name)
}

// .dnd5e.api.v1alpha1.SkillSelection skills = 6 [json_name = "skills"];
inline bool ChoiceData::has_skills() const {
  return selection_case() == kSkills;
}
inline bool ChoiceData::_internal_has_skills() const {
  return selection_case() == kSkills;
}
inline void ChoiceData::set_has_skills() {
  _impl_._oneof_case_[0] = kSkills;
}
inline void ChoiceData::clear_skills() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kSkills) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.skills_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.skills_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE ChoiceData::release_skills() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.skills)
  if (selection_case() == kSkills) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SkillSelection*>(_impl_.selection_.skills_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.skills_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::SkillSelection& ChoiceData::_internal_skills() const {
  return selection_case() == kSkills ? static_cast<const ::dnd5e::api::v1alpha1::SkillSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::SkillSelection*>(_impl_.selection_.skills_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::SkillSelection&>(::dnd5e::api::v1alpha1::_SkillSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SkillSelection& ChoiceData::skills() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.skills)
  return _internal_skills();
}
inline ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_skills() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.skills)
  if (selection_case() == kSkills) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SkillSelection*>(_impl_.selection_.skills_);
    _impl_.selection_.skills_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_skills(
    ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_skills();
    _impl_.selection_.skills_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.skills)
}
inline ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NONNULL ChoiceData::_internal_mutable_skills() {
  if (selection_case() != kSkills) {
    clear_selection();
    set_has_skills();
    _impl_.selection_.skills_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SkillSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::SkillSelection*>(_impl_.selection_.skills_);
}
inline ::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NONNULL ChoiceData::mutable_skills()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::SkillSelection* _msg = _internal_mutable_skills();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.skills)
  return _msg;
}

// .dnd5e.api.v1alpha1.LanguageSelection languages = 7 [json_name = "languages"];
inline bool ChoiceData::has_languages() const {
  return selection_case() == kLanguages;
}
inline bool ChoiceData::_internal_has_languages() const {
  return selection_case() == kLanguages;
}
inline void ChoiceData::set_has_languages() {
  _impl_._oneof_case_[0] = kLanguages;
}
inline void ChoiceData::clear_languages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kLanguages) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.languages_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.languages_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE ChoiceData::release_languages() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.languages)
  if (selection_case() == kLanguages) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::LanguageSelection*>(_impl_.selection_.languages_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.languages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::LanguageSelection& ChoiceData::_internal_languages() const {
  return selection_case() == kLanguages ? static_cast<const ::dnd5e::api::v1alpha1::LanguageSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::LanguageSelection*>(_impl_.selection_.languages_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::LanguageSelection&>(::dnd5e::api::v1alpha1::_LanguageSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::LanguageSelection& ChoiceData::languages() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.languages)
  return _internal_languages();
}
inline ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_languages() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.languages)
  if (selection_case() == kLanguages) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::LanguageSelection*>(_impl_.selection_.languages_);
    _impl_.selection_.languages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_languages(
    ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_languages();
    _impl_.selection_.languages_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.languages)
}
inline ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NONNULL ChoiceData::_internal_mutable_languages() {
  if (selection_case() != kLanguages) {
    clear_selection();
    set_has_languages();
    _impl_.selection_.languages_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::LanguageSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::LanguageSelection*>(_impl_.selection_.languages_);
}
inline ::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NONNULL ChoiceData::mutable_languages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::LanguageSelection* _msg = _internal_mutable_languages();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.languages)
  return _msg;
}

// .dnd5e.api.v1alpha1.AbilityScores ability_scores = 8 [json_name = "abilityScores"];
inline bool ChoiceData::has_ability_scores() const {
  return selection_case() == kAbilityScores;
}
inline bool ChoiceData::_internal_has_ability_scores() const {
  return selection_case() == kAbilityScores;
}
inline void ChoiceData::set_has_ability_scores() {
  _impl_._oneof_case_[0] = kAbilityScores;
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE ChoiceData::release_ability_scores() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.ability_scores)
  if (selection_case() == kAbilityScores) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(_impl_.selection_.ability_scores_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.ability_scores_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::AbilityScores& ChoiceData::_internal_ability_scores() const {
  return selection_case() == kAbilityScores ? static_cast<const ::dnd5e::api::v1alpha1::AbilityScores&>(*reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(_impl_.selection_.ability_scores_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::AbilityScores&>(::dnd5e::api::v1alpha1::_AbilityScores_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AbilityScores& ChoiceData::ability_scores() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.ability_scores)
  return _internal_ability_scores();
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_ability_scores() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.ability_scores)
  if (selection_case() == kAbilityScores) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(_impl_.selection_.ability_scores_);
    _impl_.selection_.ability_scores_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_ability_scores(
    ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_ability_scores();
    _impl_.selection_.ability_scores_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.ability_scores)
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL ChoiceData::_internal_mutable_ability_scores() {
  if (selection_case() != kAbilityScores) {
    clear_selection();
    set_has_ability_scores();
    _impl_.selection_.ability_scores_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AbilityScores>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(_impl_.selection_.ability_scores_);
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL ChoiceData::mutable_ability_scores()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::AbilityScores* _msg = _internal_mutable_ability_scores();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.ability_scores)
  return _msg;
}

// .dnd5e.api.v1alpha1.FightingStyleSelection fighting_style = 9 [json_name = "fightingStyle"];
inline bool ChoiceData::has_fighting_style() const {
  return selection_case() == kFightingStyle;
}
inline bool ChoiceData::_internal_has_fighting_style() const {
  return selection_case() == kFightingStyle;
}
inline void ChoiceData::set_has_fighting_style() {
  _impl_._oneof_case_[0] = kFightingStyle;
}
inline void ChoiceData::clear_fighting_style() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kFightingStyle) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.fighting_style_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.fighting_style_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE ChoiceData::release_fighting_style() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.fighting_style)
  if (selection_case() == kFightingStyle) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::FightingStyleSelection*>(_impl_.selection_.fighting_style_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.fighting_style_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::FightingStyleSelection& ChoiceData::_internal_fighting_style() const {
  return selection_case() == kFightingStyle ? static_cast<const ::dnd5e::api::v1alpha1::FightingStyleSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::FightingStyleSelection*>(_impl_.selection_.fighting_style_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::FightingStyleSelection&>(::dnd5e::api::v1alpha1::_FightingStyleSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::FightingStyleSelection& ChoiceData::fighting_style() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.fighting_style)
  return _internal_fighting_style();
}
inline ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_fighting_style() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.fighting_style)
  if (selection_case() == kFightingStyle) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::FightingStyleSelection*>(_impl_.selection_.fighting_style_);
    _impl_.selection_.fighting_style_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_fighting_style(
    ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_fighting_style();
    _impl_.selection_.fighting_style_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.fighting_style)
}
inline ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NONNULL ChoiceData::_internal_mutable_fighting_style() {
  if (selection_case() != kFightingStyle) {
    clear_selection();
    set_has_fighting_style();
    _impl_.selection_.fighting_style_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::FightingStyleSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::FightingStyleSelection*>(_impl_.selection_.fighting_style_);
}
inline ::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NONNULL ChoiceData::mutable_fighting_style()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::FightingStyleSelection* _msg = _internal_mutable_fighting_style();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.fighting_style)
  return _msg;
}

// .dnd5e.api.v1alpha1.EquipmentSelection equipment = 10 [json_name = "equipment"];
inline bool ChoiceData::has_equipment() const {
  return selection_case() == kEquipment;
}
inline bool ChoiceData::_internal_has_equipment() const {
  return selection_case() == kEquipment;
}
inline void ChoiceData::set_has_equipment() {
  _impl_._oneof_case_[0] = kEquipment;
}
inline void ChoiceData::clear_equipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kEquipment) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.equipment_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.equipment_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE ChoiceData::release_equipment() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.equipment)
  if (selection_case() == kEquipment) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSelection*>(_impl_.selection_.equipment_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.equipment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::EquipmentSelection& ChoiceData::_internal_equipment() const {
  return selection_case() == kEquipment ? static_cast<const ::dnd5e::api::v1alpha1::EquipmentSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSelection*>(_impl_.selection_.equipment_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::EquipmentSelection&>(::dnd5e::api::v1alpha1::_EquipmentSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::EquipmentSelection& ChoiceData::equipment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.equipment)
  return _internal_equipment();
}
inline ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_equipment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.equipment)
  if (selection_case() == kEquipment) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSelection*>(_impl_.selection_.equipment_);
    _impl_.selection_.equipment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_equipment(
    ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_equipment();
    _impl_.selection_.equipment_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.equipment)
}
inline ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NONNULL ChoiceData::_internal_mutable_equipment() {
  if (selection_case() != kEquipment) {
    clear_selection();
    set_has_equipment();
    _impl_.selection_.equipment_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::EquipmentSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSelection*>(_impl_.selection_.equipment_);
}
inline ::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NONNULL ChoiceData::mutable_equipment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::EquipmentSelection* _msg = _internal_mutable_equipment();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.equipment)
  return _msg;
}

// .dnd5e.api.v1alpha1.Background background = 11 [json_name = "background"];
inline bool ChoiceData::has_background() const {
  return selection_case() == kBackground;
}
inline void ChoiceData::set_has_background() {
  _impl_._oneof_case_[0] = kBackground;
}
inline void ChoiceData::clear_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kBackground) {
    _impl_.selection_.background_ = 0;
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::Background ChoiceData::background() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.background)
  return _internal_background();
}
inline void ChoiceData::set_background(::dnd5e::api::v1alpha1::Background value) {
  if (selection_case() != kBackground) {
    clear_selection();
    set_has_background();
  }
  _impl_.selection_.background_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceData.background)
}
inline ::dnd5e::api::v1alpha1::Background ChoiceData::_internal_background() const {
  if (selection_case() == kBackground) {
    return static_cast<::dnd5e::api::v1alpha1::Background>(_impl_.selection_.background_);
  }
  return static_cast<::dnd5e::api::v1alpha1::Background>(0);
}

// .dnd5e.api.v1alpha1.SpellSelection spells = 12 [json_name = "spells"];
inline bool ChoiceData::has_spells() const {
  return selection_case() == kSpells;
}
inline bool ChoiceData::_internal_has_spells() const {
  return selection_case() == kSpells;
}
inline void ChoiceData::set_has_spells() {
  _impl_._oneof_case_[0] = kSpells;
}
inline void ChoiceData::clear_spells() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kSpells) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.spells_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.spells_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE ChoiceData::release_spells() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.spells)
  if (selection_case() == kSpells) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SpellSelection*>(_impl_.selection_.spells_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.spells_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::SpellSelection& ChoiceData::_internal_spells() const {
  return selection_case() == kSpells ? static_cast<const ::dnd5e::api::v1alpha1::SpellSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::SpellSelection*>(_impl_.selection_.spells_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::SpellSelection&>(::dnd5e::api::v1alpha1::_SpellSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SpellSelection& ChoiceData::spells() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.spells)
  return _internal_spells();
}
inline ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_spells() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.spells)
  if (selection_case() == kSpells) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SpellSelection*>(_impl_.selection_.spells_);
    _impl_.selection_.spells_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_spells(
    ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_spells();
    _impl_.selection_.spells_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.spells)
}
inline ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NONNULL ChoiceData::_internal_mutable_spells() {
  if (selection_case() != kSpells) {
    clear_selection();
    set_has_spells();
    _impl_.selection_.spells_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SpellSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::SpellSelection*>(_impl_.selection_.spells_);
}
inline ::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NONNULL ChoiceData::mutable_spells()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::SpellSelection* _msg = _internal_mutable_spells();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.spells)
  return _msg;
}

// .dnd5e.api.v1alpha1.ToolSelection tools = 13 [json_name = "tools"];
inline bool ChoiceData::has_tools() const {
  return selection_case() == kTools;
}
inline bool ChoiceData::_internal_has_tools() const {
  return selection_case() == kTools;
}
inline void ChoiceData::set_has_tools() {
  _impl_._oneof_case_[0] = kTools;
}
inline void ChoiceData::clear_tools() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kTools) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.tools_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.tools_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE ChoiceData::release_tools() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.tools)
  if (selection_case() == kTools) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ToolSelection*>(_impl_.selection_.tools_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.tools_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::ToolSelection& ChoiceData::_internal_tools() const {
  return selection_case() == kTools ? static_cast<const ::dnd5e::api::v1alpha1::ToolSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::ToolSelection*>(_impl_.selection_.tools_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::ToolSelection&>(::dnd5e::api::v1alpha1::_ToolSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ToolSelection& ChoiceData::tools() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.tools)
  return _internal_tools();
}
inline ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_tools() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.tools)
  if (selection_case() == kTools) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ToolSelection*>(_impl_.selection_.tools_);
    _impl_.selection_.tools_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_tools(
    ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_tools();
    _impl_.selection_.tools_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.tools)
}
inline ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NONNULL ChoiceData::_internal_mutable_tools() {
  if (selection_case() != kTools) {
    clear_selection();
    set_has_tools();
    _impl_.selection_.tools_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ToolSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::ToolSelection*>(_impl_.selection_.tools_);
}
inline ::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NONNULL ChoiceData::mutable_tools()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::ToolSelection* _msg = _internal_mutable_tools();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.tools)
  return _msg;
}

// .dnd5e.api.v1alpha1.ExpertiseSelection expertise = 14 [json_name = "expertise"];
inline bool ChoiceData::has_expertise() const {
  return selection_case() == kExpertise;
}
inline bool ChoiceData::_internal_has_expertise() const {
  return selection_case() == kExpertise;
}
inline void ChoiceData::set_has_expertise() {
  _impl_._oneof_case_[0] = kExpertise;
}
inline void ChoiceData::clear_expertise() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kExpertise) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.expertise_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.expertise_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE ChoiceData::release_expertise() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.expertise)
  if (selection_case() == kExpertise) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ExpertiseSelection*>(_impl_.selection_.expertise_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.expertise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::ExpertiseSelection& ChoiceData::_internal_expertise() const {
  return selection_case() == kExpertise ? static_cast<const ::dnd5e::api::v1alpha1::ExpertiseSelection&>(*reinterpret_cast<::dnd5e::api::v1alpha1::ExpertiseSelection*>(_impl_.selection_.expertise_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::ExpertiseSelection&>(::dnd5e::api::v1alpha1::_ExpertiseSelection_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ExpertiseSelection& ChoiceData::expertise() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.expertise)
  return _internal_expertise();
}
inline ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_expertise() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.expertise)
  if (selection_case() == kExpertise) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ExpertiseSelection*>(_impl_.selection_.expertise_);
    _impl_.selection_.expertise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_expertise(
    ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_expertise();
    _impl_.selection_.expertise_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.expertise)
}
inline ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NONNULL ChoiceData::_internal_mutable_expertise() {
  if (selection_case() != kExpertise) {
    clear_selection();
    set_has_expertise();
    _impl_.selection_.expertise_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ExpertiseSelection>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::ExpertiseSelection*>(_impl_.selection_.expertise_);
}
inline ::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NONNULL ChoiceData::mutable_expertise()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::ExpertiseSelection* _msg = _internal_mutable_expertise();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.expertise)
  return _msg;
}

inline bool ChoiceData::has_selection() const {
  return selection_case() != SELECTION_NOT_SET;
}
inline void ChoiceData::clear_has_selection() {
  _impl_._oneof_case_[0] = SELECTION_NOT_SET;
}
inline ChoiceData::SelectionCase ChoiceData::selection_case() const {
  return ChoiceData::SelectionCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::SpellSelectionType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::SpellSelectionType>() {
  return ::dnd5e::api::v1alpha1::SpellSelectionType_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::ChoiceSource> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::ChoiceSource>() {
  return ::dnd5e::api::v1alpha1::ChoiceSource_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::ChoiceCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::ChoiceCategory>() {
  return ::dnd5e::api::v1alpha1::ChoiceCategory_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto_2epb_2eh
