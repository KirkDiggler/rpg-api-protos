// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: dnd5e/api/v1alpha1/choices.proto
// Protobuf C++ Version: 6.32.1

#include "dnd5e/api/v1alpha1/choices.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace dnd5e {
namespace api {
namespace v1alpha1 {

inline constexpr ToolSelection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : tools_{},
        _tools_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ToolSelection::ToolSelection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ToolSelection_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ToolSelectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ToolSelectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ToolSelectionDefaultTypeInternal() {}
  union {
    ToolSelection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ToolSelectionDefaultTypeInternal _ToolSelection_default_instance_;

inline constexpr ToolOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : available_{},
        _available_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ToolOptions::ToolOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ToolOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ToolOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ToolOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ToolOptionsDefaultTypeInternal() {}
  union {
    ToolOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ToolOptionsDefaultTypeInternal _ToolOptions_default_instance_;

inline constexpr SpellSelection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : spells_{},
        _spells_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SpellSelection::SpellSelection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SpellSelection_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SpellSelectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpellSelectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpellSelectionDefaultTypeInternal() {}
  union {
    SpellSelection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpellSelectionDefaultTypeInternal _SpellSelection_default_instance_;

inline constexpr SpellOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        available_{},
        _available_cached_byte_size_{0},
        spell_level_{0},
        selection_type_{static_cast< ::dnd5e::api::v1alpha1::SpellSelectionType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR SpellOptions::SpellOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SpellOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SpellOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpellOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpellOptionsDefaultTypeInternal() {}
  union {
    SpellOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpellOptionsDefaultTypeInternal _SpellOptions_default_instance_;

inline constexpr SkillSelection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : skills_{},
        _skills_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SkillSelection::SkillSelection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SkillSelection_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SkillSelectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SkillSelectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SkillSelectionDefaultTypeInternal() {}
  union {
    SkillSelection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SkillSelectionDefaultTypeInternal _SkillSelection_default_instance_;

inline constexpr SkillOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : available_{},
        _available_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SkillOptions::SkillOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SkillOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SkillOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SkillOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SkillOptionsDefaultTypeInternal() {}
  union {
    SkillOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SkillOptionsDefaultTypeInternal _SkillOptions_default_instance_;

inline constexpr LanguageSelection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : languages_{},
        _languages_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LanguageSelection::LanguageSelection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(LanguageSelection_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LanguageSelectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LanguageSelectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LanguageSelectionDefaultTypeInternal() {}
  union {
    LanguageSelection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LanguageSelectionDefaultTypeInternal _LanguageSelection_default_instance_;

inline constexpr LanguageOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : available_{},
        _available_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LanguageOptions::LanguageOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(LanguageOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LanguageOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LanguageOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LanguageOptionsDefaultTypeInternal() {}
  union {
    LanguageOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LanguageOptionsDefaultTypeInternal _LanguageOptions_default_instance_;

inline constexpr FightingStyleSelection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        style_{static_cast< ::dnd5e::api::v1alpha1::FightingStyle >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR FightingStyleSelection::FightingStyleSelection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(FightingStyleSelection_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct FightingStyleSelectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FightingStyleSelectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FightingStyleSelectionDefaultTypeInternal() {}
  union {
    FightingStyleSelection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FightingStyleSelectionDefaultTypeInternal _FightingStyleSelection_default_instance_;

inline constexpr FightingStyleOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : available_{},
        _available_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR FightingStyleOptions::FightingStyleOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(FightingStyleOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct FightingStyleOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FightingStyleOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FightingStyleOptionsDefaultTypeInternal() {}
  union {
    FightingStyleOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FightingStyleOptionsDefaultTypeInternal _FightingStyleOptions_default_instance_;

inline constexpr ExpertiseSelection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : skills_{},
        _skills_cached_byte_size_{0},
        tools_{},
        _tools_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ExpertiseSelection::ExpertiseSelection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ExpertiseSelection_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ExpertiseSelectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpertiseSelectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpertiseSelectionDefaultTypeInternal() {}
  union {
    ExpertiseSelection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpertiseSelectionDefaultTypeInternal _ExpertiseSelection_default_instance_;

inline constexpr ExpertiseOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : available_skills_{},
        _available_skills_cached_byte_size_{0},
        available_tools_{},
        _available_tools_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ExpertiseOptions::ExpertiseOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ExpertiseOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ExpertiseOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpertiseOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpertiseOptionsDefaultTypeInternal() {}
  union {
    ExpertiseOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpertiseOptionsDefaultTypeInternal _ExpertiseOptions_default_instance_;

inline constexpr EquipmentSelectionItem::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        quantity_{0},
        equipment_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR EquipmentSelectionItem::EquipmentSelectionItem(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(EquipmentSelectionItem_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EquipmentSelectionItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EquipmentSelectionItemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EquipmentSelectionItemDefaultTypeInternal() {}
  union {
    EquipmentSelectionItem _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EquipmentSelectionItemDefaultTypeInternal _EquipmentSelectionItem_default_instance_;

inline constexpr EquipmentItem::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        selection_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        quantity_{0},
        type_hint_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR EquipmentItem::EquipmentItem(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(EquipmentItem_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EquipmentItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EquipmentItemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EquipmentItemDefaultTypeInternal() {}
  union {
    EquipmentItem _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EquipmentItemDefaultTypeInternal _EquipmentItem_default_instance_;

inline constexpr EquipmentCategoryChoice::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        weapon_categories_{},
        _weapon_categories_cached_byte_size_{0},
        armor_categories_{},
        _armor_categories_cached_byte_size_{0},
        tool_categories_{},
        _tool_categories_cached_byte_size_{0},
        label_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        choose_{0} {}

template <typename>
PROTOBUF_CONSTEXPR EquipmentCategoryChoice::EquipmentCategoryChoice(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(EquipmentCategoryChoice_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EquipmentCategoryChoiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EquipmentCategoryChoiceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EquipmentCategoryChoiceDefaultTypeInternal() {}
  union {
    EquipmentCategoryChoice _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EquipmentCategoryChoiceDefaultTypeInternal _EquipmentCategoryChoice_default_instance_;

inline constexpr EquipmentSelection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : items_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR EquipmentSelection::EquipmentSelection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(EquipmentSelection_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EquipmentSelectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EquipmentSelectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EquipmentSelectionDefaultTypeInternal() {}
  union {
    EquipmentSelection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EquipmentSelectionDefaultTypeInternal _EquipmentSelection_default_instance_;

inline constexpr EquipmentBundle::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        items_{},
        category_choices_{},
        id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        label_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR EquipmentBundle::EquipmentBundle(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(EquipmentBundle_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EquipmentBundleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EquipmentBundleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EquipmentBundleDefaultTypeInternal() {}
  union {
    EquipmentBundle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EquipmentBundleDefaultTypeInternal _EquipmentBundle_default_instance_;

inline constexpr EquipmentOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : bundles_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR EquipmentOptions::EquipmentOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(EquipmentOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EquipmentOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EquipmentOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EquipmentOptionsDefaultTypeInternal() {}
  union {
    EquipmentOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EquipmentOptionsDefaultTypeInternal _EquipmentOptions_default_instance_;

inline constexpr ChoiceSubmission::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        selection_ids_{},
        choice_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        option_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        category_{static_cast< ::dnd5e::api::v1alpha1::ChoiceCategory >(0)},
        source_{static_cast< ::dnd5e::api::v1alpha1::ChoiceSource >(0)},
        selection_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR ChoiceSubmission::ChoiceSubmission(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ChoiceSubmission_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ChoiceSubmissionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChoiceSubmissionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChoiceSubmissionDefaultTypeInternal() {}
  union {
    ChoiceSubmission _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChoiceSubmissionDefaultTypeInternal _ChoiceSubmission_default_instance_;

inline constexpr ChoiceData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        choice_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        option_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        category_{static_cast< ::dnd5e::api::v1alpha1::ChoiceCategory >(0)},
        source_{static_cast< ::dnd5e::api::v1alpha1::ChoiceSource >(0)},
        selection_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR ChoiceData::ChoiceData(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ChoiceData_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ChoiceDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChoiceDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChoiceDataDefaultTypeInternal() {}
  union {
    ChoiceData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChoiceDataDefaultTypeInternal _ChoiceData_default_instance_;

inline constexpr Choice::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        description_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        choose_count_{0},
        choice_type_{static_cast< ::dnd5e::api::v1alpha1::ChoiceCategory >(0)},
        options_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR Choice::Choice(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Choice_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ChoiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChoiceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChoiceDefaultTypeInternal() {}
  union {
    Choice _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChoiceDefaultTypeInternal _Choice_default_instance_;
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e
static const ::_pb::EnumDescriptor* PROTOBUF_NONNULL
    file_level_enum_descriptors_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto[3];
static constexpr const ::_pb::ServiceDescriptor *PROTOBUF_NONNULL *PROTOBUF_NULLABLE
    file_level_service_descriptors_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto = nullptr;
const ::uint32_t
    TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_._oneof_case_[0]),
        16, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_.description_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_.choose_count_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_.choice_type_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_.options_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_.options_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_.options_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_.options_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_.options_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_.options_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_.options_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_.options_),
        0,
        1,
        2,
        3,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SkillOptions, _impl_.available_),
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentOptions, _impl_.bundles_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentBundle, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentBundle, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentBundle, _impl_.label_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentBundle, _impl_.items_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentBundle, _impl_.category_choices_),
        0,
        1,
        ~0u,
        ~0u,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentItem, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentItem, _impl_._oneof_case_[0]),
        12, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentItem, _impl_.selection_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentItem, _impl_.quantity_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentItem, _impl_.type_hint_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentItem, _impl_.type_hint_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentItem, _impl_.type_hint_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentItem, _impl_.type_hint_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentItem, _impl_.type_hint_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentItem, _impl_.type_hint_),
        0,
        1,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentCategoryChoice, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentCategoryChoice, _impl_.choose_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentCategoryChoice, _impl_.weapon_categories_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentCategoryChoice, _impl_.armor_categories_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentCategoryChoice, _impl_.tool_categories_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentCategoryChoice, _impl_.label_),
        1,
        ~0u,
        ~0u,
        ~0u,
        0,
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::LanguageOptions, _impl_.available_),
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ToolOptions, _impl_.available_),
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::FightingStyleOptions, _impl_.available_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SpellOptions, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SpellOptions, _impl_.available_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SpellOptions, _impl_.spell_level_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SpellOptions, _impl_.selection_type_),
        ~0u,
        0,
        1,
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ExpertiseOptions, _impl_.available_skills_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ExpertiseOptions, _impl_.available_tools_),
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_._oneof_case_[0]),
        17, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.choice_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.category_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.source_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.option_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.selection_ids_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_.selection_),
        0,
        2,
        3,
        1,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SkillSelection, _impl_.skills_),
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentSelection, _impl_.items_),
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentSelectionItem, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentSelectionItem, _impl_._oneof_case_[0]),
        12, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentSelectionItem, _impl_.equipment_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentSelectionItem, _impl_.equipment_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentSelectionItem, _impl_.equipment_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentSelectionItem, _impl_.equipment_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentSelectionItem, _impl_.equipment_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentSelectionItem, _impl_.equipment_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentSelectionItem, _impl_.quantity_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentSelectionItem, _impl_.equipment_),
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        0,
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::LanguageSelection, _impl_.languages_),
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ToolSelection, _impl_.tools_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::FightingStyleSelection, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::FightingStyleSelection, _impl_.style_),
        0,
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SpellSelection, _impl_.spells_),
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ExpertiseSelection, _impl_.skills_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ExpertiseSelection, _impl_.tools_),
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_._oneof_case_[0]),
        19, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.category_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.source_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.choice_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.option_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.selection_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_.selection_),
        2,
        3,
        0,
        1,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, sizeof(::dnd5e::api::v1alpha1::Choice)},
        {27, sizeof(::dnd5e::api::v1alpha1::SkillOptions)},
        {29, sizeof(::dnd5e::api::v1alpha1::EquipmentOptions)},
        {31, sizeof(::dnd5e::api::v1alpha1::EquipmentBundle)},
        {42, sizeof(::dnd5e::api::v1alpha1::EquipmentItem)},
        {61, sizeof(::dnd5e::api::v1alpha1::EquipmentCategoryChoice)},
        {74, sizeof(::dnd5e::api::v1alpha1::LanguageOptions)},
        {76, sizeof(::dnd5e::api::v1alpha1::ToolOptions)},
        {78, sizeof(::dnd5e::api::v1alpha1::FightingStyleOptions)},
        {80, sizeof(::dnd5e::api::v1alpha1::SpellOptions)},
        {89, sizeof(::dnd5e::api::v1alpha1::ExpertiseOptions)},
        {92, sizeof(::dnd5e::api::v1alpha1::ChoiceSubmission)},
        {121, sizeof(::dnd5e::api::v1alpha1::SkillSelection)},
        {123, sizeof(::dnd5e::api::v1alpha1::EquipmentSelection)},
        {125, sizeof(::dnd5e::api::v1alpha1::EquipmentSelectionItem)},
        {144, sizeof(::dnd5e::api::v1alpha1::LanguageSelection)},
        {146, sizeof(::dnd5e::api::v1alpha1::ToolSelection)},
        {148, sizeof(::dnd5e::api::v1alpha1::FightingStyleSelection)},
        {153, sizeof(::dnd5e::api::v1alpha1::SpellSelection)},
        {155, sizeof(::dnd5e::api::v1alpha1::ExpertiseSelection)},
        {158, sizeof(::dnd5e::api::v1alpha1::ChoiceData)},
};
static const ::_pb::Message* PROTOBUF_NONNULL const file_default_instances[] = {
    &::dnd5e::api::v1alpha1::_Choice_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_SkillOptions_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_EquipmentOptions_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_EquipmentBundle_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_EquipmentItem_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_EquipmentCategoryChoice_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_LanguageOptions_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_ToolOptions_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_FightingStyleOptions_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_SpellOptions_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_ExpertiseOptions_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_ChoiceSubmission_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_SkillSelection_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_EquipmentSelection_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_EquipmentSelectionItem_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_LanguageSelection_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_ToolSelection_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_FightingStyleSelection_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_SpellSelection_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_ExpertiseSelection_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_ChoiceData_default_instance_._instance,
};
const char descriptor_table_protodef_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n dnd5e/api/v1alpha1/choices.proto\022\022dnd5"
    "e.api.v1alpha1\032\037dnd5e/api/v1alpha1/commo"
    "n.proto\032\036dnd5e/api/v1alpha1/enums.proto\""
    "\343\005\n\006Choice\022\016\n\002id\030\001 \001(\tR\002id\022 \n\013descriptio"
    "n\030\002 \001(\tR\013description\022!\n\014choose_count\030\003 \001"
    "(\005R\013chooseCount\022C\n\013choice_type\030\004 \001(\0162\".d"
    "nd5e.api.v1alpha1.ChoiceCategoryR\nchoice"
    "Type\022G\n\rskill_options\030\005 \001(\0132 .dnd5e.api."
    "v1alpha1.SkillOptionsH\000R\014skillOptions\022S\n"
    "\021equipment_options\030\006 \001(\0132$.dnd5e.api.v1a"
    "lpha1.EquipmentOptionsH\000R\020equipmentOptio"
    "ns\022P\n\020language_options\030\007 \001(\0132#.dnd5e.api"
    ".v1alpha1.LanguageOptionsH\000R\017languageOpt"
    "ions\022D\n\014tool_options\030\010 \001(\0132\037.dnd5e.api.v"
    "1alpha1.ToolOptionsH\000R\013toolOptions\022`\n\026fi"
    "ghting_style_options\030\t \001(\0132(.dnd5e.api.v"
    "1alpha1.FightingStyleOptionsH\000R\024fighting"
    "StyleOptions\022G\n\rspell_options\030\n \001(\0132 .dn"
    "d5e.api.v1alpha1.SpellOptionsH\000R\014spellOp"
    "tions\022S\n\021expertise_options\030\013 \001(\0132$.dnd5e"
    ".api.v1alpha1.ExpertiseOptionsH\000R\020expert"
    "iseOptionsB\t\n\007options\"G\n\014SkillOptions\0227\n"
    "\tavailable\030\001 \003(\0162\031.dnd5e.api.v1alpha1.Sk"
    "illR\tavailable\"Q\n\020EquipmentOptions\022=\n\007bu"
    "ndles\030\001 \003(\0132#.dnd5e.api.v1alpha1.Equipme"
    "ntBundleR\007bundles\"\310\001\n\017EquipmentBundle\022\016\n"
    "\002id\030\001 \001(\tR\002id\022\024\n\005label\030\002 \001(\tR\005label\0227\n\005i"
    "tems\030\003 \003(\0132!.dnd5e.api.v1alpha1.Equipmen"
    "tItemR\005items\022V\n\020category_choices\030\004 \003(\0132+"
    ".dnd5e.api.v1alpha1.EquipmentCategoryCho"
    "iceR\017categoryChoices\"\346\002\n\rEquipmentItem\022!"
    "\n\014selection_id\030\001 \001(\tR\013selectionId\022\032\n\010qua"
    "ntity\030\002 \001(\005R\010quantity\0224\n\006weapon\030\003 \001(\0162\032."
    "dnd5e.api.v1alpha1.WeaponH\000R\006weapon\0221\n\005a"
    "rmor\030\004 \001(\0162\031.dnd5e.api.v1alpha1.ArmorH\000R"
    "\005armor\022.\n\004tool\030\005 \001(\0162\030.dnd5e.api.v1alpha"
    "1.ToolH\000R\004tool\022.\n\004pack\030\006 \001(\0162\030.dnd5e.api"
    ".v1alpha1.PackH\000R\004pack\022@\n\nammunition\030\007 \001"
    "(\0162\036.dnd5e.api.v1alpha1.AmmunitionH\000R\nam"
    "munitionB\013\n\ttype_hint\"\261\002\n\027EquipmentCateg"
    "oryChoice\022\026\n\006choose\030\001 \001(\005R\006choose\022O\n\021wea"
    "pon_categories\030\002 \003(\0162\".dnd5e.api.v1alpha"
    "1.WeaponCategoryR\020weaponCategories\022L\n\020ar"
    "mor_categories\030\003 \003(\0162!.dnd5e.api.v1alpha"
    "1.ArmorCategoryR\017armorCategories\022I\n\017tool"
    "_categories\030\004 \003(\0162 .dnd5e.api.v1alpha1.T"
    "oolCategoryR\016toolCategories\022\024\n\005label\030\005 \001"
    "(\tR\005label\"M\n\017LanguageOptions\022:\n\tavailabl"
    "e\030\001 \003(\0162\034.dnd5e.api.v1alpha1.LanguageR\ta"
    "vailable\"E\n\013ToolOptions\0226\n\tavailable\030\001 \003"
    "(\0162\030.dnd5e.api.v1alpha1.ToolR\tavailable\""
    "W\n\024FightingStyleOptions\022\?\n\tavailable\030\001 \003"
    "(\0162!.dnd5e.api.v1alpha1.FightingStyleR\ta"
    "vailable\"\267\001\n\014SpellOptions\0227\n\tavailable\030\001"
    " \003(\0162\031.dnd5e.api.v1alpha1.SpellR\tavailab"
    "le\022\037\n\013spell_level\030\002 \001(\005R\nspellLevel\022M\n\016s"
    "election_type\030\003 \001(\0162&.dnd5e.api.v1alpha1"
    ".SpellSelectionTypeR\rselectionType\"\233\001\n\020E"
    "xpertiseOptions\022D\n\020available_skills\030\001 \003("
    "\0162\031.dnd5e.api.v1alpha1.SkillR\017availableS"
    "kills\022A\n\017available_tools\030\002 \003(\0162\030.dnd5e.a"
    "pi.v1alpha1.ToolR\016availableTools\"\333\005\n\020Cho"
    "iceSubmission\022\033\n\tchoice_id\030\001 \001(\tR\010choice"
    "Id\022>\n\010category\030\002 \001(\0162\".dnd5e.api.v1alpha"
    "1.ChoiceCategoryR\010category\0228\n\006source\030\003 \001"
    "(\0162 .dnd5e.api.v1alpha1.ChoiceSourceR\006so"
    "urce\022\033\n\toption_id\030\004 \001(\tR\010optionId\022#\n\rsel"
    "ection_ids\030\005 \003(\tR\014selectionIds\022<\n\006skills"
    "\030\006 \001(\0132\".dnd5e.api.v1alpha1.SkillSelecti"
    "onH\000R\006skills\022F\n\tequipment\030\007 \001(\0132&.dnd5e."
    "api.v1alpha1.EquipmentSelectionH\000R\tequip"
    "ment\022E\n\tlanguages\030\010 \001(\0132%.dnd5e.api.v1al"
    "pha1.LanguageSelectionH\000R\tlanguages\0229\n\005t"
    "ools\030\t \001(\0132!.dnd5e.api.v1alpha1.ToolSele"
    "ctionH\000R\005tools\022S\n\016fighting_style\030\n \001(\0132*"
    ".dnd5e.api.v1alpha1.FightingStyleSelecti"
    "onH\000R\rfightingStyle\022<\n\006spells\030\013 \001(\0132\".dn"
    "d5e.api.v1alpha1.SpellSelectionH\000R\006spell"
    "s\022F\n\texpertise\030\014 \001(\0132&.dnd5e.api.v1alpha"
    "1.ExpertiseSelectionH\000R\texpertiseB\013\n\tsel"
    "ection\"C\n\016SkillSelection\0221\n\006skills\030\001 \003(\016"
    "2\031.dnd5e.api.v1alpha1.SkillR\006skills\"V\n\022E"
    "quipmentSelection\022@\n\005items\030\001 \003(\0132*.dnd5e"
    ".api.v1alpha1.EquipmentSelectionItemR\005it"
    "ems\"\374\002\n\026EquipmentSelectionItem\0224\n\006weapon"
    "\030\001 \001(\0162\032.dnd5e.api.v1alpha1.WeaponH\000R\006we"
    "apon\0221\n\005armor\030\002 \001(\0162\031.dnd5e.api.v1alpha1"
    ".ArmorH\000R\005armor\022.\n\004tool\030\003 \001(\0162\030.dnd5e.ap"
    "i.v1alpha1.ToolH\000R\004tool\022.\n\004pack\030\004 \001(\0162\030."
    "dnd5e.api.v1alpha1.PackH\000R\004pack\022@\n\nammun"
    "ition\030\005 \001(\0162\036.dnd5e.api.v1alpha1.Ammunit"
    "ionH\000R\nammunition\022.\n\022other_equipment_id\030"
    "\006 \001(\tH\000R\020otherEquipmentId\022\032\n\010quantity\030\007 "
    "\001(\005R\010quantityB\013\n\tequipment\"O\n\021LanguageSe"
    "lection\022:\n\tlanguages\030\001 \003(\0162\034.dnd5e.api.v"
    "1alpha1.LanguageR\tlanguages\"\?\n\rToolSelec"
    "tion\022.\n\005tools\030\001 \003(\0162\030.dnd5e.api.v1alpha1"
    ".ToolR\005tools\"Q\n\026FightingStyleSelection\0227"
    "\n\005style\030\001 \001(\0162!.dnd5e.api.v1alpha1.Fight"
    "ingStyleR\005style\"C\n\016SpellSelection\0221\n\006spe"
    "lls\030\001 \003(\0162\031.dnd5e.api.v1alpha1.SpellR\006sp"
    "ells\"w\n\022ExpertiseSelection\0221\n\006skills\030\001 \003"
    "(\0162\031.dnd5e.api.v1alpha1.SkillR\006skills\022.\n"
    "\005tools\030\002 \003(\0162\030.dnd5e.api.v1alpha1.ToolR\005"
    "tools\"\324\006\n\nChoiceData\022>\n\010category\030\001 \001(\0162\""
    ".dnd5e.api.v1alpha1.ChoiceCategoryR\010cate"
    "gory\0228\n\006source\030\002 \001(\0162 .dnd5e.api.v1alpha"
    "1.ChoiceSourceR\006source\022\033\n\tchoice_id\030\003 \001("
    "\tR\010choiceId\022\033\n\toption_id\030\004 \001(\tR\010optionId"
    "\022\024\n\004name\030\005 \001(\tH\000R\004name\022<\n\006skills\030\006 \001(\0132\""
    ".dnd5e.api.v1alpha1.SkillSelectionH\000R\006sk"
    "ills\022E\n\tlanguages\030\007 \001(\0132%.dnd5e.api.v1al"
    "pha1.LanguageSelectionH\000R\tlanguages\022J\n\016a"
    "bility_scores\030\010 \001(\0132!.dnd5e.api.v1alpha1"
    ".AbilityScoresH\000R\rabilityScores\022S\n\016fight"
    "ing_style\030\t \001(\0132*.dnd5e.api.v1alpha1.Fig"
    "htingStyleSelectionH\000R\rfightingStyle\022F\n\t"
    "equipment\030\n \001(\0132&.dnd5e.api.v1alpha1.Equ"
    "ipmentSelectionH\000R\tequipment\022@\n\nbackgrou"
    "nd\030\013 \001(\0162\036.dnd5e.api.v1alpha1.Background"
    "H\000R\nbackground\022<\n\006spells\030\014 \001(\0132\".dnd5e.a"
    "pi.v1alpha1.SpellSelectionH\000R\006spells\0229\n\005"
    "tools\030\r \001(\0132!.dnd5e.api.v1alpha1.ToolSel"
    "ectionH\000R\005tools\022F\n\texpertise\030\016 \001(\0132&.dnd"
    "5e.api.v1alpha1.ExpertiseSelectionH\000R\tex"
    "pertiseB\013\n\tselection*\241\001\n\022SpellSelectionT"
    "ype\022$\n SPELL_SELECTION_TYPE_UNSPECIFIED\020"
    "\000\022\"\n\036SPELL_SELECTION_TYPE_SPELLBOOK\020\001\022\036\n"
    "\032SPELL_SELECTION_TYPE_KNOWN\020\002\022!\n\035SPELL_S"
    "ELECTION_TYPE_PREPARED\020\003*\315\001\n\014ChoiceSourc"
    "e\022\035\n\031CHOICE_SOURCE_UNSPECIFIED\020\000\022\030\n\024CHOI"
    "CE_SOURCE_PLAYER\020\001\022\026\n\022CHOICE_SOURCE_RACE"
    "\020\002\022\031\n\025CHOICE_SOURCE_SUBRACE\020\003\022\027\n\023CHOICE_"
    "SOURCE_CLASS\020\004\022\034\n\030CHOICE_SOURCE_BACKGROU"
    "ND\020\005\022\032\n\026CHOICE_SOURCE_LEVEL_UP\020\006*\335\004\n\016Cho"
    "iceCategory\022\037\n\033CHOICE_CATEGORY_UNSPECIFI"
    "ED\020\000\022\035\n\031CHOICE_CATEGORY_EQUIPMENT\020\001\022\032\n\026C"
    "HOICE_CATEGORY_SKILLS\020\002\022\031\n\025CHOICE_CATEGO"
    "RY_TOOLS\020\003\022\035\n\031CHOICE_CATEGORY_LANGUAGES\020"
    "\004\022(\n$CHOICE_CATEGORY_WEAPON_PROFICIENCIE"
    "S\020\005\022\'\n#CHOICE_CATEGORY_ARMOR_PROFICIENCI"
    "ES\020\006\022\032\n\026CHOICE_CATEGORY_SPELLS\020\007\022\031\n\025CHOI"
    "CE_CATEGORY_FEATS\020\010\022\"\n\036CHOICE_CATEGORY_A"
    "BILITY_SCORES\020\t\022\030\n\024CHOICE_CATEGORY_NAME\020"
    "\n\022\"\n\036CHOICE_CATEGORY_FIGHTING_STYLE\020\013\022\030\n"
    "\024CHOICE_CATEGORY_RACE\020\014\022\031\n\025CHOICE_CATEGO"
    "RY_CLASS\020\r\022\036\n\032CHOICE_CATEGORY_BACKGROUND"
    "\020\016\022\034\n\030CHOICE_CATEGORY_CANTRIPS\020\017\022\035\n\031CHOI"
    "CE_CATEGORY_EXPERTISE\020\020\022\033\n\027CHOICE_CATEGO"
    "RY_SUBRACE\020\021\022\032\n\026CHOICE_CATEGORY_TRAITS\020\022"
    "B\335\001\n\026com.dnd5e.api.v1alpha1B\014ChoicesProt"
    "oP\001ZKgithub.com/KirkDiggler/rpg-api-prot"
    "os/gen/go/dnd5e/api/v1alpha1;apiv1alpha1"
    "\242\002\003DAX\252\002\022Dnd5e.Api.V1alpha1\312\002\022Dnd5e\\Api\\"
    "V1alpha1\342\002\036Dnd5e\\Api\\V1alpha1\\GPBMetadat"
    "a\352\002\024Dnd5e::Api::V1alpha1b\006proto3"
};
static const ::_pbi::DescriptorTable* PROTOBUF_NONNULL const
    descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto_deps[2] = {
        &::descriptor_table_dnd5e_2fapi_2fv1alpha1_2fcommon_2eproto,
        &::descriptor_table_dnd5e_2fapi_2fv1alpha1_2fenums_2eproto,
};
static ::absl::once_flag descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto = {
    false,
    false,
    6232,
    descriptor_table_protodef_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
    "dnd5e/api/v1alpha1/choices.proto",
    &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto_once,
    descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto_deps,
    2,
    21,
    schemas,
    file_default_instances,
    TableStruct_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto::offsets,
    file_level_enum_descriptors_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
    file_level_service_descriptors_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
};
namespace dnd5e {
namespace api {
namespace v1alpha1 {
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SpellSelectionType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto);
  return file_level_enum_descriptors_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t SpellSelectionType_internal_data_[] = {
    262144u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ChoiceSource_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto);
  return file_level_enum_descriptors_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t ChoiceSource_internal_data_[] = {
    458752u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ChoiceCategory_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto);
  return file_level_enum_descriptors_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t ChoiceCategory_internal_data_[] = {
    1245184u, 0u, };
// ===================================================================

class Choice::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Choice>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Choice, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Choice, _impl_._oneof_case_);
};

void Choice::set_allocated_skill_options(::dnd5e::api::v1alpha1::SkillOptions* PROTOBUF_NULLABLE skill_options) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_options();
  if (skill_options) {
    ::google::protobuf::Arena* submessage_arena = skill_options->GetArena();
    if (message_arena != submessage_arena) {
      skill_options = ::google::protobuf::internal::GetOwnedMessage(message_arena, skill_options, submessage_arena);
    }
    set_has_skill_options();
    _impl_.options_.skill_options_ = skill_options;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Choice.skill_options)
}
void Choice::set_allocated_equipment_options(::dnd5e::api::v1alpha1::EquipmentOptions* PROTOBUF_NULLABLE equipment_options) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_options();
  if (equipment_options) {
    ::google::protobuf::Arena* submessage_arena = equipment_options->GetArena();
    if (message_arena != submessage_arena) {
      equipment_options = ::google::protobuf::internal::GetOwnedMessage(message_arena, equipment_options, submessage_arena);
    }
    set_has_equipment_options();
    _impl_.options_.equipment_options_ = equipment_options;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Choice.equipment_options)
}
void Choice::set_allocated_language_options(::dnd5e::api::v1alpha1::LanguageOptions* PROTOBUF_NULLABLE language_options) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_options();
  if (language_options) {
    ::google::protobuf::Arena* submessage_arena = language_options->GetArena();
    if (message_arena != submessage_arena) {
      language_options = ::google::protobuf::internal::GetOwnedMessage(message_arena, language_options, submessage_arena);
    }
    set_has_language_options();
    _impl_.options_.language_options_ = language_options;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Choice.language_options)
}
void Choice::set_allocated_tool_options(::dnd5e::api::v1alpha1::ToolOptions* PROTOBUF_NULLABLE tool_options) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_options();
  if (tool_options) {
    ::google::protobuf::Arena* submessage_arena = tool_options->GetArena();
    if (message_arena != submessage_arena) {
      tool_options = ::google::protobuf::internal::GetOwnedMessage(message_arena, tool_options, submessage_arena);
    }
    set_has_tool_options();
    _impl_.options_.tool_options_ = tool_options;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Choice.tool_options)
}
void Choice::set_allocated_fighting_style_options(::dnd5e::api::v1alpha1::FightingStyleOptions* PROTOBUF_NULLABLE fighting_style_options) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_options();
  if (fighting_style_options) {
    ::google::protobuf::Arena* submessage_arena = fighting_style_options->GetArena();
    if (message_arena != submessage_arena) {
      fighting_style_options = ::google::protobuf::internal::GetOwnedMessage(message_arena, fighting_style_options, submessage_arena);
    }
    set_has_fighting_style_options();
    _impl_.options_.fighting_style_options_ = fighting_style_options;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Choice.fighting_style_options)
}
void Choice::set_allocated_spell_options(::dnd5e::api::v1alpha1::SpellOptions* PROTOBUF_NULLABLE spell_options) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_options();
  if (spell_options) {
    ::google::protobuf::Arena* submessage_arena = spell_options->GetArena();
    if (message_arena != submessage_arena) {
      spell_options = ::google::protobuf::internal::GetOwnedMessage(message_arena, spell_options, submessage_arena);
    }
    set_has_spell_options();
    _impl_.options_.spell_options_ = spell_options;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Choice.spell_options)
}
void Choice::set_allocated_expertise_options(::dnd5e::api::v1alpha1::ExpertiseOptions* PROTOBUF_NULLABLE expertise_options) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_options();
  if (expertise_options) {
    ::google::protobuf::Arena* submessage_arena = expertise_options->GetArena();
    if (message_arena != submessage_arena) {
      expertise_options = ::google::protobuf::internal::GetOwnedMessage(message_arena, expertise_options, submessage_arena);
    }
    set_has_expertise_options();
    _impl_.options_.expertise_options_ = expertise_options;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Choice.expertise_options)
}
Choice::Choice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Choice_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.Choice)
}
PROTOBUF_NDEBUG_INLINE Choice::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::Choice& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        id_(arena, from.id_),
        description_(arena, from.description_),
        options_{},
        _oneof_case_{from._oneof_case_[0]} {}

Choice::Choice(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Choice& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Choice_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Choice* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, choose_count_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, choose_count_),
           offsetof(Impl_, choice_type_) -
               offsetof(Impl_, choose_count_) +
               sizeof(Impl_::choice_type_));
  switch (options_case()) {
    case OPTIONS_NOT_SET:
      break;
      case kSkillOptions:
        _impl_.options_.skill_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.skill_options_);
        break;
      case kEquipmentOptions:
        _impl_.options_.equipment_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.equipment_options_);
        break;
      case kLanguageOptions:
        _impl_.options_.language_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.language_options_);
        break;
      case kToolOptions:
        _impl_.options_.tool_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.tool_options_);
        break;
      case kFightingStyleOptions:
        _impl_.options_.fighting_style_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.fighting_style_options_);
        break;
      case kSpellOptions:
        _impl_.options_.spell_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.spell_options_);
        break;
      case kExpertiseOptions:
        _impl_.options_.expertise_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.expertise_options_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.Choice)
}
PROTOBUF_NDEBUG_INLINE Choice::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        id_(arena),
        description_(arena),
        options_{},
        _oneof_case_{} {}

inline void Choice::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, choose_count_),
           0,
           offsetof(Impl_, choice_type_) -
               offsetof(Impl_, choose_count_) +
               sizeof(Impl_::choice_type_));
}
Choice::~Choice() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.Choice)
  SharedDtor(*this);
}
inline void Choice::SharedDtor(MessageLite& self) {
  Choice& this_ = static_cast<Choice&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.id_.Destroy();
  this_._impl_.description_.Destroy();
  if (this_.has_options()) {
    this_.clear_options();
  }
  this_._impl_.~Impl_();
}

void Choice::clear_options() {
// @@protoc_insertion_point(one_of_clear_start:dnd5e.api.v1alpha1.Choice)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (options_case()) {
    case kSkillOptions: {
      if (GetArena() == nullptr) {
        delete _impl_.options_.skill_options_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.skill_options_);
      }
      break;
    }
    case kEquipmentOptions: {
      if (GetArena() == nullptr) {
        delete _impl_.options_.equipment_options_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.equipment_options_);
      }
      break;
    }
    case kLanguageOptions: {
      if (GetArena() == nullptr) {
        delete _impl_.options_.language_options_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.language_options_);
      }
      break;
    }
    case kToolOptions: {
      if (GetArena() == nullptr) {
        delete _impl_.options_.tool_options_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.tool_options_);
      }
      break;
    }
    case kFightingStyleOptions: {
      if (GetArena() == nullptr) {
        delete _impl_.options_.fighting_style_options_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.fighting_style_options_);
      }
      break;
    }
    case kSpellOptions: {
      if (GetArena() == nullptr) {
        delete _impl_.options_.spell_options_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.spell_options_);
      }
      break;
    }
    case kExpertiseOptions: {
      if (GetArena() == nullptr) {
        delete _impl_.options_.expertise_options_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.expertise_options_);
      }
      break;
    }
    case OPTIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = OPTIONS_NOT_SET;
}


inline void* PROTOBUF_NONNULL Choice::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Choice(arena);
}
constexpr auto Choice::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Choice),
                                            alignof(Choice));
}
constexpr auto Choice::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Choice_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Choice::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Choice>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Choice::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Choice>(), &Choice::ByteSizeLong,
              &Choice::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Choice, _impl_._cached_size_),
          false,
      },
      &Choice::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Choice_class_data_ =
        Choice::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Choice::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Choice_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Choice_class_data_.tc_table);
  return Choice_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 11, 7, 55, 2>
Choice::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Choice, _impl_._has_bits_),
    0, // no _extensions_
    11, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294965248,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    Choice_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Choice>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.ChoiceCategory choice_type = 4 [json_name = "choiceType"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Choice, _impl_.choice_type_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(Choice, _impl_.choice_type_)}},
    // string id = 1 [json_name = "id"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Choice, _impl_.id_)}},
    // string description = 2 [json_name = "description"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(Choice, _impl_.description_)}},
    // int32 choose_count = 3 [json_name = "chooseCount"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Choice, _impl_.choose_count_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(Choice, _impl_.choose_count_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string id = 1 [json_name = "id"];
    {PROTOBUF_FIELD_OFFSET(Choice, _impl_.id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string description = 2 [json_name = "description"];
    {PROTOBUF_FIELD_OFFSET(Choice, _impl_.description_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 choose_count = 3 [json_name = "chooseCount"];
    {PROTOBUF_FIELD_OFFSET(Choice, _impl_.choose_count_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // .dnd5e.api.v1alpha1.ChoiceCategory choice_type = 4 [json_name = "choiceType"];
    {PROTOBUF_FIELD_OFFSET(Choice, _impl_.choice_type_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.SkillOptions skill_options = 5 [json_name = "skillOptions"];
    {PROTOBUF_FIELD_OFFSET(Choice, _impl_.options_.skill_options_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.EquipmentOptions equipment_options = 6 [json_name = "equipmentOptions"];
    {PROTOBUF_FIELD_OFFSET(Choice, _impl_.options_.equipment_options_), _Internal::kOneofCaseOffset + 0, 1, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.LanguageOptions language_options = 7 [json_name = "languageOptions"];
    {PROTOBUF_FIELD_OFFSET(Choice, _impl_.options_.language_options_), _Internal::kOneofCaseOffset + 0, 2, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.ToolOptions tool_options = 8 [json_name = "toolOptions"];
    {PROTOBUF_FIELD_OFFSET(Choice, _impl_.options_.tool_options_), _Internal::kOneofCaseOffset + 0, 3, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.FightingStyleOptions fighting_style_options = 9 [json_name = "fightingStyleOptions"];
    {PROTOBUF_FIELD_OFFSET(Choice, _impl_.options_.fighting_style_options_), _Internal::kOneofCaseOffset + 0, 4, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.SpellOptions spell_options = 10 [json_name = "spellOptions"];
    {PROTOBUF_FIELD_OFFSET(Choice, _impl_.options_.spell_options_), _Internal::kOneofCaseOffset + 0, 5, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.ExpertiseOptions expertise_options = 11 [json_name = "expertiseOptions"];
    {PROTOBUF_FIELD_OFFSET(Choice, _impl_.options_.expertise_options_), _Internal::kOneofCaseOffset + 0, 6, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SkillOptions>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentOptions>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::LanguageOptions>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ToolOptions>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::FightingStyleOptions>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SpellOptions>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ExpertiseOptions>()},
  }},
  {{
    "\31\2\13\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.Choice"
    "id"
    "description"
  }},
};
PROTOBUF_NOINLINE void Choice::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.Choice)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    if ((cached_has_bits & 0x00000001U) != 0) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002U) != 0) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000000cU) != 0) {
    ::memset(&_impl_.choose_count_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.choice_type_) -
        reinterpret_cast<char*>(&_impl_.choose_count_)) + sizeof(_impl_.choice_type_));
  }
  clear_options();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Choice::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Choice& this_ = static_cast<const Choice&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Choice::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Choice& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.Choice)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string id = 1 [json_name = "id"];
  if ((this_._impl_._has_bits_[0] & 0x00000001U) != 0) {
    if (!this_._internal_id().empty()) {
      const ::std::string& _s = this_._internal_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.Choice.id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string description = 2 [json_name = "description"];
  if ((this_._impl_._has_bits_[0] & 0x00000002U) != 0) {
    if (!this_._internal_description().empty()) {
      const ::std::string& _s = this_._internal_description();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.Choice.description");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // int32 choose_count = 3 [json_name = "chooseCount"];
  if ((this_._impl_._has_bits_[0] & 0x00000004U) != 0) {
    if (this_._internal_choose_count() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
              stream, this_._internal_choose_count(), target);
    }
  }

  // .dnd5e.api.v1alpha1.ChoiceCategory choice_type = 4 [json_name = "choiceType"];
  if ((this_._impl_._has_bits_[0] & 0x00000008U) != 0) {
    if (this_._internal_choice_type() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          4, this_._internal_choice_type(), target);
    }
  }

  switch (this_.options_case()) {
    case kSkillOptions: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *this_._impl_.options_.skill_options_, this_._impl_.options_.skill_options_->GetCachedSize(), target,
          stream);
      break;
    }
    case kEquipmentOptions: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *this_._impl_.options_.equipment_options_, this_._impl_.options_.equipment_options_->GetCachedSize(), target,
          stream);
      break;
    }
    case kLanguageOptions: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          7, *this_._impl_.options_.language_options_, this_._impl_.options_.language_options_->GetCachedSize(), target,
          stream);
      break;
    }
    case kToolOptions: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          8, *this_._impl_.options_.tool_options_, this_._impl_.options_.tool_options_->GetCachedSize(), target,
          stream);
      break;
    }
    case kFightingStyleOptions: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          9, *this_._impl_.options_.fighting_style_options_, this_._impl_.options_.fighting_style_options_->GetCachedSize(), target,
          stream);
      break;
    }
    case kSpellOptions: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          10, *this_._impl_.options_.spell_options_, this_._impl_.options_.spell_options_->GetCachedSize(), target,
          stream);
      break;
    }
    case kExpertiseOptions: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          11, *this_._impl_.options_.expertise_options_, this_._impl_.options_.expertise_options_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.Choice)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Choice::ByteSizeLong(const MessageLite& base) {
  const Choice& this_ = static_cast<const Choice&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Choice::ByteSizeLong() const {
  const Choice& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.Choice)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fU) != 0) {
    // string id = 1 [json_name = "id"];
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (!this_._internal_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_id());
      }
    }
    // string description = 2 [json_name = "description"];
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (!this_._internal_description().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_description());
      }
    }
    // int32 choose_count = 3 [json_name = "chooseCount"];
    if ((cached_has_bits & 0x00000004U) != 0) {
      if (this_._internal_choose_count() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_choose_count());
      }
    }
    // .dnd5e.api.v1alpha1.ChoiceCategory choice_type = 4 [json_name = "choiceType"];
    if ((cached_has_bits & 0x00000008U) != 0) {
      if (this_._internal_choice_type() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_choice_type());
      }
    }
  }
  switch (this_.options_case()) {
    // .dnd5e.api.v1alpha1.SkillOptions skill_options = 5 [json_name = "skillOptions"];
    case kSkillOptions: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.options_.skill_options_);
      break;
    }
    // .dnd5e.api.v1alpha1.EquipmentOptions equipment_options = 6 [json_name = "equipmentOptions"];
    case kEquipmentOptions: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.options_.equipment_options_);
      break;
    }
    // .dnd5e.api.v1alpha1.LanguageOptions language_options = 7 [json_name = "languageOptions"];
    case kLanguageOptions: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.options_.language_options_);
      break;
    }
    // .dnd5e.api.v1alpha1.ToolOptions tool_options = 8 [json_name = "toolOptions"];
    case kToolOptions: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.options_.tool_options_);
      break;
    }
    // .dnd5e.api.v1alpha1.FightingStyleOptions fighting_style_options = 9 [json_name = "fightingStyleOptions"];
    case kFightingStyleOptions: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.options_.fighting_style_options_);
      break;
    }
    // .dnd5e.api.v1alpha1.SpellOptions spell_options = 10 [json_name = "spellOptions"];
    case kSpellOptions: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.options_.spell_options_);
      break;
    }
    // .dnd5e.api.v1alpha1.ExpertiseOptions expertise_options = 11 [json_name = "expertiseOptions"];
    case kExpertiseOptions: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.options_.expertise_options_);
      break;
    }
    case OPTIONS_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Choice::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Choice*>(&to_msg);
  auto& from = static_cast<const Choice&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.Choice)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fU) != 0) {
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (!from._internal_id().empty()) {
        _this->_internal_set_id(from._internal_id());
      } else {
        if (_this->_impl_.id_.IsDefault()) {
          _this->_internal_set_id("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (!from._internal_description().empty()) {
        _this->_internal_set_description(from._internal_description());
      } else {
        if (_this->_impl_.description_.IsDefault()) {
          _this->_internal_set_description("");
        }
      }
    }
    if ((cached_has_bits & 0x00000004U) != 0) {
      if (from._internal_choose_count() != 0) {
        _this->_impl_.choose_count_ = from._impl_.choose_count_;
      }
    }
    if ((cached_has_bits & 0x00000008U) != 0) {
      if (from._internal_choice_type() != 0) {
        _this->_impl_.choice_type_ = from._impl_.choice_type_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_options();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kSkillOptions: {
        if (oneof_needs_init) {
          _this->_impl_.options_.skill_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.skill_options_);
        } else {
          _this->_impl_.options_.skill_options_->MergeFrom(*from._impl_.options_.skill_options_);
        }
        break;
      }
      case kEquipmentOptions: {
        if (oneof_needs_init) {
          _this->_impl_.options_.equipment_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.equipment_options_);
        } else {
          _this->_impl_.options_.equipment_options_->MergeFrom(*from._impl_.options_.equipment_options_);
        }
        break;
      }
      case kLanguageOptions: {
        if (oneof_needs_init) {
          _this->_impl_.options_.language_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.language_options_);
        } else {
          _this->_impl_.options_.language_options_->MergeFrom(*from._impl_.options_.language_options_);
        }
        break;
      }
      case kToolOptions: {
        if (oneof_needs_init) {
          _this->_impl_.options_.tool_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.tool_options_);
        } else {
          _this->_impl_.options_.tool_options_->MergeFrom(*from._impl_.options_.tool_options_);
        }
        break;
      }
      case kFightingStyleOptions: {
        if (oneof_needs_init) {
          _this->_impl_.options_.fighting_style_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.fighting_style_options_);
        } else {
          _this->_impl_.options_.fighting_style_options_->MergeFrom(*from._impl_.options_.fighting_style_options_);
        }
        break;
      }
      case kSpellOptions: {
        if (oneof_needs_init) {
          _this->_impl_.options_.spell_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.spell_options_);
        } else {
          _this->_impl_.options_.spell_options_->MergeFrom(*from._impl_.options_.spell_options_);
        }
        break;
      }
      case kExpertiseOptions: {
        if (oneof_needs_init) {
          _this->_impl_.options_.expertise_options_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.options_.expertise_options_);
        } else {
          _this->_impl_.options_.expertise_options_->MergeFrom(*from._impl_.options_.expertise_options_);
        }
        break;
      }
      case OPTIONS_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Choice::CopyFrom(const Choice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.Choice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Choice::InternalSwap(Choice* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, &other->_impl_.id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, &other->_impl_.description_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Choice, _impl_.choice_type_)
      + sizeof(Choice::_impl_.choice_type_)
      - PROTOBUF_FIELD_OFFSET(Choice, _impl_.choose_count_)>(
          reinterpret_cast<char*>(&_impl_.choose_count_),
          reinterpret_cast<char*>(&other->_impl_.choose_count_));
  swap(_impl_.options_, other->_impl_.options_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata Choice::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SkillOptions::_Internal {
 public:
};

SkillOptions::SkillOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SkillOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.SkillOptions)
}
PROTOBUF_NDEBUG_INLINE SkillOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::SkillOptions& from_msg)
      : available_{visibility, arena, from.available_},
        _available_cached_byte_size_{0},
        _cached_size_{0} {}

SkillOptions::SkillOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const SkillOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SkillOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SkillOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.SkillOptions)
}
PROTOBUF_NDEBUG_INLINE SkillOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : available_{visibility, arena},
        _available_cached_byte_size_{0},
        _cached_size_{0} {}

inline void SkillOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
SkillOptions::~SkillOptions() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.SkillOptions)
  SharedDtor(*this);
}
inline void SkillOptions::SharedDtor(MessageLite& self) {
  SkillOptions& this_ = static_cast<SkillOptions&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SkillOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SkillOptions(arena);
}
constexpr auto SkillOptions::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SkillOptions, _impl_.available_) +
          decltype(SkillOptions::_impl_.available_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(SkillOptions), alignof(SkillOptions), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SkillOptions::PlacementNew_,
                                 sizeof(SkillOptions),
                                 alignof(SkillOptions));
  }
}
constexpr auto SkillOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SkillOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SkillOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SkillOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SkillOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SkillOptions>(), &SkillOptions::ByteSizeLong,
              &SkillOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SkillOptions, _impl_._cached_size_),
          false,
      },
      &SkillOptions::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SkillOptions_class_data_ =
        SkillOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SkillOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SkillOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SkillOptions_class_data_.tc_table);
  return SkillOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
SkillOptions::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SkillOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SkillOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.Skill available = 1 [json_name = "available"];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(SkillOptions, _impl_.available_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.Skill available = 1 [json_name = "available"];
    {PROTOBUF_FIELD_OFFSET(SkillOptions, _impl_.available_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void SkillOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.SkillOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.available_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SkillOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SkillOptions& this_ = static_cast<const SkillOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SkillOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SkillOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.SkillOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.Skill available = 1 [json_name = "available"];
  {
    ::size_t byte_size = this_._impl_._available_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, this_._internal_available(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.SkillOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SkillOptions::ByteSizeLong(const MessageLite& base) {
  const SkillOptions& this_ = static_cast<const SkillOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SkillOptions::ByteSizeLong() const {
  const SkillOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.SkillOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.Skill available = 1 [json_name = "available"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_available(), 1, this_._impl_._available_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SkillOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SkillOptions*>(&to_msg);
  auto& from = static_cast<const SkillOptions&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.SkillOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_available()->MergeFrom(from._internal_available());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SkillOptions::CopyFrom(const SkillOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.SkillOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SkillOptions::InternalSwap(SkillOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.available_.InternalSwap(&other->_impl_.available_);
}

::google::protobuf::Metadata SkillOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class EquipmentOptions::_Internal {
 public:
};

EquipmentOptions::EquipmentOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EquipmentOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.EquipmentOptions)
}
PROTOBUF_NDEBUG_INLINE EquipmentOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::EquipmentOptions& from_msg)
      : bundles_{visibility, arena, from.bundles_},
        _cached_size_{0} {}

EquipmentOptions::EquipmentOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const EquipmentOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EquipmentOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  EquipmentOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.EquipmentOptions)
}
PROTOBUF_NDEBUG_INLINE EquipmentOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : bundles_{visibility, arena},
        _cached_size_{0} {}

inline void EquipmentOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
EquipmentOptions::~EquipmentOptions() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.EquipmentOptions)
  SharedDtor(*this);
}
inline void EquipmentOptions::SharedDtor(MessageLite& self) {
  EquipmentOptions& this_ = static_cast<EquipmentOptions&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL EquipmentOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) EquipmentOptions(arena);
}
constexpr auto EquipmentOptions::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(EquipmentOptions, _impl_.bundles_) +
          decltype(EquipmentOptions::_impl_.bundles_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(EquipmentOptions), alignof(EquipmentOptions), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&EquipmentOptions::PlacementNew_,
                                 sizeof(EquipmentOptions),
                                 alignof(EquipmentOptions));
  }
}
constexpr auto EquipmentOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_EquipmentOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &EquipmentOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<EquipmentOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &EquipmentOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<EquipmentOptions>(), &EquipmentOptions::ByteSizeLong,
              &EquipmentOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(EquipmentOptions, _impl_._cached_size_),
          false,
      },
      &EquipmentOptions::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull EquipmentOptions_class_data_ =
        EquipmentOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
EquipmentOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&EquipmentOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(EquipmentOptions_class_data_.tc_table);
  return EquipmentOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2>
EquipmentOptions::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    EquipmentOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.EquipmentBundle bundles = 1 [json_name = "bundles"];
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(EquipmentOptions, _impl_.bundles_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.EquipmentBundle bundles = 1 [json_name = "bundles"];
    {PROTOBUF_FIELD_OFFSET(EquipmentOptions, _impl_.bundles_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentBundle>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void EquipmentOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.EquipmentOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bundles_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL EquipmentOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const EquipmentOptions& this_ = static_cast<const EquipmentOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL EquipmentOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const EquipmentOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.EquipmentOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.EquipmentBundle bundles = 1 [json_name = "bundles"];
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_bundles_size());
       i < n; i++) {
    const auto& repfield = this_._internal_bundles().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            1, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.EquipmentOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t EquipmentOptions::ByteSizeLong(const MessageLite& base) {
  const EquipmentOptions& this_ = static_cast<const EquipmentOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t EquipmentOptions::ByteSizeLong() const {
  const EquipmentOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.EquipmentOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.EquipmentBundle bundles = 1 [json_name = "bundles"];
    {
      total_size += 1UL * this_._internal_bundles_size();
      for (const auto& msg : this_._internal_bundles()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void EquipmentOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<EquipmentOptions*>(&to_msg);
  auto& from = static_cast<const EquipmentOptions&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.EquipmentOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_bundles()->MergeFrom(
      from._internal_bundles());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EquipmentOptions::CopyFrom(const EquipmentOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.EquipmentOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EquipmentOptions::InternalSwap(EquipmentOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bundles_.InternalSwap(&other->_impl_.bundles_);
}

::google::protobuf::Metadata EquipmentOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class EquipmentBundle::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<EquipmentBundle>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_._has_bits_);
};

EquipmentBundle::EquipmentBundle(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EquipmentBundle_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.EquipmentBundle)
}
PROTOBUF_NDEBUG_INLINE EquipmentBundle::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::EquipmentBundle& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        items_{visibility, arena, from.items_},
        category_choices_{visibility, arena, from.category_choices_},
        id_(arena, from.id_),
        label_(arena, from.label_) {}

EquipmentBundle::EquipmentBundle(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const EquipmentBundle& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EquipmentBundle_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  EquipmentBundle* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.EquipmentBundle)
}
PROTOBUF_NDEBUG_INLINE EquipmentBundle::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        items_{visibility, arena},
        category_choices_{visibility, arena},
        id_(arena),
        label_(arena) {}

inline void EquipmentBundle::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
EquipmentBundle::~EquipmentBundle() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.EquipmentBundle)
  SharedDtor(*this);
}
inline void EquipmentBundle::SharedDtor(MessageLite& self) {
  EquipmentBundle& this_ = static_cast<EquipmentBundle&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.id_.Destroy();
  this_._impl_.label_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL EquipmentBundle::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) EquipmentBundle(arena);
}
constexpr auto EquipmentBundle::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_.items_) +
          decltype(EquipmentBundle::_impl_.items_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_.category_choices_) +
          decltype(EquipmentBundle::_impl_.category_choices_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(EquipmentBundle), alignof(EquipmentBundle), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&EquipmentBundle::PlacementNew_,
                                 sizeof(EquipmentBundle),
                                 alignof(EquipmentBundle));
  }
}
constexpr auto EquipmentBundle::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_EquipmentBundle_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &EquipmentBundle::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<EquipmentBundle>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &EquipmentBundle::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<EquipmentBundle>(), &EquipmentBundle::ByteSizeLong,
              &EquipmentBundle::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_._cached_size_),
          false,
      },
      &EquipmentBundle::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull EquipmentBundle_class_data_ =
        EquipmentBundle::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
EquipmentBundle::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&EquipmentBundle_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(EquipmentBundle_class_data_.tc_table);
  return EquipmentBundle_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 50, 2>
EquipmentBundle::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    EquipmentBundle_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentBundle>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.EquipmentCategoryChoice category_choices = 4 [json_name = "categoryChoices"];
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 1, PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_.category_choices_)}},
    // string id = 1 [json_name = "id"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_.id_)}},
    // string label = 2 [json_name = "label"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_.label_)}},
    // repeated .dnd5e.api.v1alpha1.EquipmentItem items = 3 [json_name = "items"];
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_.items_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string id = 1 [json_name = "id"];
    {PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_.id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string label = 2 [json_name = "label"];
    {PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_.label_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .dnd5e.api.v1alpha1.EquipmentItem items = 3 [json_name = "items"];
    {PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_.items_), -1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.EquipmentCategoryChoice category_choices = 4 [json_name = "categoryChoices"];
    {PROTOBUF_FIELD_OFFSET(EquipmentBundle, _impl_.category_choices_), -1, 1, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentItem>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentCategoryChoice>()},
  }},
  {{
    "\42\2\5\0\0\0\0\0"
    "dnd5e.api.v1alpha1.EquipmentBundle"
    "id"
    "label"
  }},
};
PROTOBUF_NOINLINE void EquipmentBundle::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.EquipmentBundle)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _impl_.category_choices_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    if ((cached_has_bits & 0x00000001U) != 0) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002U) != 0) {
      _impl_.label_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL EquipmentBundle::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const EquipmentBundle& this_ = static_cast<const EquipmentBundle&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL EquipmentBundle::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const EquipmentBundle& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.EquipmentBundle)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string id = 1 [json_name = "id"];
  if ((this_._impl_._has_bits_[0] & 0x00000001U) != 0) {
    if (!this_._internal_id().empty()) {
      const ::std::string& _s = this_._internal_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.EquipmentBundle.id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string label = 2 [json_name = "label"];
  if ((this_._impl_._has_bits_[0] & 0x00000002U) != 0) {
    if (!this_._internal_label().empty()) {
      const ::std::string& _s = this_._internal_label();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.EquipmentBundle.label");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // repeated .dnd5e.api.v1alpha1.EquipmentItem items = 3 [json_name = "items"];
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_items_size());
       i < n; i++) {
    const auto& repfield = this_._internal_items().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            3, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  // repeated .dnd5e.api.v1alpha1.EquipmentCategoryChoice category_choices = 4 [json_name = "categoryChoices"];
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_category_choices_size());
       i < n; i++) {
    const auto& repfield = this_._internal_category_choices().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            4, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.EquipmentBundle)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t EquipmentBundle::ByteSizeLong(const MessageLite& base) {
  const EquipmentBundle& this_ = static_cast<const EquipmentBundle&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t EquipmentBundle::ByteSizeLong() const {
  const EquipmentBundle& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.EquipmentBundle)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.EquipmentItem items = 3 [json_name = "items"];
    {
      total_size += 1UL * this_._internal_items_size();
      for (const auto& msg : this_._internal_items()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .dnd5e.api.v1alpha1.EquipmentCategoryChoice category_choices = 4 [json_name = "categoryChoices"];
    {
      total_size += 1UL * this_._internal_category_choices_size();
      for (const auto& msg : this_._internal_category_choices()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    // string id = 1 [json_name = "id"];
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (!this_._internal_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_id());
      }
    }
    // string label = 2 [json_name = "label"];
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (!this_._internal_label().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_label());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void EquipmentBundle::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<EquipmentBundle*>(&to_msg);
  auto& from = static_cast<const EquipmentBundle&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.EquipmentBundle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_items()->MergeFrom(
      from._internal_items());
  _this->_internal_mutable_category_choices()->MergeFrom(
      from._internal_category_choices());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (!from._internal_id().empty()) {
        _this->_internal_set_id(from._internal_id());
      } else {
        if (_this->_impl_.id_.IsDefault()) {
          _this->_internal_set_id("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (!from._internal_label().empty()) {
        _this->_internal_set_label(from._internal_label());
      } else {
        if (_this->_impl_.label_.IsDefault()) {
          _this->_internal_set_label("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EquipmentBundle::CopyFrom(const EquipmentBundle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.EquipmentBundle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EquipmentBundle::InternalSwap(EquipmentBundle* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  _impl_.category_choices_.InternalSwap(&other->_impl_.category_choices_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, &other->_impl_.id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.label_, &other->_impl_.label_, arena);
}

::google::protobuf::Metadata EquipmentBundle::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class EquipmentItem::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<EquipmentItem>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(EquipmentItem, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentItem, _impl_._oneof_case_);
};

EquipmentItem::EquipmentItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EquipmentItem_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.EquipmentItem)
}
PROTOBUF_NDEBUG_INLINE EquipmentItem::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::EquipmentItem& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        selection_id_(arena, from.selection_id_),
        type_hint_{},
        _oneof_case_{from._oneof_case_[0]} {}

EquipmentItem::EquipmentItem(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const EquipmentItem& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EquipmentItem_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  EquipmentItem* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.quantity_ = from._impl_.quantity_;
  switch (type_hint_case()) {
    case TYPE_HINT_NOT_SET:
      break;
      case kWeapon:
        _impl_.type_hint_.weapon_ = from._impl_.type_hint_.weapon_;
        break;
      case kArmor:
        _impl_.type_hint_.armor_ = from._impl_.type_hint_.armor_;
        break;
      case kTool:
        _impl_.type_hint_.tool_ = from._impl_.type_hint_.tool_;
        break;
      case kPack:
        _impl_.type_hint_.pack_ = from._impl_.type_hint_.pack_;
        break;
      case kAmmunition:
        _impl_.type_hint_.ammunition_ = from._impl_.type_hint_.ammunition_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.EquipmentItem)
}
PROTOBUF_NDEBUG_INLINE EquipmentItem::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        selection_id_(arena),
        type_hint_{},
        _oneof_case_{} {}

inline void EquipmentItem::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.quantity_ = {};
}
EquipmentItem::~EquipmentItem() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.EquipmentItem)
  SharedDtor(*this);
}
inline void EquipmentItem::SharedDtor(MessageLite& self) {
  EquipmentItem& this_ = static_cast<EquipmentItem&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.selection_id_.Destroy();
  if (this_.has_type_hint()) {
    this_.clear_type_hint();
  }
  this_._impl_.~Impl_();
}

void EquipmentItem::clear_type_hint() {
// @@protoc_insertion_point(one_of_clear_start:dnd5e.api.v1alpha1.EquipmentItem)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (type_hint_case()) {
    case kWeapon: {
      // No need to clear
      break;
    }
    case kArmor: {
      // No need to clear
      break;
    }
    case kTool: {
      // No need to clear
      break;
    }
    case kPack: {
      // No need to clear
      break;
    }
    case kAmmunition: {
      // No need to clear
      break;
    }
    case TYPE_HINT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPE_HINT_NOT_SET;
}


inline void* PROTOBUF_NONNULL EquipmentItem::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) EquipmentItem(arena);
}
constexpr auto EquipmentItem::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(EquipmentItem),
                                            alignof(EquipmentItem));
}
constexpr auto EquipmentItem::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_EquipmentItem_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &EquipmentItem::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<EquipmentItem>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &EquipmentItem::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<EquipmentItem>(), &EquipmentItem::ByteSizeLong,
              &EquipmentItem::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(EquipmentItem, _impl_._cached_size_),
          false,
      },
      &EquipmentItem::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull EquipmentItem_class_data_ =
        EquipmentItem::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
EquipmentItem::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&EquipmentItem_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(EquipmentItem_class_data_.tc_table);
  return EquipmentItem_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 7, 0, 53, 2>
EquipmentItem::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EquipmentItem, _impl_._has_bits_),
    0, // no _extensions_
    7, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    EquipmentItem_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentItem>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // int32 quantity = 2 [json_name = "quantity"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(EquipmentItem, _impl_.quantity_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(EquipmentItem, _impl_.quantity_)}},
    // string selection_id = 1 [json_name = "selectionId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(EquipmentItem, _impl_.selection_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string selection_id = 1 [json_name = "selectionId"];
    {PROTOBUF_FIELD_OFFSET(EquipmentItem, _impl_.selection_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 quantity = 2 [json_name = "quantity"];
    {PROTOBUF_FIELD_OFFSET(EquipmentItem, _impl_.quantity_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // .dnd5e.api.v1alpha1.Weapon weapon = 3 [json_name = "weapon"];
    {PROTOBUF_FIELD_OFFSET(EquipmentItem, _impl_.type_hint_.weapon_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.Armor armor = 4 [json_name = "armor"];
    {PROTOBUF_FIELD_OFFSET(EquipmentItem, _impl_.type_hint_.armor_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.Tool tool = 5 [json_name = "tool"];
    {PROTOBUF_FIELD_OFFSET(EquipmentItem, _impl_.type_hint_.tool_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.Pack pack = 6 [json_name = "pack"];
    {PROTOBUF_FIELD_OFFSET(EquipmentItem, _impl_.type_hint_.pack_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.Ammunition ammunition = 7 [json_name = "ammunition"];
    {PROTOBUF_FIELD_OFFSET(EquipmentItem, _impl_.type_hint_.ammunition_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
    "\40\14\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.EquipmentItem"
    "selection_id"
  }},
};
PROTOBUF_NOINLINE void EquipmentItem::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.EquipmentItem)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001U) != 0) {
    _impl_.selection_id_.ClearNonDefaultToEmpty();
  }
  _impl_.quantity_ = 0;
  clear_type_hint();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL EquipmentItem::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const EquipmentItem& this_ = static_cast<const EquipmentItem&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL EquipmentItem::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const EquipmentItem& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.EquipmentItem)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string selection_id = 1 [json_name = "selectionId"];
  if ((this_._impl_._has_bits_[0] & 0x00000001U) != 0) {
    if (!this_._internal_selection_id().empty()) {
      const ::std::string& _s = this_._internal_selection_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.EquipmentItem.selection_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // int32 quantity = 2 [json_name = "quantity"];
  if ((this_._impl_._has_bits_[0] & 0x00000002U) != 0) {
    if (this_._internal_quantity() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
              stream, this_._internal_quantity(), target);
    }
  }

  switch (this_.type_hint_case()) {
    case kWeapon: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          3, this_._internal_weapon(), target);
      break;
    }
    case kArmor: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          4, this_._internal_armor(), target);
      break;
    }
    case kTool: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          5, this_._internal_tool(), target);
      break;
    }
    case kPack: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          6, this_._internal_pack(), target);
      break;
    }
    case kAmmunition: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          7, this_._internal_ammunition(), target);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.EquipmentItem)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t EquipmentItem::ByteSizeLong(const MessageLite& base) {
  const EquipmentItem& this_ = static_cast<const EquipmentItem&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t EquipmentItem::ByteSizeLong() const {
  const EquipmentItem& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.EquipmentItem)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    // string selection_id = 1 [json_name = "selectionId"];
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (!this_._internal_selection_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_selection_id());
      }
    }
    // int32 quantity = 2 [json_name = "quantity"];
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (this_._internal_quantity() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_quantity());
      }
    }
  }
  switch (this_.type_hint_case()) {
    // .dnd5e.api.v1alpha1.Weapon weapon = 3 [json_name = "weapon"];
    case kWeapon: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_weapon());
      break;
    }
    // .dnd5e.api.v1alpha1.Armor armor = 4 [json_name = "armor"];
    case kArmor: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_armor());
      break;
    }
    // .dnd5e.api.v1alpha1.Tool tool = 5 [json_name = "tool"];
    case kTool: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_tool());
      break;
    }
    // .dnd5e.api.v1alpha1.Pack pack = 6 [json_name = "pack"];
    case kPack: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_pack());
      break;
    }
    // .dnd5e.api.v1alpha1.Ammunition ammunition = 7 [json_name = "ammunition"];
    case kAmmunition: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_ammunition());
      break;
    }
    case TYPE_HINT_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void EquipmentItem::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<EquipmentItem*>(&to_msg);
  auto& from = static_cast<const EquipmentItem&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.EquipmentItem)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (!from._internal_selection_id().empty()) {
        _this->_internal_set_selection_id(from._internal_selection_id());
      } else {
        if (_this->_impl_.selection_id_.IsDefault()) {
          _this->_internal_set_selection_id("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (from._internal_quantity() != 0) {
        _this->_impl_.quantity_ = from._impl_.quantity_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_type_hint();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kWeapon: {
        _this->_impl_.type_hint_.weapon_ = from._impl_.type_hint_.weapon_;
        break;
      }
      case kArmor: {
        _this->_impl_.type_hint_.armor_ = from._impl_.type_hint_.armor_;
        break;
      }
      case kTool: {
        _this->_impl_.type_hint_.tool_ = from._impl_.type_hint_.tool_;
        break;
      }
      case kPack: {
        _this->_impl_.type_hint_.pack_ = from._impl_.type_hint_.pack_;
        break;
      }
      case kAmmunition: {
        _this->_impl_.type_hint_.ammunition_ = from._impl_.type_hint_.ammunition_;
        break;
      }
      case TYPE_HINT_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EquipmentItem::CopyFrom(const EquipmentItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.EquipmentItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EquipmentItem::InternalSwap(EquipmentItem* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.selection_id_, &other->_impl_.selection_id_, arena);
  swap(_impl_.quantity_, other->_impl_.quantity_);
  swap(_impl_.type_hint_, other->_impl_.type_hint_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata EquipmentItem::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class EquipmentCategoryChoice::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<EquipmentCategoryChoice>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_._has_bits_);
};

EquipmentCategoryChoice::EquipmentCategoryChoice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EquipmentCategoryChoice_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.EquipmentCategoryChoice)
}
PROTOBUF_NDEBUG_INLINE EquipmentCategoryChoice::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::EquipmentCategoryChoice& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        weapon_categories_{visibility, arena, from.weapon_categories_},
        _weapon_categories_cached_byte_size_{0},
        armor_categories_{visibility, arena, from.armor_categories_},
        _armor_categories_cached_byte_size_{0},
        tool_categories_{visibility, arena, from.tool_categories_},
        _tool_categories_cached_byte_size_{0},
        label_(arena, from.label_) {}

EquipmentCategoryChoice::EquipmentCategoryChoice(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const EquipmentCategoryChoice& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EquipmentCategoryChoice_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  EquipmentCategoryChoice* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.choose_ = from._impl_.choose_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.EquipmentCategoryChoice)
}
PROTOBUF_NDEBUG_INLINE EquipmentCategoryChoice::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        weapon_categories_{visibility, arena},
        _weapon_categories_cached_byte_size_{0},
        armor_categories_{visibility, arena},
        _armor_categories_cached_byte_size_{0},
        tool_categories_{visibility, arena},
        _tool_categories_cached_byte_size_{0},
        label_(arena) {}

inline void EquipmentCategoryChoice::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.choose_ = {};
}
EquipmentCategoryChoice::~EquipmentCategoryChoice() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.EquipmentCategoryChoice)
  SharedDtor(*this);
}
inline void EquipmentCategoryChoice::SharedDtor(MessageLite& self) {
  EquipmentCategoryChoice& this_ = static_cast<EquipmentCategoryChoice&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.label_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL EquipmentCategoryChoice::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) EquipmentCategoryChoice(arena);
}
constexpr auto EquipmentCategoryChoice::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.weapon_categories_) +
          decltype(EquipmentCategoryChoice::_impl_.weapon_categories_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.armor_categories_) +
          decltype(EquipmentCategoryChoice::_impl_.armor_categories_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.tool_categories_) +
          decltype(EquipmentCategoryChoice::_impl_.tool_categories_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(EquipmentCategoryChoice), alignof(EquipmentCategoryChoice), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&EquipmentCategoryChoice::PlacementNew_,
                                 sizeof(EquipmentCategoryChoice),
                                 alignof(EquipmentCategoryChoice));
  }
}
constexpr auto EquipmentCategoryChoice::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_EquipmentCategoryChoice_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &EquipmentCategoryChoice::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<EquipmentCategoryChoice>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &EquipmentCategoryChoice::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<EquipmentCategoryChoice>(), &EquipmentCategoryChoice::ByteSizeLong,
              &EquipmentCategoryChoice::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_._cached_size_),
          false,
      },
      &EquipmentCategoryChoice::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull EquipmentCategoryChoice_class_data_ =
        EquipmentCategoryChoice::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
EquipmentCategoryChoice::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&EquipmentCategoryChoice_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(EquipmentCategoryChoice_class_data_.tc_table);
  return EquipmentCategoryChoice_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 56, 2>
EquipmentCategoryChoice::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    EquipmentCategoryChoice_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentCategoryChoice>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int32 choose = 1 [json_name = "choose"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(EquipmentCategoryChoice, _impl_.choose_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.choose_)}},
    // repeated .dnd5e.api.v1alpha1.WeaponCategory weapon_categories = 2 [json_name = "weaponCategories"];
    {::_pbi::TcParser::FastV32P1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.weapon_categories_)}},
    // repeated .dnd5e.api.v1alpha1.ArmorCategory armor_categories = 3 [json_name = "armorCategories"];
    {::_pbi::TcParser::FastV32P1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.armor_categories_)}},
    // repeated .dnd5e.api.v1alpha1.ToolCategory tool_categories = 4 [json_name = "toolCategories"];
    {::_pbi::TcParser::FastV32P1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.tool_categories_)}},
    // string label = 5 [json_name = "label"];
    {::_pbi::TcParser::FastUS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.label_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 choose = 1 [json_name = "choose"];
    {PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.choose_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // repeated .dnd5e.api.v1alpha1.WeaponCategory weapon_categories = 2 [json_name = "weaponCategories"];
    {PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.weapon_categories_), -1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // repeated .dnd5e.api.v1alpha1.ArmorCategory armor_categories = 3 [json_name = "armorCategories"];
    {PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.armor_categories_), -1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // repeated .dnd5e.api.v1alpha1.ToolCategory tool_categories = 4 [json_name = "toolCategories"];
    {PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.tool_categories_), -1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // string label = 5 [json_name = "label"];
    {PROTOBUF_FIELD_OFFSET(EquipmentCategoryChoice, _impl_.label_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\52\0\0\0\0\5\0\0"
    "dnd5e.api.v1alpha1.EquipmentCategoryChoice"
    "label"
  }},
};
PROTOBUF_NOINLINE void EquipmentCategoryChoice::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.EquipmentCategoryChoice)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.weapon_categories_.Clear();
  _impl_.armor_categories_.Clear();
  _impl_.tool_categories_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001U) != 0) {
    _impl_.label_.ClearNonDefaultToEmpty();
  }
  _impl_.choose_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL EquipmentCategoryChoice::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const EquipmentCategoryChoice& this_ = static_cast<const EquipmentCategoryChoice&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL EquipmentCategoryChoice::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const EquipmentCategoryChoice& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.EquipmentCategoryChoice)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int32 choose = 1 [json_name = "choose"];
  if ((this_._impl_._has_bits_[0] & 0x00000002U) != 0) {
    if (this_._internal_choose() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
              stream, this_._internal_choose(), target);
    }
  }

  // repeated .dnd5e.api.v1alpha1.WeaponCategory weapon_categories = 2 [json_name = "weaponCategories"];
  {
    ::size_t byte_size = this_._impl_._weapon_categories_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, this_._internal_weapon_categories(), byte_size, target);
    }
  }

  // repeated .dnd5e.api.v1alpha1.ArmorCategory armor_categories = 3 [json_name = "armorCategories"];
  {
    ::size_t byte_size = this_._impl_._armor_categories_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          3, this_._internal_armor_categories(), byte_size, target);
    }
  }

  // repeated .dnd5e.api.v1alpha1.ToolCategory tool_categories = 4 [json_name = "toolCategories"];
  {
    ::size_t byte_size = this_._impl_._tool_categories_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          4, this_._internal_tool_categories(), byte_size, target);
    }
  }

  // string label = 5 [json_name = "label"];
  if ((this_._impl_._has_bits_[0] & 0x00000001U) != 0) {
    if (!this_._internal_label().empty()) {
      const ::std::string& _s = this_._internal_label();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.EquipmentCategoryChoice.label");
      target = stream->WriteStringMaybeAliased(5, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.EquipmentCategoryChoice)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t EquipmentCategoryChoice::ByteSizeLong(const MessageLite& base) {
  const EquipmentCategoryChoice& this_ = static_cast<const EquipmentCategoryChoice&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t EquipmentCategoryChoice::ByteSizeLong() const {
  const EquipmentCategoryChoice& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.EquipmentCategoryChoice)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.WeaponCategory weapon_categories = 2 [json_name = "weaponCategories"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_weapon_categories(), 1, this_._impl_._weapon_categories_cached_byte_size_);
    }
    // repeated .dnd5e.api.v1alpha1.ArmorCategory armor_categories = 3 [json_name = "armorCategories"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_armor_categories(), 1, this_._impl_._armor_categories_cached_byte_size_);
    }
    // repeated .dnd5e.api.v1alpha1.ToolCategory tool_categories = 4 [json_name = "toolCategories"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_tool_categories(), 1, this_._impl_._tool_categories_cached_byte_size_);
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    // string label = 5 [json_name = "label"];
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (!this_._internal_label().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_label());
      }
    }
    // int32 choose = 1 [json_name = "choose"];
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (this_._internal_choose() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_choose());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void EquipmentCategoryChoice::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<EquipmentCategoryChoice*>(&to_msg);
  auto& from = static_cast<const EquipmentCategoryChoice&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.EquipmentCategoryChoice)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_weapon_categories()->MergeFrom(from._internal_weapon_categories());
  _this->_internal_mutable_armor_categories()->MergeFrom(from._internal_armor_categories());
  _this->_internal_mutable_tool_categories()->MergeFrom(from._internal_tool_categories());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (!from._internal_label().empty()) {
        _this->_internal_set_label(from._internal_label());
      } else {
        if (_this->_impl_.label_.IsDefault()) {
          _this->_internal_set_label("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (from._internal_choose() != 0) {
        _this->_impl_.choose_ = from._impl_.choose_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EquipmentCategoryChoice::CopyFrom(const EquipmentCategoryChoice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.EquipmentCategoryChoice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EquipmentCategoryChoice::InternalSwap(EquipmentCategoryChoice* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.weapon_categories_.InternalSwap(&other->_impl_.weapon_categories_);
  _impl_.armor_categories_.InternalSwap(&other->_impl_.armor_categories_);
  _impl_.tool_categories_.InternalSwap(&other->_impl_.tool_categories_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.label_, &other->_impl_.label_, arena);
  swap(_impl_.choose_, other->_impl_.choose_);
}

::google::protobuf::Metadata EquipmentCategoryChoice::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LanguageOptions::_Internal {
 public:
};

LanguageOptions::LanguageOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LanguageOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.LanguageOptions)
}
PROTOBUF_NDEBUG_INLINE LanguageOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::LanguageOptions& from_msg)
      : available_{visibility, arena, from.available_},
        _available_cached_byte_size_{0},
        _cached_size_{0} {}

LanguageOptions::LanguageOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const LanguageOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LanguageOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LanguageOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.LanguageOptions)
}
PROTOBUF_NDEBUG_INLINE LanguageOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : available_{visibility, arena},
        _available_cached_byte_size_{0},
        _cached_size_{0} {}

inline void LanguageOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
LanguageOptions::~LanguageOptions() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.LanguageOptions)
  SharedDtor(*this);
}
inline void LanguageOptions::SharedDtor(MessageLite& self) {
  LanguageOptions& this_ = static_cast<LanguageOptions&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL LanguageOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) LanguageOptions(arena);
}
constexpr auto LanguageOptions::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(LanguageOptions, _impl_.available_) +
          decltype(LanguageOptions::_impl_.available_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(LanguageOptions), alignof(LanguageOptions), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&LanguageOptions::PlacementNew_,
                                 sizeof(LanguageOptions),
                                 alignof(LanguageOptions));
  }
}
constexpr auto LanguageOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_LanguageOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &LanguageOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<LanguageOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &LanguageOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<LanguageOptions>(), &LanguageOptions::ByteSizeLong,
              &LanguageOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(LanguageOptions, _impl_._cached_size_),
          false,
      },
      &LanguageOptions::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull LanguageOptions_class_data_ =
        LanguageOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
LanguageOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&LanguageOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(LanguageOptions_class_data_.tc_table);
  return LanguageOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
LanguageOptions::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    LanguageOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::LanguageOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.Language available = 1 [json_name = "available"];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(LanguageOptions, _impl_.available_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.Language available = 1 [json_name = "available"];
    {PROTOBUF_FIELD_OFFSET(LanguageOptions, _impl_.available_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void LanguageOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.LanguageOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.available_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL LanguageOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const LanguageOptions& this_ = static_cast<const LanguageOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL LanguageOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const LanguageOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.LanguageOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.Language available = 1 [json_name = "available"];
  {
    ::size_t byte_size = this_._impl_._available_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, this_._internal_available(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.LanguageOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t LanguageOptions::ByteSizeLong(const MessageLite& base) {
  const LanguageOptions& this_ = static_cast<const LanguageOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t LanguageOptions::ByteSizeLong() const {
  const LanguageOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.LanguageOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.Language available = 1 [json_name = "available"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_available(), 1, this_._impl_._available_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void LanguageOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LanguageOptions*>(&to_msg);
  auto& from = static_cast<const LanguageOptions&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.LanguageOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_available()->MergeFrom(from._internal_available());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LanguageOptions::CopyFrom(const LanguageOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.LanguageOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LanguageOptions::InternalSwap(LanguageOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.available_.InternalSwap(&other->_impl_.available_);
}

::google::protobuf::Metadata LanguageOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ToolOptions::_Internal {
 public:
};

ToolOptions::ToolOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ToolOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.ToolOptions)
}
PROTOBUF_NDEBUG_INLINE ToolOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::ToolOptions& from_msg)
      : available_{visibility, arena, from.available_},
        _available_cached_byte_size_{0},
        _cached_size_{0} {}

ToolOptions::ToolOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ToolOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ToolOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ToolOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.ToolOptions)
}
PROTOBUF_NDEBUG_INLINE ToolOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : available_{visibility, arena},
        _available_cached_byte_size_{0},
        _cached_size_{0} {}

inline void ToolOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
ToolOptions::~ToolOptions() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.ToolOptions)
  SharedDtor(*this);
}
inline void ToolOptions::SharedDtor(MessageLite& self) {
  ToolOptions& this_ = static_cast<ToolOptions&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ToolOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ToolOptions(arena);
}
constexpr auto ToolOptions::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ToolOptions, _impl_.available_) +
          decltype(ToolOptions::_impl_.available_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(ToolOptions), alignof(ToolOptions), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ToolOptions::PlacementNew_,
                                 sizeof(ToolOptions),
                                 alignof(ToolOptions));
  }
}
constexpr auto ToolOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ToolOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ToolOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ToolOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ToolOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ToolOptions>(), &ToolOptions::ByteSizeLong,
              &ToolOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ToolOptions, _impl_._cached_size_),
          false,
      },
      &ToolOptions::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ToolOptions_class_data_ =
        ToolOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ToolOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ToolOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ToolOptions_class_data_.tc_table);
  return ToolOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
ToolOptions::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ToolOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ToolOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.Tool available = 1 [json_name = "available"];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(ToolOptions, _impl_.available_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.Tool available = 1 [json_name = "available"];
    {PROTOBUF_FIELD_OFFSET(ToolOptions, _impl_.available_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ToolOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.ToolOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.available_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ToolOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ToolOptions& this_ = static_cast<const ToolOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ToolOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ToolOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.ToolOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.Tool available = 1 [json_name = "available"];
  {
    ::size_t byte_size = this_._impl_._available_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, this_._internal_available(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.ToolOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ToolOptions::ByteSizeLong(const MessageLite& base) {
  const ToolOptions& this_ = static_cast<const ToolOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ToolOptions::ByteSizeLong() const {
  const ToolOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.ToolOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.Tool available = 1 [json_name = "available"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_available(), 1, this_._impl_._available_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ToolOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ToolOptions*>(&to_msg);
  auto& from = static_cast<const ToolOptions&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.ToolOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_available()->MergeFrom(from._internal_available());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ToolOptions::CopyFrom(const ToolOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.ToolOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ToolOptions::InternalSwap(ToolOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.available_.InternalSwap(&other->_impl_.available_);
}

::google::protobuf::Metadata ToolOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class FightingStyleOptions::_Internal {
 public:
};

FightingStyleOptions::FightingStyleOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FightingStyleOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.FightingStyleOptions)
}
PROTOBUF_NDEBUG_INLINE FightingStyleOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::FightingStyleOptions& from_msg)
      : available_{visibility, arena, from.available_},
        _available_cached_byte_size_{0},
        _cached_size_{0} {}

FightingStyleOptions::FightingStyleOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const FightingStyleOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FightingStyleOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  FightingStyleOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.FightingStyleOptions)
}
PROTOBUF_NDEBUG_INLINE FightingStyleOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : available_{visibility, arena},
        _available_cached_byte_size_{0},
        _cached_size_{0} {}

inline void FightingStyleOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
FightingStyleOptions::~FightingStyleOptions() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.FightingStyleOptions)
  SharedDtor(*this);
}
inline void FightingStyleOptions::SharedDtor(MessageLite& self) {
  FightingStyleOptions& this_ = static_cast<FightingStyleOptions&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL FightingStyleOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) FightingStyleOptions(arena);
}
constexpr auto FightingStyleOptions::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(FightingStyleOptions, _impl_.available_) +
          decltype(FightingStyleOptions::_impl_.available_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(FightingStyleOptions), alignof(FightingStyleOptions), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&FightingStyleOptions::PlacementNew_,
                                 sizeof(FightingStyleOptions),
                                 alignof(FightingStyleOptions));
  }
}
constexpr auto FightingStyleOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_FightingStyleOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &FightingStyleOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<FightingStyleOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &FightingStyleOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<FightingStyleOptions>(), &FightingStyleOptions::ByteSizeLong,
              &FightingStyleOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(FightingStyleOptions, _impl_._cached_size_),
          false,
      },
      &FightingStyleOptions::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull FightingStyleOptions_class_data_ =
        FightingStyleOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
FightingStyleOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&FightingStyleOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(FightingStyleOptions_class_data_.tc_table);
  return FightingStyleOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
FightingStyleOptions::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    FightingStyleOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::FightingStyleOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.FightingStyle available = 1 [json_name = "available"];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(FightingStyleOptions, _impl_.available_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.FightingStyle available = 1 [json_name = "available"];
    {PROTOBUF_FIELD_OFFSET(FightingStyleOptions, _impl_.available_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void FightingStyleOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.FightingStyleOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.available_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL FightingStyleOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const FightingStyleOptions& this_ = static_cast<const FightingStyleOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL FightingStyleOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const FightingStyleOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.FightingStyleOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.FightingStyle available = 1 [json_name = "available"];
  {
    ::size_t byte_size = this_._impl_._available_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, this_._internal_available(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.FightingStyleOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t FightingStyleOptions::ByteSizeLong(const MessageLite& base) {
  const FightingStyleOptions& this_ = static_cast<const FightingStyleOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t FightingStyleOptions::ByteSizeLong() const {
  const FightingStyleOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.FightingStyleOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.FightingStyle available = 1 [json_name = "available"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_available(), 1, this_._impl_._available_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void FightingStyleOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<FightingStyleOptions*>(&to_msg);
  auto& from = static_cast<const FightingStyleOptions&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.FightingStyleOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_available()->MergeFrom(from._internal_available());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FightingStyleOptions::CopyFrom(const FightingStyleOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.FightingStyleOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void FightingStyleOptions::InternalSwap(FightingStyleOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.available_.InternalSwap(&other->_impl_.available_);
}

::google::protobuf::Metadata FightingStyleOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SpellOptions::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<SpellOptions>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SpellOptions, _impl_._has_bits_);
};

SpellOptions::SpellOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SpellOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.SpellOptions)
}
PROTOBUF_NDEBUG_INLINE SpellOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::SpellOptions& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        available_{visibility, arena, from.available_},
        _available_cached_byte_size_{0} {}

SpellOptions::SpellOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const SpellOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SpellOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SpellOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, spell_level_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, spell_level_),
           offsetof(Impl_, selection_type_) -
               offsetof(Impl_, spell_level_) +
               sizeof(Impl_::selection_type_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.SpellOptions)
}
PROTOBUF_NDEBUG_INLINE SpellOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        available_{visibility, arena},
        _available_cached_byte_size_{0} {}

inline void SpellOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, spell_level_),
           0,
           offsetof(Impl_, selection_type_) -
               offsetof(Impl_, spell_level_) +
               sizeof(Impl_::selection_type_));
}
SpellOptions::~SpellOptions() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.SpellOptions)
  SharedDtor(*this);
}
inline void SpellOptions::SharedDtor(MessageLite& self) {
  SpellOptions& this_ = static_cast<SpellOptions&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SpellOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SpellOptions(arena);
}
constexpr auto SpellOptions::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SpellOptions, _impl_.available_) +
          decltype(SpellOptions::_impl_.available_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(SpellOptions), alignof(SpellOptions), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SpellOptions::PlacementNew_,
                                 sizeof(SpellOptions),
                                 alignof(SpellOptions));
  }
}
constexpr auto SpellOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SpellOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SpellOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SpellOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SpellOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SpellOptions>(), &SpellOptions::ByteSizeLong,
              &SpellOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SpellOptions, _impl_._cached_size_),
          false,
      },
      &SpellOptions::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SpellOptions_class_data_ =
        SpellOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SpellOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SpellOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SpellOptions_class_data_.tc_table);
  return SpellOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
SpellOptions::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SpellOptions, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SpellOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SpellOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .dnd5e.api.v1alpha1.Spell available = 1 [json_name = "available"];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(SpellOptions, _impl_.available_)}},
    // int32 spell_level = 2 [json_name = "spellLevel"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SpellOptions, _impl_.spell_level_), 0>(),
     {16, 0, 0, PROTOBUF_FIELD_OFFSET(SpellOptions, _impl_.spell_level_)}},
    // .dnd5e.api.v1alpha1.SpellSelectionType selection_type = 3 [json_name = "selectionType"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SpellOptions, _impl_.selection_type_), 1>(),
     {24, 1, 0, PROTOBUF_FIELD_OFFSET(SpellOptions, _impl_.selection_type_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.Spell available = 1 [json_name = "available"];
    {PROTOBUF_FIELD_OFFSET(SpellOptions, _impl_.available_), -1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // int32 spell_level = 2 [json_name = "spellLevel"];
    {PROTOBUF_FIELD_OFFSET(SpellOptions, _impl_.spell_level_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // .dnd5e.api.v1alpha1.SpellSelectionType selection_type = 3 [json_name = "selectionType"];
    {PROTOBUF_FIELD_OFFSET(SpellOptions, _impl_.selection_type_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void SpellOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.SpellOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.available_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    ::memset(&_impl_.spell_level_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.selection_type_) -
        reinterpret_cast<char*>(&_impl_.spell_level_)) + sizeof(_impl_.selection_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SpellOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SpellOptions& this_ = static_cast<const SpellOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SpellOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SpellOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.SpellOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.Spell available = 1 [json_name = "available"];
  {
    ::size_t byte_size = this_._impl_._available_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, this_._internal_available(), byte_size, target);
    }
  }

  // int32 spell_level = 2 [json_name = "spellLevel"];
  if ((this_._impl_._has_bits_[0] & 0x00000001U) != 0) {
    if (this_._internal_spell_level() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
              stream, this_._internal_spell_level(), target);
    }
  }

  // .dnd5e.api.v1alpha1.SpellSelectionType selection_type = 3 [json_name = "selectionType"];
  if ((this_._impl_._has_bits_[0] & 0x00000002U) != 0) {
    if (this_._internal_selection_type() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          3, this_._internal_selection_type(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.SpellOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SpellOptions::ByteSizeLong(const MessageLite& base) {
  const SpellOptions& this_ = static_cast<const SpellOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SpellOptions::ByteSizeLong() const {
  const SpellOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.SpellOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.Spell available = 1 [json_name = "available"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_available(), 1, this_._impl_._available_cached_byte_size_);
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    // int32 spell_level = 2 [json_name = "spellLevel"];
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (this_._internal_spell_level() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_spell_level());
      }
    }
    // .dnd5e.api.v1alpha1.SpellSelectionType selection_type = 3 [json_name = "selectionType"];
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (this_._internal_selection_type() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_selection_type());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SpellOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SpellOptions*>(&to_msg);
  auto& from = static_cast<const SpellOptions&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.SpellOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_available()->MergeFrom(from._internal_available());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (from._internal_spell_level() != 0) {
        _this->_impl_.spell_level_ = from._impl_.spell_level_;
      }
    }
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (from._internal_selection_type() != 0) {
        _this->_impl_.selection_type_ = from._impl_.selection_type_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SpellOptions::CopyFrom(const SpellOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.SpellOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SpellOptions::InternalSwap(SpellOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.available_.InternalSwap(&other->_impl_.available_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpellOptions, _impl_.selection_type_)
      + sizeof(SpellOptions::_impl_.selection_type_)
      - PROTOBUF_FIELD_OFFSET(SpellOptions, _impl_.spell_level_)>(
          reinterpret_cast<char*>(&_impl_.spell_level_),
          reinterpret_cast<char*>(&other->_impl_.spell_level_));
}

::google::protobuf::Metadata SpellOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ExpertiseOptions::_Internal {
 public:
};

ExpertiseOptions::ExpertiseOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ExpertiseOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.ExpertiseOptions)
}
PROTOBUF_NDEBUG_INLINE ExpertiseOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::ExpertiseOptions& from_msg)
      : available_skills_{visibility, arena, from.available_skills_},
        _available_skills_cached_byte_size_{0},
        available_tools_{visibility, arena, from.available_tools_},
        _available_tools_cached_byte_size_{0},
        _cached_size_{0} {}

ExpertiseOptions::ExpertiseOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ExpertiseOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ExpertiseOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ExpertiseOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.ExpertiseOptions)
}
PROTOBUF_NDEBUG_INLINE ExpertiseOptions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : available_skills_{visibility, arena},
        _available_skills_cached_byte_size_{0},
        available_tools_{visibility, arena},
        _available_tools_cached_byte_size_{0},
        _cached_size_{0} {}

inline void ExpertiseOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
ExpertiseOptions::~ExpertiseOptions() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.ExpertiseOptions)
  SharedDtor(*this);
}
inline void ExpertiseOptions::SharedDtor(MessageLite& self) {
  ExpertiseOptions& this_ = static_cast<ExpertiseOptions&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ExpertiseOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ExpertiseOptions(arena);
}
constexpr auto ExpertiseOptions::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ExpertiseOptions, _impl_.available_skills_) +
          decltype(ExpertiseOptions::_impl_.available_skills_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ExpertiseOptions, _impl_.available_tools_) +
          decltype(ExpertiseOptions::_impl_.available_tools_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(ExpertiseOptions), alignof(ExpertiseOptions), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ExpertiseOptions::PlacementNew_,
                                 sizeof(ExpertiseOptions),
                                 alignof(ExpertiseOptions));
  }
}
constexpr auto ExpertiseOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ExpertiseOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ExpertiseOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ExpertiseOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ExpertiseOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ExpertiseOptions>(), &ExpertiseOptions::ByteSizeLong,
              &ExpertiseOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ExpertiseOptions, _impl_._cached_size_),
          false,
      },
      &ExpertiseOptions::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ExpertiseOptions_class_data_ =
        ExpertiseOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ExpertiseOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ExpertiseOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ExpertiseOptions_class_data_.tc_table);
  return ExpertiseOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
ExpertiseOptions::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ExpertiseOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ExpertiseOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.Tool available_tools = 2 [json_name = "availableTools"];
    {::_pbi::TcParser::FastV32P1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(ExpertiseOptions, _impl_.available_tools_)}},
    // repeated .dnd5e.api.v1alpha1.Skill available_skills = 1 [json_name = "availableSkills"];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(ExpertiseOptions, _impl_.available_skills_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.Skill available_skills = 1 [json_name = "availableSkills"];
    {PROTOBUF_FIELD_OFFSET(ExpertiseOptions, _impl_.available_skills_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // repeated .dnd5e.api.v1alpha1.Tool available_tools = 2 [json_name = "availableTools"];
    {PROTOBUF_FIELD_OFFSET(ExpertiseOptions, _impl_.available_tools_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ExpertiseOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.ExpertiseOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.available_skills_.Clear();
  _impl_.available_tools_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ExpertiseOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ExpertiseOptions& this_ = static_cast<const ExpertiseOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ExpertiseOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ExpertiseOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.ExpertiseOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.Skill available_skills = 1 [json_name = "availableSkills"];
  {
    ::size_t byte_size = this_._impl_._available_skills_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, this_._internal_available_skills(), byte_size, target);
    }
  }

  // repeated .dnd5e.api.v1alpha1.Tool available_tools = 2 [json_name = "availableTools"];
  {
    ::size_t byte_size = this_._impl_._available_tools_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, this_._internal_available_tools(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.ExpertiseOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ExpertiseOptions::ByteSizeLong(const MessageLite& base) {
  const ExpertiseOptions& this_ = static_cast<const ExpertiseOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ExpertiseOptions::ByteSizeLong() const {
  const ExpertiseOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.ExpertiseOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.Skill available_skills = 1 [json_name = "availableSkills"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_available_skills(), 1, this_._impl_._available_skills_cached_byte_size_);
    }
    // repeated .dnd5e.api.v1alpha1.Tool available_tools = 2 [json_name = "availableTools"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_available_tools(), 1, this_._impl_._available_tools_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ExpertiseOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ExpertiseOptions*>(&to_msg);
  auto& from = static_cast<const ExpertiseOptions&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.ExpertiseOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_available_skills()->MergeFrom(from._internal_available_skills());
  _this->_internal_mutable_available_tools()->MergeFrom(from._internal_available_tools());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ExpertiseOptions::CopyFrom(const ExpertiseOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.ExpertiseOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ExpertiseOptions::InternalSwap(ExpertiseOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.available_skills_.InternalSwap(&other->_impl_.available_skills_);
  _impl_.available_tools_.InternalSwap(&other->_impl_.available_tools_);
}

::google::protobuf::Metadata ExpertiseOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ChoiceSubmission::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ChoiceSubmission>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceSubmission, _impl_._oneof_case_);
};

void ChoiceSubmission::set_allocated_skills(::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE skills) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (skills) {
    ::google::protobuf::Arena* submessage_arena = skills->GetArena();
    if (message_arena != submessage_arena) {
      skills = ::google::protobuf::internal::GetOwnedMessage(message_arena, skills, submessage_arena);
    }
    set_has_skills();
    _impl_.selection_.skills_ = skills;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.skills)
}
void ChoiceSubmission::set_allocated_equipment(::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE equipment) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (equipment) {
    ::google::protobuf::Arena* submessage_arena = equipment->GetArena();
    if (message_arena != submessage_arena) {
      equipment = ::google::protobuf::internal::GetOwnedMessage(message_arena, equipment, submessage_arena);
    }
    set_has_equipment();
    _impl_.selection_.equipment_ = equipment;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.equipment)
}
void ChoiceSubmission::set_allocated_languages(::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE languages) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (languages) {
    ::google::protobuf::Arena* submessage_arena = languages->GetArena();
    if (message_arena != submessage_arena) {
      languages = ::google::protobuf::internal::GetOwnedMessage(message_arena, languages, submessage_arena);
    }
    set_has_languages();
    _impl_.selection_.languages_ = languages;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.languages)
}
void ChoiceSubmission::set_allocated_tools(::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE tools) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (tools) {
    ::google::protobuf::Arena* submessage_arena = tools->GetArena();
    if (message_arena != submessage_arena) {
      tools = ::google::protobuf::internal::GetOwnedMessage(message_arena, tools, submessage_arena);
    }
    set_has_tools();
    _impl_.selection_.tools_ = tools;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.tools)
}
void ChoiceSubmission::set_allocated_fighting_style(::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE fighting_style) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (fighting_style) {
    ::google::protobuf::Arena* submessage_arena = fighting_style->GetArena();
    if (message_arena != submessage_arena) {
      fighting_style = ::google::protobuf::internal::GetOwnedMessage(message_arena, fighting_style, submessage_arena);
    }
    set_has_fighting_style();
    _impl_.selection_.fighting_style_ = fighting_style;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.fighting_style)
}
void ChoiceSubmission::set_allocated_spells(::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE spells) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (spells) {
    ::google::protobuf::Arena* submessage_arena = spells->GetArena();
    if (message_arena != submessage_arena) {
      spells = ::google::protobuf::internal::GetOwnedMessage(message_arena, spells, submessage_arena);
    }
    set_has_spells();
    _impl_.selection_.spells_ = spells;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.spells)
}
void ChoiceSubmission::set_allocated_expertise(::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE expertise) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (expertise) {
    ::google::protobuf::Arena* submessage_arena = expertise->GetArena();
    if (message_arena != submessage_arena) {
      expertise = ::google::protobuf::internal::GetOwnedMessage(message_arena, expertise, submessage_arena);
    }
    set_has_expertise();
    _impl_.selection_.expertise_ = expertise;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceSubmission.expertise)
}
ChoiceSubmission::ChoiceSubmission(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChoiceSubmission_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.ChoiceSubmission)
}
PROTOBUF_NDEBUG_INLINE ChoiceSubmission::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::ChoiceSubmission& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        selection_ids_{visibility, arena, from.selection_ids_},
        choice_id_(arena, from.choice_id_),
        option_id_(arena, from.option_id_),
        selection_{},
        _oneof_case_{from._oneof_case_[0]} {}

ChoiceSubmission::ChoiceSubmission(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ChoiceSubmission& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChoiceSubmission_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ChoiceSubmission* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, category_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, category_),
           offsetof(Impl_, source_) -
               offsetof(Impl_, category_) +
               sizeof(Impl_::source_));
  switch (selection_case()) {
    case SELECTION_NOT_SET:
      break;
      case kSkills:
        _impl_.selection_.skills_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.skills_);
        break;
      case kEquipment:
        _impl_.selection_.equipment_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.equipment_);
        break;
      case kLanguages:
        _impl_.selection_.languages_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.languages_);
        break;
      case kTools:
        _impl_.selection_.tools_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.tools_);
        break;
      case kFightingStyle:
        _impl_.selection_.fighting_style_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.fighting_style_);
        break;
      case kSpells:
        _impl_.selection_.spells_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.spells_);
        break;
      case kExpertise:
        _impl_.selection_.expertise_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.expertise_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.ChoiceSubmission)
}
PROTOBUF_NDEBUG_INLINE ChoiceSubmission::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        selection_ids_{visibility, arena},
        choice_id_(arena),
        option_id_(arena),
        selection_{},
        _oneof_case_{} {}

inline void ChoiceSubmission::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, category_),
           0,
           offsetof(Impl_, source_) -
               offsetof(Impl_, category_) +
               sizeof(Impl_::source_));
}
ChoiceSubmission::~ChoiceSubmission() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.ChoiceSubmission)
  SharedDtor(*this);
}
inline void ChoiceSubmission::SharedDtor(MessageLite& self) {
  ChoiceSubmission& this_ = static_cast<ChoiceSubmission&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.choice_id_.Destroy();
  this_._impl_.option_id_.Destroy();
  if (this_.has_selection()) {
    this_.clear_selection();
  }
  this_._impl_.~Impl_();
}

void ChoiceSubmission::clear_selection() {
// @@protoc_insertion_point(one_of_clear_start:dnd5e.api.v1alpha1.ChoiceSubmission)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (selection_case()) {
    case kSkills: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.skills_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.skills_);
      }
      break;
    }
    case kEquipment: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.equipment_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.equipment_);
      }
      break;
    }
    case kLanguages: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.languages_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.languages_);
      }
      break;
    }
    case kTools: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.tools_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.tools_);
      }
      break;
    }
    case kFightingStyle: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.fighting_style_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.fighting_style_);
      }
      break;
    }
    case kSpells: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.spells_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.spells_);
      }
      break;
    }
    case kExpertise: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.expertise_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.expertise_);
      }
      break;
    }
    case SELECTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SELECTION_NOT_SET;
}


inline void* PROTOBUF_NONNULL ChoiceSubmission::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ChoiceSubmission(arena);
}
constexpr auto ChoiceSubmission::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.selection_ids_) +
          decltype(ChoiceSubmission::_impl_.selection_ids_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(ChoiceSubmission), alignof(ChoiceSubmission), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ChoiceSubmission::PlacementNew_,
                                 sizeof(ChoiceSubmission),
                                 alignof(ChoiceSubmission));
  }
}
constexpr auto ChoiceSubmission::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ChoiceSubmission_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ChoiceSubmission::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ChoiceSubmission>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ChoiceSubmission::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ChoiceSubmission>(), &ChoiceSubmission::ByteSizeLong,
              &ChoiceSubmission::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_._cached_size_),
          false,
      },
      &ChoiceSubmission::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ChoiceSubmission_class_data_ =
        ChoiceSubmission::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ChoiceSubmission::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ChoiceSubmission_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ChoiceSubmission_class_data_.tc_table);
  return ChoiceSubmission_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 12, 7, 83, 2>
ChoiceSubmission::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_._has_bits_),
    0, // no _extensions_
    12, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963200,  // skipmap
    offsetof(decltype(_table_), field_entries),
    12,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ChoiceSubmission_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ChoiceSubmission>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string choice_id = 1 [json_name = "choiceId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.choice_id_)}},
    // .dnd5e.api.v1alpha1.ChoiceCategory category = 2 [json_name = "category"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChoiceSubmission, _impl_.category_), 2>(),
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.category_)}},
    // .dnd5e.api.v1alpha1.ChoiceSource source = 3 [json_name = "source"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChoiceSubmission, _impl_.source_), 3>(),
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.source_)}},
    // string option_id = 4 [json_name = "optionId"];
    {::_pbi::TcParser::FastUS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.option_id_)}},
    // repeated string selection_ids = 5 [json_name = "selectionIds"];
    {::_pbi::TcParser::FastUR1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.selection_ids_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string choice_id = 1 [json_name = "choiceId"];
    {PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.choice_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.ChoiceCategory category = 2 [json_name = "category"];
    {PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.category_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.ChoiceSource source = 3 [json_name = "source"];
    {PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.source_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // string option_id = 4 [json_name = "optionId"];
    {PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.option_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated string selection_ids = 5 [json_name = "selectionIds"];
    {PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.selection_ids_), -1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // .dnd5e.api.v1alpha1.SkillSelection skills = 6 [json_name = "skills"];
    {PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.selection_.skills_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.EquipmentSelection equipment = 7 [json_name = "equipment"];
    {PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.selection_.equipment_), _Internal::kOneofCaseOffset + 0, 1, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.LanguageSelection languages = 8 [json_name = "languages"];
    {PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.selection_.languages_), _Internal::kOneofCaseOffset + 0, 2, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.ToolSelection tools = 9 [json_name = "tools"];
    {PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.selection_.tools_), _Internal::kOneofCaseOffset + 0, 3, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.FightingStyleSelection fighting_style = 10 [json_name = "fightingStyle"];
    {PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.selection_.fighting_style_), _Internal::kOneofCaseOffset + 0, 4, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.SpellSelection spells = 11 [json_name = "spells"];
    {PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.selection_.spells_), _Internal::kOneofCaseOffset + 0, 5, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.ExpertiseSelection expertise = 12 [json_name = "expertise"];
    {PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.selection_.expertise_), _Internal::kOneofCaseOffset + 0, 6, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SkillSelection>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentSelection>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::LanguageSelection>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ToolSelection>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::FightingStyleSelection>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SpellSelection>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ExpertiseSelection>()},
  }},
  {{
    "\43\11\0\0\11\15\0\0\0\0\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.ChoiceSubmission"
    "choice_id"
    "option_id"
    "selection_ids"
  }},
};
PROTOBUF_NOINLINE void ChoiceSubmission::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.ChoiceSubmission)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.selection_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    if ((cached_has_bits & 0x00000001U) != 0) {
      _impl_.choice_id_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002U) != 0) {
      _impl_.option_id_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000000cU) != 0) {
    ::memset(&_impl_.category_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.source_) -
        reinterpret_cast<char*>(&_impl_.category_)) + sizeof(_impl_.source_));
  }
  clear_selection();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ChoiceSubmission::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ChoiceSubmission& this_ = static_cast<const ChoiceSubmission&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ChoiceSubmission::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ChoiceSubmission& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.ChoiceSubmission)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string choice_id = 1 [json_name = "choiceId"];
  if ((this_._impl_._has_bits_[0] & 0x00000001U) != 0) {
    if (!this_._internal_choice_id().empty()) {
      const ::std::string& _s = this_._internal_choice_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.ChoiceSubmission.choice_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.ChoiceCategory category = 2 [json_name = "category"];
  if ((this_._impl_._has_bits_[0] & 0x00000004U) != 0) {
    if (this_._internal_category() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          2, this_._internal_category(), target);
    }
  }

  // .dnd5e.api.v1alpha1.ChoiceSource source = 3 [json_name = "source"];
  if ((this_._impl_._has_bits_[0] & 0x00000008U) != 0) {
    if (this_._internal_source() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          3, this_._internal_source(), target);
    }
  }

  // string option_id = 4 [json_name = "optionId"];
  if ((this_._impl_._has_bits_[0] & 0x00000002U) != 0) {
    if (!this_._internal_option_id().empty()) {
      const ::std::string& _s = this_._internal_option_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.ChoiceSubmission.option_id");
      target = stream->WriteStringMaybeAliased(4, _s, target);
    }
  }

  // repeated string selection_ids = 5 [json_name = "selectionIds"];
  for (int i = 0, n = this_._internal_selection_ids_size(); i < n; ++i) {
    const auto& s = this_._internal_selection_ids().Get(i);
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.ChoiceSubmission.selection_ids");
    target = stream->WriteString(5, s, target);
  }

  switch (this_.selection_case()) {
    case kSkills: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *this_._impl_.selection_.skills_, this_._impl_.selection_.skills_->GetCachedSize(), target,
          stream);
      break;
    }
    case kEquipment: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          7, *this_._impl_.selection_.equipment_, this_._impl_.selection_.equipment_->GetCachedSize(), target,
          stream);
      break;
    }
    case kLanguages: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          8, *this_._impl_.selection_.languages_, this_._impl_.selection_.languages_->GetCachedSize(), target,
          stream);
      break;
    }
    case kTools: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          9, *this_._impl_.selection_.tools_, this_._impl_.selection_.tools_->GetCachedSize(), target,
          stream);
      break;
    }
    case kFightingStyle: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          10, *this_._impl_.selection_.fighting_style_, this_._impl_.selection_.fighting_style_->GetCachedSize(), target,
          stream);
      break;
    }
    case kSpells: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          11, *this_._impl_.selection_.spells_, this_._impl_.selection_.spells_->GetCachedSize(), target,
          stream);
      break;
    }
    case kExpertise: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          12, *this_._impl_.selection_.expertise_, this_._impl_.selection_.expertise_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.ChoiceSubmission)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ChoiceSubmission::ByteSizeLong(const MessageLite& base) {
  const ChoiceSubmission& this_ = static_cast<const ChoiceSubmission&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ChoiceSubmission::ByteSizeLong() const {
  const ChoiceSubmission& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.ChoiceSubmission)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated string selection_ids = 5 [json_name = "selectionIds"];
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_selection_ids().size());
      for (int i = 0, n = this_._internal_selection_ids().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_selection_ids().Get(i));
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fU) != 0) {
    // string choice_id = 1 [json_name = "choiceId"];
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (!this_._internal_choice_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_choice_id());
      }
    }
    // string option_id = 4 [json_name = "optionId"];
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (!this_._internal_option_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_option_id());
      }
    }
    // .dnd5e.api.v1alpha1.ChoiceCategory category = 2 [json_name = "category"];
    if ((cached_has_bits & 0x00000004U) != 0) {
      if (this_._internal_category() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_category());
      }
    }
    // .dnd5e.api.v1alpha1.ChoiceSource source = 3 [json_name = "source"];
    if ((cached_has_bits & 0x00000008U) != 0) {
      if (this_._internal_source() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_source());
      }
    }
  }
  switch (this_.selection_case()) {
    // .dnd5e.api.v1alpha1.SkillSelection skills = 6 [json_name = "skills"];
    case kSkills: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.skills_);
      break;
    }
    // .dnd5e.api.v1alpha1.EquipmentSelection equipment = 7 [json_name = "equipment"];
    case kEquipment: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.equipment_);
      break;
    }
    // .dnd5e.api.v1alpha1.LanguageSelection languages = 8 [json_name = "languages"];
    case kLanguages: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.languages_);
      break;
    }
    // .dnd5e.api.v1alpha1.ToolSelection tools = 9 [json_name = "tools"];
    case kTools: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.tools_);
      break;
    }
    // .dnd5e.api.v1alpha1.FightingStyleSelection fighting_style = 10 [json_name = "fightingStyle"];
    case kFightingStyle: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.fighting_style_);
      break;
    }
    // .dnd5e.api.v1alpha1.SpellSelection spells = 11 [json_name = "spells"];
    case kSpells: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.spells_);
      break;
    }
    // .dnd5e.api.v1alpha1.ExpertiseSelection expertise = 12 [json_name = "expertise"];
    case kExpertise: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.expertise_);
      break;
    }
    case SELECTION_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ChoiceSubmission::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ChoiceSubmission*>(&to_msg);
  auto& from = static_cast<const ChoiceSubmission&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.ChoiceSubmission)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_selection_ids()->MergeFrom(from._internal_selection_ids());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fU) != 0) {
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (!from._internal_choice_id().empty()) {
        _this->_internal_set_choice_id(from._internal_choice_id());
      } else {
        if (_this->_impl_.choice_id_.IsDefault()) {
          _this->_internal_set_choice_id("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (!from._internal_option_id().empty()) {
        _this->_internal_set_option_id(from._internal_option_id());
      } else {
        if (_this->_impl_.option_id_.IsDefault()) {
          _this->_internal_set_option_id("");
        }
      }
    }
    if ((cached_has_bits & 0x00000004U) != 0) {
      if (from._internal_category() != 0) {
        _this->_impl_.category_ = from._impl_.category_;
      }
    }
    if ((cached_has_bits & 0x00000008U) != 0) {
      if (from._internal_source() != 0) {
        _this->_impl_.source_ = from._impl_.source_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_selection();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kSkills: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.skills_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.skills_);
        } else {
          _this->_impl_.selection_.skills_->MergeFrom(*from._impl_.selection_.skills_);
        }
        break;
      }
      case kEquipment: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.equipment_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.equipment_);
        } else {
          _this->_impl_.selection_.equipment_->MergeFrom(*from._impl_.selection_.equipment_);
        }
        break;
      }
      case kLanguages: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.languages_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.languages_);
        } else {
          _this->_impl_.selection_.languages_->MergeFrom(*from._impl_.selection_.languages_);
        }
        break;
      }
      case kTools: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.tools_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.tools_);
        } else {
          _this->_impl_.selection_.tools_->MergeFrom(*from._impl_.selection_.tools_);
        }
        break;
      }
      case kFightingStyle: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.fighting_style_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.fighting_style_);
        } else {
          _this->_impl_.selection_.fighting_style_->MergeFrom(*from._impl_.selection_.fighting_style_);
        }
        break;
      }
      case kSpells: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.spells_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.spells_);
        } else {
          _this->_impl_.selection_.spells_->MergeFrom(*from._impl_.selection_.spells_);
        }
        break;
      }
      case kExpertise: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.expertise_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.expertise_);
        } else {
          _this->_impl_.selection_.expertise_->MergeFrom(*from._impl_.selection_.expertise_);
        }
        break;
      }
      case SELECTION_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ChoiceSubmission::CopyFrom(const ChoiceSubmission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.ChoiceSubmission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ChoiceSubmission::InternalSwap(ChoiceSubmission* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.selection_ids_.InternalSwap(&other->_impl_.selection_ids_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.choice_id_, &other->_impl_.choice_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.option_id_, &other->_impl_.option_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.source_)
      + sizeof(ChoiceSubmission::_impl_.source_)
      - PROTOBUF_FIELD_OFFSET(ChoiceSubmission, _impl_.category_)>(
          reinterpret_cast<char*>(&_impl_.category_),
          reinterpret_cast<char*>(&other->_impl_.category_));
  swap(_impl_.selection_, other->_impl_.selection_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata ChoiceSubmission::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SkillSelection::_Internal {
 public:
};

SkillSelection::SkillSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SkillSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.SkillSelection)
}
PROTOBUF_NDEBUG_INLINE SkillSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::SkillSelection& from_msg)
      : skills_{visibility, arena, from.skills_},
        _skills_cached_byte_size_{0},
        _cached_size_{0} {}

SkillSelection::SkillSelection(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const SkillSelection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SkillSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SkillSelection* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.SkillSelection)
}
PROTOBUF_NDEBUG_INLINE SkillSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : skills_{visibility, arena},
        _skills_cached_byte_size_{0},
        _cached_size_{0} {}

inline void SkillSelection::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
SkillSelection::~SkillSelection() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.SkillSelection)
  SharedDtor(*this);
}
inline void SkillSelection::SharedDtor(MessageLite& self) {
  SkillSelection& this_ = static_cast<SkillSelection&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SkillSelection::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SkillSelection(arena);
}
constexpr auto SkillSelection::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SkillSelection, _impl_.skills_) +
          decltype(SkillSelection::_impl_.skills_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(SkillSelection), alignof(SkillSelection), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SkillSelection::PlacementNew_,
                                 sizeof(SkillSelection),
                                 alignof(SkillSelection));
  }
}
constexpr auto SkillSelection::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SkillSelection_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SkillSelection::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SkillSelection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SkillSelection::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SkillSelection>(), &SkillSelection::ByteSizeLong,
              &SkillSelection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SkillSelection, _impl_._cached_size_),
          false,
      },
      &SkillSelection::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SkillSelection_class_data_ =
        SkillSelection::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SkillSelection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SkillSelection_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SkillSelection_class_data_.tc_table);
  return SkillSelection_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
SkillSelection::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SkillSelection_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SkillSelection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(SkillSelection, _impl_.skills_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
    {PROTOBUF_FIELD_OFFSET(SkillSelection, _impl_.skills_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void SkillSelection::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.SkillSelection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.skills_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SkillSelection::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SkillSelection& this_ = static_cast<const SkillSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SkillSelection::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SkillSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.SkillSelection)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
  {
    ::size_t byte_size = this_._impl_._skills_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, this_._internal_skills(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.SkillSelection)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SkillSelection::ByteSizeLong(const MessageLite& base) {
  const SkillSelection& this_ = static_cast<const SkillSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SkillSelection::ByteSizeLong() const {
  const SkillSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.SkillSelection)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_skills(), 1, this_._impl_._skills_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SkillSelection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SkillSelection*>(&to_msg);
  auto& from = static_cast<const SkillSelection&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.SkillSelection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_skills()->MergeFrom(from._internal_skills());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SkillSelection::CopyFrom(const SkillSelection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.SkillSelection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SkillSelection::InternalSwap(SkillSelection* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.skills_.InternalSwap(&other->_impl_.skills_);
}

::google::protobuf::Metadata SkillSelection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class EquipmentSelection::_Internal {
 public:
};

EquipmentSelection::EquipmentSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EquipmentSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.EquipmentSelection)
}
PROTOBUF_NDEBUG_INLINE EquipmentSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::EquipmentSelection& from_msg)
      : items_{visibility, arena, from.items_},
        _cached_size_{0} {}

EquipmentSelection::EquipmentSelection(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const EquipmentSelection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EquipmentSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  EquipmentSelection* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.EquipmentSelection)
}
PROTOBUF_NDEBUG_INLINE EquipmentSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : items_{visibility, arena},
        _cached_size_{0} {}

inline void EquipmentSelection::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
EquipmentSelection::~EquipmentSelection() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.EquipmentSelection)
  SharedDtor(*this);
}
inline void EquipmentSelection::SharedDtor(MessageLite& self) {
  EquipmentSelection& this_ = static_cast<EquipmentSelection&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL EquipmentSelection::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) EquipmentSelection(arena);
}
constexpr auto EquipmentSelection::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(EquipmentSelection, _impl_.items_) +
          decltype(EquipmentSelection::_impl_.items_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(EquipmentSelection), alignof(EquipmentSelection), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&EquipmentSelection::PlacementNew_,
                                 sizeof(EquipmentSelection),
                                 alignof(EquipmentSelection));
  }
}
constexpr auto EquipmentSelection::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_EquipmentSelection_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &EquipmentSelection::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<EquipmentSelection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &EquipmentSelection::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<EquipmentSelection>(), &EquipmentSelection::ByteSizeLong,
              &EquipmentSelection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(EquipmentSelection, _impl_._cached_size_),
          false,
      },
      &EquipmentSelection::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull EquipmentSelection_class_data_ =
        EquipmentSelection::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
EquipmentSelection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&EquipmentSelection_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(EquipmentSelection_class_data_.tc_table);
  return EquipmentSelection_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2>
EquipmentSelection::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    EquipmentSelection_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentSelection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.EquipmentSelectionItem items = 1 [json_name = "items"];
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(EquipmentSelection, _impl_.items_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.EquipmentSelectionItem items = 1 [json_name = "items"];
    {PROTOBUF_FIELD_OFFSET(EquipmentSelection, _impl_.items_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentSelectionItem>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void EquipmentSelection::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.EquipmentSelection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL EquipmentSelection::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const EquipmentSelection& this_ = static_cast<const EquipmentSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL EquipmentSelection::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const EquipmentSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.EquipmentSelection)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.EquipmentSelectionItem items = 1 [json_name = "items"];
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_items_size());
       i < n; i++) {
    const auto& repfield = this_._internal_items().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            1, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.EquipmentSelection)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t EquipmentSelection::ByteSizeLong(const MessageLite& base) {
  const EquipmentSelection& this_ = static_cast<const EquipmentSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t EquipmentSelection::ByteSizeLong() const {
  const EquipmentSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.EquipmentSelection)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.EquipmentSelectionItem items = 1 [json_name = "items"];
    {
      total_size += 1UL * this_._internal_items_size();
      for (const auto& msg : this_._internal_items()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void EquipmentSelection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<EquipmentSelection*>(&to_msg);
  auto& from = static_cast<const EquipmentSelection&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.EquipmentSelection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_items()->MergeFrom(
      from._internal_items());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EquipmentSelection::CopyFrom(const EquipmentSelection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.EquipmentSelection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EquipmentSelection::InternalSwap(EquipmentSelection* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::google::protobuf::Metadata EquipmentSelection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class EquipmentSelectionItem::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<EquipmentSelectionItem>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(EquipmentSelectionItem, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EquipmentSelectionItem, _impl_._oneof_case_);
};

EquipmentSelectionItem::EquipmentSelectionItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EquipmentSelectionItem_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.EquipmentSelectionItem)
}
PROTOBUF_NDEBUG_INLINE EquipmentSelectionItem::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::EquipmentSelectionItem& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        equipment_{},
        _oneof_case_{from._oneof_case_[0]} {}

EquipmentSelectionItem::EquipmentSelectionItem(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const EquipmentSelectionItem& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EquipmentSelectionItem_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  EquipmentSelectionItem* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.quantity_ = from._impl_.quantity_;
  switch (equipment_case()) {
    case EQUIPMENT_NOT_SET:
      break;
      case kWeapon:
        _impl_.equipment_.weapon_ = from._impl_.equipment_.weapon_;
        break;
      case kArmor:
        _impl_.equipment_.armor_ = from._impl_.equipment_.armor_;
        break;
      case kTool:
        _impl_.equipment_.tool_ = from._impl_.equipment_.tool_;
        break;
      case kPack:
        _impl_.equipment_.pack_ = from._impl_.equipment_.pack_;
        break;
      case kAmmunition:
        _impl_.equipment_.ammunition_ = from._impl_.equipment_.ammunition_;
        break;
      case kOtherEquipmentId:
        new (&_impl_.equipment_.other_equipment_id_) decltype(_impl_.equipment_.other_equipment_id_){arena, from._impl_.equipment_.other_equipment_id_};
        break;
  }

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.EquipmentSelectionItem)
}
PROTOBUF_NDEBUG_INLINE EquipmentSelectionItem::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        equipment_{},
        _oneof_case_{} {}

inline void EquipmentSelectionItem::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.quantity_ = {};
}
EquipmentSelectionItem::~EquipmentSelectionItem() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.EquipmentSelectionItem)
  SharedDtor(*this);
}
inline void EquipmentSelectionItem::SharedDtor(MessageLite& self) {
  EquipmentSelectionItem& this_ = static_cast<EquipmentSelectionItem&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_equipment()) {
    this_.clear_equipment();
  }
  this_._impl_.~Impl_();
}

void EquipmentSelectionItem::clear_equipment() {
// @@protoc_insertion_point(one_of_clear_start:dnd5e.api.v1alpha1.EquipmentSelectionItem)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (equipment_case()) {
    case kWeapon: {
      // No need to clear
      break;
    }
    case kArmor: {
      // No need to clear
      break;
    }
    case kTool: {
      // No need to clear
      break;
    }
    case kPack: {
      // No need to clear
      break;
    }
    case kAmmunition: {
      // No need to clear
      break;
    }
    case kOtherEquipmentId: {
      _impl_.equipment_.other_equipment_id_.Destroy();
      break;
    }
    case EQUIPMENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = EQUIPMENT_NOT_SET;
}


inline void* PROTOBUF_NONNULL EquipmentSelectionItem::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) EquipmentSelectionItem(arena);
}
constexpr auto EquipmentSelectionItem::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(EquipmentSelectionItem),
                                            alignof(EquipmentSelectionItem));
}
constexpr auto EquipmentSelectionItem::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_EquipmentSelectionItem_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &EquipmentSelectionItem::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<EquipmentSelectionItem>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &EquipmentSelectionItem::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<EquipmentSelectionItem>(), &EquipmentSelectionItem::ByteSizeLong,
              &EquipmentSelectionItem::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(EquipmentSelectionItem, _impl_._cached_size_),
          false,
      },
      &EquipmentSelectionItem::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull EquipmentSelectionItem_class_data_ =
        EquipmentSelectionItem::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
EquipmentSelectionItem::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&EquipmentSelectionItem_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(EquipmentSelectionItem_class_data_.tc_table);
  return EquipmentSelectionItem_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 7, 0, 68, 2>
EquipmentSelectionItem::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EquipmentSelectionItem, _impl_._has_bits_),
    0, // no _extensions_
    7, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    EquipmentSelectionItem_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentSelectionItem>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // int32 quantity = 7 [json_name = "quantity"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(EquipmentSelectionItem, _impl_.quantity_), 0>(),
     {56, 0, 0, PROTOBUF_FIELD_OFFSET(EquipmentSelectionItem, _impl_.quantity_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.Weapon weapon = 1 [json_name = "weapon"];
    {PROTOBUF_FIELD_OFFSET(EquipmentSelectionItem, _impl_.equipment_.weapon_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.Armor armor = 2 [json_name = "armor"];
    {PROTOBUF_FIELD_OFFSET(EquipmentSelectionItem, _impl_.equipment_.armor_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.Tool tool = 3 [json_name = "tool"];
    {PROTOBUF_FIELD_OFFSET(EquipmentSelectionItem, _impl_.equipment_.tool_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.Pack pack = 4 [json_name = "pack"];
    {PROTOBUF_FIELD_OFFSET(EquipmentSelectionItem, _impl_.equipment_.pack_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.Ammunition ammunition = 5 [json_name = "ammunition"];
    {PROTOBUF_FIELD_OFFSET(EquipmentSelectionItem, _impl_.equipment_.ammunition_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // string other_equipment_id = 6 [json_name = "otherEquipmentId"];
    {PROTOBUF_FIELD_OFFSET(EquipmentSelectionItem, _impl_.equipment_.other_equipment_id_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 quantity = 7 [json_name = "quantity"];
    {PROTOBUF_FIELD_OFFSET(EquipmentSelectionItem, _impl_.quantity_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
    "\51\0\0\0\0\0\22\0"
    "dnd5e.api.v1alpha1.EquipmentSelectionItem"
    "other_equipment_id"
  }},
};
PROTOBUF_NOINLINE void EquipmentSelectionItem::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.EquipmentSelectionItem)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.quantity_ = 0;
  clear_equipment();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL EquipmentSelectionItem::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const EquipmentSelectionItem& this_ = static_cast<const EquipmentSelectionItem&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL EquipmentSelectionItem::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const EquipmentSelectionItem& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.EquipmentSelectionItem)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (this_.equipment_case()) {
    case kWeapon: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          1, this_._internal_weapon(), target);
      break;
    }
    case kArmor: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          2, this_._internal_armor(), target);
      break;
    }
    case kTool: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          3, this_._internal_tool(), target);
      break;
    }
    case kPack: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          4, this_._internal_pack(), target);
      break;
    }
    case kAmmunition: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          5, this_._internal_ammunition(), target);
      break;
    }
    case kOtherEquipmentId: {
      const ::std::string& _s = this_._internal_other_equipment_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.EquipmentSelectionItem.other_equipment_id");
      target = stream->WriteStringMaybeAliased(6, _s, target);
      break;
    }
    default:
      break;
  }
  // int32 quantity = 7 [json_name = "quantity"];
  if ((this_._impl_._has_bits_[0] & 0x00000001U) != 0) {
    if (this_._internal_quantity() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<7>(
              stream, this_._internal_quantity(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.EquipmentSelectionItem)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t EquipmentSelectionItem::ByteSizeLong(const MessageLite& base) {
  const EquipmentSelectionItem& this_ = static_cast<const EquipmentSelectionItem&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t EquipmentSelectionItem::ByteSizeLong() const {
  const EquipmentSelectionItem& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.EquipmentSelectionItem)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // int32 quantity = 7 [json_name = "quantity"];
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (this_._internal_quantity() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_quantity());
      }
    }
  }
  switch (this_.equipment_case()) {
    // .dnd5e.api.v1alpha1.Weapon weapon = 1 [json_name = "weapon"];
    case kWeapon: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_weapon());
      break;
    }
    // .dnd5e.api.v1alpha1.Armor armor = 2 [json_name = "armor"];
    case kArmor: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_armor());
      break;
    }
    // .dnd5e.api.v1alpha1.Tool tool = 3 [json_name = "tool"];
    case kTool: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_tool());
      break;
    }
    // .dnd5e.api.v1alpha1.Pack pack = 4 [json_name = "pack"];
    case kPack: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_pack());
      break;
    }
    // .dnd5e.api.v1alpha1.Ammunition ammunition = 5 [json_name = "ammunition"];
    case kAmmunition: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_ammunition());
      break;
    }
    // string other_equipment_id = 6 [json_name = "otherEquipmentId"];
    case kOtherEquipmentId: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_other_equipment_id());
      break;
    }
    case EQUIPMENT_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void EquipmentSelectionItem::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<EquipmentSelectionItem*>(&to_msg);
  auto& from = static_cast<const EquipmentSelectionItem&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.EquipmentSelectionItem)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001U) != 0) {
    if (from._internal_quantity() != 0) {
      _this->_impl_.quantity_ = from._impl_.quantity_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_equipment();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kWeapon: {
        _this->_impl_.equipment_.weapon_ = from._impl_.equipment_.weapon_;
        break;
      }
      case kArmor: {
        _this->_impl_.equipment_.armor_ = from._impl_.equipment_.armor_;
        break;
      }
      case kTool: {
        _this->_impl_.equipment_.tool_ = from._impl_.equipment_.tool_;
        break;
      }
      case kPack: {
        _this->_impl_.equipment_.pack_ = from._impl_.equipment_.pack_;
        break;
      }
      case kAmmunition: {
        _this->_impl_.equipment_.ammunition_ = from._impl_.equipment_.ammunition_;
        break;
      }
      case kOtherEquipmentId: {
        if (oneof_needs_init) {
          _this->_impl_.equipment_.other_equipment_id_.InitDefault();
        }
        _this->_impl_.equipment_.other_equipment_id_.Set(from._internal_other_equipment_id(), arena);
        break;
      }
      case EQUIPMENT_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EquipmentSelectionItem::CopyFrom(const EquipmentSelectionItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.EquipmentSelectionItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EquipmentSelectionItem::InternalSwap(EquipmentSelectionItem* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.quantity_, other->_impl_.quantity_);
  swap(_impl_.equipment_, other->_impl_.equipment_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata EquipmentSelectionItem::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LanguageSelection::_Internal {
 public:
};

LanguageSelection::LanguageSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LanguageSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.LanguageSelection)
}
PROTOBUF_NDEBUG_INLINE LanguageSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::LanguageSelection& from_msg)
      : languages_{visibility, arena, from.languages_},
        _languages_cached_byte_size_{0},
        _cached_size_{0} {}

LanguageSelection::LanguageSelection(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const LanguageSelection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LanguageSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LanguageSelection* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.LanguageSelection)
}
PROTOBUF_NDEBUG_INLINE LanguageSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : languages_{visibility, arena},
        _languages_cached_byte_size_{0},
        _cached_size_{0} {}

inline void LanguageSelection::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
LanguageSelection::~LanguageSelection() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.LanguageSelection)
  SharedDtor(*this);
}
inline void LanguageSelection::SharedDtor(MessageLite& self) {
  LanguageSelection& this_ = static_cast<LanguageSelection&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL LanguageSelection::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) LanguageSelection(arena);
}
constexpr auto LanguageSelection::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(LanguageSelection, _impl_.languages_) +
          decltype(LanguageSelection::_impl_.languages_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(LanguageSelection), alignof(LanguageSelection), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&LanguageSelection::PlacementNew_,
                                 sizeof(LanguageSelection),
                                 alignof(LanguageSelection));
  }
}
constexpr auto LanguageSelection::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_LanguageSelection_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &LanguageSelection::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<LanguageSelection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &LanguageSelection::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<LanguageSelection>(), &LanguageSelection::ByteSizeLong,
              &LanguageSelection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(LanguageSelection, _impl_._cached_size_),
          false,
      },
      &LanguageSelection::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull LanguageSelection_class_data_ =
        LanguageSelection::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
LanguageSelection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&LanguageSelection_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(LanguageSelection_class_data_.tc_table);
  return LanguageSelection_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
LanguageSelection::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    LanguageSelection_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::LanguageSelection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.Language languages = 1 [json_name = "languages"];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(LanguageSelection, _impl_.languages_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.Language languages = 1 [json_name = "languages"];
    {PROTOBUF_FIELD_OFFSET(LanguageSelection, _impl_.languages_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void LanguageSelection::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.LanguageSelection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.languages_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL LanguageSelection::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const LanguageSelection& this_ = static_cast<const LanguageSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL LanguageSelection::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const LanguageSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.LanguageSelection)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.Language languages = 1 [json_name = "languages"];
  {
    ::size_t byte_size = this_._impl_._languages_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, this_._internal_languages(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.LanguageSelection)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t LanguageSelection::ByteSizeLong(const MessageLite& base) {
  const LanguageSelection& this_ = static_cast<const LanguageSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t LanguageSelection::ByteSizeLong() const {
  const LanguageSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.LanguageSelection)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.Language languages = 1 [json_name = "languages"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_languages(), 1, this_._impl_._languages_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void LanguageSelection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LanguageSelection*>(&to_msg);
  auto& from = static_cast<const LanguageSelection&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.LanguageSelection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_languages()->MergeFrom(from._internal_languages());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LanguageSelection::CopyFrom(const LanguageSelection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.LanguageSelection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LanguageSelection::InternalSwap(LanguageSelection* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.languages_.InternalSwap(&other->_impl_.languages_);
}

::google::protobuf::Metadata LanguageSelection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ToolSelection::_Internal {
 public:
};

ToolSelection::ToolSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ToolSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.ToolSelection)
}
PROTOBUF_NDEBUG_INLINE ToolSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::ToolSelection& from_msg)
      : tools_{visibility, arena, from.tools_},
        _tools_cached_byte_size_{0},
        _cached_size_{0} {}

ToolSelection::ToolSelection(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ToolSelection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ToolSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ToolSelection* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.ToolSelection)
}
PROTOBUF_NDEBUG_INLINE ToolSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : tools_{visibility, arena},
        _tools_cached_byte_size_{0},
        _cached_size_{0} {}

inline void ToolSelection::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
ToolSelection::~ToolSelection() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.ToolSelection)
  SharedDtor(*this);
}
inline void ToolSelection::SharedDtor(MessageLite& self) {
  ToolSelection& this_ = static_cast<ToolSelection&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ToolSelection::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ToolSelection(arena);
}
constexpr auto ToolSelection::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ToolSelection, _impl_.tools_) +
          decltype(ToolSelection::_impl_.tools_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(ToolSelection), alignof(ToolSelection), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ToolSelection::PlacementNew_,
                                 sizeof(ToolSelection),
                                 alignof(ToolSelection));
  }
}
constexpr auto ToolSelection::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ToolSelection_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ToolSelection::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ToolSelection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ToolSelection::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ToolSelection>(), &ToolSelection::ByteSizeLong,
              &ToolSelection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ToolSelection, _impl_._cached_size_),
          false,
      },
      &ToolSelection::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ToolSelection_class_data_ =
        ToolSelection::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ToolSelection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ToolSelection_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ToolSelection_class_data_.tc_table);
  return ToolSelection_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
ToolSelection::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ToolSelection_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ToolSelection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.Tool tools = 1 [json_name = "tools"];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(ToolSelection, _impl_.tools_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.Tool tools = 1 [json_name = "tools"];
    {PROTOBUF_FIELD_OFFSET(ToolSelection, _impl_.tools_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ToolSelection::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.ToolSelection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tools_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ToolSelection::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ToolSelection& this_ = static_cast<const ToolSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ToolSelection::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ToolSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.ToolSelection)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.Tool tools = 1 [json_name = "tools"];
  {
    ::size_t byte_size = this_._impl_._tools_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, this_._internal_tools(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.ToolSelection)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ToolSelection::ByteSizeLong(const MessageLite& base) {
  const ToolSelection& this_ = static_cast<const ToolSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ToolSelection::ByteSizeLong() const {
  const ToolSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.ToolSelection)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.Tool tools = 1 [json_name = "tools"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_tools(), 1, this_._impl_._tools_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ToolSelection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ToolSelection*>(&to_msg);
  auto& from = static_cast<const ToolSelection&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.ToolSelection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_tools()->MergeFrom(from._internal_tools());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ToolSelection::CopyFrom(const ToolSelection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.ToolSelection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ToolSelection::InternalSwap(ToolSelection* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tools_.InternalSwap(&other->_impl_.tools_);
}

::google::protobuf::Metadata ToolSelection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class FightingStyleSelection::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<FightingStyleSelection>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(FightingStyleSelection, _impl_._has_bits_);
};

FightingStyleSelection::FightingStyleSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FightingStyleSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.FightingStyleSelection)
}
FightingStyleSelection::FightingStyleSelection(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FightingStyleSelection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FightingStyleSelection_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE FightingStyleSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void FightingStyleSelection::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.style_ = {};
}
FightingStyleSelection::~FightingStyleSelection() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.FightingStyleSelection)
  SharedDtor(*this);
}
inline void FightingStyleSelection::SharedDtor(MessageLite& self) {
  FightingStyleSelection& this_ = static_cast<FightingStyleSelection&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL FightingStyleSelection::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) FightingStyleSelection(arena);
}
constexpr auto FightingStyleSelection::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(FightingStyleSelection),
                                            alignof(FightingStyleSelection));
}
constexpr auto FightingStyleSelection::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_FightingStyleSelection_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &FightingStyleSelection::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<FightingStyleSelection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &FightingStyleSelection::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<FightingStyleSelection>(), &FightingStyleSelection::ByteSizeLong,
              &FightingStyleSelection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(FightingStyleSelection, _impl_._cached_size_),
          false,
      },
      &FightingStyleSelection::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull FightingStyleSelection_class_data_ =
        FightingStyleSelection::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
FightingStyleSelection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&FightingStyleSelection_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(FightingStyleSelection_class_data_.tc_table);
  return FightingStyleSelection_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
FightingStyleSelection::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FightingStyleSelection, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    FightingStyleSelection_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::FightingStyleSelection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.FightingStyle style = 1 [json_name = "style"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(FightingStyleSelection, _impl_.style_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(FightingStyleSelection, _impl_.style_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.FightingStyle style = 1 [json_name = "style"];
    {PROTOBUF_FIELD_OFFSET(FightingStyleSelection, _impl_.style_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void FightingStyleSelection::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.FightingStyleSelection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.style_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL FightingStyleSelection::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const FightingStyleSelection& this_ = static_cast<const FightingStyleSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL FightingStyleSelection::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const FightingStyleSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.FightingStyleSelection)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .dnd5e.api.v1alpha1.FightingStyle style = 1 [json_name = "style"];
  if ((this_._impl_._has_bits_[0] & 0x00000001U) != 0) {
    if (this_._internal_style() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          1, this_._internal_style(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.FightingStyleSelection)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t FightingStyleSelection::ByteSizeLong(const MessageLite& base) {
  const FightingStyleSelection& this_ = static_cast<const FightingStyleSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t FightingStyleSelection::ByteSizeLong() const {
  const FightingStyleSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.FightingStyleSelection)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // .dnd5e.api.v1alpha1.FightingStyle style = 1 [json_name = "style"];
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (this_._internal_style() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_style());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void FightingStyleSelection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<FightingStyleSelection*>(&to_msg);
  auto& from = static_cast<const FightingStyleSelection&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.FightingStyleSelection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001U) != 0) {
    if (from._internal_style() != 0) {
      _this->_impl_.style_ = from._impl_.style_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FightingStyleSelection::CopyFrom(const FightingStyleSelection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.FightingStyleSelection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void FightingStyleSelection::InternalSwap(FightingStyleSelection* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.style_, other->_impl_.style_);
}

::google::protobuf::Metadata FightingStyleSelection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SpellSelection::_Internal {
 public:
};

SpellSelection::SpellSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SpellSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.SpellSelection)
}
PROTOBUF_NDEBUG_INLINE SpellSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::SpellSelection& from_msg)
      : spells_{visibility, arena, from.spells_},
        _spells_cached_byte_size_{0},
        _cached_size_{0} {}

SpellSelection::SpellSelection(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const SpellSelection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SpellSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SpellSelection* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.SpellSelection)
}
PROTOBUF_NDEBUG_INLINE SpellSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : spells_{visibility, arena},
        _spells_cached_byte_size_{0},
        _cached_size_{0} {}

inline void SpellSelection::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
SpellSelection::~SpellSelection() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.SpellSelection)
  SharedDtor(*this);
}
inline void SpellSelection::SharedDtor(MessageLite& self) {
  SpellSelection& this_ = static_cast<SpellSelection&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SpellSelection::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SpellSelection(arena);
}
constexpr auto SpellSelection::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SpellSelection, _impl_.spells_) +
          decltype(SpellSelection::_impl_.spells_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(SpellSelection), alignof(SpellSelection), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SpellSelection::PlacementNew_,
                                 sizeof(SpellSelection),
                                 alignof(SpellSelection));
  }
}
constexpr auto SpellSelection::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SpellSelection_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SpellSelection::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SpellSelection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SpellSelection::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SpellSelection>(), &SpellSelection::ByteSizeLong,
              &SpellSelection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SpellSelection, _impl_._cached_size_),
          false,
      },
      &SpellSelection::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SpellSelection_class_data_ =
        SpellSelection::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SpellSelection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SpellSelection_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SpellSelection_class_data_.tc_table);
  return SpellSelection_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
SpellSelection::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SpellSelection_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SpellSelection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.Spell spells = 1 [json_name = "spells"];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(SpellSelection, _impl_.spells_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.Spell spells = 1 [json_name = "spells"];
    {PROTOBUF_FIELD_OFFSET(SpellSelection, _impl_.spells_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void SpellSelection::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.SpellSelection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.spells_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SpellSelection::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SpellSelection& this_ = static_cast<const SpellSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SpellSelection::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SpellSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.SpellSelection)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.Spell spells = 1 [json_name = "spells"];
  {
    ::size_t byte_size = this_._impl_._spells_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, this_._internal_spells(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.SpellSelection)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SpellSelection::ByteSizeLong(const MessageLite& base) {
  const SpellSelection& this_ = static_cast<const SpellSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SpellSelection::ByteSizeLong() const {
  const SpellSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.SpellSelection)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.Spell spells = 1 [json_name = "spells"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_spells(), 1, this_._impl_._spells_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SpellSelection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SpellSelection*>(&to_msg);
  auto& from = static_cast<const SpellSelection&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.SpellSelection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_spells()->MergeFrom(from._internal_spells());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SpellSelection::CopyFrom(const SpellSelection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.SpellSelection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SpellSelection::InternalSwap(SpellSelection* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.spells_.InternalSwap(&other->_impl_.spells_);
}

::google::protobuf::Metadata SpellSelection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ExpertiseSelection::_Internal {
 public:
};

ExpertiseSelection::ExpertiseSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ExpertiseSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.ExpertiseSelection)
}
PROTOBUF_NDEBUG_INLINE ExpertiseSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::ExpertiseSelection& from_msg)
      : skills_{visibility, arena, from.skills_},
        _skills_cached_byte_size_{0},
        tools_{visibility, arena, from.tools_},
        _tools_cached_byte_size_{0},
        _cached_size_{0} {}

ExpertiseSelection::ExpertiseSelection(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ExpertiseSelection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ExpertiseSelection_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ExpertiseSelection* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.ExpertiseSelection)
}
PROTOBUF_NDEBUG_INLINE ExpertiseSelection::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : skills_{visibility, arena},
        _skills_cached_byte_size_{0},
        tools_{visibility, arena},
        _tools_cached_byte_size_{0},
        _cached_size_{0} {}

inline void ExpertiseSelection::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
ExpertiseSelection::~ExpertiseSelection() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.ExpertiseSelection)
  SharedDtor(*this);
}
inline void ExpertiseSelection::SharedDtor(MessageLite& self) {
  ExpertiseSelection& this_ = static_cast<ExpertiseSelection&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ExpertiseSelection::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ExpertiseSelection(arena);
}
constexpr auto ExpertiseSelection::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ExpertiseSelection, _impl_.skills_) +
          decltype(ExpertiseSelection::_impl_.skills_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ExpertiseSelection, _impl_.tools_) +
          decltype(ExpertiseSelection::_impl_.tools_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(ExpertiseSelection), alignof(ExpertiseSelection), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ExpertiseSelection::PlacementNew_,
                                 sizeof(ExpertiseSelection),
                                 alignof(ExpertiseSelection));
  }
}
constexpr auto ExpertiseSelection::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ExpertiseSelection_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ExpertiseSelection::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ExpertiseSelection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ExpertiseSelection::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ExpertiseSelection>(), &ExpertiseSelection::ByteSizeLong,
              &ExpertiseSelection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ExpertiseSelection, _impl_._cached_size_),
          false,
      },
      &ExpertiseSelection::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ExpertiseSelection_class_data_ =
        ExpertiseSelection::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ExpertiseSelection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ExpertiseSelection_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ExpertiseSelection_class_data_.tc_table);
  return ExpertiseSelection_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
ExpertiseSelection::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ExpertiseSelection_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ExpertiseSelection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .dnd5e.api.v1alpha1.Tool tools = 2 [json_name = "tools"];
    {::_pbi::TcParser::FastV32P1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(ExpertiseSelection, _impl_.tools_)}},
    // repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(ExpertiseSelection, _impl_.skills_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
    {PROTOBUF_FIELD_OFFSET(ExpertiseSelection, _impl_.skills_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // repeated .dnd5e.api.v1alpha1.Tool tools = 2 [json_name = "tools"];
    {PROTOBUF_FIELD_OFFSET(ExpertiseSelection, _impl_.tools_), 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ExpertiseSelection::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.ExpertiseSelection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.skills_.Clear();
  _impl_.tools_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ExpertiseSelection::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ExpertiseSelection& this_ = static_cast<const ExpertiseSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ExpertiseSelection::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ExpertiseSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.ExpertiseSelection)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
  {
    ::size_t byte_size = this_._impl_._skills_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, this_._internal_skills(), byte_size, target);
    }
  }

  // repeated .dnd5e.api.v1alpha1.Tool tools = 2 [json_name = "tools"];
  {
    ::size_t byte_size = this_._impl_._tools_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, this_._internal_tools(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.ExpertiseSelection)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ExpertiseSelection::ByteSizeLong(const MessageLite& base) {
  const ExpertiseSelection& this_ = static_cast<const ExpertiseSelection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ExpertiseSelection::ByteSizeLong() const {
  const ExpertiseSelection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.ExpertiseSelection)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_skills(), 1, this_._impl_._skills_cached_byte_size_);
    }
    // repeated .dnd5e.api.v1alpha1.Tool tools = 2 [json_name = "tools"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_tools(), 1, this_._impl_._tools_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ExpertiseSelection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ExpertiseSelection*>(&to_msg);
  auto& from = static_cast<const ExpertiseSelection&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.ExpertiseSelection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_skills()->MergeFrom(from._internal_skills());
  _this->_internal_mutable_tools()->MergeFrom(from._internal_tools());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ExpertiseSelection::CopyFrom(const ExpertiseSelection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.ExpertiseSelection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ExpertiseSelection::InternalSwap(ExpertiseSelection* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.skills_.InternalSwap(&other->_impl_.skills_);
  _impl_.tools_.InternalSwap(&other->_impl_.tools_);
}

::google::protobuf::Metadata ExpertiseSelection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ChoiceData::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ChoiceData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ChoiceData, _impl_._oneof_case_);
};

void ChoiceData::set_allocated_skills(::dnd5e::api::v1alpha1::SkillSelection* PROTOBUF_NULLABLE skills) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (skills) {
    ::google::protobuf::Arena* submessage_arena = skills->GetArena();
    if (message_arena != submessage_arena) {
      skills = ::google::protobuf::internal::GetOwnedMessage(message_arena, skills, submessage_arena);
    }
    set_has_skills();
    _impl_.selection_.skills_ = skills;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.skills)
}
void ChoiceData::set_allocated_languages(::dnd5e::api::v1alpha1::LanguageSelection* PROTOBUF_NULLABLE languages) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (languages) {
    ::google::protobuf::Arena* submessage_arena = languages->GetArena();
    if (message_arena != submessage_arena) {
      languages = ::google::protobuf::internal::GetOwnedMessage(message_arena, languages, submessage_arena);
    }
    set_has_languages();
    _impl_.selection_.languages_ = languages;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.languages)
}
void ChoiceData::set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE ability_scores) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (ability_scores) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(ability_scores)->GetArena();
    if (message_arena != submessage_arena) {
      ability_scores = ::google::protobuf::internal::GetOwnedMessage(message_arena, ability_scores, submessage_arena);
    }
    set_has_ability_scores();
    _impl_.selection_.ability_scores_ = ability_scores;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.ability_scores)
}
void ChoiceData::clear_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kAbilityScores) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.ability_scores_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.ability_scores_);
    }
    clear_has_selection();
  }
}
void ChoiceData::set_allocated_fighting_style(::dnd5e::api::v1alpha1::FightingStyleSelection* PROTOBUF_NULLABLE fighting_style) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (fighting_style) {
    ::google::protobuf::Arena* submessage_arena = fighting_style->GetArena();
    if (message_arena != submessage_arena) {
      fighting_style = ::google::protobuf::internal::GetOwnedMessage(message_arena, fighting_style, submessage_arena);
    }
    set_has_fighting_style();
    _impl_.selection_.fighting_style_ = fighting_style;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.fighting_style)
}
void ChoiceData::set_allocated_equipment(::dnd5e::api::v1alpha1::EquipmentSelection* PROTOBUF_NULLABLE equipment) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (equipment) {
    ::google::protobuf::Arena* submessage_arena = equipment->GetArena();
    if (message_arena != submessage_arena) {
      equipment = ::google::protobuf::internal::GetOwnedMessage(message_arena, equipment, submessage_arena);
    }
    set_has_equipment();
    _impl_.selection_.equipment_ = equipment;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.equipment)
}
void ChoiceData::set_allocated_spells(::dnd5e::api::v1alpha1::SpellSelection* PROTOBUF_NULLABLE spells) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (spells) {
    ::google::protobuf::Arena* submessage_arena = spells->GetArena();
    if (message_arena != submessage_arena) {
      spells = ::google::protobuf::internal::GetOwnedMessage(message_arena, spells, submessage_arena);
    }
    set_has_spells();
    _impl_.selection_.spells_ = spells;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.spells)
}
void ChoiceData::set_allocated_tools(::dnd5e::api::v1alpha1::ToolSelection* PROTOBUF_NULLABLE tools) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (tools) {
    ::google::protobuf::Arena* submessage_arena = tools->GetArena();
    if (message_arena != submessage_arena) {
      tools = ::google::protobuf::internal::GetOwnedMessage(message_arena, tools, submessage_arena);
    }
    set_has_tools();
    _impl_.selection_.tools_ = tools;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.tools)
}
void ChoiceData::set_allocated_expertise(::dnd5e::api::v1alpha1::ExpertiseSelection* PROTOBUF_NULLABLE expertise) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_selection();
  if (expertise) {
    ::google::protobuf::Arena* submessage_arena = expertise->GetArena();
    if (message_arena != submessage_arena) {
      expertise = ::google::protobuf::internal::GetOwnedMessage(message_arena, expertise, submessage_arena);
    }
    set_has_expertise();
    _impl_.selection_.expertise_ = expertise;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.expertise)
}
ChoiceData::ChoiceData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChoiceData_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.ChoiceData)
}
PROTOBUF_NDEBUG_INLINE ChoiceData::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::ChoiceData& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        choice_id_(arena, from.choice_id_),
        option_id_(arena, from.option_id_),
        selection_{},
        _oneof_case_{from._oneof_case_[0]} {}

ChoiceData::ChoiceData(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ChoiceData& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChoiceData_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ChoiceData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, category_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, category_),
           offsetof(Impl_, source_) -
               offsetof(Impl_, category_) +
               sizeof(Impl_::source_));
  switch (selection_case()) {
    case SELECTION_NOT_SET:
      break;
      case kName:
        new (&_impl_.selection_.name_) decltype(_impl_.selection_.name_){arena, from._impl_.selection_.name_};
        break;
      case kSkills:
        _impl_.selection_.skills_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.skills_);
        break;
      case kLanguages:
        _impl_.selection_.languages_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.languages_);
        break;
      case kAbilityScores:
        _impl_.selection_.ability_scores_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.ability_scores_);
        break;
      case kFightingStyle:
        _impl_.selection_.fighting_style_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.fighting_style_);
        break;
      case kEquipment:
        _impl_.selection_.equipment_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.equipment_);
        break;
      case kBackground:
        _impl_.selection_.background_ = from._impl_.selection_.background_;
        break;
      case kSpells:
        _impl_.selection_.spells_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.spells_);
        break;
      case kTools:
        _impl_.selection_.tools_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.tools_);
        break;
      case kExpertise:
        _impl_.selection_.expertise_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.expertise_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.ChoiceData)
}
PROTOBUF_NDEBUG_INLINE ChoiceData::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        choice_id_(arena),
        option_id_(arena),
        selection_{},
        _oneof_case_{} {}

inline void ChoiceData::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, category_),
           0,
           offsetof(Impl_, source_) -
               offsetof(Impl_, category_) +
               sizeof(Impl_::source_));
}
ChoiceData::~ChoiceData() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.ChoiceData)
  SharedDtor(*this);
}
inline void ChoiceData::SharedDtor(MessageLite& self) {
  ChoiceData& this_ = static_cast<ChoiceData&>(self);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.choice_id_.Destroy();
  this_._impl_.option_id_.Destroy();
  if (this_.has_selection()) {
    this_.clear_selection();
  }
  this_._impl_.~Impl_();
}

void ChoiceData::clear_selection() {
// @@protoc_insertion_point(one_of_clear_start:dnd5e.api.v1alpha1.ChoiceData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (selection_case()) {
    case kName: {
      _impl_.selection_.name_.Destroy();
      break;
    }
    case kSkills: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.skills_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.skills_);
      }
      break;
    }
    case kLanguages: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.languages_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.languages_);
      }
      break;
    }
    case kAbilityScores: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.ability_scores_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.ability_scores_);
      }
      break;
    }
    case kFightingStyle: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.fighting_style_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.fighting_style_);
      }
      break;
    }
    case kEquipment: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.equipment_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.equipment_);
      }
      break;
    }
    case kBackground: {
      // No need to clear
      break;
    }
    case kSpells: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.spells_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.spells_);
      }
      break;
    }
    case kTools: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.tools_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.tools_);
      }
      break;
    }
    case kExpertise: {
      if (GetArena() == nullptr) {
        delete _impl_.selection_.expertise_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.expertise_);
      }
      break;
    }
    case SELECTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SELECTION_NOT_SET;
}


inline void* PROTOBUF_NONNULL ChoiceData::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ChoiceData(arena);
}
constexpr auto ChoiceData::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ChoiceData),
                                            alignof(ChoiceData));
}
constexpr auto ChoiceData::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ChoiceData_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ChoiceData::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ChoiceData>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ChoiceData::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ChoiceData>(), &ChoiceData::ByteSizeLong,
              &ChoiceData::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_._cached_size_),
          false,
      },
      &ChoiceData::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ChoiceData_class_data_ =
        ChoiceData::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ChoiceData::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ChoiceData_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ChoiceData_class_data_.tc_table);
  return ChoiceData_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 14, 8, 68, 2>
ChoiceData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_._has_bits_),
    0, // no _extensions_
    14, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950912,  // skipmap
    offsetof(decltype(_table_), field_entries),
    14,  // num_field_entries
    8,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ChoiceData_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ChoiceData>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string option_id = 4 [json_name = "optionId"];
    {::_pbi::TcParser::FastUS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.option_id_)}},
    // .dnd5e.api.v1alpha1.ChoiceCategory category = 1 [json_name = "category"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChoiceData, _impl_.category_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.category_)}},
    // .dnd5e.api.v1alpha1.ChoiceSource source = 2 [json_name = "source"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChoiceData, _impl_.source_), 3>(),
     {16, 3, 0, PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.source_)}},
    // string choice_id = 3 [json_name = "choiceId"];
    {::_pbi::TcParser::FastUS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.choice_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.ChoiceCategory category = 1 [json_name = "category"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.category_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.ChoiceSource source = 2 [json_name = "source"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.source_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // string choice_id = 3 [json_name = "choiceId"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.choice_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string option_id = 4 [json_name = "optionId"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.option_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string name = 5 [json_name = "name"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.selection_.name_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.SkillSelection skills = 6 [json_name = "skills"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.selection_.skills_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.LanguageSelection languages = 7 [json_name = "languages"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.selection_.languages_), _Internal::kOneofCaseOffset + 0, 1, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.AbilityScores ability_scores = 8 [json_name = "abilityScores"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.selection_.ability_scores_), _Internal::kOneofCaseOffset + 0, 2, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.FightingStyleSelection fighting_style = 9 [json_name = "fightingStyle"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.selection_.fighting_style_), _Internal::kOneofCaseOffset + 0, 3, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.EquipmentSelection equipment = 10 [json_name = "equipment"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.selection_.equipment_), _Internal::kOneofCaseOffset + 0, 4, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.Background background = 11 [json_name = "background"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.selection_.background_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.SpellSelection spells = 12 [json_name = "spells"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.selection_.spells_), _Internal::kOneofCaseOffset + 0, 5, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.ToolSelection tools = 13 [json_name = "tools"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.selection_.tools_), _Internal::kOneofCaseOffset + 0, 6, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.ExpertiseSelection expertise = 14 [json_name = "expertise"];
    {PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.selection_.expertise_), _Internal::kOneofCaseOffset + 0, 7, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SkillSelection>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::LanguageSelection>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::AbilityScores>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::FightingStyleSelection>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EquipmentSelection>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SpellSelection>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ToolSelection>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ExpertiseSelection>()},
  }},
  {{
    "\35\0\0\11\11\4\0\0\0\0\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.ChoiceData"
    "choice_id"
    "option_id"
    "name"
  }},
};
PROTOBUF_NOINLINE void ChoiceData::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.ChoiceData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003U) != 0) {
    if ((cached_has_bits & 0x00000001U) != 0) {
      _impl_.choice_id_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002U) != 0) {
      _impl_.option_id_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000000cU) != 0) {
    ::memset(&_impl_.category_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.source_) -
        reinterpret_cast<char*>(&_impl_.category_)) + sizeof(_impl_.source_));
  }
  clear_selection();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ChoiceData::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ChoiceData& this_ = static_cast<const ChoiceData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ChoiceData::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ChoiceData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    this_.VerifyHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.ChoiceData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .dnd5e.api.v1alpha1.ChoiceCategory category = 1 [json_name = "category"];
  if ((this_._impl_._has_bits_[0] & 0x00000004U) != 0) {
    if (this_._internal_category() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          1, this_._internal_category(), target);
    }
  }

  // .dnd5e.api.v1alpha1.ChoiceSource source = 2 [json_name = "source"];
  if ((this_._impl_._has_bits_[0] & 0x00000008U) != 0) {
    if (this_._internal_source() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          2, this_._internal_source(), target);
    }
  }

  // string choice_id = 3 [json_name = "choiceId"];
  if ((this_._impl_._has_bits_[0] & 0x00000001U) != 0) {
    if (!this_._internal_choice_id().empty()) {
      const ::std::string& _s = this_._internal_choice_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.ChoiceData.choice_id");
      target = stream->WriteStringMaybeAliased(3, _s, target);
    }
  }

  // string option_id = 4 [json_name = "optionId"];
  if ((this_._impl_._has_bits_[0] & 0x00000002U) != 0) {
    if (!this_._internal_option_id().empty()) {
      const ::std::string& _s = this_._internal_option_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.ChoiceData.option_id");
      target = stream->WriteStringMaybeAliased(4, _s, target);
    }
  }

  switch (this_.selection_case()) {
    case kName: {
      const ::std::string& _s = this_._internal_name();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.ChoiceData.name");
      target = stream->WriteStringMaybeAliased(5, _s, target);
      break;
    }
    case kSkills: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *this_._impl_.selection_.skills_, this_._impl_.selection_.skills_->GetCachedSize(), target,
          stream);
      break;
    }
    case kLanguages: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          7, *this_._impl_.selection_.languages_, this_._impl_.selection_.languages_->GetCachedSize(), target,
          stream);
      break;
    }
    case kAbilityScores: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          8, *this_._impl_.selection_.ability_scores_, this_._impl_.selection_.ability_scores_->GetCachedSize(), target,
          stream);
      break;
    }
    case kFightingStyle: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          9, *this_._impl_.selection_.fighting_style_, this_._impl_.selection_.fighting_style_->GetCachedSize(), target,
          stream);
      break;
    }
    case kEquipment: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          10, *this_._impl_.selection_.equipment_, this_._impl_.selection_.equipment_->GetCachedSize(), target,
          stream);
      break;
    }
    case kBackground: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          11, this_._internal_background(), target);
      break;
    }
    case kSpells: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          12, *this_._impl_.selection_.spells_, this_._impl_.selection_.spells_->GetCachedSize(), target,
          stream);
      break;
    }
    case kTools: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          13, *this_._impl_.selection_.tools_, this_._impl_.selection_.tools_->GetCachedSize(), target,
          stream);
      break;
    }
    case kExpertise: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          14, *this_._impl_.selection_.expertise_, this_._impl_.selection_.expertise_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.ChoiceData)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ChoiceData::ByteSizeLong(const MessageLite& base) {
  const ChoiceData& this_ = static_cast<const ChoiceData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ChoiceData::ByteSizeLong() const {
  const ChoiceData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.ChoiceData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fU) != 0) {
    // string choice_id = 3 [json_name = "choiceId"];
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (!this_._internal_choice_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_choice_id());
      }
    }
    // string option_id = 4 [json_name = "optionId"];
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (!this_._internal_option_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_option_id());
      }
    }
    // .dnd5e.api.v1alpha1.ChoiceCategory category = 1 [json_name = "category"];
    if ((cached_has_bits & 0x00000004U) != 0) {
      if (this_._internal_category() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_category());
      }
    }
    // .dnd5e.api.v1alpha1.ChoiceSource source = 2 [json_name = "source"];
    if ((cached_has_bits & 0x00000008U) != 0) {
      if (this_._internal_source() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_source());
      }
    }
  }
  switch (this_.selection_case()) {
    // string name = 5 [json_name = "name"];
    case kName: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
      break;
    }
    // .dnd5e.api.v1alpha1.SkillSelection skills = 6 [json_name = "skills"];
    case kSkills: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.skills_);
      break;
    }
    // .dnd5e.api.v1alpha1.LanguageSelection languages = 7 [json_name = "languages"];
    case kLanguages: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.languages_);
      break;
    }
    // .dnd5e.api.v1alpha1.AbilityScores ability_scores = 8 [json_name = "abilityScores"];
    case kAbilityScores: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.ability_scores_);
      break;
    }
    // .dnd5e.api.v1alpha1.FightingStyleSelection fighting_style = 9 [json_name = "fightingStyle"];
    case kFightingStyle: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.fighting_style_);
      break;
    }
    // .dnd5e.api.v1alpha1.EquipmentSelection equipment = 10 [json_name = "equipment"];
    case kEquipment: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.equipment_);
      break;
    }
    // .dnd5e.api.v1alpha1.Background background = 11 [json_name = "background"];
    case kBackground: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_background());
      break;
    }
    // .dnd5e.api.v1alpha1.SpellSelection spells = 12 [json_name = "spells"];
    case kSpells: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.spells_);
      break;
    }
    // .dnd5e.api.v1alpha1.ToolSelection tools = 13 [json_name = "tools"];
    case kTools: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.tools_);
      break;
    }
    // .dnd5e.api.v1alpha1.ExpertiseSelection expertise = 14 [json_name = "expertise"];
    case kExpertise: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.selection_.expertise_);
      break;
    }
    case SELECTION_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ChoiceData::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ChoiceData*>(&to_msg);
  auto& from = static_cast<const ChoiceData&>(from_msg);
  if constexpr (::_pbi::DebugHardenVerifyHasBitConsistency()) {
    from.VerifyHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.ChoiceData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fU) != 0) {
    if ((cached_has_bits & 0x00000001U) != 0) {
      if (!from._internal_choice_id().empty()) {
        _this->_internal_set_choice_id(from._internal_choice_id());
      } else {
        if (_this->_impl_.choice_id_.IsDefault()) {
          _this->_internal_set_choice_id("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002U) != 0) {
      if (!from._internal_option_id().empty()) {
        _this->_internal_set_option_id(from._internal_option_id());
      } else {
        if (_this->_impl_.option_id_.IsDefault()) {
          _this->_internal_set_option_id("");
        }
      }
    }
    if ((cached_has_bits & 0x00000004U) != 0) {
      if (from._internal_category() != 0) {
        _this->_impl_.category_ = from._impl_.category_;
      }
    }
    if ((cached_has_bits & 0x00000008U) != 0) {
      if (from._internal_source() != 0) {
        _this->_impl_.source_ = from._impl_.source_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_selection();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kName: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.name_.InitDefault();
        }
        _this->_impl_.selection_.name_.Set(from._internal_name(), arena);
        break;
      }
      case kSkills: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.skills_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.skills_);
        } else {
          _this->_impl_.selection_.skills_->MergeFrom(*from._impl_.selection_.skills_);
        }
        break;
      }
      case kLanguages: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.languages_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.languages_);
        } else {
          _this->_impl_.selection_.languages_->MergeFrom(*from._impl_.selection_.languages_);
        }
        break;
      }
      case kAbilityScores: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.ability_scores_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.ability_scores_);
        } else {
          _this->_impl_.selection_.ability_scores_->MergeFrom(*from._impl_.selection_.ability_scores_);
        }
        break;
      }
      case kFightingStyle: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.fighting_style_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.fighting_style_);
        } else {
          _this->_impl_.selection_.fighting_style_->MergeFrom(*from._impl_.selection_.fighting_style_);
        }
        break;
      }
      case kEquipment: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.equipment_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.equipment_);
        } else {
          _this->_impl_.selection_.equipment_->MergeFrom(*from._impl_.selection_.equipment_);
        }
        break;
      }
      case kBackground: {
        _this->_impl_.selection_.background_ = from._impl_.selection_.background_;
        break;
      }
      case kSpells: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.spells_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.spells_);
        } else {
          _this->_impl_.selection_.spells_->MergeFrom(*from._impl_.selection_.spells_);
        }
        break;
      }
      case kTools: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.tools_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.tools_);
        } else {
          _this->_impl_.selection_.tools_->MergeFrom(*from._impl_.selection_.tools_);
        }
        break;
      }
      case kExpertise: {
        if (oneof_needs_init) {
          _this->_impl_.selection_.expertise_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.selection_.expertise_);
        } else {
          _this->_impl_.selection_.expertise_->MergeFrom(*from._impl_.selection_.expertise_);
        }
        break;
      }
      case SELECTION_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ChoiceData::CopyFrom(const ChoiceData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.ChoiceData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ChoiceData::InternalSwap(ChoiceData* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.choice_id_, &other->_impl_.choice_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.option_id_, &other->_impl_.option_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.source_)
      + sizeof(ChoiceData::_impl_.source_)
      - PROTOBUF_FIELD_OFFSET(ChoiceData, _impl_.category_)>(
          reinterpret_cast<char*>(&_impl_.category_),
          reinterpret_cast<char*>(&other->_impl_.category_));
  swap(_impl_.selection_, other->_impl_.selection_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata ChoiceData::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ [[maybe_unused]] =
        (::_pbi::AddDescriptors(&descriptor_table_dnd5e_2fapi_2fv1alpha1_2fchoices_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
