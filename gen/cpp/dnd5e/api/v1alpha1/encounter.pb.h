// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: dnd5e/api/v1alpha1/encounter.proto
// Protobuf C++ Version: 6.31.1

#ifndef dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_2epb_2eh
#define dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/v1alpha1/room_common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
}  // extern "C"
namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum MovementError_ErrorCode : int;
extern const uint32_t MovementError_ErrorCode_internal_data_[];
class AttackRequest;
struct AttackRequestDefaultTypeInternal;
extern AttackRequestDefaultTypeInternal _AttackRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AttackRequest_class_data_;
class AttackResponse;
struct AttackResponseDefaultTypeInternal;
extern AttackResponseDefaultTypeInternal _AttackResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AttackResponse_class_data_;
class AttackResult;
struct AttackResultDefaultTypeInternal;
extern AttackResultDefaultTypeInternal _AttackResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AttackResult_class_data_;
class CombatState;
struct CombatStateDefaultTypeInternal;
extern CombatStateDefaultTypeInternal _CombatState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CombatState_class_data_;
class DungeonStartRequest;
struct DungeonStartRequestDefaultTypeInternal;
extern DungeonStartRequestDefaultTypeInternal _DungeonStartRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DungeonStartRequest_class_data_;
class DungeonStartResponse;
struct DungeonStartResponseDefaultTypeInternal;
extern DungeonStartResponseDefaultTypeInternal _DungeonStartResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DungeonStartResponse_class_data_;
class EndTurnRequest;
struct EndTurnRequestDefaultTypeInternal;
extern EndTurnRequestDefaultTypeInternal _EndTurnRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EndTurnRequest_class_data_;
class EndTurnResponse;
struct EndTurnResponseDefaultTypeInternal;
extern EndTurnResponseDefaultTypeInternal _EndTurnResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EndTurnResponse_class_data_;
class EntityPlacement;
struct EntityPlacementDefaultTypeInternal;
extern EntityPlacementDefaultTypeInternal _EntityPlacement_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EntityPlacement_class_data_;
class GetCombatStateRequest;
struct GetCombatStateRequestDefaultTypeInternal;
extern GetCombatStateRequestDefaultTypeInternal _GetCombatStateRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCombatStateRequest_class_data_;
class GetCombatStateResponse;
struct GetCombatStateResponseDefaultTypeInternal;
extern GetCombatStateResponseDefaultTypeInternal _GetCombatStateResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCombatStateResponse_class_data_;
class InitiativeEntry;
struct InitiativeEntryDefaultTypeInternal;
extern InitiativeEntryDefaultTypeInternal _InitiativeEntry_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InitiativeEntry_class_data_;
class MoveCharacterRequest;
struct MoveCharacterRequestDefaultTypeInternal;
extern MoveCharacterRequestDefaultTypeInternal _MoveCharacterRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MoveCharacterRequest_class_data_;
class MoveCharacterResponse;
struct MoveCharacterResponseDefaultTypeInternal;
extern MoveCharacterResponseDefaultTypeInternal _MoveCharacterResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MoveCharacterResponse_class_data_;
class MovementError;
struct MovementErrorDefaultTypeInternal;
extern MovementErrorDefaultTypeInternal _MovementError_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MovementError_class_data_;
class MovementError_DetailsEntry_DoNotUse;
struct MovementError_DetailsEntry_DoNotUseDefaultTypeInternal;
extern MovementError_DetailsEntry_DoNotUseDefaultTypeInternal _MovementError_DetailsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MovementError_DetailsEntry_DoNotUse_class_data_;
class Room;
struct RoomDefaultTypeInternal;
extern RoomDefaultTypeInternal _Room_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Room_class_data_;
class Room_EntitiesEntry_DoNotUse;
struct Room_EntitiesEntry_DoNotUseDefaultTypeInternal;
extern Room_EntitiesEntry_DoNotUseDefaultTypeInternal _Room_EntitiesEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Room_EntitiesEntry_DoNotUse_class_data_;
class TurnChangeEvent;
struct TurnChangeEventDefaultTypeInternal;
extern TurnChangeEventDefaultTypeInternal _TurnChangeEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TurnChangeEvent_class_data_;
class TurnState;
struct TurnStateDefaultTypeInternal;
extern TurnStateDefaultTypeInternal _TurnState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TurnState_class_data_;
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::MovementError_ErrorCode_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::MovementError_ErrorCode>;
}  // namespace protobuf
}  // namespace google

namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum MovementError_ErrorCode : int {
  MovementError_ErrorCode_ERROR_CODE_UNSPECIFIED = 0,
  MovementError_ErrorCode_ERROR_CODE_INVALID_POSITION = 1,
  MovementError_ErrorCode_ERROR_CODE_INSUFFICIENT_MOVEMENT = 2,
  MovementError_ErrorCode_ERROR_CODE_PATH_BLOCKED = 3,
  MovementError_ErrorCode_ERROR_CODE_POSITION_OCCUPIED = 4,
  MovementError_ErrorCode_ERROR_CODE_OUT_OF_BOUNDS = 5,
  MovementError_ErrorCode_ERROR_CODE_NOT_YOUR_TURN = 6,
  MovementError_ErrorCode_MovementError_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MovementError_ErrorCode_MovementError_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MovementError_ErrorCode_internal_data_[];
inline constexpr MovementError_ErrorCode MovementError_ErrorCode_ErrorCode_MIN =
    static_cast<MovementError_ErrorCode>(0);
inline constexpr MovementError_ErrorCode MovementError_ErrorCode_ErrorCode_MAX =
    static_cast<MovementError_ErrorCode>(6);
inline bool MovementError_ErrorCode_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int MovementError_ErrorCode_ErrorCode_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MovementError_ErrorCode_descriptor();
template <typename T>
const ::std::string& MovementError_ErrorCode_Name(T value) {
  static_assert(::std::is_same<T, MovementError_ErrorCode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ErrorCode_Name().");
  return MovementError_ErrorCode_Name(static_cast<MovementError_ErrorCode>(value));
}
template <>
inline const ::std::string& MovementError_ErrorCode_Name(MovementError_ErrorCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MovementError_ErrorCode_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool MovementError_ErrorCode_Parse(
    ::absl::string_view name, MovementError_ErrorCode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MovementError_ErrorCode>(MovementError_ErrorCode_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class TurnChangeEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.TurnChangeEvent) */ {
 public:
  inline TurnChangeEvent() : TurnChangeEvent(nullptr) {}
  ~TurnChangeEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TurnChangeEvent* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TurnChangeEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TurnChangeEvent(::google::protobuf::internal::ConstantInitialized);

  inline TurnChangeEvent(const TurnChangeEvent& from) : TurnChangeEvent(nullptr, from) {}
  inline TurnChangeEvent(TurnChangeEvent&& from) noexcept
      : TurnChangeEvent(nullptr, ::std::move(from)) {}
  inline TurnChangeEvent& operator=(const TurnChangeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnChangeEvent& operator=(TurnChangeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnChangeEvent& default_instance() {
    return *reinterpret_cast<const TurnChangeEvent*>(
        &_TurnChangeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(TurnChangeEvent& a, TurnChangeEvent& b) { a.Swap(&b); }
  inline void Swap(TurnChangeEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnChangeEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnChangeEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TurnChangeEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TurnChangeEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TurnChangeEvent& from) { TurnChangeEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TurnChangeEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.TurnChangeEvent"; }

 protected:
  explicit TurnChangeEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TurnChangeEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TurnChangeEvent& from);
  TurnChangeEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TurnChangeEvent&& from) noexcept
      : TurnChangeEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPreviousEntityIdFieldNumber = 1,
    kNextEntityIdFieldNumber = 2,
    kRoundFieldNumber = 3,
    kNewRoundFieldNumber = 4,
  };
  // string previous_entity_id = 1 [json_name = "previousEntityId"];
  void clear_previous_entity_id() ;
  const ::std::string& previous_entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_previous_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_previous_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_previous_entity_id();
  void set_allocated_previous_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_previous_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_previous_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_previous_entity_id();

  public:
  // string next_entity_id = 2 [json_name = "nextEntityId"];
  void clear_next_entity_id() ;
  const ::std::string& next_entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_next_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_next_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_next_entity_id();
  void set_allocated_next_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_next_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_next_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_next_entity_id();

  public:
  // int32 round = 3 [json_name = "round"];
  void clear_round() ;
  ::int32_t round() const;
  void set_round(::int32_t value);

  private:
  ::int32_t _internal_round() const;
  void _internal_set_round(::int32_t value);

  public:
  // bool new_round = 4 [json_name = "newRound"];
  void clear_new_round() ;
  bool new_round() const;
  void set_new_round(bool value);

  private:
  bool _internal_new_round() const;
  void _internal_set_new_round(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.TurnChangeEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 75,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TurnChangeEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr previous_entity_id_;
    ::google::protobuf::internal::ArenaStringPtr next_entity_id_;
    ::int32_t round_;
    bool new_round_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TurnChangeEvent_class_data_;
// -------------------------------------------------------------------

class MovementError_DetailsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, std::string,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  MovementError_DetailsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MovementError_DetailsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit MovementError_DetailsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_MovementError_DetailsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 62,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull MovementError_DetailsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class InitiativeEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.InitiativeEntry) */ {
 public:
  inline InitiativeEntry() : InitiativeEntry(nullptr) {}
  ~InitiativeEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InitiativeEntry* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InitiativeEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InitiativeEntry(::google::protobuf::internal::ConstantInitialized);

  inline InitiativeEntry(const InitiativeEntry& from) : InitiativeEntry(nullptr, from) {}
  inline InitiativeEntry(InitiativeEntry&& from) noexcept
      : InitiativeEntry(nullptr, ::std::move(from)) {}
  inline InitiativeEntry& operator=(const InitiativeEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitiativeEntry& operator=(InitiativeEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitiativeEntry& default_instance() {
    return *reinterpret_cast<const InitiativeEntry*>(
        &_InitiativeEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(InitiativeEntry& a, InitiativeEntry& b) { a.Swap(&b); }
  inline void Swap(InitiativeEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitiativeEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitiativeEntry* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InitiativeEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InitiativeEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InitiativeEntry& from) { InitiativeEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InitiativeEntry* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.InitiativeEntry"; }

 protected:
  explicit InitiativeEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InitiativeEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InitiativeEntry& from);
  InitiativeEntry(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InitiativeEntry&& from) noexcept
      : InitiativeEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kEntityTypeFieldNumber = 2,
    kInitiativeFieldNumber = 3,
    kModifierFieldNumber = 4,
    kHasActedFieldNumber = 5,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // string entity_type = 2 [json_name = "entityType"];
  void clear_entity_type() ;
  const ::std::string& entity_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_type();
  void set_allocated_entity_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_type();

  public:
  // int32 initiative = 3 [json_name = "initiative"];
  void clear_initiative() ;
  ::int32_t initiative() const;
  void set_initiative(::int32_t value);

  private:
  ::int32_t _internal_initiative() const;
  void _internal_set_initiative(::int32_t value);

  public:
  // int32 modifier = 4 [json_name = "modifier"];
  void clear_modifier() ;
  ::int32_t modifier() const;
  void set_modifier(::int32_t value);

  private:
  ::int32_t _internal_modifier() const;
  void _internal_set_modifier(::int32_t value);

  public:
  // bool has_acted = 5 [json_name = "hasActed"];
  void clear_has_acted() ;
  bool has_acted() const;
  void set_has_acted(bool value);

  private:
  bool _internal_has_acted() const;
  void _internal_set_has_acted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.InitiativeEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 63,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InitiativeEntry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr entity_type_;
    ::int32_t initiative_;
    ::int32_t modifier_;
    bool has_acted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InitiativeEntry_class_data_;
// -------------------------------------------------------------------

class GetCombatStateRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetCombatStateRequest) */ {
 public:
  inline GetCombatStateRequest() : GetCombatStateRequest(nullptr) {}
  ~GetCombatStateRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCombatStateRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCombatStateRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCombatStateRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetCombatStateRequest(const GetCombatStateRequest& from) : GetCombatStateRequest(nullptr, from) {}
  inline GetCombatStateRequest(GetCombatStateRequest&& from) noexcept
      : GetCombatStateRequest(nullptr, ::std::move(from)) {}
  inline GetCombatStateRequest& operator=(const GetCombatStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCombatStateRequest& operator=(GetCombatStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCombatStateRequest& default_instance() {
    return *reinterpret_cast<const GetCombatStateRequest*>(
        &_GetCombatStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(GetCombatStateRequest& a, GetCombatStateRequest& b) { a.Swap(&b); }
  inline void Swap(GetCombatStateRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCombatStateRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCombatStateRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCombatStateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCombatStateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCombatStateRequest& from) { GetCombatStateRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCombatStateRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetCombatStateRequest"; }

 protected:
  explicit GetCombatStateRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCombatStateRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCombatStateRequest& from);
  GetCombatStateRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCombatStateRequest&& from) noexcept
      : GetCombatStateRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetCombatStateRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 61,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCombatStateRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCombatStateRequest_class_data_;
// -------------------------------------------------------------------

class EndTurnRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EndTurnRequest) */ {
 public:
  inline EndTurnRequest() : EndTurnRequest(nullptr) {}
  ~EndTurnRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EndTurnRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EndTurnRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EndTurnRequest(::google::protobuf::internal::ConstantInitialized);

  inline EndTurnRequest(const EndTurnRequest& from) : EndTurnRequest(nullptr, from) {}
  inline EndTurnRequest(EndTurnRequest&& from) noexcept
      : EndTurnRequest(nullptr, ::std::move(from)) {}
  inline EndTurnRequest& operator=(const EndTurnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndTurnRequest& operator=(EndTurnRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndTurnRequest& default_instance() {
    return *reinterpret_cast<const EndTurnRequest*>(
        &_EndTurnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(EndTurnRequest& a, EndTurnRequest& b) { a.Swap(&b); }
  inline void Swap(EndTurnRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndTurnRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndTurnRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EndTurnRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EndTurnRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EndTurnRequest& from) { EndTurnRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EndTurnRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EndTurnRequest"; }

 protected:
  explicit EndTurnRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EndTurnRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EndTurnRequest& from);
  EndTurnRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EndTurnRequest&& from) noexcept
      : EndTurnRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kEntityIdFieldNumber = 2,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string entity_id = 2 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EndTurnRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 63,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EndTurnRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EndTurnRequest_class_data_;
// -------------------------------------------------------------------

class DungeonStartRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DungeonStartRequest) */ {
 public:
  inline DungeonStartRequest() : DungeonStartRequest(nullptr) {}
  ~DungeonStartRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DungeonStartRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DungeonStartRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DungeonStartRequest(::google::protobuf::internal::ConstantInitialized);

  inline DungeonStartRequest(const DungeonStartRequest& from) : DungeonStartRequest(nullptr, from) {}
  inline DungeonStartRequest(DungeonStartRequest&& from) noexcept
      : DungeonStartRequest(nullptr, ::std::move(from)) {}
  inline DungeonStartRequest& operator=(const DungeonStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonStartRequest& operator=(DungeonStartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonStartRequest& default_instance() {
    return *reinterpret_cast<const DungeonStartRequest*>(
        &_DungeonStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(DungeonStartRequest& a, DungeonStartRequest& b) { a.Swap(&b); }
  inline void Swap(DungeonStartRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonStartRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonStartRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DungeonStartRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DungeonStartRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DungeonStartRequest& from) { DungeonStartRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DungeonStartRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DungeonStartRequest"; }

 protected:
  explicit DungeonStartRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DungeonStartRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DungeonStartRequest& from);
  DungeonStartRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DungeonStartRequest&& from) noexcept
      : DungeonStartRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterIdsFieldNumber = 1,
  };
  // repeated string character_ids = 1 [json_name = "characterIds"];
  int character_ids_size() const;
  private:
  int _internal_character_ids_size() const;

  public:
  void clear_character_ids() ;
  const ::std::string& character_ids(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_character_ids(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_ids(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_character_ids();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_character_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& character_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_character_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_character_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_character_ids();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DungeonStartRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DungeonStartRequest& from_msg);
    ::google::protobuf::RepeatedPtrField<::std::string> character_ids_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DungeonStartRequest_class_data_;
// -------------------------------------------------------------------

class AttackResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AttackResult) */ {
 public:
  inline AttackResult() : AttackResult(nullptr) {}
  ~AttackResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackResult* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackResult(::google::protobuf::internal::ConstantInitialized);

  inline AttackResult(const AttackResult& from) : AttackResult(nullptr, from) {}
  inline AttackResult(AttackResult&& from) noexcept
      : AttackResult(nullptr, ::std::move(from)) {}
  inline AttackResult& operator=(const AttackResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackResult& operator=(AttackResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackResult& default_instance() {
    return *reinterpret_cast<const AttackResult*>(
        &_AttackResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(AttackResult& a, AttackResult& b) { a.Swap(&b); }
  inline void Swap(AttackResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackResult& from) { AttackResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AttackResult"; }

 protected:
  explicit AttackResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AttackResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AttackResult& from);
  AttackResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AttackResult&& from) noexcept
      : AttackResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDamageTypeFieldNumber = 6,
    kAttackRollFieldNumber = 2,
    kAttackTotalFieldNumber = 3,
    kTargetAcFieldNumber = 4,
    kHitFieldNumber = 1,
    kCriticalFieldNumber = 7,
    kDamageFieldNumber = 5,
  };
  // string damage_type = 6 [json_name = "damageType"];
  void clear_damage_type() ;
  const ::std::string& damage_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_damage_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_damage_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_damage_type();
  void set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_damage_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_damage_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_damage_type();

  public:
  // int32 attack_roll = 2 [json_name = "attackRoll"];
  void clear_attack_roll() ;
  ::int32_t attack_roll() const;
  void set_attack_roll(::int32_t value);

  private:
  ::int32_t _internal_attack_roll() const;
  void _internal_set_attack_roll(::int32_t value);

  public:
  // int32 attack_total = 3 [json_name = "attackTotal"];
  void clear_attack_total() ;
  ::int32_t attack_total() const;
  void set_attack_total(::int32_t value);

  private:
  ::int32_t _internal_attack_total() const;
  void _internal_set_attack_total(::int32_t value);

  public:
  // int32 target_ac = 4 [json_name = "targetAc"];
  void clear_target_ac() ;
  ::int32_t target_ac() const;
  void set_target_ac(::int32_t value);

  private:
  ::int32_t _internal_target_ac() const;
  void _internal_set_target_ac(::int32_t value);

  public:
  // bool hit = 1 [json_name = "hit"];
  void clear_hit() ;
  bool hit() const;
  void set_hit(bool value);

  private:
  bool _internal_hit() const;
  void _internal_set_hit(bool value);

  public:
  // bool critical = 7 [json_name = "critical"];
  void clear_critical() ;
  bool critical() const;
  void set_critical(bool value);

  private:
  bool _internal_critical() const;
  void _internal_set_critical(bool value);

  public:
  // int32 damage = 5 [json_name = "damage"];
  void clear_damage() ;
  ::int32_t damage() const;
  void set_damage(::int32_t value);

  private:
  ::int32_t _internal_damage() const;
  void _internal_set_damage(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AttackResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AttackResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr damage_type_;
    ::int32_t attack_roll_;
    ::int32_t attack_total_;
    ::int32_t target_ac_;
    bool hit_;
    bool critical_;
    ::int32_t damage_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AttackResult_class_data_;
// -------------------------------------------------------------------

class AttackRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AttackRequest) */ {
 public:
  inline AttackRequest() : AttackRequest(nullptr) {}
  ~AttackRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackRequest(::google::protobuf::internal::ConstantInitialized);

  inline AttackRequest(const AttackRequest& from) : AttackRequest(nullptr, from) {}
  inline AttackRequest(AttackRequest&& from) noexcept
      : AttackRequest(nullptr, ::std::move(from)) {}
  inline AttackRequest& operator=(const AttackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackRequest& operator=(AttackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackRequest& default_instance() {
    return *reinterpret_cast<const AttackRequest*>(
        &_AttackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(AttackRequest& a, AttackRequest& b) { a.Swap(&b); }
  inline void Swap(AttackRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackRequest& from) { AttackRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AttackRequest"; }

 protected:
  explicit AttackRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AttackRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AttackRequest& from);
  AttackRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AttackRequest&& from) noexcept
      : AttackRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kAttackerIdFieldNumber = 2,
    kTargetIdFieldNumber = 3,
    kWeaponIdFieldNumber = 4,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string attacker_id = 2 [json_name = "attackerId"];
  void clear_attacker_id() ;
  const ::std::string& attacker_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_attacker_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_attacker_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_attacker_id();
  void set_allocated_attacker_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_attacker_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_attacker_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_attacker_id();

  public:
  // string target_id = 3 [json_name = "targetId"];
  void clear_target_id() ;
  const ::std::string& target_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_target_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_target_id();
  void set_allocated_target_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_target_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_target_id();

  public:
  // string weapon_id = 4 [json_name = "weaponId"];
  void clear_weapon_id() ;
  const ::std::string& weapon_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_weapon_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_weapon_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_weapon_id();
  void set_allocated_weapon_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_weapon_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_weapon_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_weapon_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AttackRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 82,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AttackRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr attacker_id_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    ::google::protobuf::internal::ArenaStringPtr weapon_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AttackRequest_class_data_;
// -------------------------------------------------------------------

class TurnState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.TurnState) */ {
 public:
  inline TurnState() : TurnState(nullptr) {}
  ~TurnState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TurnState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TurnState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TurnState(::google::protobuf::internal::ConstantInitialized);

  inline TurnState(const TurnState& from) : TurnState(nullptr, from) {}
  inline TurnState(TurnState&& from) noexcept
      : TurnState(nullptr, ::std::move(from)) {}
  inline TurnState& operator=(const TurnState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnState& operator=(TurnState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnState& default_instance() {
    return *reinterpret_cast<const TurnState*>(
        &_TurnState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(TurnState& a, TurnState& b) { a.Swap(&b); }
  inline void Swap(TurnState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TurnState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TurnState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TurnState& from) { TurnState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TurnState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.TurnState"; }

 protected:
  explicit TurnState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TurnState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TurnState& from);
  TurnState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TurnState&& from) noexcept
      : TurnState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kPositionFieldNumber = 7,
    kMovementUsedFieldNumber = 2,
    kMovementMaxFieldNumber = 3,
    kActionUsedFieldNumber = 4,
    kBonusActionUsedFieldNumber = 5,
    kReactionAvailableFieldNumber = 6,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // .api.v1alpha1.Position position = 7 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::api::v1alpha1::Position& position() const;
  [[nodiscard]] ::api::v1alpha1::Position* PROTOBUF_NULLABLE release_position();
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  ::api::v1alpha1::Position* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::api::v1alpha1::Position& _internal_position() const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // int32 movement_used = 2 [json_name = "movementUsed"];
  void clear_movement_used() ;
  ::int32_t movement_used() const;
  void set_movement_used(::int32_t value);

  private:
  ::int32_t _internal_movement_used() const;
  void _internal_set_movement_used(::int32_t value);

  public:
  // int32 movement_max = 3 [json_name = "movementMax"];
  void clear_movement_max() ;
  ::int32_t movement_max() const;
  void set_movement_max(::int32_t value);

  private:
  ::int32_t _internal_movement_max() const;
  void _internal_set_movement_max(::int32_t value);

  public:
  // bool action_used = 4 [json_name = "actionUsed"];
  void clear_action_used() ;
  bool action_used() const;
  void set_action_used(bool value);

  private:
  bool _internal_action_used() const;
  void _internal_set_action_used(bool value);

  public:
  // bool bonus_action_used = 5 [json_name = "bonusActionUsed"];
  void clear_bonus_action_used() ;
  bool bonus_action_used() const;
  void set_bonus_action_used(bool value);

  private:
  bool _internal_bonus_action_used() const;
  void _internal_set_bonus_action_used(bool value);

  public:
  // bool reaction_available = 6 [json_name = "reactionAvailable"];
  void clear_reaction_available() ;
  bool reaction_available() const;
  void set_reaction_available(bool value);

  private:
  bool _internal_reaction_available() const;
  void _internal_set_reaction_available(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.TurnState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   1, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TurnState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE position_;
    ::int32_t movement_used_;
    ::int32_t movement_max_;
    bool action_used_;
    bool bonus_action_used_;
    bool reaction_available_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TurnState_class_data_;
// -------------------------------------------------------------------

class MovementError final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MovementError) */ {
 public:
  inline MovementError() : MovementError(nullptr) {}
  ~MovementError() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MovementError* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MovementError));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MovementError(::google::protobuf::internal::ConstantInitialized);

  inline MovementError(const MovementError& from) : MovementError(nullptr, from) {}
  inline MovementError(MovementError&& from) noexcept
      : MovementError(nullptr, ::std::move(from)) {}
  inline MovementError& operator=(const MovementError& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovementError& operator=(MovementError&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovementError& default_instance() {
    return *reinterpret_cast<const MovementError*>(
        &_MovementError_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(MovementError& a, MovementError& b) { a.Swap(&b); }
  inline void Swap(MovementError* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovementError* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MovementError* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MovementError>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MovementError& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MovementError& from) { MovementError::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MovementError* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MovementError"; }

 protected:
  explicit MovementError(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MovementError(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MovementError& from);
  MovementError(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MovementError&& from) noexcept
      : MovementError(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ErrorCode = MovementError_ErrorCode;
  static constexpr ErrorCode ERROR_CODE_UNSPECIFIED = MovementError_ErrorCode_ERROR_CODE_UNSPECIFIED;
  static constexpr ErrorCode ERROR_CODE_INVALID_POSITION = MovementError_ErrorCode_ERROR_CODE_INVALID_POSITION;
  static constexpr ErrorCode ERROR_CODE_INSUFFICIENT_MOVEMENT = MovementError_ErrorCode_ERROR_CODE_INSUFFICIENT_MOVEMENT;
  static constexpr ErrorCode ERROR_CODE_PATH_BLOCKED = MovementError_ErrorCode_ERROR_CODE_PATH_BLOCKED;
  static constexpr ErrorCode ERROR_CODE_POSITION_OCCUPIED = MovementError_ErrorCode_ERROR_CODE_POSITION_OCCUPIED;
  static constexpr ErrorCode ERROR_CODE_OUT_OF_BOUNDS = MovementError_ErrorCode_ERROR_CODE_OUT_OF_BOUNDS;
  static constexpr ErrorCode ERROR_CODE_NOT_YOUR_TURN = MovementError_ErrorCode_ERROR_CODE_NOT_YOUR_TURN;
  static inline bool ErrorCode_IsValid(int value) {
    return MovementError_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN = MovementError_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX = MovementError_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE = MovementError_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ErrorCode_descriptor() {
    return MovementError_ErrorCode_descriptor();
  }
  template <typename T>
  static inline const ::std::string& ErrorCode_Name(T value) {
    return MovementError_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(
      ::absl::string_view name, ErrorCode* PROTOBUF_NONNULL value) {
    return MovementError_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kDetailsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // map<string, string> details = 3 [json_name = "details"];
  int details_size() const;
  private:
  int _internal_details_size() const;

  public:
  void clear_details() ;
  const ::google::protobuf::Map<std::string, std::string>& details() const;
  ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL mutable_details();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_details() const;
  ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL _internal_mutable_details();

  public:
  // string message = 2 [json_name = "message"];
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // .dnd5e.api.v1alpha1.MovementError.ErrorCode code = 1 [json_name = "code"];
  void clear_code() ;
  ::dnd5e::api::v1alpha1::MovementError_ErrorCode code() const;
  void set_code(::dnd5e::api::v1alpha1::MovementError_ErrorCode value);

  private:
  ::dnd5e::api::v1alpha1::MovementError_ErrorCode _internal_code() const;
  void _internal_set_code(::dnd5e::api::v1alpha1::MovementError_ErrorCode value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MovementError)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 3,
                                   1, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MovementError& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<MovementError_DetailsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        details_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    int code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MovementError_class_data_;
// -------------------------------------------------------------------

class MoveCharacterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MoveCharacterRequest) */ {
 public:
  inline MoveCharacterRequest() : MoveCharacterRequest(nullptr) {}
  ~MoveCharacterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MoveCharacterRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MoveCharacterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveCharacterRequest(::google::protobuf::internal::ConstantInitialized);

  inline MoveCharacterRequest(const MoveCharacterRequest& from) : MoveCharacterRequest(nullptr, from) {}
  inline MoveCharacterRequest(MoveCharacterRequest&& from) noexcept
      : MoveCharacterRequest(nullptr, ::std::move(from)) {}
  inline MoveCharacterRequest& operator=(const MoveCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveCharacterRequest& operator=(MoveCharacterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveCharacterRequest& default_instance() {
    return *reinterpret_cast<const MoveCharacterRequest*>(
        &_MoveCharacterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(MoveCharacterRequest& a, MoveCharacterRequest& b) { a.Swap(&b); }
  inline void Swap(MoveCharacterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveCharacterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveCharacterRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MoveCharacterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveCharacterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveCharacterRequest& from) { MoveCharacterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MoveCharacterRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MoveCharacterRequest"; }

 protected:
  explicit MoveCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MoveCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MoveCharacterRequest& from);
  MoveCharacterRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MoveCharacterRequest&& from) noexcept
      : MoveCharacterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kEntityIdFieldNumber = 2,
    kTargetPositionFieldNumber = 3,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string entity_id = 2 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // .api.v1alpha1.Position target_position = 3 [json_name = "targetPosition"];
  bool has_target_position() const;
  void clear_target_position() ;
  const ::api::v1alpha1::Position& target_position() const;
  [[nodiscard]] ::api::v1alpha1::Position* PROTOBUF_NULLABLE release_target_position();
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_target_position();
  void set_allocated_target_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_target_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  ::api::v1alpha1::Position* PROTOBUF_NULLABLE unsafe_arena_release_target_position();

  private:
  const ::api::v1alpha1::Position& _internal_target_position() const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL _internal_mutable_target_position();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MoveCharacterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 69,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MoveCharacterRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE target_position_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MoveCharacterRequest_class_data_;
// -------------------------------------------------------------------

class EntityPlacement final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EntityPlacement) */ {
 public:
  inline EntityPlacement() : EntityPlacement(nullptr) {}
  ~EntityPlacement() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EntityPlacement* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EntityPlacement));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntityPlacement(::google::protobuf::internal::ConstantInitialized);

  inline EntityPlacement(const EntityPlacement& from) : EntityPlacement(nullptr, from) {}
  inline EntityPlacement(EntityPlacement&& from) noexcept
      : EntityPlacement(nullptr, ::std::move(from)) {}
  inline EntityPlacement& operator=(const EntityPlacement& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityPlacement& operator=(EntityPlacement&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityPlacement& default_instance() {
    return *reinterpret_cast<const EntityPlacement*>(
        &_EntityPlacement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(EntityPlacement& a, EntityPlacement& b) { a.Swap(&b); }
  inline void Swap(EntityPlacement* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityPlacement* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityPlacement* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EntityPlacement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntityPlacement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntityPlacement& from) { EntityPlacement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EntityPlacement* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EntityPlacement"; }

 protected:
  explicit EntityPlacement(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EntityPlacement(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EntityPlacement& from);
  EntityPlacement(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EntityPlacement&& from) noexcept
      : EntityPlacement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kEntityTypeFieldNumber = 2,
    kPositionFieldNumber = 3,
    kSizeFieldNumber = 4,
    kBlocksMovementFieldNumber = 5,
    kBlocksLineOfSightFieldNumber = 6,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // string entity_type = 2 [json_name = "entityType"];
  void clear_entity_type() ;
  const ::std::string& entity_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_type();
  void set_allocated_entity_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_type();

  public:
  // .api.v1alpha1.Position position = 3 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::api::v1alpha1::Position& position() const;
  [[nodiscard]] ::api::v1alpha1::Position* PROTOBUF_NULLABLE release_position();
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  ::api::v1alpha1::Position* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::api::v1alpha1::Position& _internal_position() const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // int32 size = 4 [json_name = "size"];
  void clear_size() ;
  ::int32_t size() const;
  void set_size(::int32_t value);

  private:
  ::int32_t _internal_size() const;
  void _internal_set_size(::int32_t value);

  public:
  // bool blocks_movement = 5 [json_name = "blocksMovement"];
  void clear_blocks_movement() ;
  bool blocks_movement() const;
  void set_blocks_movement(bool value);

  private:
  bool _internal_blocks_movement() const;
  void _internal_set_blocks_movement(bool value);

  public:
  // bool blocks_line_of_sight = 6 [json_name = "blocksLineOfSight"];
  void clear_blocks_line_of_sight() ;
  bool blocks_line_of_sight() const;
  void set_blocks_line_of_sight(bool value);

  private:
  bool _internal_blocks_line_of_sight() const;
  void _internal_set_blocks_line_of_sight(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EntityPlacement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   1, 63,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EntityPlacement& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr entity_type_;
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE position_;
    ::int32_t size_;
    bool blocks_movement_;
    bool blocks_line_of_sight_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EntityPlacement_class_data_;
// -------------------------------------------------------------------

class Room_EntitiesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  Room_EntitiesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Room_EntitiesEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit Room_EntitiesEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_Room_EntitiesEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 49,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull Room_EntitiesEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class CombatState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CombatState) */ {
 public:
  inline CombatState() : CombatState(nullptr) {}
  ~CombatState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CombatState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CombatState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CombatState(::google::protobuf::internal::ConstantInitialized);

  inline CombatState(const CombatState& from) : CombatState(nullptr, from) {}
  inline CombatState(CombatState&& from) noexcept
      : CombatState(nullptr, ::std::move(from)) {}
  inline CombatState& operator=(const CombatState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombatState& operator=(CombatState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombatState& default_instance() {
    return *reinterpret_cast<const CombatState*>(
        &_CombatState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(CombatState& a, CombatState& b) { a.Swap(&b); }
  inline void Swap(CombatState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombatState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombatState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CombatState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CombatState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CombatState& from) { CombatState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CombatState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CombatState"; }

 protected:
  explicit CombatState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CombatState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CombatState& from);
  CombatState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CombatState&& from) noexcept
      : CombatState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTurnOrderFieldNumber = 3,
    kEncounterIdFieldNumber = 1,
    kCurrentTurnFieldNumber = 5,
    kRoundFieldNumber = 2,
    kActiveIndexFieldNumber = 4,
    kCombatStartedFieldNumber = 6,
    kCombatEndedFieldNumber = 7,
  };
  // repeated .dnd5e.api.v1alpha1.InitiativeEntry turn_order = 3 [json_name = "turnOrder"];
  int turn_order_size() const;
  private:
  int _internal_turn_order_size() const;

  public:
  void clear_turn_order() ;
  ::dnd5e::api::v1alpha1::InitiativeEntry* PROTOBUF_NONNULL mutable_turn_order(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>* PROTOBUF_NONNULL mutable_turn_order();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>& _internal_turn_order() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>* PROTOBUF_NONNULL _internal_mutable_turn_order();
  public:
  const ::dnd5e::api::v1alpha1::InitiativeEntry& turn_order(int index) const;
  ::dnd5e::api::v1alpha1::InitiativeEntry* PROTOBUF_NONNULL add_turn_order();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>& turn_order() const;
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // .dnd5e.api.v1alpha1.TurnState current_turn = 5 [json_name = "currentTurn"];
  bool has_current_turn() const;
  void clear_current_turn() ;
  const ::dnd5e::api::v1alpha1::TurnState& current_turn() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE release_current_turn();
  ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NONNULL mutable_current_turn();
  void set_allocated_current_turn(::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_current_turn(::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE unsafe_arena_release_current_turn();

  private:
  const ::dnd5e::api::v1alpha1::TurnState& _internal_current_turn() const;
  ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NONNULL _internal_mutable_current_turn();

  public:
  // int32 round = 2 [json_name = "round"];
  void clear_round() ;
  ::int32_t round() const;
  void set_round(::int32_t value);

  private:
  ::int32_t _internal_round() const;
  void _internal_set_round(::int32_t value);

  public:
  // int32 active_index = 4 [json_name = "activeIndex"];
  void clear_active_index() ;
  ::int32_t active_index() const;
  void set_active_index(::int32_t value);

  private:
  ::int32_t _internal_active_index() const;
  void _internal_set_active_index(::int32_t value);

  public:
  // bool combat_started = 6 [json_name = "combatStarted"];
  void clear_combat_started() ;
  bool combat_started() const;
  void set_combat_started(bool value);

  private:
  bool _internal_combat_started() const;
  void _internal_set_combat_started(bool value);

  public:
  // bool combat_ended = 7 [json_name = "combatEnded"];
  void clear_combat_ended() ;
  bool combat_ended() const;
  void set_combat_ended(bool value);

  private:
  bool _internal_combat_ended() const;
  void _internal_set_combat_ended(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CombatState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   2, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CombatState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::InitiativeEntry > turn_order_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE current_turn_;
    ::int32_t round_;
    ::int32_t active_index_;
    bool combat_started_;
    bool combat_ended_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CombatState_class_data_;
// -------------------------------------------------------------------

class Room final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.Room) */ {
 public:
  inline Room() : Room(nullptr) {}
  ~Room() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Room* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Room));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Room(::google::protobuf::internal::ConstantInitialized);

  inline Room(const Room& from) : Room(nullptr, from) {}
  inline Room(Room&& from) noexcept
      : Room(nullptr, ::std::move(from)) {}
  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room& operator=(Room&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Room& default_instance() {
    return *reinterpret_cast<const Room*>(
        &_Room_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Room& a, Room& b) { a.Swap(&b); }
  inline void Swap(Room* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Room>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Room& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Room& from) { Room::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Room* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.Room"; }

 protected:
  explicit Room(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Room(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Room& from);
  Room(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Room&& from) noexcept
      : Room(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntitiesFieldNumber = 7,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kGridTypeFieldNumber = 5,
    kHexOrientationFieldNumber = 6,
  };
  // map<string, .dnd5e.api.v1alpha1.EntityPlacement> entities = 7 [json_name = "entities"];
  int entities_size() const;
  private:
  int _internal_entities_size() const;

  public:
  void clear_entities() ;
  const ::google::protobuf::Map<std::string, ::dnd5e::api::v1alpha1::EntityPlacement>& entities() const;
  ::google::protobuf::Map<std::string, ::dnd5e::api::v1alpha1::EntityPlacement>* PROTOBUF_NONNULL mutable_entities();

  private:
  const ::google::protobuf::Map<std::string, ::dnd5e::api::v1alpha1::EntityPlacement>& _internal_entities() const;
  ::google::protobuf::Map<std::string, ::dnd5e::api::v1alpha1::EntityPlacement>* PROTOBUF_NONNULL _internal_mutable_entities();

  public:
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string type = 2 [json_name = "type"];
  void clear_type() ;
  const ::std::string& type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_type();
  void set_allocated_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_type();

  public:
  // int32 width = 3 [json_name = "width"];
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // int32 height = 4 [json_name = "height"];
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // .api.v1alpha1.GridType grid_type = 5 [json_name = "gridType"];
  void clear_grid_type() ;
  ::api::v1alpha1::GridType grid_type() const;
  void set_grid_type(::api::v1alpha1::GridType value);

  private:
  ::api::v1alpha1::GridType _internal_grid_type() const;
  void _internal_set_grid_type(::api::v1alpha1::GridType value);

  public:
  // optional bool hex_orientation = 6 [json_name = "hexOrientation"];
  bool has_hex_orientation() const;
  void clear_hex_orientation() ;
  bool hex_orientation() const;
  void set_hex_orientation(bool value);

  private:
  bool _internal_hex_orientation() const;
  void _internal_set_hex_orientation(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.Room)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   2, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Room& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<Room_EntitiesEntry_DoNotUse, std::string, ::dnd5e::api::v1alpha1::EntityPlacement,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        entities_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::int32_t width_;
    ::int32_t height_;
    int grid_type_;
    bool hex_orientation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Room_class_data_;
// -------------------------------------------------------------------

class EndTurnResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EndTurnResponse) */ {
 public:
  inline EndTurnResponse() : EndTurnResponse(nullptr) {}
  ~EndTurnResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EndTurnResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EndTurnResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EndTurnResponse(::google::protobuf::internal::ConstantInitialized);

  inline EndTurnResponse(const EndTurnResponse& from) : EndTurnResponse(nullptr, from) {}
  inline EndTurnResponse(EndTurnResponse&& from) noexcept
      : EndTurnResponse(nullptr, ::std::move(from)) {}
  inline EndTurnResponse& operator=(const EndTurnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndTurnResponse& operator=(EndTurnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndTurnResponse& default_instance() {
    return *reinterpret_cast<const EndTurnResponse*>(
        &_EndTurnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(EndTurnResponse& a, EndTurnResponse& b) { a.Swap(&b); }
  inline void Swap(EndTurnResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndTurnResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndTurnResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EndTurnResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EndTurnResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EndTurnResponse& from) { EndTurnResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EndTurnResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EndTurnResponse"; }

 protected:
  explicit EndTurnResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EndTurnResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EndTurnResponse& from);
  EndTurnResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EndTurnResponse&& from) noexcept
      : EndTurnResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCombatStateFieldNumber = 2,
    kTurnChangeFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 3 [json_name = "turnChange"];
  bool has_turn_change() const;
  void clear_turn_change() ;
  const ::dnd5e::api::v1alpha1::TurnChangeEvent& turn_change() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE release_turn_change();
  ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL mutable_turn_change();
  void set_allocated_turn_change(::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_turn_change(::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE unsafe_arena_release_turn_change();

  private:
  const ::dnd5e::api::v1alpha1::TurnChangeEvent& _internal_turn_change() const;
  ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL _internal_mutable_turn_change();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EndTurnResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EndTurnResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE turn_change_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EndTurnResponse_class_data_;
// -------------------------------------------------------------------

class MoveCharacterResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MoveCharacterResponse) */ {
 public:
  inline MoveCharacterResponse() : MoveCharacterResponse(nullptr) {}
  ~MoveCharacterResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MoveCharacterResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MoveCharacterResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveCharacterResponse(::google::protobuf::internal::ConstantInitialized);

  inline MoveCharacterResponse(const MoveCharacterResponse& from) : MoveCharacterResponse(nullptr, from) {}
  inline MoveCharacterResponse(MoveCharacterResponse&& from) noexcept
      : MoveCharacterResponse(nullptr, ::std::move(from)) {}
  inline MoveCharacterResponse& operator=(const MoveCharacterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveCharacterResponse& operator=(MoveCharacterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveCharacterResponse& default_instance() {
    return *reinterpret_cast<const MoveCharacterResponse*>(
        &_MoveCharacterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(MoveCharacterResponse& a, MoveCharacterResponse& b) { a.Swap(&b); }
  inline void Swap(MoveCharacterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveCharacterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveCharacterResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MoveCharacterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveCharacterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveCharacterResponse& from) { MoveCharacterResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MoveCharacterResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MoveCharacterResponse"; }

 protected:
  explicit MoveCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MoveCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MoveCharacterResponse& from);
  MoveCharacterResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MoveCharacterResponse&& from) noexcept
      : MoveCharacterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 2,
    kUpdatedRoomFieldNumber = 4,
    kCombatStateFieldNumber = 5,
    kSuccessFieldNumber = 1,
    kMovementRemainingFieldNumber = 3,
  };
  // .dnd5e.api.v1alpha1.MovementError error = 2 [json_name = "error"];
  bool has_error() const;
  void clear_error() ;
  const ::dnd5e::api::v1alpha1::MovementError& error() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE release_error();
  ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NONNULL mutable_error();
  void set_allocated_error(::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_error(::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE unsafe_arena_release_error();

  private:
  const ::dnd5e::api::v1alpha1::MovementError& _internal_error() const;
  ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // .dnd5e.api.v1alpha1.Room updated_room = 4 [json_name = "updatedRoom"];
  bool has_updated_room() const;
  void clear_updated_room() ;
  const ::dnd5e::api::v1alpha1::Room& updated_room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_updated_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_updated_room();
  void set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_updated_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_updated_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_updated_room();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 5 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // int32 movement_remaining = 3 [json_name = "movementRemaining"];
  void clear_movement_remaining() ;
  ::int32_t movement_remaining() const;
  void set_movement_remaining(::int32_t value);

  private:
  ::int32_t _internal_movement_remaining() const;
  void _internal_set_movement_remaining(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MoveCharacterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MoveCharacterResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE error_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE updated_room_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    bool success_;
    ::int32_t movement_remaining_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MoveCharacterResponse_class_data_;
// -------------------------------------------------------------------

class GetCombatStateResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetCombatStateResponse) */ {
 public:
  inline GetCombatStateResponse() : GetCombatStateResponse(nullptr) {}
  ~GetCombatStateResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCombatStateResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCombatStateResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCombatStateResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetCombatStateResponse(const GetCombatStateResponse& from) : GetCombatStateResponse(nullptr, from) {}
  inline GetCombatStateResponse(GetCombatStateResponse&& from) noexcept
      : GetCombatStateResponse(nullptr, ::std::move(from)) {}
  inline GetCombatStateResponse& operator=(const GetCombatStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCombatStateResponse& operator=(GetCombatStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCombatStateResponse& default_instance() {
    return *reinterpret_cast<const GetCombatStateResponse*>(
        &_GetCombatStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(GetCombatStateResponse& a, GetCombatStateResponse& b) { a.Swap(&b); }
  inline void Swap(GetCombatStateResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCombatStateResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCombatStateResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCombatStateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCombatStateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCombatStateResponse& from) { GetCombatStateResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCombatStateResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetCombatStateResponse"; }

 protected:
  explicit GetCombatStateResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCombatStateResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCombatStateResponse& from);
  GetCombatStateResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCombatStateResponse&& from) noexcept
      : GetCombatStateResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoomFieldNumber = 1,
    kCombatStateFieldNumber = 2,
  };
  // .dnd5e.api.v1alpha1.Room room = 1 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetCombatStateResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCombatStateResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCombatStateResponse_class_data_;
// -------------------------------------------------------------------

class DungeonStartResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DungeonStartResponse) */ {
 public:
  inline DungeonStartResponse() : DungeonStartResponse(nullptr) {}
  ~DungeonStartResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DungeonStartResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DungeonStartResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DungeonStartResponse(::google::protobuf::internal::ConstantInitialized);

  inline DungeonStartResponse(const DungeonStartResponse& from) : DungeonStartResponse(nullptr, from) {}
  inline DungeonStartResponse(DungeonStartResponse&& from) noexcept
      : DungeonStartResponse(nullptr, ::std::move(from)) {}
  inline DungeonStartResponse& operator=(const DungeonStartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonStartResponse& operator=(DungeonStartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonStartResponse& default_instance() {
    return *reinterpret_cast<const DungeonStartResponse*>(
        &_DungeonStartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(DungeonStartResponse& a, DungeonStartResponse& b) { a.Swap(&b); }
  inline void Swap(DungeonStartResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonStartResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonStartResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DungeonStartResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DungeonStartResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DungeonStartResponse& from) { DungeonStartResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DungeonStartResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DungeonStartResponse"; }

 protected:
  explicit DungeonStartResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DungeonStartResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DungeonStartResponse& from);
  DungeonStartResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DungeonStartResponse&& from) noexcept
      : DungeonStartResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kRoomFieldNumber = 2,
    kCombatStateFieldNumber = 3,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 3 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DungeonStartResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DungeonStartResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DungeonStartResponse_class_data_;
// -------------------------------------------------------------------

class AttackResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AttackResponse) */ {
 public:
  inline AttackResponse() : AttackResponse(nullptr) {}
  ~AttackResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackResponse(::google::protobuf::internal::ConstantInitialized);

  inline AttackResponse(const AttackResponse& from) : AttackResponse(nullptr, from) {}
  inline AttackResponse(AttackResponse&& from) noexcept
      : AttackResponse(nullptr, ::std::move(from)) {}
  inline AttackResponse& operator=(const AttackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackResponse& operator=(AttackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackResponse& default_instance() {
    return *reinterpret_cast<const AttackResponse*>(
        &_AttackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(AttackResponse& a, AttackResponse& b) { a.Swap(&b); }
  inline void Swap(AttackResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackResponse& from) { AttackResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AttackResponse"; }

 protected:
  explicit AttackResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AttackResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AttackResponse& from);
  AttackResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AttackResponse&& from) noexcept
      : AttackResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 2,
    kResultFieldNumber = 3,
    kCombatStateFieldNumber = 4,
    kUpdatedRoomFieldNumber = 5,
    kSuccessFieldNumber = 1,
  };
  // string error = 2 [json_name = "error"];
  void clear_error() ;
  const ::std::string& error() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
  bool has_result() const;
  void clear_result() ;
  const ::dnd5e::api::v1alpha1::AttackResult& result() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE release_result();
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::dnd5e::api::v1alpha1::AttackResult& _internal_result() const;
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // .dnd5e.api.v1alpha1.Room updated_room = 5 [json_name = "updatedRoom"];
  bool has_updated_room() const;
  void clear_updated_room() ;
  const ::dnd5e::api::v1alpha1::Room& updated_room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_updated_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_updated_room();
  void set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_updated_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_updated_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_updated_room();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AttackResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   3, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AttackResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE result_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE updated_room_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AttackResponse_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EntityPlacement

// string entity_id = 1 [json_name = "entityId"];
inline void EntityPlacement::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EntityPlacement::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EntityPlacement::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL EntityPlacement::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
  return _s;
}
inline const ::std::string& EntityPlacement::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void EntityPlacement::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EntityPlacement::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EntityPlacement::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void EntityPlacement::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
}

// string entity_type = 2 [json_name = "entityType"];
inline void EntityPlacement::clear_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& EntityPlacement::entity_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.entity_type)
  return _internal_entity_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EntityPlacement::set_entity_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.entity_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.entity_type)
}
inline ::std::string* PROTOBUF_NONNULL EntityPlacement::mutable_entity_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_entity_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EntityPlacement.entity_type)
  return _s;
}
inline const ::std::string& EntityPlacement::_internal_entity_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_type_.Get();
}
inline void EntityPlacement::_internal_set_entity_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.entity_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EntityPlacement::_internal_mutable_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.entity_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EntityPlacement::release_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EntityPlacement.entity_type)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.entity_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_type_.Set("", GetArena());
  }
  return released;
}
inline void EntityPlacement::set_allocated_entity_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.entity_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_type_.IsDefault()) {
    _impl_.entity_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EntityPlacement.entity_type)
}

// .api.v1alpha1.Position position = 3 [json_name = "position"];
inline bool EntityPlacement::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::api::v1alpha1::Position& EntityPlacement::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::api::v1alpha1::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::v1alpha1::Position&>(::api::v1alpha1::_Position_default_instance_);
}
inline const ::api::v1alpha1::Position& EntityPlacement::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.position)
  return _internal_position();
}
inline void EntityPlacement::unsafe_arena_set_allocated_position(
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EntityPlacement.position)
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE EntityPlacement::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::api::v1alpha1::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE EntityPlacement::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EntityPlacement.position)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::api::v1alpha1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL EntityPlacement::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::api::v1alpha1::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(p);
  }
  return _impl_.position_;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL EntityPlacement::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::api::v1alpha1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EntityPlacement.position)
  return _msg;
}
inline void EntityPlacement::set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EntityPlacement.position)
}

// int32 size = 4 [json_name = "size"];
inline void EntityPlacement::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t EntityPlacement::size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.size)
  return _internal_size();
}
inline void EntityPlacement::set_size(::int32_t value) {
  _internal_set_size(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.size)
}
inline ::int32_t EntityPlacement::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void EntityPlacement::_internal_set_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// bool blocks_movement = 5 [json_name = "blocksMovement"];
inline void EntityPlacement::clear_blocks_movement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_movement_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool EntityPlacement::blocks_movement() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.blocks_movement)
  return _internal_blocks_movement();
}
inline void EntityPlacement::set_blocks_movement(bool value) {
  _internal_set_blocks_movement(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.blocks_movement)
}
inline bool EntityPlacement::_internal_blocks_movement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blocks_movement_;
}
inline void EntityPlacement::_internal_set_blocks_movement(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_movement_ = value;
}

// bool blocks_line_of_sight = 6 [json_name = "blocksLineOfSight"];
inline void EntityPlacement::clear_blocks_line_of_sight() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_line_of_sight_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool EntityPlacement::blocks_line_of_sight() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.blocks_line_of_sight)
  return _internal_blocks_line_of_sight();
}
inline void EntityPlacement::set_blocks_line_of_sight(bool value) {
  _internal_set_blocks_line_of_sight(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.blocks_line_of_sight)
}
inline bool EntityPlacement::_internal_blocks_line_of_sight() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blocks_line_of_sight_;
}
inline void EntityPlacement::_internal_set_blocks_line_of_sight(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_line_of_sight_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Room

// string id = 1 [json_name = "id"];
inline void Room::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Room::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Room::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.id)
}
inline ::std::string* PROTOBUF_NONNULL Room::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Room.id)
  return _s;
}
inline const ::std::string& Room::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Room::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Room::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Room::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Room.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void Room::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Room.id)
}

// string type = 2 [json_name = "type"];
inline void Room::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Room::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Room::set_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.type)
}
inline ::std::string* PROTOBUF_NONNULL Room::mutable_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Room.type)
  return _s;
}
inline const ::std::string& Room::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void Room::_internal_set_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Room::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Room::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Room.type)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.type_.Set("", GetArena());
  }
  return released;
}
inline void Room::set_allocated_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Room.type)
}

// int32 width = 3 [json_name = "width"];
inline void Room::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t Room::width() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.width)
  return _internal_width();
}
inline void Room::set_width(::int32_t value) {
  _internal_set_width(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.width)
}
inline ::int32_t Room::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void Room::_internal_set_width(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// int32 height = 4 [json_name = "height"];
inline void Room::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t Room::height() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.height)
  return _internal_height();
}
inline void Room::set_height(::int32_t value) {
  _internal_set_height(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.height)
}
inline ::int32_t Room::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void Room::_internal_set_height(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// .api.v1alpha1.GridType grid_type = 5 [json_name = "gridType"];
inline void Room::clear_grid_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::api::v1alpha1::GridType Room::grid_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.grid_type)
  return _internal_grid_type();
}
inline void Room::set_grid_type(::api::v1alpha1::GridType value) {
  _internal_set_grid_type(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.grid_type)
}
inline ::api::v1alpha1::GridType Room::_internal_grid_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::api::v1alpha1::GridType>(_impl_.grid_type_);
}
inline void Room::_internal_set_grid_type(::api::v1alpha1::GridType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_type_ = value;
}

// optional bool hex_orientation = 6 [json_name = "hexOrientation"];
inline bool Room::has_hex_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Room::clear_hex_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hex_orientation_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Room::hex_orientation() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.hex_orientation)
  return _internal_hex_orientation();
}
inline void Room::set_hex_orientation(bool value) {
  _internal_set_hex_orientation(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.hex_orientation)
}
inline bool Room::_internal_hex_orientation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hex_orientation_;
}
inline void Room::_internal_set_hex_orientation(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hex_orientation_ = value;
}

// map<string, .dnd5e.api.v1alpha1.EntityPlacement> entities = 7 [json_name = "entities"];
inline int Room::_internal_entities_size() const {
  return _internal_entities().size();
}
inline int Room::entities_size() const {
  return _internal_entities_size();
}
inline void Room::clear_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entities_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::dnd5e::api::v1alpha1::EntityPlacement>& Room::_internal_entities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entities_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::dnd5e::api::v1alpha1::EntityPlacement>& Room::entities() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:dnd5e.api.v1alpha1.Room.entities)
  return _internal_entities();
}
inline ::google::protobuf::Map<std::string, ::dnd5e::api::v1alpha1::EntityPlacement>* PROTOBUF_NONNULL Room::_internal_mutable_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entities_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::dnd5e::api::v1alpha1::EntityPlacement>* PROTOBUF_NONNULL Room::mutable_entities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:dnd5e.api.v1alpha1.Room.entities)
  return _internal_mutable_entities();
}

// -------------------------------------------------------------------

// DungeonStartRequest

// repeated string character_ids = 1 [json_name = "characterIds"];
inline int DungeonStartRequest::_internal_character_ids_size() const {
  return _internal_character_ids().size();
}
inline int DungeonStartRequest::character_ids_size() const {
  return _internal_character_ids_size();
}
inline void DungeonStartRequest::clear_character_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_ids_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartRequest::add_character_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_character_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  return _s;
}
inline const ::std::string& DungeonStartRequest::character_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  return _internal_character_ids().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartRequest::mutable_character_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  return _internal_mutable_character_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void DungeonStartRequest::set_character_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_character_ids()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
}
template <typename Arg_, typename... Args_>
inline void DungeonStartRequest::add_character_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_character_ids(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& DungeonStartRequest::character_ids()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  return _internal_character_ids();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
DungeonStartRequest::mutable_character_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_character_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DungeonStartRequest::_internal_character_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
DungeonStartRequest::_internal_mutable_character_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.character_ids_;
}

// -------------------------------------------------------------------

// DungeonStartResponse

// string encounter_id = 1 [json_name = "encounterId"];
inline void DungeonStartResponse::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DungeonStartResponse::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DungeonStartResponse::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartResponse::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
  return _s;
}
inline const ::std::string& DungeonStartResponse::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void DungeonStartResponse::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartResponse::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DungeonStartResponse::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void DungeonStartResponse::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
}

// .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
inline bool DungeonStartResponse::has_room() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void DungeonStartResponse::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dnd5e::api::v1alpha1::Room& DungeonStartResponse::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& DungeonStartResponse::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.room)
  return _internal_room();
}
inline void DungeonStartResponse::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE DungeonStartResponse::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE DungeonStartResponse::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonStartResponse.room)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL DungeonStartResponse::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL DungeonStartResponse::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartResponse.room)
  return _msg;
}
inline void DungeonStartResponse::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.room)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 3 [json_name = "combatState"];
inline bool DungeonStartResponse::has_combat_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void DungeonStartResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::dnd5e::api::v1alpha1::CombatState& DungeonStartResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& DungeonStartResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)
  return _internal_combat_state();
}
inline void DungeonStartResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE DungeonStartResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE DungeonStartResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL DungeonStartResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL DungeonStartResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)
  return _msg;
}
inline void DungeonStartResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)
}

// -------------------------------------------------------------------

// InitiativeEntry

// string entity_id = 1 [json_name = "entityId"];
inline void InitiativeEntry::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& InitiativeEntry::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InitiativeEntry::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL InitiativeEntry::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
  return _s;
}
inline const ::std::string& InitiativeEntry::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void InitiativeEntry::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InitiativeEntry::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InitiativeEntry::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void InitiativeEntry::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
}

// string entity_type = 2 [json_name = "entityType"];
inline void InitiativeEntry::clear_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& InitiativeEntry::entity_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
  return _internal_entity_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InitiativeEntry::set_entity_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.entity_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
}
inline ::std::string* PROTOBUF_NONNULL InitiativeEntry::mutable_entity_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_entity_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
  return _s;
}
inline const ::std::string& InitiativeEntry::_internal_entity_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_type_.Get();
}
inline void InitiativeEntry::_internal_set_entity_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.entity_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InitiativeEntry::_internal_mutable_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.entity_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InitiativeEntry::release_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.entity_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_type_.Set("", GetArena());
  }
  return released;
}
inline void InitiativeEntry::set_allocated_entity_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.entity_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_type_.IsDefault()) {
    _impl_.entity_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
}

// int32 initiative = 3 [json_name = "initiative"];
inline void InitiativeEntry::clear_initiative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiative_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t InitiativeEntry::initiative() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.initiative)
  return _internal_initiative();
}
inline void InitiativeEntry::set_initiative(::int32_t value) {
  _internal_set_initiative(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.initiative)
}
inline ::int32_t InitiativeEntry::_internal_initiative() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initiative_;
}
inline void InitiativeEntry::_internal_set_initiative(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiative_ = value;
}

// int32 modifier = 4 [json_name = "modifier"];
inline void InitiativeEntry::clear_modifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t InitiativeEntry::modifier() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.modifier)
  return _internal_modifier();
}
inline void InitiativeEntry::set_modifier(::int32_t value) {
  _internal_set_modifier(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.modifier)
}
inline ::int32_t InitiativeEntry::_internal_modifier() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.modifier_;
}
inline void InitiativeEntry::_internal_set_modifier(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modifier_ = value;
}

// bool has_acted = 5 [json_name = "hasActed"];
inline void InitiativeEntry::clear_has_acted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_acted_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool InitiativeEntry::has_acted() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.has_acted)
  return _internal_has_acted();
}
inline void InitiativeEntry::set_has_acted(bool value) {
  _internal_set_has_acted(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.has_acted)
}
inline bool InitiativeEntry::_internal_has_acted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_acted_;
}
inline void InitiativeEntry::_internal_set_has_acted(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_acted_ = value;
}

// -------------------------------------------------------------------

// TurnState

// string entity_id = 1 [json_name = "entityId"];
inline void TurnState::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TurnState::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TurnState::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL TurnState::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnState.entity_id)
  return _s;
}
inline const ::std::string& TurnState::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void TurnState::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TurnState::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TurnState::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnState.entity_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void TurnState::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnState.entity_id)
}

// int32 movement_used = 2 [json_name = "movementUsed"];
inline void TurnState::clear_movement_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_used_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t TurnState::movement_used() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.movement_used)
  return _internal_movement_used();
}
inline void TurnState::set_movement_used(::int32_t value) {
  _internal_set_movement_used(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.movement_used)
}
inline ::int32_t TurnState::_internal_movement_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movement_used_;
}
inline void TurnState::_internal_set_movement_used(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_used_ = value;
}

// int32 movement_max = 3 [json_name = "movementMax"];
inline void TurnState::clear_movement_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_max_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t TurnState::movement_max() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.movement_max)
  return _internal_movement_max();
}
inline void TurnState::set_movement_max(::int32_t value) {
  _internal_set_movement_max(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.movement_max)
}
inline ::int32_t TurnState::_internal_movement_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movement_max_;
}
inline void TurnState::_internal_set_movement_max(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_max_ = value;
}

// bool action_used = 4 [json_name = "actionUsed"];
inline void TurnState::clear_action_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_used_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool TurnState::action_used() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.action_used)
  return _internal_action_used();
}
inline void TurnState::set_action_used(bool value) {
  _internal_set_action_used(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.action_used)
}
inline bool TurnState::_internal_action_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_used_;
}
inline void TurnState::_internal_set_action_used(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_used_ = value;
}

// bool bonus_action_used = 5 [json_name = "bonusActionUsed"];
inline void TurnState::clear_bonus_action_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonus_action_used_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool TurnState::bonus_action_used() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.bonus_action_used)
  return _internal_bonus_action_used();
}
inline void TurnState::set_bonus_action_used(bool value) {
  _internal_set_bonus_action_used(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.bonus_action_used)
}
inline bool TurnState::_internal_bonus_action_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bonus_action_used_;
}
inline void TurnState::_internal_set_bonus_action_used(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonus_action_used_ = value;
}

// bool reaction_available = 6 [json_name = "reactionAvailable"];
inline void TurnState::clear_reaction_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reaction_available_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool TurnState::reaction_available() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.reaction_available)
  return _internal_reaction_available();
}
inline void TurnState::set_reaction_available(bool value) {
  _internal_set_reaction_available(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.reaction_available)
}
inline bool TurnState::_internal_reaction_available() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reaction_available_;
}
inline void TurnState::_internal_set_reaction_available(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reaction_available_ = value;
}

// .api.v1alpha1.Position position = 7 [json_name = "position"];
inline bool TurnState::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::api::v1alpha1::Position& TurnState::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::api::v1alpha1::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::v1alpha1::Position&>(::api::v1alpha1::_Position_default_instance_);
}
inline const ::api::v1alpha1::Position& TurnState::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.position)
  return _internal_position();
}
inline void TurnState::unsafe_arena_set_allocated_position(
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.TurnState.position)
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE TurnState::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::api::v1alpha1::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE TurnState::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnState.position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::api::v1alpha1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL TurnState::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::api::v1alpha1::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(p);
  }
  return _impl_.position_;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL TurnState::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::api::v1alpha1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnState.position)
  return _msg;
}
inline void TurnState::set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnState.position)
}

// -------------------------------------------------------------------

// CombatState

// string encounter_id = 1 [json_name = "encounterId"];
inline void CombatState::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CombatState::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CombatState::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL CombatState::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatState.encounter_id)
  return _s;
}
inline const ::std::string& CombatState::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void CombatState::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CombatState::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CombatState::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatState.encounter_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void CombatState::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatState.encounter_id)
}

// int32 round = 2 [json_name = "round"];
inline void CombatState::clear_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CombatState::round() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.round)
  return _internal_round();
}
inline void CombatState::set_round(::int32_t value) {
  _internal_set_round(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.round)
}
inline ::int32_t CombatState::_internal_round() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.round_;
}
inline void CombatState::_internal_set_round(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = value;
}

// repeated .dnd5e.api.v1alpha1.InitiativeEntry turn_order = 3 [json_name = "turnOrder"];
inline int CombatState::_internal_turn_order_size() const {
  return _internal_turn_order().size();
}
inline int CombatState::turn_order_size() const {
  return _internal_turn_order_size();
}
inline void CombatState::clear_turn_order() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.turn_order_.Clear();
}
inline ::dnd5e::api::v1alpha1::InitiativeEntry* PROTOBUF_NONNULL CombatState::mutable_turn_order(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatState.turn_order)
  return _internal_mutable_turn_order()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>* PROTOBUF_NONNULL CombatState::mutable_turn_order()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.CombatState.turn_order)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_turn_order();
}
inline const ::dnd5e::api::v1alpha1::InitiativeEntry& CombatState::turn_order(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.turn_order)
  return _internal_turn_order().Get(index);
}
inline ::dnd5e::api::v1alpha1::InitiativeEntry* PROTOBUF_NONNULL CombatState::add_turn_order()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::InitiativeEntry* _add = _internal_mutable_turn_order()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.CombatState.turn_order)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>& CombatState::turn_order() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.CombatState.turn_order)
  return _internal_turn_order();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>&
CombatState::_internal_turn_order() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.turn_order_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>* PROTOBUF_NONNULL
CombatState::_internal_mutable_turn_order() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.turn_order_;
}

// int32 active_index = 4 [json_name = "activeIndex"];
inline void CombatState::clear_active_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t CombatState::active_index() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.active_index)
  return _internal_active_index();
}
inline void CombatState::set_active_index(::int32_t value) {
  _internal_set_active_index(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.active_index)
}
inline ::int32_t CombatState::_internal_active_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.active_index_;
}
inline void CombatState::_internal_set_active_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_index_ = value;
}

// .dnd5e.api.v1alpha1.TurnState current_turn = 5 [json_name = "currentTurn"];
inline bool CombatState::has_current_turn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.current_turn_ != nullptr);
  return value;
}
inline void CombatState::clear_current_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_turn_ != nullptr) _impl_.current_turn_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dnd5e::api::v1alpha1::TurnState& CombatState::_internal_current_turn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::TurnState* p = _impl_.current_turn_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::TurnState&>(::dnd5e::api::v1alpha1::_TurnState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::TurnState& CombatState::current_turn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.current_turn)
  return _internal_current_turn();
}
inline void CombatState::unsafe_arena_set_allocated_current_turn(
    ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.current_turn_);
  }
  _impl_.current_turn_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CombatState.current_turn)
}
inline ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE CombatState::release_current_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::TurnState* released = _impl_.current_turn_;
  _impl_.current_turn_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE CombatState::unsafe_arena_release_current_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatState.current_turn)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::TurnState* temp = _impl_.current_turn_;
  _impl_.current_turn_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NONNULL CombatState::_internal_mutable_current_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_turn_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::TurnState>(GetArena());
    _impl_.current_turn_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnState*>(p);
  }
  return _impl_.current_turn_;
}
inline ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NONNULL CombatState::mutable_current_turn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::dnd5e::api::v1alpha1::TurnState* _msg = _internal_mutable_current_turn();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatState.current_turn)
  return _msg;
}
inline void CombatState::set_allocated_current_turn(::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.current_turn_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.current_turn_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatState.current_turn)
}

// bool combat_started = 6 [json_name = "combatStarted"];
inline void CombatState::clear_combat_started() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combat_started_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool CombatState::combat_started() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.combat_started)
  return _internal_combat_started();
}
inline void CombatState::set_combat_started(bool value) {
  _internal_set_combat_started(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.combat_started)
}
inline bool CombatState::_internal_combat_started() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.combat_started_;
}
inline void CombatState::_internal_set_combat_started(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combat_started_ = value;
}

// bool combat_ended = 7 [json_name = "combatEnded"];
inline void CombatState::clear_combat_ended() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combat_ended_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool CombatState::combat_ended() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.combat_ended)
  return _internal_combat_ended();
}
inline void CombatState::set_combat_ended(bool value) {
  _internal_set_combat_ended(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.combat_ended)
}
inline bool CombatState::_internal_combat_ended() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.combat_ended_;
}
inline void CombatState::_internal_set_combat_ended(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combat_ended_ = value;
}

// -------------------------------------------------------------------

// GetCombatStateRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void GetCombatStateRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetCombatStateRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetCombatStateRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL GetCombatStateRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
  return _s;
}
inline const ::std::string& GetCombatStateRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void GetCombatStateRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetCombatStateRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetCombatStateRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void GetCombatStateRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
}

// -------------------------------------------------------------------

// GetCombatStateResponse

// .dnd5e.api.v1alpha1.Room room = 1 [json_name = "room"];
inline bool GetCombatStateResponse::has_room() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void GetCombatStateResponse::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::Room& GetCombatStateResponse::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& GetCombatStateResponse::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCombatStateResponse.room)
  return _internal_room();
}
inline void GetCombatStateResponse::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetCombatStateResponse.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE GetCombatStateResponse::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE GetCombatStateResponse::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCombatStateResponse.room)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL GetCombatStateResponse::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL GetCombatStateResponse::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCombatStateResponse.room)
  return _msg;
}
inline void GetCombatStateResponse::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCombatStateResponse.room)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
inline bool GetCombatStateResponse::has_combat_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void GetCombatStateResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dnd5e::api::v1alpha1::CombatState& GetCombatStateResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& GetCombatStateResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)
  return _internal_combat_state();
}
inline void GetCombatStateResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE GetCombatStateResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE GetCombatStateResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL GetCombatStateResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL GetCombatStateResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)
  return _msg;
}
inline void GetCombatStateResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)
}

// -------------------------------------------------------------------

// MoveCharacterRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void MoveCharacterRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoveCharacterRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MoveCharacterRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
  return _s;
}
inline const ::std::string& MoveCharacterRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void MoveCharacterRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MoveCharacterRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void MoveCharacterRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
}

// string entity_id = 2 [json_name = "entityId"];
inline void MoveCharacterRequest::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoveCharacterRequest::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MoveCharacterRequest::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterRequest::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
  return _s;
}
inline const ::std::string& MoveCharacterRequest::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void MoveCharacterRequest::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterRequest::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MoveCharacterRequest::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void MoveCharacterRequest::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
}

// .api.v1alpha1.Position target_position = 3 [json_name = "targetPosition"];
inline bool MoveCharacterRequest::has_target_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_position_ != nullptr);
  return value;
}
inline const ::api::v1alpha1::Position& MoveCharacterRequest::_internal_target_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::api::v1alpha1::Position* p = _impl_.target_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::v1alpha1::Position&>(::api::v1alpha1::_Position_default_instance_);
}
inline const ::api::v1alpha1::Position& MoveCharacterRequest::target_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterRequest.target_position)
  return _internal_target_position();
}
inline void MoveCharacterRequest::unsafe_arena_set_allocated_target_position(
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_position_);
  }
  _impl_.target_position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MoveCharacterRequest.target_position)
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE MoveCharacterRequest::release_target_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::api::v1alpha1::Position* released = _impl_.target_position_;
  _impl_.target_position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE MoveCharacterRequest::unsafe_arena_release_target_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterRequest.target_position)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::api::v1alpha1::Position* temp = _impl_.target_position_;
  _impl_.target_position_ = nullptr;
  return temp;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MoveCharacterRequest::_internal_mutable_target_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::api::v1alpha1::Position>(GetArena());
    _impl_.target_position_ = reinterpret_cast<::api::v1alpha1::Position*>(p);
  }
  return _impl_.target_position_;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MoveCharacterRequest::mutable_target_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::api::v1alpha1::Position* _msg = _internal_mutable_target_position();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterRequest.target_position)
  return _msg;
}
inline void MoveCharacterRequest::set_allocated_target_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.target_position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterRequest.target_position)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MovementError

// .dnd5e.api.v1alpha1.MovementError.ErrorCode code = 1 [json_name = "code"];
inline void MovementError::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::dnd5e::api::v1alpha1::MovementError_ErrorCode MovementError::code() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MovementError.code)
  return _internal_code();
}
inline void MovementError::set_code(::dnd5e::api::v1alpha1::MovementError_ErrorCode value) {
  _internal_set_code(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MovementError.code)
}
inline ::dnd5e::api::v1alpha1::MovementError_ErrorCode MovementError::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::MovementError_ErrorCode>(_impl_.code_);
}
inline void MovementError::_internal_set_code(::dnd5e::api::v1alpha1::MovementError_ErrorCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = value;
}

// string message = 2 [json_name = "message"];
inline void MovementError::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MovementError::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MovementError.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MovementError::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MovementError.message)
}
inline ::std::string* PROTOBUF_NONNULL MovementError::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MovementError.message)
  return _s;
}
inline const ::std::string& MovementError::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void MovementError::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MovementError::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MovementError::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MovementError.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void MovementError::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MovementError.message)
}

// map<string, string> details = 3 [json_name = "details"];
inline int MovementError::_internal_details_size() const {
  return _internal_details().size();
}
inline int MovementError::details_size() const {
  return _internal_details_size();
}
inline void MovementError::clear_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& MovementError::_internal_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.details_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& MovementError::details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:dnd5e.api.v1alpha1.MovementError.details)
  return _internal_details();
}
inline ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL MovementError::_internal_mutable_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.details_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL MovementError::mutable_details()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:dnd5e.api.v1alpha1.MovementError.details)
  return _internal_mutable_details();
}

// -------------------------------------------------------------------

// MoveCharacterResponse

// bool success = 1 [json_name = "success"];
inline void MoveCharacterResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool MoveCharacterResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.success)
  return _internal_success();
}
inline void MoveCharacterResponse::set_success(bool value) {
  _internal_set_success(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterResponse.success)
}
inline bool MoveCharacterResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void MoveCharacterResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// .dnd5e.api.v1alpha1.MovementError error = 2 [json_name = "error"];
inline bool MoveCharacterResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline void MoveCharacterResponse::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::MovementError& MoveCharacterResponse::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::MovementError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::MovementError&>(::dnd5e::api::v1alpha1::_MovementError_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::MovementError& MoveCharacterResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.error)
  return _internal_error();
}
inline void MoveCharacterResponse::unsafe_arena_set_allocated_error(
    ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::dnd5e::api::v1alpha1::MovementError*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.error)
}
inline ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE MoveCharacterResponse::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::MovementError* released = _impl_.error_;
  _impl_.error_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE MoveCharacterResponse::unsafe_arena_release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::MovementError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NONNULL MoveCharacterResponse::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::MovementError>(GetArena());
    _impl_.error_ = reinterpret_cast<::dnd5e::api::v1alpha1::MovementError*>(p);
  }
  return _impl_.error_;
}
inline ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NONNULL MoveCharacterResponse::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::MovementError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterResponse.error)
  return _msg;
}
inline void MoveCharacterResponse::set_allocated_error(::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::dnd5e::api::v1alpha1::MovementError*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.error)
}

// int32 movement_remaining = 3 [json_name = "movementRemaining"];
inline void MoveCharacterResponse::clear_movement_remaining() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_remaining_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t MoveCharacterResponse::movement_remaining() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.movement_remaining)
  return _internal_movement_remaining();
}
inline void MoveCharacterResponse::set_movement_remaining(::int32_t value) {
  _internal_set_movement_remaining(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterResponse.movement_remaining)
}
inline ::int32_t MoveCharacterResponse::_internal_movement_remaining() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movement_remaining_;
}
inline void MoveCharacterResponse::_internal_set_movement_remaining(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_remaining_ = value;
}

// .dnd5e.api.v1alpha1.Room updated_room = 4 [json_name = "updatedRoom"];
inline bool MoveCharacterResponse::has_updated_room() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_room_ != nullptr);
  return value;
}
inline void MoveCharacterResponse::clear_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ != nullptr) _impl_.updated_room_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dnd5e::api::v1alpha1::Room& MoveCharacterResponse::_internal_updated_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.updated_room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& MoveCharacterResponse::updated_room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)
  return _internal_updated_room();
}
inline void MoveCharacterResponse::unsafe_arena_set_allocated_updated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }
  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE MoveCharacterResponse::release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::Room* released = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE MoveCharacterResponse::unsafe_arena_release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL MoveCharacterResponse::_internal_mutable_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.updated_room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL MoveCharacterResponse::mutable_updated_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_updated_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)
  return _msg;
}
inline void MoveCharacterResponse::set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 5 [json_name = "combatState"];
inline bool MoveCharacterResponse::has_combat_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void MoveCharacterResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::dnd5e::api::v1alpha1::CombatState& MoveCharacterResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& MoveCharacterResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.combat_state)
  return _internal_combat_state();
}
inline void MoveCharacterResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE MoveCharacterResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE MoveCharacterResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterResponse.combat_state)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL MoveCharacterResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL MoveCharacterResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterResponse.combat_state)
  return _msg;
}
inline void MoveCharacterResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.combat_state)
}

// -------------------------------------------------------------------

// EndTurnRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void EndTurnRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EndTurnRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EndTurnRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL EndTurnRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
  return _s;
}
inline const ::std::string& EndTurnRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void EndTurnRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EndTurnRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EndTurnRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void EndTurnRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
}

// string entity_id = 2 [json_name = "entityId"];
inline void EndTurnRequest::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& EndTurnRequest::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EndTurnRequest::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL EndTurnRequest::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
  return _s;
}
inline const ::std::string& EndTurnRequest::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void EndTurnRequest::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EndTurnRequest::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EndTurnRequest::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void EndTurnRequest::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
}

// -------------------------------------------------------------------

// TurnChangeEvent

// string previous_entity_id = 1 [json_name = "previousEntityId"];
inline void TurnChangeEvent::clear_previous_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.previous_entity_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TurnChangeEvent::previous_entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
  return _internal_previous_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TurnChangeEvent::set_previous_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.previous_entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
}
inline ::std::string* PROTOBUF_NONNULL TurnChangeEvent::mutable_previous_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_previous_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
  return _s;
}
inline const ::std::string& TurnChangeEvent::_internal_previous_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.previous_entity_id_.Get();
}
inline void TurnChangeEvent::_internal_set_previous_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.previous_entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TurnChangeEvent::_internal_mutable_previous_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.previous_entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TurnChangeEvent::release_previous_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.previous_entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.previous_entity_id_.Set("", GetArena());
  }
  return released;
}
inline void TurnChangeEvent::set_allocated_previous_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.previous_entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.previous_entity_id_.IsDefault()) {
    _impl_.previous_entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
}

// string next_entity_id = 2 [json_name = "nextEntityId"];
inline void TurnChangeEvent::clear_next_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_entity_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& TurnChangeEvent::next_entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
  return _internal_next_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TurnChangeEvent::set_next_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.next_entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
}
inline ::std::string* PROTOBUF_NONNULL TurnChangeEvent::mutable_next_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_next_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
  return _s;
}
inline const ::std::string& TurnChangeEvent::_internal_next_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_entity_id_.Get();
}
inline void TurnChangeEvent::_internal_set_next_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.next_entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TurnChangeEvent::_internal_mutable_next_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.next_entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TurnChangeEvent::release_next_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.next_entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.next_entity_id_.Set("", GetArena());
  }
  return released;
}
inline void TurnChangeEvent::set_allocated_next_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.next_entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_entity_id_.IsDefault()) {
    _impl_.next_entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
}

// int32 round = 3 [json_name = "round"];
inline void TurnChangeEvent::clear_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t TurnChangeEvent::round() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnChangeEvent.round)
  return _internal_round();
}
inline void TurnChangeEvent::set_round(::int32_t value) {
  _internal_set_round(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnChangeEvent.round)
}
inline ::int32_t TurnChangeEvent::_internal_round() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.round_;
}
inline void TurnChangeEvent::_internal_set_round(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = value;
}

// bool new_round = 4 [json_name = "newRound"];
inline void TurnChangeEvent::clear_new_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_round_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool TurnChangeEvent::new_round() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnChangeEvent.new_round)
  return _internal_new_round();
}
inline void TurnChangeEvent::set_new_round(bool value) {
  _internal_set_new_round(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnChangeEvent.new_round)
}
inline bool TurnChangeEvent::_internal_new_round() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_round_;
}
inline void TurnChangeEvent::_internal_set_new_round(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_round_ = value;
}

// -------------------------------------------------------------------

// EndTurnResponse

// bool success = 1 [json_name = "success"];
inline void EndTurnResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool EndTurnResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnResponse.success)
  return _internal_success();
}
inline void EndTurnResponse::set_success(bool value) {
  _internal_set_success(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EndTurnResponse.success)
}
inline bool EndTurnResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void EndTurnResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
inline bool EndTurnResponse::has_combat_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void EndTurnResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::CombatState& EndTurnResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& EndTurnResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)
  return _internal_combat_state();
}
inline void EndTurnResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE EndTurnResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE EndTurnResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL EndTurnResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL EndTurnResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)
  return _msg;
}
inline void EndTurnResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)
}

// .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 3 [json_name = "turnChange"];
inline bool EndTurnResponse::has_turn_change() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.turn_change_ != nullptr);
  return value;
}
inline void EndTurnResponse::clear_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.turn_change_ != nullptr) _impl_.turn_change_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dnd5e::api::v1alpha1::TurnChangeEvent& EndTurnResponse::_internal_turn_change() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::TurnChangeEvent* p = _impl_.turn_change_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::TurnChangeEvent&>(::dnd5e::api::v1alpha1::_TurnChangeEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::TurnChangeEvent& EndTurnResponse::turn_change() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)
  return _internal_turn_change();
}
inline void EndTurnResponse::unsafe_arena_set_allocated_turn_change(
    ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.turn_change_);
  }
  _impl_.turn_change_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnChangeEvent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE EndTurnResponse::release_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::TurnChangeEvent* released = _impl_.turn_change_;
  _impl_.turn_change_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE EndTurnResponse::unsafe_arena_release_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::TurnChangeEvent* temp = _impl_.turn_change_;
  _impl_.turn_change_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL EndTurnResponse::_internal_mutable_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.turn_change_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::TurnChangeEvent>(GetArena());
    _impl_.turn_change_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnChangeEvent*>(p);
  }
  return _impl_.turn_change_;
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL EndTurnResponse::mutable_turn_change()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::dnd5e::api::v1alpha1::TurnChangeEvent* _msg = _internal_mutable_turn_change();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)
  return _msg;
}
inline void EndTurnResponse::set_allocated_turn_change(::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.turn_change_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.turn_change_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnChangeEvent*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)
}

// -------------------------------------------------------------------

// AttackRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void AttackRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& AttackRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
  return _s;
}
inline const ::std::string& AttackRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void AttackRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
}

// string attacker_id = 2 [json_name = "attackerId"];
inline void AttackRequest::clear_attacker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attacker_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& AttackRequest::attacker_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
  return _internal_attacker_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackRequest::set_attacker_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.attacker_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::mutable_attacker_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_attacker_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
  return _s;
}
inline const ::std::string& AttackRequest::_internal_attacker_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attacker_id_.Get();
}
inline void AttackRequest::_internal_set_attacker_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.attacker_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::_internal_mutable_attacker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.attacker_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackRequest::release_attacker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.attacker_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.attacker_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackRequest::set_allocated_attacker_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.attacker_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.attacker_id_.IsDefault()) {
    _impl_.attacker_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
}

// string target_id = 3 [json_name = "targetId"];
inline void AttackRequest::clear_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& AttackRequest::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackRequest::set_target_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.target_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::mutable_target_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackRequest.target_id)
  return _s;
}
inline const ::std::string& AttackRequest::_internal_target_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_id_.Get();
}
inline void AttackRequest::_internal_set_target_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.target_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::_internal_mutable_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.target_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackRequest::release_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackRequest.target_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.target_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.target_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackRequest::set_allocated_target_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.target_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_id_.IsDefault()) {
    _impl_.target_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackRequest.target_id)
}

// string weapon_id = 4 [json_name = "weaponId"];
inline void AttackRequest::clear_weapon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapon_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& AttackRequest::weapon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
  return _internal_weapon_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackRequest::set_weapon_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.weapon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::mutable_weapon_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_weapon_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
  return _s;
}
inline const ::std::string& AttackRequest::_internal_weapon_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.weapon_id_.Get();
}
inline void AttackRequest::_internal_set_weapon_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.weapon_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::_internal_mutable_weapon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.weapon_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackRequest::release_weapon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.weapon_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.weapon_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackRequest::set_allocated_weapon_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.weapon_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.weapon_id_.IsDefault()) {
    _impl_.weapon_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
}

// -------------------------------------------------------------------

// AttackResult

// bool hit = 1 [json_name = "hit"];
inline void AttackResult::clear_hit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hit_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool AttackResult::hit() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.hit)
  return _internal_hit();
}
inline void AttackResult::set_hit(bool value) {
  _internal_set_hit(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.hit)
}
inline bool AttackResult::_internal_hit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hit_;
}
inline void AttackResult::_internal_set_hit(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hit_ = value;
}

// int32 attack_roll = 2 [json_name = "attackRoll"];
inline void AttackResult::clear_attack_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_roll_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AttackResult::attack_roll() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.attack_roll)
  return _internal_attack_roll();
}
inline void AttackResult::set_attack_roll(::int32_t value) {
  _internal_set_attack_roll(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.attack_roll)
}
inline ::int32_t AttackResult::_internal_attack_roll() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attack_roll_;
}
inline void AttackResult::_internal_set_attack_roll(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_roll_ = value;
}

// int32 attack_total = 3 [json_name = "attackTotal"];
inline void AttackResult::clear_attack_total() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_total_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t AttackResult::attack_total() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.attack_total)
  return _internal_attack_total();
}
inline void AttackResult::set_attack_total(::int32_t value) {
  _internal_set_attack_total(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.attack_total)
}
inline ::int32_t AttackResult::_internal_attack_total() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attack_total_;
}
inline void AttackResult::_internal_set_attack_total(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_total_ = value;
}

// int32 target_ac = 4 [json_name = "targetAc"];
inline void AttackResult::clear_target_ac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ac_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t AttackResult::target_ac() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.target_ac)
  return _internal_target_ac();
}
inline void AttackResult::set_target_ac(::int32_t value) {
  _internal_set_target_ac(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.target_ac)
}
inline ::int32_t AttackResult::_internal_target_ac() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_ac_;
}
inline void AttackResult::_internal_set_target_ac(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ac_ = value;
}

// int32 damage = 5 [json_name = "damage"];
inline void AttackResult::clear_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t AttackResult::damage() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.damage)
  return _internal_damage();
}
inline void AttackResult::set_damage(::int32_t value) {
  _internal_set_damage(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.damage)
}
inline ::int32_t AttackResult::_internal_damage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_;
}
inline void AttackResult::_internal_set_damage(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = value;
}

// string damage_type = 6 [json_name = "damageType"];
inline void AttackResult::clear_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& AttackResult::damage_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.damage_type)
  return _internal_damage_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackResult::set_damage_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.damage_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.damage_type)
}
inline ::std::string* PROTOBUF_NONNULL AttackResult::mutable_damage_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_damage_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResult.damage_type)
  return _s;
}
inline const ::std::string& AttackResult::_internal_damage_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_type_.Get();
}
inline void AttackResult::_internal_set_damage_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.damage_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackResult::_internal_mutable_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.damage_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackResult::release_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResult.damage_type)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.damage_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  return released;
}
inline void AttackResult::set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.damage_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.damage_type_.IsDefault()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResult.damage_type)
}

// bool critical = 7 [json_name = "critical"];
inline void AttackResult::clear_critical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool AttackResult::critical() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.critical)
  return _internal_critical();
}
inline void AttackResult::set_critical(bool value) {
  _internal_set_critical(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.critical)
}
inline bool AttackResult::_internal_critical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.critical_;
}
inline void AttackResult::_internal_set_critical(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_ = value;
}

// -------------------------------------------------------------------

// AttackResponse

// bool success = 1 [json_name = "success"];
inline void AttackResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool AttackResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.success)
  return _internal_success();
}
inline void AttackResponse::set_success(bool value) {
  _internal_set_success(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResponse.success)
}
inline bool AttackResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void AttackResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string error = 2 [json_name = "error"];
inline void AttackResponse::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& AttackResponse::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackResponse::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResponse.error)
}
inline ::std::string* PROTOBUF_NONNULL AttackResponse::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.error)
  return _s;
}
inline const ::std::string& AttackResponse::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void AttackResponse::_internal_set_error(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackResponse::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackResponse::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.error)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void AttackResponse::set_allocated_error(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.error)
}

// .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
inline bool AttackResponse::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void AttackResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dnd5e::api::v1alpha1::AttackResult& AttackResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::AttackResult* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::AttackResult&>(::dnd5e::api::v1alpha1::_AttackResult_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AttackResult& AttackResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.result)
  return _internal_result();
}
inline void AttackResponse::unsafe_arena_set_allocated_result(
    ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResult*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResponse.result)
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE AttackResponse::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::AttackResult* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE AttackResponse::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.result)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::AttackResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL AttackResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AttackResult>(GetArena());
    _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResult*>(p);
  }
  return _impl_.result_;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL AttackResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::dnd5e::api::v1alpha1::AttackResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.result)
  return _msg;
}
inline void AttackResponse::set_allocated_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.result)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
inline bool AttackResponse::has_combat_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void AttackResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::dnd5e::api::v1alpha1::CombatState& AttackResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& AttackResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.combat_state)
  return _internal_combat_state();
}
inline void AttackResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE AttackResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE AttackResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.combat_state)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL AttackResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL AttackResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.combat_state)
  return _msg;
}
inline void AttackResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.combat_state)
}

// .dnd5e.api.v1alpha1.Room updated_room = 5 [json_name = "updatedRoom"];
inline bool AttackResponse::has_updated_room() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_room_ != nullptr);
  return value;
}
inline void AttackResponse::clear_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ != nullptr) _impl_.updated_room_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::dnd5e::api::v1alpha1::Room& AttackResponse::_internal_updated_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.updated_room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& AttackResponse::updated_room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.updated_room)
  return _internal_updated_room();
}
inline void AttackResponse::unsafe_arena_set_allocated_updated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }
  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResponse.updated_room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE AttackResponse::release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::dnd5e::api::v1alpha1::Room* released = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE AttackResponse::unsafe_arena_release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.updated_room)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL AttackResponse::_internal_mutable_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.updated_room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL AttackResponse::mutable_updated_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_updated_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.updated_room)
  return _msg;
}
inline void AttackResponse::set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.updated_room)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::MovementError_ErrorCode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::MovementError_ErrorCode>() {
  return ::dnd5e::api::v1alpha1::MovementError_ErrorCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_2epb_2eh
