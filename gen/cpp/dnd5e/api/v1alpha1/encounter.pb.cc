// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: dnd5e/api/v1alpha1/encounter.proto
// Protobuf C++ Version: 6.33.2

#include "dnd5e/api/v1alpha1/encounter.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace dnd5e {
namespace api {
namespace v1alpha1 {

inline constexpr TurnChangeEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        previous_entity_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        next_entity_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        round_{0},
        new_round_{false} {}

template <typename>
PROTOBUF_CONSTEXPR TurnChangeEvent::TurnChangeEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(TurnChangeEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TurnChangeEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TurnChangeEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TurnChangeEventDefaultTypeInternal() {}
  union {
    TurnChangeEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TurnChangeEventDefaultTypeInternal _TurnChangeEvent_default_instance_;

inline constexpr StreamEncounterEventsRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR StreamEncounterEventsRequest::StreamEncounterEventsRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(StreamEncounterEventsRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct StreamEncounterEventsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamEncounterEventsRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamEncounterEventsRequestDefaultTypeInternal() {}
  union {
    StreamEncounterEventsRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamEncounterEventsRequestDefaultTypeInternal _StreamEncounterEventsRequest_default_instance_;

inline constexpr StartCombatRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        theme_{static_cast< ::dnd5e::api::v1alpha1::DungeonTheme >(0)},
        difficulty_{static_cast< ::dnd5e::api::v1alpha1::DungeonDifficulty >(0)},
        length_{static_cast< ::dnd5e::api::v1alpha1::DungeonLength >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR StartCombatRequest::StartCombatRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(StartCombatRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct StartCombatRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StartCombatRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StartCombatRequestDefaultTypeInternal() {}
  union {
    StartCombatRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StartCombatRequestDefaultTypeInternal _StartCombatRequest_default_instance_;

inline constexpr SetReadyResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        success_{false} {}

template <typename>
PROTOBUF_CONSTEXPR SetReadyResponse::SetReadyResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SetReadyResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SetReadyResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetReadyResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetReadyResponseDefaultTypeInternal() {}
  union {
    SetReadyResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetReadyResponseDefaultTypeInternal _SetReadyResponse_default_instance_;

inline constexpr SetReadyRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        is_ready_{false} {}

template <typename>
PROTOBUF_CONSTEXPR SetReadyRequest::SetReadyRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SetReadyRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SetReadyRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetReadyRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetReadyRequestDefaultTypeInternal() {}
  union {
    SetReadyRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetReadyRequestDefaultTypeInternal _SetReadyRequest_default_instance_;

inline constexpr RerollEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        die_index_{0},
        before_{0},
        after_{0} {}

template <typename>
PROTOBUF_CONSTEXPR RerollEvent::RerollEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RerollEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RerollEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RerollEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RerollEventDefaultTypeInternal() {}
  union {
    RerollEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RerollEventDefaultTypeInternal _RerollEvent_default_instance_;

inline constexpr PlayerReadyEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        is_ready_{false} {}

template <typename>
PROTOBUF_CONSTEXPR PlayerReadyEvent::PlayerReadyEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PlayerReadyEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PlayerReadyEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerReadyEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerReadyEventDefaultTypeInternal() {}
  union {
    PlayerReadyEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerReadyEventDefaultTypeInternal _PlayerReadyEvent_default_instance_;

inline constexpr PlayerLeftEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        character_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR PlayerLeftEvent::PlayerLeftEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PlayerLeftEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PlayerLeftEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerLeftEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerLeftEventDefaultTypeInternal() {}
  union {
    PlayerLeftEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerLeftEventDefaultTypeInternal _PlayerLeftEvent_default_instance_;

inline constexpr PlayerDisconnectedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        character_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR PlayerDisconnectedEvent::PlayerDisconnectedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PlayerDisconnectedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PlayerDisconnectedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerDisconnectedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerDisconnectedEventDefaultTypeInternal() {}
  union {
    PlayerDisconnectedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerDisconnectedEventDefaultTypeInternal _PlayerDisconnectedEvent_default_instance_;

inline constexpr OpenDoorRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        dungeon_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        connection_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR OpenDoorRequest::OpenDoorRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(OpenDoorRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct OpenDoorRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpenDoorRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpenDoorRequestDefaultTypeInternal() {}
  union {
    OpenDoorRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpenDoorRequestDefaultTypeInternal _OpenDoorRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MovementError_DetailsEntry_DoNotUse::MovementError_DetailsEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : MovementError_DetailsEntry_DoNotUse::MapEntry(MovementError_DetailsEntry_DoNotUse_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : MovementError_DetailsEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct MovementError_DetailsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MovementError_DetailsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MovementError_DetailsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    MovementError_DetailsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MovementError_DetailsEntry_DoNotUseDefaultTypeInternal _MovementError_DetailsEntry_DoNotUse_default_instance_;

inline constexpr MonsterCombatState::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        monster_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        monster_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        current_hit_points_{0},
        max_hit_points_{0},
        monster_type_{static_cast< ::dnd5e::api::v1alpha1::MonsterType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR MonsterCombatState::MonsterCombatState(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MonsterCombatState_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MonsterCombatStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonsterCombatStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonsterCombatStateDefaultTypeInternal() {}
  union {
    MonsterCombatState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonsterCombatStateDefaultTypeInternal _MonsterCombatState_default_instance_;

inline constexpr LeaveEncounterResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        success_{false} {}

template <typename>
PROTOBUF_CONSTEXPR LeaveEncounterResponse::LeaveEncounterResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(LeaveEncounterResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LeaveEncounterResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaveEncounterResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaveEncounterResponseDefaultTypeInternal() {}
  union {
    LeaveEncounterResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaveEncounterResponseDefaultTypeInternal _LeaveEncounterResponse_default_instance_;

inline constexpr LeaveEncounterRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR LeaveEncounterRequest::LeaveEncounterRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(LeaveEncounterRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LeaveEncounterRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaveEncounterRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaveEncounterRequestDefaultTypeInternal() {}
  union {
    LeaveEncounterRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaveEncounterRequestDefaultTypeInternal _LeaveEncounterRequest_default_instance_;

inline constexpr JoinEncounterRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        character_ids_{},
        join_code_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR JoinEncounterRequest::JoinEncounterRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(JoinEncounterRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct JoinEncounterRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JoinEncounterRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~JoinEncounterRequestDefaultTypeInternal() {}
  union {
    JoinEncounterRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinEncounterRequestDefaultTypeInternal _JoinEncounterRequest_default_instance_;

inline constexpr InitiativeEntry::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        entity_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        entity_type_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        initiative_{0},
        modifier_{0},
        has_acted_{false} {}

template <typename>
PROTOBUF_CONSTEXPR InitiativeEntry::InitiativeEntry(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(InitiativeEntry_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct InitiativeEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InitiativeEntryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InitiativeEntryDefaultTypeInternal() {}
  union {
    InitiativeEntry _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InitiativeEntryDefaultTypeInternal _InitiativeEntry_default_instance_;

inline constexpr HealResult::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        amount_healed_{0},
        new_hp_{0},
        max_hp_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HealResult::HealResult(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(HealResult_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HealResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HealResultDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HealResultDefaultTypeInternal() {}
  union {
    HealResult _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HealResultDefaultTypeInternal _HealResult_default_instance_;

inline constexpr GrantedAction::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        type_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        weapon_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR GrantedAction::GrantedAction(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(GrantedAction_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct GrantedActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GrantedActionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GrantedActionDefaultTypeInternal() {}
  union {
    GrantedAction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GrantedActionDefaultTypeInternal _GrantedAction_default_instance_;

inline constexpr GetEncounterStateRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR GetEncounterStateRequest::GetEncounterStateRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(GetEncounterStateRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct GetEncounterStateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetEncounterStateRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetEncounterStateRequestDefaultTypeInternal() {}
  union {
    GetEncounterStateRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetEncounterStateRequestDefaultTypeInternal _GetEncounterStateRequest_default_instance_;

inline constexpr GetEncounterHistoryRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        up_to_event_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        limit_{0} {}

template <typename>
PROTOBUF_CONSTEXPR GetEncounterHistoryRequest::GetEncounterHistoryRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(GetEncounterHistoryRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct GetEncounterHistoryRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetEncounterHistoryRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetEncounterHistoryRequestDefaultTypeInternal() {}
  union {
    GetEncounterHistoryRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetEncounterHistoryRequestDefaultTypeInternal _GetEncounterHistoryRequest_default_instance_;

inline constexpr GetCombatStateRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR GetCombatStateRequest::GetCombatStateRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(GetCombatStateRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct GetCombatStateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetCombatStateRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetCombatStateRequestDefaultTypeInternal() {}
  union {
    GetCombatStateRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetCombatStateRequestDefaultTypeInternal _GetCombatStateRequest_default_instance_;

inline constexpr EndTurnRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        entity_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR EndTurnRequest::EndTurnRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(EndTurnRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EndTurnRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndTurnRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndTurnRequestDefaultTypeInternal() {}
  union {
    EndTurnRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndTurnRequestDefaultTypeInternal _EndTurnRequest_default_instance_;

inline constexpr EncounterResult::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        reason_{static_cast< ::dnd5e::api::v1alpha1::EncounterEndReason >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR EncounterResult::EncounterResult(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(EncounterResult_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EncounterResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EncounterResultDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EncounterResultDefaultTypeInternal() {}
  union {
    EncounterResult _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EncounterResultDefaultTypeInternal _EncounterResult_default_instance_;

inline constexpr DungeonVictoryEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        dungeon_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        rooms_cleared_{0},
        dungeon_state_{static_cast< ::dnd5e::api::v1alpha1::DungeonState >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR DungeonVictoryEvent::DungeonVictoryEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DungeonVictoryEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DungeonVictoryEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DungeonVictoryEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DungeonVictoryEventDefaultTypeInternal() {}
  union {
    DungeonVictoryEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DungeonVictoryEventDefaultTypeInternal _DungeonVictoryEvent_default_instance_;

inline constexpr DungeonStartRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        character_ids_{},
        theme_{static_cast< ::dnd5e::api::v1alpha1::DungeonTheme >(0)},
        difficulty_{static_cast< ::dnd5e::api::v1alpha1::DungeonDifficulty >(0)},
        length_{static_cast< ::dnd5e::api::v1alpha1::DungeonLength >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR DungeonStartRequest::DungeonStartRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DungeonStartRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DungeonStartRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DungeonStartRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DungeonStartRequestDefaultTypeInternal() {}
  union {
    DungeonStartRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DungeonStartRequestDefaultTypeInternal _DungeonStartRequest_default_instance_;

inline constexpr DungeonFailureEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        dungeon_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        final_room_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        dungeon_state_{static_cast< ::dnd5e::api::v1alpha1::DungeonState >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR DungeonFailureEvent::DungeonFailureEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DungeonFailureEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DungeonFailureEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DungeonFailureEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DungeonFailureEventDefaultTypeInternal() {}
  union {
    DungeonFailureEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DungeonFailureEventDefaultTypeInternal _DungeonFailureEvent_default_instance_;

inline constexpr CreateEncounterRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        character_ids_{} {}

template <typename>
PROTOBUF_CONSTEXPR CreateEncounterRequest::CreateEncounterRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CreateEncounterRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CreateEncounterRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateEncounterRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateEncounterRequestDefaultTypeInternal() {}
  union {
    CreateEncounterRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateEncounterRequestDefaultTypeInternal _CreateEncounterRequest_default_instance_;

inline constexpr CombatPausedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        disconnected_player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR CombatPausedEvent::CombatPausedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CombatPausedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CombatPausedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CombatPausedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CombatPausedEventDefaultTypeInternal() {}
  union {
    CombatPausedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CombatPausedEventDefaultTypeInternal _CombatPausedEvent_default_instance_;

inline constexpr AttackRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        attacker_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        target_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        weapon_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        attack_hand_{static_cast< ::dnd5e::api::v1alpha1::AttackHand >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR AttackRequest::AttackRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(AttackRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AttackRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttackRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttackRequestDefaultTypeInternal() {}
  union {
    AttackRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttackRequestDefaultTypeInternal _AttackRequest_default_instance_;

inline constexpr ActivateFeatureRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        character_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        feature_id_{static_cast< ::dnd5e::api::v1alpha1::FeatureId >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR ActivateFeatureRequest::ActivateFeatureRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ActivateFeatureRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ActivateFeatureRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActivateFeatureRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActivateFeatureRequestDefaultTypeInternal() {}
  union {
    ActivateFeatureRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActivateFeatureRequestDefaultTypeInternal _ActivateFeatureRequest_default_instance_;

inline constexpr TurnState::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        entity_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        position_{nullptr},
        movement_used_{0},
        movement_max_{0},
        action_used_{false},
        bonus_action_used_{false},
        reaction_available_{false} {}

template <typename>
PROTOBUF_CONSTEXPR TurnState::TurnState(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(TurnState_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TurnStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TurnStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TurnStateDefaultTypeInternal() {}
  union {
    TurnState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TurnStateDefaultTypeInternal _TurnState_default_instance_;

inline constexpr MovementError::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        code_{static_cast< ::dnd5e::api::v1alpha1::MovementError_ErrorCode >(0)},
        details_{} {}

template <typename>
PROTOBUF_CONSTEXPR MovementError::MovementError(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MovementError_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MovementErrorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MovementErrorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MovementErrorDefaultTypeInternal() {}
  union {
    MovementError _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MovementErrorDefaultTypeInternal _MovementError_default_instance_;

inline constexpr MoveCharacterRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        path_{},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        entity_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR MoveCharacterRequest::MoveCharacterRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MoveCharacterRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MoveCharacterRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveCharacterRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveCharacterRequestDefaultTypeInternal() {}
  union {
    MoveCharacterRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveCharacterRequestDefaultTypeInternal _MoveCharacterRequest_default_instance_;

inline constexpr EntityPlacement::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        entity_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        position_{nullptr},
        entity_type_{static_cast< ::dnd5e::api::v1alpha1::EntityType >(0)},
        size_{static_cast< ::dnd5e::api::v1alpha1::EntitySize >(0)},
        blocks_movement_{false},
        blocks_line_of_sight_{false},
        visual_type_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR EntityPlacement::EntityPlacement(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(EntityPlacement_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EntityPlacementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EntityPlacementDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EntityPlacementDefaultTypeInternal() {}
  union {
    EntityPlacement _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EntityPlacementDefaultTypeInternal _EntityPlacement_default_instance_;

inline constexpr DoorInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        connection_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        physical_hint_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        leads_to_room_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        position_{nullptr},
        is_open_{false} {}

template <typename>
PROTOBUF_CONSTEXPR DoorInfo::DoorInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DoorInfo_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DoorInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoorInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoorInfoDefaultTypeInternal() {}
  union {
    DoorInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoorInfoDefaultTypeInternal _DoorInfo_default_instance_;

inline constexpr DamageComponent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        original_dice_rolls_{},
        _original_dice_rolls_cached_byte_size_{0},
        final_dice_rolls_{},
        _final_dice_rolls_cached_byte_size_{0},
        rerolls_{},
        source_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        damage_type_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        source_ref_{nullptr},
        flat_bonus_{0},
        is_critical_{false},
        multiplier_{0} {}

template <typename>
PROTOBUF_CONSTEXPR DamageComponent::DamageComponent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DamageComponent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DamageComponentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DamageComponentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DamageComponentDefaultTypeInternal() {}
  union {
    DamageComponent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DamageComponentDefaultTypeInternal _DamageComponent_default_instance_;

inline constexpr CombatEndedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        result_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR CombatEndedEvent::CombatEndedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CombatEndedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CombatEndedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CombatEndedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CombatEndedEventDefaultTypeInternal() {}
  union {
    CombatEndedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CombatEndedEventDefaultTypeInternal _CombatEndedEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Room_EntitiesEntry_DoNotUse::Room_EntitiesEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : Room_EntitiesEntry_DoNotUse::MapEntry(Room_EntitiesEntry_DoNotUse_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : Room_EntitiesEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct Room_EntitiesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Room_EntitiesEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Room_EntitiesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Room_EntitiesEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Room_EntitiesEntry_DoNotUseDefaultTypeInternal _Room_EntitiesEntry_DoNotUse_default_instance_;

inline constexpr DamageBreakdown::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        components_{},
        ability_used_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        total_damage_{0} {}

template <typename>
PROTOBUF_CONSTEXPR DamageBreakdown::DamageBreakdown(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DamageBreakdown_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DamageBreakdownDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DamageBreakdownDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DamageBreakdownDefaultTypeInternal() {}
  union {
    DamageBreakdown _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DamageBreakdownDefaultTypeInternal _DamageBreakdown_default_instance_;

inline constexpr CombatState::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        turn_order_{},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        current_turn_{nullptr},
        round_{0},
        active_index_{0},
        combat_started_{false},
        combat_ended_{false} {}

template <typename>
PROTOBUF_CONSTEXPR CombatState::CombatState(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CombatState_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CombatStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CombatStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CombatStateDefaultTypeInternal() {}
  union {
    CombatState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CombatStateDefaultTypeInternal _CombatState_default_instance_;

inline constexpr Room::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        walls_{},
        id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        type_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        origin_{nullptr},
        width_{0},
        height_{0},
        grid_type_{static_cast< ::api::v1alpha1::GridType >(0)},
        hex_orientation_{false},
        entities_{} {}

template <typename>
PROTOBUF_CONSTEXPR Room::Room(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Room_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RoomDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoomDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoomDefaultTypeInternal() {}
  union {
    Room _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoomDefaultTypeInternal _Room_default_instance_;

inline constexpr CombatResumedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        combat_state_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR CombatResumedEvent::CombatResumedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CombatResumedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CombatResumedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CombatResumedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CombatResumedEventDefaultTypeInternal() {}
  union {
    CombatResumedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CombatResumedEventDefaultTypeInternal _CombatResumedEvent_default_instance_;

inline constexpr AttackResult::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        damage_type_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        damage_breakdown_{nullptr},
        attack_roll_{0},
        attack_total_{0},
        target_ac_{0},
        hit_{false},
        critical_{false},
        damage_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AttackResult::AttackResult(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(AttackResult_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AttackResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttackResultDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttackResultDefaultTypeInternal() {}
  union {
    AttackResult _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttackResultDefaultTypeInternal _AttackResult_default_instance_;

inline constexpr TurnEndedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        turn_change_{nullptr},
        combat_state_{nullptr},
        updated_room_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR TurnEndedEvent::TurnEndedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(TurnEndedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TurnEndedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TurnEndedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TurnEndedEventDefaultTypeInternal() {}
  union {
    TurnEndedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TurnEndedEventDefaultTypeInternal _TurnEndedEvent_default_instance_;

inline constexpr RoomRevealedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        doors_{},
        dungeon_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        connection_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        room_{nullptr},
        combat_state_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RoomRevealedEvent::RoomRevealedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RoomRevealedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RoomRevealedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoomRevealedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoomRevealedEventDefaultTypeInternal() {}
  union {
    RoomRevealedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoomRevealedEventDefaultTypeInternal _RoomRevealedEvent_default_instance_;

inline constexpr MovementCompletedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        path_{},
        entity_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        stop_reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        final_position_{nullptr},
        updated_room_{nullptr},
        movement_remaining_{0} {}

template <typename>
PROTOBUF_CONSTEXPR MovementCompletedEvent::MovementCompletedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MovementCompletedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MovementCompletedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MovementCompletedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MovementCompletedEventDefaultTypeInternal() {}
  union {
    MovementCompletedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MovementCompletedEventDefaultTypeInternal _MovementCompletedEvent_default_instance_;

inline constexpr MoveCharacterResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        stop_reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        error_{nullptr},
        final_position_{nullptr},
        updated_room_{nullptr},
        success_{false},
        movement_remaining_{0} {}

template <typename>
PROTOBUF_CONSTEXPR MoveCharacterResponse::MoveCharacterResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MoveCharacterResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MoveCharacterResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveCharacterResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveCharacterResponseDefaultTypeInternal() {}
  union {
    MoveCharacterResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveCharacterResponseDefaultTypeInternal _MoveCharacterResponse_default_instance_;

inline constexpr MonsterExecutedAction::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        action_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        target_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        action_type_{static_cast< ::dnd5e::api::v1alpha1::MonsterActionType >(0)},
        success_{false},
        details_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR MonsterExecutedAction::MonsterExecutedAction(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MonsterExecutedAction_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MonsterExecutedActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonsterExecutedActionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonsterExecutedActionDefaultTypeInternal() {}
  union {
    MonsterExecutedAction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonsterExecutedActionDefaultTypeInternal _MonsterExecutedAction_default_instance_;

inline constexpr GetCombatStateResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        room_{nullptr},
        combat_state_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR GetCombatStateResponse::GetCombatStateResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(GetCombatStateResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct GetCombatStateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetCombatStateResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetCombatStateResponseDefaultTypeInternal() {}
  union {
    GetCombatStateResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetCombatStateResponseDefaultTypeInternal _GetCombatStateResponse_default_instance_;

inline constexpr CreateEncounterResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        join_code_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        room_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR CreateEncounterResponse::CreateEncounterResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CreateEncounterResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CreateEncounterResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateEncounterResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateEncounterResponseDefaultTypeInternal() {}
  union {
    CreateEncounterResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateEncounterResponseDefaultTypeInternal _CreateEncounterResponse_default_instance_;

inline constexpr AttackResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        error_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        result_{nullptr},
        combat_state_{nullptr},
        updated_room_{nullptr},
        granted_action_{nullptr},
        success_{false} {}

template <typename>
PROTOBUF_CONSTEXPR AttackResponse::AttackResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(AttackResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AttackResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttackResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttackResponseDefaultTypeInternal() {}
  union {
    AttackResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttackResponseDefaultTypeInternal _AttackResponse_default_instance_;

inline constexpr PartyMember::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        character_{nullptr},
        is_host_{false},
        is_ready_{false},
        is_connected_{false} {}

template <typename>
PROTOBUF_CONSTEXPR PartyMember::PartyMember(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PartyMember_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PartyMemberDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PartyMemberDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PartyMemberDefaultTypeInternal() {}
  union {
    PartyMember _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PartyMemberDefaultTypeInternal _PartyMember_default_instance_;

inline constexpr MonsterTurnResult::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        actions_{},
        movement_path_{},
        monster_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        monster_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR MonsterTurnResult::MonsterTurnResult(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MonsterTurnResult_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MonsterTurnResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonsterTurnResultDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonsterTurnResultDefaultTypeInternal() {}
  union {
    MonsterTurnResult _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonsterTurnResultDefaultTypeInternal _MonsterTurnResult_default_instance_;

inline constexpr FeatureActivatedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        character_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        feature_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        updated_character_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR FeatureActivatedEvent::FeatureActivatedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(FeatureActivatedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct FeatureActivatedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeatureActivatedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeatureActivatedEventDefaultTypeInternal() {}
  union {
    FeatureActivatedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeatureActivatedEventDefaultTypeInternal _FeatureActivatedEvent_default_instance_;

inline constexpr AttackResolvedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        attacker_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        target_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        result_{nullptr},
        updated_attacker_{nullptr},
        updated_target_{nullptr},
        updated_room_{nullptr},
        granted_action_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR AttackResolvedEvent::AttackResolvedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(AttackResolvedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AttackResolvedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttackResolvedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttackResolvedEventDefaultTypeInternal() {}
  union {
    AttackResolvedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttackResolvedEventDefaultTypeInternal _AttackResolvedEvent_default_instance_;

inline constexpr ActivateFeatureResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        updated_character_{nullptr},
        updated_combat_state_{nullptr},
        success_{false} {}

template <typename>
PROTOBUF_CONSTEXPR ActivateFeatureResponse::ActivateFeatureResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ActivateFeatureResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ActivateFeatureResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActivateFeatureResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActivateFeatureResponseDefaultTypeInternal() {}
  union {
    ActivateFeatureResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActivateFeatureResponseDefaultTypeInternal _ActivateFeatureResponse_default_instance_;

inline constexpr StartCombatResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        monster_turns_{},
        doors_{},
        dungeon_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        combat_state_{nullptr},
        room_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR StartCombatResponse::StartCombatResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(StartCombatResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct StartCombatResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StartCombatResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StartCombatResponseDefaultTypeInternal() {}
  union {
    StartCombatResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StartCombatResponseDefaultTypeInternal _StartCombatResponse_default_instance_;

inline constexpr PlayerReconnectedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        member_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PlayerReconnectedEvent::PlayerReconnectedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PlayerReconnectedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PlayerReconnectedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerReconnectedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerReconnectedEventDefaultTypeInternal() {}
  union {
    PlayerReconnectedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerReconnectedEventDefaultTypeInternal _PlayerReconnectedEvent_default_instance_;

inline constexpr PlayerJoinedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        member_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PlayerJoinedEvent::PlayerJoinedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PlayerJoinedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PlayerJoinedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerJoinedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerJoinedEventDefaultTypeInternal() {}
  union {
    PlayerJoinedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerJoinedEventDefaultTypeInternal _PlayerJoinedEvent_default_instance_;

inline constexpr OpenDoorResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        monster_turns_{},
        doors_{},
        error_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        room_{nullptr},
        combat_state_{nullptr},
        success_{false},
        dungeon_state_{static_cast< ::dnd5e::api::v1alpha1::DungeonState >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR OpenDoorResponse::OpenDoorResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(OpenDoorResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct OpenDoorResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OpenDoorResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OpenDoorResponseDefaultTypeInternal() {}
  union {
    OpenDoorResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OpenDoorResponseDefaultTypeInternal _OpenDoorResponse_default_instance_;

inline constexpr MonsterTurnCompletedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        updated_characters_{},
        monster_turn_{nullptr},
        updated_room_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR MonsterTurnCompletedEvent::MonsterTurnCompletedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MonsterTurnCompletedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MonsterTurnCompletedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonsterTurnCompletedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonsterTurnCompletedEventDefaultTypeInternal() {}
  union {
    MonsterTurnCompletedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonsterTurnCompletedEventDefaultTypeInternal _MonsterTurnCompletedEvent_default_instance_;

inline constexpr JoinEncounterResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        party_{},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        room_{nullptr},
        state_{static_cast< ::dnd5e::api::v1alpha1::EncounterState >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR JoinEncounterResponse::JoinEncounterResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(JoinEncounterResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct JoinEncounterResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JoinEncounterResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~JoinEncounterResponseDefaultTypeInternal() {}
  union {
    JoinEncounterResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinEncounterResponseDefaultTypeInternal _JoinEncounterResponse_default_instance_;

inline constexpr GetEncounterStateResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        party_{},
        monsters_{},
        doors_{},
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        join_code_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        host_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        last_event_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        dungeon_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        combat_state_{nullptr},
        room_{nullptr},
        state_{static_cast< ::dnd5e::api::v1alpha1::EncounterState >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR GetEncounterStateResponse::GetEncounterStateResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(GetEncounterStateResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct GetEncounterStateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetEncounterStateResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetEncounterStateResponseDefaultTypeInternal() {}
  union {
    GetEncounterStateResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetEncounterStateResponseDefaultTypeInternal _GetEncounterStateResponse_default_instance_;

inline constexpr EndTurnResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        monster_turns_{},
        combat_state_{nullptr},
        turn_change_{nullptr},
        encounter_result_{nullptr},
        success_{false} {}

template <typename>
PROTOBUF_CONSTEXPR EndTurnResponse::EndTurnResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(EndTurnResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EndTurnResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndTurnResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndTurnResponseDefaultTypeInternal() {}
  union {
    EndTurnResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndTurnResponseDefaultTypeInternal _EndTurnResponse_default_instance_;

inline constexpr DungeonStartResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        monster_turns_{},
        doors_{},
        dungeon_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        encounter_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        room_{nullptr},
        combat_state_{nullptr},
        dungeon_state_{static_cast< ::dnd5e::api::v1alpha1::DungeonState >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR DungeonStartResponse::DungeonStartResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DungeonStartResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DungeonStartResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DungeonStartResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DungeonStartResponseDefaultTypeInternal() {}
  union {
    DungeonStartResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DungeonStartResponseDefaultTypeInternal _DungeonStartResponse_default_instance_;

inline constexpr CombatStartedEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        party_{},
        monsters_{},
        doors_{},
        monster_turns_{},
        dungeon_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        combat_state_{nullptr},
        room_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR CombatStartedEvent::CombatStartedEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CombatStartedEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CombatStartedEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CombatStartedEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CombatStartedEventDefaultTypeInternal() {}
  union {
    CombatStartedEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CombatStartedEventDefaultTypeInternal _CombatStartedEvent_default_instance_;

inline constexpr EncounterEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        event_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_{::int64_t{0}},
        event_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR EncounterEvent::EncounterEvent(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(EncounterEvent_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EncounterEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EncounterEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EncounterEventDefaultTypeInternal() {}
  union {
    EncounterEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EncounterEventDefaultTypeInternal _EncounterEvent_default_instance_;

inline constexpr GetEncounterHistoryResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        events_{},
        last_event_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        has_more_{false} {}

template <typename>
PROTOBUF_CONSTEXPR GetEncounterHistoryResponse::GetEncounterHistoryResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(GetEncounterHistoryResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct GetEncounterHistoryResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetEncounterHistoryResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetEncounterHistoryResponseDefaultTypeInternal() {}
  union {
    GetEncounterHistoryResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetEncounterHistoryResponseDefaultTypeInternal _GetEncounterHistoryResponse_default_instance_;
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e
static const ::_pb::EnumDescriptor* PROTOBUF_NONNULL
    file_level_enum_descriptors_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto[3];
static constexpr const ::_pb::ServiceDescriptor* PROTOBUF_NONNULL* PROTOBUF_NULLABLE
    file_level_service_descriptors_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto = nullptr;
const ::uint32_t
    TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EntityPlacement, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EntityPlacement, _impl_._oneof_case_[0]),
        13, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EntityPlacement, _impl_.entity_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EntityPlacement, _impl_.entity_type_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EntityPlacement, _impl_.position_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EntityPlacement, _impl_.size_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EntityPlacement, _impl_.blocks_movement_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EntityPlacement, _impl_.blocks_line_of_sight_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EntityPlacement, _impl_.visual_type_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EntityPlacement, _impl_.visual_type_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EntityPlacement, _impl_.visual_type_),
        0,
        2,
        1,
        3,
        4,
        5,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room_EntitiesEntry_DoNotUse, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room_EntitiesEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room_EntitiesEntry_DoNotUse, _impl_.value_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room, _impl_._has_bits_),
        12, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room, _impl_.type_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room, _impl_.width_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room, _impl_.height_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room, _impl_.grid_type_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room, _impl_.hex_orientation_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room, _impl_.entities_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room, _impl_.walls_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::Room, _impl_.origin_),
        1,
        2,
        4,
        5,
        6,
        7,
        8,
        0,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DoorInfo, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DoorInfo, _impl_.connection_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DoorInfo, _impl_.position_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DoorInfo, _impl_.physical_hint_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DoorInfo, _impl_.is_open_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DoorInfo, _impl_.leads_to_room_id_),
        0,
        3,
        1,
        4,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartRequest, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartRequest, _impl_.character_ids_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartRequest, _impl_.theme_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartRequest, _impl_.difficulty_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartRequest, _impl_.length_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartResponse, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartResponse, _impl_.dungeon_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartResponse, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartResponse, _impl_.room_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartResponse, _impl_.combat_state_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartResponse, _impl_.monster_turns_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartResponse, _impl_.doors_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonStartResponse, _impl_.dungeon_state_),
        2,
        3,
        4,
        5,
        0,
        1,
        6,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::OpenDoorRequest, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::OpenDoorRequest, _impl_.dungeon_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::OpenDoorRequest, _impl_.connection_id_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::OpenDoorResponse, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::OpenDoorResponse, _impl_.success_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::OpenDoorResponse, _impl_.error_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::OpenDoorResponse, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::OpenDoorResponse, _impl_.room_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::OpenDoorResponse, _impl_.combat_state_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::OpenDoorResponse, _impl_.monster_turns_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::OpenDoorResponse, _impl_.doors_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::OpenDoorResponse, _impl_.dungeon_state_),
        6,
        2,
        3,
        4,
        5,
        0,
        1,
        7,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::InitiativeEntry, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::InitiativeEntry, _impl_.entity_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::InitiativeEntry, _impl_.entity_type_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::InitiativeEntry, _impl_.initiative_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::InitiativeEntry, _impl_.modifier_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::InitiativeEntry, _impl_.has_acted_),
        0,
        1,
        2,
        3,
        4,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnState, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnState, _impl_.entity_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnState, _impl_.movement_used_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnState, _impl_.movement_max_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnState, _impl_.action_used_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnState, _impl_.bonus_action_used_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnState, _impl_.reaction_available_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnState, _impl_.position_),
        0,
        2,
        3,
        4,
        5,
        6,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatState, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatState, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatState, _impl_.round_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatState, _impl_.turn_order_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatState, _impl_.active_index_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatState, _impl_.current_turn_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatState, _impl_.combat_started_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatState, _impl_.combat_ended_),
        1,
        3,
        0,
        4,
        2,
        5,
        6,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetCombatStateRequest, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetCombatStateRequest, _impl_.encounter_id_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetCombatStateResponse, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetCombatStateResponse, _impl_.room_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetCombatStateResponse, _impl_.combat_state_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateRequest, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateRequest, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateRequest, _impl_.player_id_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterCombatState, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterCombatState, _impl_.monster_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterCombatState, _impl_.monster_name_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterCombatState, _impl_.current_hit_points_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterCombatState, _impl_.max_hit_points_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterCombatState, _impl_.monster_type_),
        0,
        1,
        2,
        3,
        4,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateResponse, _impl_._has_bits_),
        14, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateResponse, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateResponse, _impl_.state_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateResponse, _impl_.party_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateResponse, _impl_.join_code_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateResponse, _impl_.host_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateResponse, _impl_.combat_state_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateResponse, _impl_.room_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateResponse, _impl_.monsters_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateResponse, _impl_.last_event_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateResponse, _impl_.doors_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterStateResponse, _impl_.dungeon_id_),
        3,
        10,
        0,
        4,
        5,
        8,
        9,
        1,
        6,
        2,
        7,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterHistoryRequest, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterHistoryRequest, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterHistoryRequest, _impl_.up_to_event_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterHistoryRequest, _impl_.limit_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterHistoryResponse, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterHistoryResponse, _impl_.events_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterHistoryResponse, _impl_.has_more_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GetEncounterHistoryResponse, _impl_.last_event_id_),
        0,
        2,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MoveCharacterRequest, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MoveCharacterRequest, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MoveCharacterRequest, _impl_.entity_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MoveCharacterRequest, _impl_.path_),
        1,
        2,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementError_DetailsEntry_DoNotUse, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementError_DetailsEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementError_DetailsEntry_DoNotUse, _impl_.value_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementError, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementError, _impl_.code_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementError, _impl_.message_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementError, _impl_.details_),
        1,
        0,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MoveCharacterResponse, _impl_._has_bits_),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MoveCharacterResponse, _impl_.success_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MoveCharacterResponse, _impl_.error_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MoveCharacterResponse, _impl_.final_position_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MoveCharacterResponse, _impl_.movement_remaining_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MoveCharacterResponse, _impl_.stop_reason_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MoveCharacterResponse, _impl_.updated_room_),
        4,
        1,
        2,
        5,
        0,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EndTurnRequest, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EndTurnRequest, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EndTurnRequest, _impl_.entity_id_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnChangeEvent, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnChangeEvent, _impl_.previous_entity_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnChangeEvent, _impl_.next_entity_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnChangeEvent, _impl_.round_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnChangeEvent, _impl_.new_round_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EndTurnResponse, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EndTurnResponse, _impl_.success_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EndTurnResponse, _impl_.combat_state_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EndTurnResponse, _impl_.turn_change_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EndTurnResponse, _impl_.monster_turns_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EndTurnResponse, _impl_.encounter_result_),
        4,
        1,
        2,
        0,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackRequest, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackRequest, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackRequest, _impl_.attacker_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackRequest, _impl_.target_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackRequest, _impl_.weapon_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackRequest, _impl_.attack_hand_),
        0,
        1,
        2,
        3,
        4,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::RerollEvent, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::RerollEvent, _impl_.die_index_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::RerollEvent, _impl_.before_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::RerollEvent, _impl_.after_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::RerollEvent, _impl_.reason_),
        1,
        2,
        3,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageComponent, _impl_._has_bits_),
        12, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageComponent, _impl_.source_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageComponent, _impl_.original_dice_rolls_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageComponent, _impl_.final_dice_rolls_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageComponent, _impl_.rerolls_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageComponent, _impl_.flat_bonus_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageComponent, _impl_.damage_type_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageComponent, _impl_.is_critical_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageComponent, _impl_.source_ref_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageComponent, _impl_.multiplier_),
        3,
        0,
        1,
        2,
        6,
        4,
        7,
        5,
        8,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageBreakdown, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageBreakdown, _impl_.components_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageBreakdown, _impl_.ability_used_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DamageBreakdown, _impl_.total_damage_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResult, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResult, _impl_.hit_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResult, _impl_.attack_roll_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResult, _impl_.attack_total_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResult, _impl_.target_ac_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResult, _impl_.damage_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResult, _impl_.damage_type_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResult, _impl_.critical_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResult, _impl_.damage_breakdown_),
        5,
        2,
        3,
        4,
        7,
        0,
        6,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GrantedAction, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GrantedAction, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GrantedAction, _impl_.type_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GrantedAction, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GrantedAction, _impl_.reason_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::GrantedAction, _impl_.weapon_id_),
        0,
        1,
        2,
        3,
        4,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResponse, _impl_._has_bits_),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResponse, _impl_.success_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResponse, _impl_.error_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResponse, _impl_.result_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResponse, _impl_.combat_state_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResponse, _impl_.updated_room_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResponse, _impl_.granted_action_),
        5,
        0,
        1,
        2,
        3,
        4,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterResult, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterResult, _impl_.reason_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::HealResult, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::HealResult, _impl_.amount_healed_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::HealResult, _impl_.new_hp_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::HealResult, _impl_.max_hp_),
        0,
        1,
        2,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterExecutedAction, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterExecutedAction, _impl_._oneof_case_[0]),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterExecutedAction, _impl_.action_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterExecutedAction, _impl_.action_type_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterExecutedAction, _impl_.target_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterExecutedAction, _impl_.success_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterExecutedAction, _impl_.details_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterExecutedAction, _impl_.details_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterExecutedAction, _impl_.details_),
        0,
        2,
        1,
        3,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterTurnResult, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterTurnResult, _impl_.monster_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterTurnResult, _impl_.monster_name_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterTurnResult, _impl_.actions_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterTurnResult, _impl_.movement_path_),
        2,
        3,
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ActivateFeatureRequest, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ActivateFeatureRequest, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ActivateFeatureRequest, _impl_.character_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ActivateFeatureRequest, _impl_.feature_id_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ActivateFeatureResponse, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ActivateFeatureResponse, _impl_.success_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ActivateFeatureResponse, _impl_.message_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ActivateFeatureResponse, _impl_.updated_character_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::ActivateFeatureResponse, _impl_.updated_combat_state_),
        3,
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PartyMember, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PartyMember, _impl_.player_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PartyMember, _impl_.character_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PartyMember, _impl_.is_host_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PartyMember, _impl_.is_ready_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PartyMember, _impl_.is_connected_),
        0,
        1,
        2,
        3,
        4,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CreateEncounterRequest, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CreateEncounterRequest, _impl_.character_ids_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CreateEncounterResponse, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CreateEncounterResponse, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CreateEncounterResponse, _impl_.join_code_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CreateEncounterResponse, _impl_.room_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::JoinEncounterRequest, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::JoinEncounterRequest, _impl_.join_code_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::JoinEncounterRequest, _impl_.character_ids_),
        1,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::JoinEncounterResponse, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::JoinEncounterResponse, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::JoinEncounterResponse, _impl_.room_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::JoinEncounterResponse, _impl_.party_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::JoinEncounterResponse, _impl_.state_),
        1,
        2,
        0,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SetReadyRequest, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SetReadyRequest, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SetReadyRequest, _impl_.player_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SetReadyRequest, _impl_.is_ready_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SetReadyResponse, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::SetReadyResponse, _impl_.success_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StartCombatRequest, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StartCombatRequest, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StartCombatRequest, _impl_.theme_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StartCombatRequest, _impl_.difficulty_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StartCombatRequest, _impl_.length_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StartCombatResponse, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StartCombatResponse, _impl_.combat_state_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StartCombatResponse, _impl_.room_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StartCombatResponse, _impl_.monster_turns_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StartCombatResponse, _impl_.doors_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StartCombatResponse, _impl_.dungeon_id_),
        3,
        4,
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::LeaveEncounterRequest, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::LeaveEncounterRequest, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::LeaveEncounterRequest, _impl_.player_id_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::LeaveEncounterResponse, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::LeaveEncounterResponse, _impl_.success_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StreamEncounterEventsRequest, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StreamEncounterEventsRequest, _impl_.encounter_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::StreamEncounterEventsRequest, _impl_.player_id_),
        0,
        1,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_._oneof_case_[0]),
        24, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.timestamp_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_.event_),
        0,
        1,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerJoinedEvent, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerJoinedEvent, _impl_.member_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerLeftEvent, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerLeftEvent, _impl_.player_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerLeftEvent, _impl_.character_id_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerReadyEvent, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerReadyEvent, _impl_.player_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerReadyEvent, _impl_.is_ready_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatStartedEvent, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatStartedEvent, _impl_.combat_state_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatStartedEvent, _impl_.room_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatStartedEvent, _impl_.party_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatStartedEvent, _impl_.monsters_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatStartedEvent, _impl_.doors_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatStartedEvent, _impl_.dungeon_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatStartedEvent, _impl_.monster_turns_),
        5,
        6,
        0,
        1,
        2,
        4,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementCompletedEvent, _impl_._has_bits_),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementCompletedEvent, _impl_.entity_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementCompletedEvent, _impl_.path_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementCompletedEvent, _impl_.final_position_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementCompletedEvent, _impl_.movement_remaining_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementCompletedEvent, _impl_.stop_reason_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MovementCompletedEvent, _impl_.updated_room_),
        1,
        0,
        3,
        5,
        2,
        4,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResolvedEvent, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResolvedEvent, _impl_.attacker_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResolvedEvent, _impl_.target_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResolvedEvent, _impl_.result_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResolvedEvent, _impl_.updated_attacker_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResolvedEvent, _impl_.updated_target_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResolvedEvent, _impl_.updated_room_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::AttackResolvedEvent, _impl_.granted_action_),
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::FeatureActivatedEvent, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::FeatureActivatedEvent, _impl_.character_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::FeatureActivatedEvent, _impl_.feature_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::FeatureActivatedEvent, _impl_.message_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::FeatureActivatedEvent, _impl_.updated_character_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnEndedEvent, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnEndedEvent, _impl_.turn_change_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnEndedEvent, _impl_.combat_state_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::TurnEndedEvent, _impl_.updated_room_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent, _impl_.monster_turn_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent, _impl_.updated_characters_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent, _impl_.updated_room_),
        1,
        0,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatEndedEvent, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatEndedEvent, _impl_.result_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerDisconnectedEvent, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerDisconnectedEvent, _impl_.player_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerDisconnectedEvent, _impl_.character_id_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerReconnectedEvent, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerReconnectedEvent, _impl_.player_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::PlayerReconnectedEvent, _impl_.member_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatPausedEvent, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatPausedEvent, _impl_.reason_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatPausedEvent, _impl_.disconnected_player_id_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatResumedEvent, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::CombatResumedEvent, _impl_.combat_state_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::RoomRevealedEvent, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::RoomRevealedEvent, _impl_.dungeon_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::RoomRevealedEvent, _impl_.connection_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::RoomRevealedEvent, _impl_.room_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::RoomRevealedEvent, _impl_.combat_state_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::RoomRevealedEvent, _impl_.doors_),
        1,
        2,
        3,
        4,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonVictoryEvent, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonVictoryEvent, _impl_.dungeon_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonVictoryEvent, _impl_.rooms_cleared_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonVictoryEvent, _impl_.dungeon_state_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonFailureEvent, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonFailureEvent, _impl_.dungeon_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonFailureEvent, _impl_.final_room_id_),
        PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::DungeonFailureEvent, _impl_.dungeon_state_),
        0,
        1,
        2,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, sizeof(::dnd5e::api::v1alpha1::EntityPlacement)},
        {21, sizeof(::dnd5e::api::v1alpha1::Room_EntitiesEntry_DoNotUse)},
        {28, sizeof(::dnd5e::api::v1alpha1::Room)},
        {49, sizeof(::dnd5e::api::v1alpha1::DoorInfo)},
        {62, sizeof(::dnd5e::api::v1alpha1::DungeonStartRequest)},
        {73, sizeof(::dnd5e::api::v1alpha1::DungeonStartResponse)},
        {90, sizeof(::dnd5e::api::v1alpha1::OpenDoorRequest)},
        {97, sizeof(::dnd5e::api::v1alpha1::OpenDoorResponse)},
        {116, sizeof(::dnd5e::api::v1alpha1::InitiativeEntry)},
        {129, sizeof(::dnd5e::api::v1alpha1::TurnState)},
        {146, sizeof(::dnd5e::api::v1alpha1::CombatState)},
        {163, sizeof(::dnd5e::api::v1alpha1::GetCombatStateRequest)},
        {168, sizeof(::dnd5e::api::v1alpha1::GetCombatStateResponse)},
        {175, sizeof(::dnd5e::api::v1alpha1::GetEncounterStateRequest)},
        {182, sizeof(::dnd5e::api::v1alpha1::MonsterCombatState)},
        {195, sizeof(::dnd5e::api::v1alpha1::GetEncounterStateResponse)},
        {220, sizeof(::dnd5e::api::v1alpha1::GetEncounterHistoryRequest)},
        {229, sizeof(::dnd5e::api::v1alpha1::GetEncounterHistoryResponse)},
        {238, sizeof(::dnd5e::api::v1alpha1::MoveCharacterRequest)},
        {247, sizeof(::dnd5e::api::v1alpha1::MovementError_DetailsEntry_DoNotUse)},
        {254, sizeof(::dnd5e::api::v1alpha1::MovementError)},
        {263, sizeof(::dnd5e::api::v1alpha1::MoveCharacterResponse)},
        {278, sizeof(::dnd5e::api::v1alpha1::EndTurnRequest)},
        {285, sizeof(::dnd5e::api::v1alpha1::TurnChangeEvent)},
        {296, sizeof(::dnd5e::api::v1alpha1::EndTurnResponse)},
        {309, sizeof(::dnd5e::api::v1alpha1::AttackRequest)},
        {322, sizeof(::dnd5e::api::v1alpha1::RerollEvent)},
        {333, sizeof(::dnd5e::api::v1alpha1::DamageComponent)},
        {354, sizeof(::dnd5e::api::v1alpha1::DamageBreakdown)},
        {363, sizeof(::dnd5e::api::v1alpha1::AttackResult)},
        {382, sizeof(::dnd5e::api::v1alpha1::GrantedAction)},
        {395, sizeof(::dnd5e::api::v1alpha1::AttackResponse)},
        {410, sizeof(::dnd5e::api::v1alpha1::EncounterResult)},
        {415, sizeof(::dnd5e::api::v1alpha1::HealResult)},
        {424, sizeof(::dnd5e::api::v1alpha1::MonsterExecutedAction)},
        {441, sizeof(::dnd5e::api::v1alpha1::MonsterTurnResult)},
        {452, sizeof(::dnd5e::api::v1alpha1::ActivateFeatureRequest)},
        {461, sizeof(::dnd5e::api::v1alpha1::ActivateFeatureResponse)},
        {472, sizeof(::dnd5e::api::v1alpha1::PartyMember)},
        {485, sizeof(::dnd5e::api::v1alpha1::CreateEncounterRequest)},
        {490, sizeof(::dnd5e::api::v1alpha1::CreateEncounterResponse)},
        {499, sizeof(::dnd5e::api::v1alpha1::JoinEncounterRequest)},
        {506, sizeof(::dnd5e::api::v1alpha1::JoinEncounterResponse)},
        {517, sizeof(::dnd5e::api::v1alpha1::SetReadyRequest)},
        {526, sizeof(::dnd5e::api::v1alpha1::SetReadyResponse)},
        {531, sizeof(::dnd5e::api::v1alpha1::StartCombatRequest)},
        {542, sizeof(::dnd5e::api::v1alpha1::StartCombatResponse)},
        {555, sizeof(::dnd5e::api::v1alpha1::LeaveEncounterRequest)},
        {562, sizeof(::dnd5e::api::v1alpha1::LeaveEncounterResponse)},
        {567, sizeof(::dnd5e::api::v1alpha1::StreamEncounterEventsRequest)},
        {574, sizeof(::dnd5e::api::v1alpha1::EncounterEvent)},
        {617, sizeof(::dnd5e::api::v1alpha1::PlayerJoinedEvent)},
        {622, sizeof(::dnd5e::api::v1alpha1::PlayerLeftEvent)},
        {629, sizeof(::dnd5e::api::v1alpha1::PlayerReadyEvent)},
        {636, sizeof(::dnd5e::api::v1alpha1::CombatStartedEvent)},
        {653, sizeof(::dnd5e::api::v1alpha1::MovementCompletedEvent)},
        {668, sizeof(::dnd5e::api::v1alpha1::AttackResolvedEvent)},
        {685, sizeof(::dnd5e::api::v1alpha1::FeatureActivatedEvent)},
        {696, sizeof(::dnd5e::api::v1alpha1::TurnEndedEvent)},
        {705, sizeof(::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent)},
        {714, sizeof(::dnd5e::api::v1alpha1::CombatEndedEvent)},
        {719, sizeof(::dnd5e::api::v1alpha1::PlayerDisconnectedEvent)},
        {726, sizeof(::dnd5e::api::v1alpha1::PlayerReconnectedEvent)},
        {733, sizeof(::dnd5e::api::v1alpha1::CombatPausedEvent)},
        {740, sizeof(::dnd5e::api::v1alpha1::CombatResumedEvent)},
        {745, sizeof(::dnd5e::api::v1alpha1::RoomRevealedEvent)},
        {758, sizeof(::dnd5e::api::v1alpha1::DungeonVictoryEvent)},
        {767, sizeof(::dnd5e::api::v1alpha1::DungeonFailureEvent)},
};
static const ::_pb::Message* PROTOBUF_NONNULL const file_default_instances[] = {
    &::dnd5e::api::v1alpha1::_EntityPlacement_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_Room_EntitiesEntry_DoNotUse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_Room_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_DoorInfo_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_DungeonStartRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_DungeonStartResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_OpenDoorRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_OpenDoorResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_InitiativeEntry_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_TurnState_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_CombatState_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_GetCombatStateRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_GetCombatStateResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_GetEncounterStateRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_MonsterCombatState_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_GetEncounterStateResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_GetEncounterHistoryRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_GetEncounterHistoryResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_MoveCharacterRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_MovementError_DetailsEntry_DoNotUse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_MovementError_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_MoveCharacterResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_EndTurnRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_TurnChangeEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_EndTurnResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_AttackRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_RerollEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_DamageComponent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_DamageBreakdown_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_AttackResult_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_GrantedAction_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_AttackResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_EncounterResult_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_HealResult_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_MonsterExecutedAction_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_MonsterTurnResult_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_ActivateFeatureRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_ActivateFeatureResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_PartyMember_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_CreateEncounterRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_CreateEncounterResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_JoinEncounterRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_JoinEncounterResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_SetReadyRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_SetReadyResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_StartCombatRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_StartCombatResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_LeaveEncounterRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_LeaveEncounterResponse_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_StreamEncounterEventsRequest_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_EncounterEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_PlayerJoinedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_PlayerLeftEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_PlayerReadyEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_CombatStartedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_MovementCompletedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_AttackResolvedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_FeatureActivatedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_TurnEndedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_MonsterTurnCompletedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_CombatEndedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_PlayerDisconnectedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_PlayerReconnectedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_CombatPausedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_CombatResumedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_RoomRevealedEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_DungeonVictoryEvent_default_instance_._instance,
    &::dnd5e::api::v1alpha1::_DungeonFailureEvent_default_instance_._instance,
};
const char descriptor_table_protodef_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\"dnd5e/api/v1alpha1/encounter.proto\022\022dn"
    "d5e.api.v1alpha1\032\036api/v1alpha1/room_comm"
    "on.proto\032\"dnd5e/api/v1alpha1/character.p"
    "roto\032\037dnd5e/api/v1alpha1/common.proto\032\036d"
    "nd5e/api/v1alpha1/enums.proto\"\317\003\n\017Entity"
    "Placement\022\033\n\tentity_id\030\001 \001(\tR\010entityId\022\?"
    "\n\013entity_type\030\002 \001(\0162\036.dnd5e.api.v1alpha1"
    ".EntityTypeR\nentityType\0222\n\010position\030\003 \001("
    "\0132\026.api.v1alpha1.PositionR\010position\0222\n\004s"
    "ize\030\004 \001(\0162\036.dnd5e.api.v1alpha1.EntitySiz"
    "eR\004size\022\'\n\017blocks_movement\030\005 \001(\010R\016blocks"
    "Movement\022/\n\024blocks_line_of_sight\030\006 \001(\010R\021"
    "blocksLineOfSight\022D\n\014monster_type\030\007 \001(\0162"
    "\037.dnd5e.api.v1alpha1.MonsterTypeH\000R\013mons"
    "terType\022G\n\robstacle_type\030\010 \001(\0162 .dnd5e.a"
    "pi.v1alpha1.ObstacleTypeH\000R\014obstacleType"
    "B\r\n\013visual_type\"\317\003\n\004Room\022\016\n\002id\030\001 \001(\tR\002id"
    "\022\022\n\004type\030\002 \001(\tR\004type\022\024\n\005width\030\003 \001(\005R\005wid"
    "th\022\026\n\006height\030\004 \001(\005R\006height\0223\n\tgrid_type\030"
    "\005 \001(\0162\026.api.v1alpha1.GridTypeR\010gridType\022"
    ",\n\017hex_orientation\030\006 \001(\010H\000R\016hexOrientati"
    "on\210\001\001\022B\n\010entities\030\007 \003(\0132&.dnd5e.api.v1al"
    "pha1.Room.EntitiesEntryR\010entities\022(\n\005wal"
    "ls\030\010 \003(\0132\022.api.v1alpha1.WallR\005walls\022.\n\006o"
    "rigin\030\t \001(\0132\026.api.v1alpha1.PositionR\006ori"
    "gin\032`\n\rEntitiesEntry\022\020\n\003key\030\001 \001(\tR\003key\0229"
    "\n\005value\030\002 \001(\0132#.dnd5e.api.v1alpha1.Entit"
    "yPlacementR\005value:\0028\001B\022\n\020_hex_orientatio"
    "n\"\312\001\n\010DoorInfo\022#\n\rconnection_id\030\001 \001(\tR\014c"
    "onnectionId\0222\n\010position\030\002 \001(\0132\026.api.v1al"
    "pha1.PositionR\010position\022#\n\rphysical_hint"
    "\030\003 \001(\tR\014physicalHint\022\027\n\007is_open\030\004 \001(\010R\006i"
    "sOpen\022\'\n\020leads_to_room_id\030\005 \001(\tR\rleadsTo"
    "RoomId\"\364\001\n\023DungeonStartRequest\022#\n\rcharac"
    "ter_ids\030\001 \003(\tR\014characterIds\0226\n\005theme\030\002 \001"
    "(\0162 .dnd5e.api.v1alpha1.DungeonThemeR\005th"
    "eme\022E\n\ndifficulty\030\003 \001(\0162%.dnd5e.api.v1al"
    "pha1.DungeonDifficultyR\ndifficulty\0229\n\006le"
    "ngth\030\004 \001(\0162!.dnd5e.api.v1alpha1.DungeonL"
    "engthR\006length\"\221\003\n\024DungeonStartResponse\022\035"
    "\n\ndungeon_id\030\001 \001(\tR\tdungeonId\022!\n\014encount"
    "er_id\030\002 \001(\tR\013encounterId\022,\n\004room\030\003 \001(\0132\030"
    ".dnd5e.api.v1alpha1.RoomR\004room\022B\n\014combat"
    "_state\030\004 \001(\0132\037.dnd5e.api.v1alpha1.Combat"
    "StateR\013combatState\022J\n\rmonster_turns\030\005 \003("
    "\0132%.dnd5e.api.v1alpha1.MonsterTurnResult"
    "R\014monsterTurns\0222\n\005doors\030\006 \003(\0132\034.dnd5e.ap"
    "i.v1alpha1.DoorInfoR\005doors\022E\n\rdungeon_st"
    "ate\030\007 \001(\0162 .dnd5e.api.v1alpha1.DungeonSt"
    "ateR\014dungeonState\"U\n\017OpenDoorRequest\022\035\n\n"
    "dungeon_id\030\001 \001(\tR\tdungeonId\022#\n\rconnectio"
    "n_id\030\002 \001(\tR\014connectionId\"\236\003\n\020OpenDoorRes"
    "ponse\022\030\n\007success\030\001 \001(\010R\007success\022\024\n\005error"
    "\030\002 \001(\tR\005error\022!\n\014encounter_id\030\003 \001(\tR\013enc"
    "ounterId\022,\n\004room\030\004 \001(\0132\030.dnd5e.api.v1alp"
    "ha1.RoomR\004room\022B\n\014combat_state\030\005 \001(\0132\037.d"
    "nd5e.api.v1alpha1.CombatStateR\013combatSta"
    "te\022J\n\rmonster_turns\030\006 \003(\0132%.dnd5e.api.v1"
    "alpha1.MonsterTurnResultR\014monsterTurns\0222"
    "\n\005doors\030\007 \003(\0132\034.dnd5e.api.v1alpha1.DoorI"
    "nfoR\005doors\022E\n\rdungeon_state\030\010 \001(\0162 .dnd5"
    "e.api.v1alpha1.DungeonStateR\014dungeonStat"
    "e\"\250\001\n\017InitiativeEntry\022\033\n\tentity_id\030\001 \001(\t"
    "R\010entityId\022\037\n\013entity_type\030\002 \001(\tR\nentityT"
    "ype\022\036\n\ninitiative\030\003 \001(\005R\ninitiative\022\032\n\010m"
    "odifier\030\004 \001(\005R\010modifier\022\033\n\thas_acted\030\005 \001"
    "(\010R\010hasActed\"\240\002\n\tTurnState\022\033\n\tentity_id\030"
    "\001 \001(\tR\010entityId\022#\n\rmovement_used\030\002 \001(\005R\014"
    "movementUsed\022!\n\014movement_max\030\003 \001(\005R\013move"
    "mentMax\022\037\n\013action_used\030\004 \001(\010R\nactionUsed"
    "\022*\n\021bonus_action_used\030\005 \001(\010R\017bonusAction"
    "Used\022-\n\022reaction_available\030\006 \001(\010R\021reacti"
    "onAvailable\0222\n\010position\030\007 \001(\0132\026.api.v1al"
    "pha1.PositionR\010position\"\271\002\n\013CombatState\022"
    "!\n\014encounter_id\030\001 \001(\tR\013encounterId\022\024\n\005ro"
    "und\030\002 \001(\005R\005round\022B\n\nturn_order\030\003 \003(\0132#.d"
    "nd5e.api.v1alpha1.InitiativeEntryR\tturnO"
    "rder\022!\n\014active_index\030\004 \001(\005R\013activeIndex\022"
    "@\n\014current_turn\030\005 \001(\0132\035.dnd5e.api.v1alph"
    "a1.TurnStateR\013currentTurn\022%\n\016combat_star"
    "ted\030\006 \001(\010R\rcombatStarted\022!\n\014combat_ended"
    "\030\007 \001(\010R\013combatEnded\":\n\025GetCombatStateReq"
    "uest\022!\n\014encounter_id\030\001 \001(\tR\013encounterId\""
    "\212\001\n\026GetCombatStateResponse\022,\n\004room\030\001 \001(\013"
    "2\030.dnd5e.api.v1alpha1.RoomR\004room\022B\n\014comb"
    "at_state\030\002 \001(\0132\037.dnd5e.api.v1alpha1.Comb"
    "atStateR\013combatState\"Z\n\030GetEncounterStat"
    "eRequest\022!\n\014encounter_id\030\001 \001(\tR\013encounte"
    "rId\022\033\n\tplayer_id\030\002 \001(\tR\010playerId\"\356\001\n\022Mon"
    "sterCombatState\022\035\n\nmonster_id\030\001 \001(\tR\tmon"
    "sterId\022!\n\014monster_name\030\002 \001(\tR\013monsterNam"
    "e\022,\n\022current_hit_points\030\003 \001(\005R\020currentHi"
    "tPoints\022$\n\016max_hit_points\030\004 \001(\005R\014maxHitP"
    "oints\022B\n\014monster_type\030\005 \001(\0162\037.dnd5e.api."
    "v1alpha1.MonsterTypeR\013monsterType\"\222\004\n\031Ge"
    "tEncounterStateResponse\022!\n\014encounter_id\030"
    "\001 \001(\tR\013encounterId\0228\n\005state\030\002 \001(\0162\".dnd5"
    "e.api.v1alpha1.EncounterStateR\005state\0225\n\005"
    "party\030\003 \003(\0132\037.dnd5e.api.v1alpha1.PartyMe"
    "mberR\005party\022\033\n\tjoin_code\030\004 \001(\tR\010joinCode"
    "\022\027\n\007host_id\030\005 \001(\tR\006hostId\022B\n\014combat_stat"
    "e\030\006 \001(\0132\037.dnd5e.api.v1alpha1.CombatState"
    "R\013combatState\022,\n\004room\030\007 \001(\0132\030.dnd5e.api."
    "v1alpha1.RoomR\004room\022B\n\010monsters\030\010 \003(\0132&."
    "dnd5e.api.v1alpha1.MonsterCombatStateR\010m"
    "onsters\022\"\n\rlast_event_id\030\t \001(\tR\013lastEven"
    "tId\0222\n\005doors\030\n \003(\0132\034.dnd5e.api.v1alpha1."
    "DoorInfoR\005doors\022\035\n\ndungeon_id\030\013 \001(\tR\tdun"
    "geonId\"z\n\032GetEncounterHistoryRequest\022!\n\014"
    "encounter_id\030\001 \001(\tR\013encounterId\022#\n\016up_to"
    "_event_id\030\002 \001(\tR\013upToEventId\022\024\n\005limit\030\003 "
    "\001(\005R\005limit\"\230\001\n\033GetEncounterHistoryRespon"
    "se\022:\n\006events\030\001 \003(\0132\".dnd5e.api.v1alpha1."
    "EncounterEventR\006events\022\031\n\010has_more\030\002 \001(\010"
    "R\007hasMore\022\"\n\rlast_event_id\030\003 \001(\tR\013lastEv"
    "entId\"\202\001\n\024MoveCharacterRequest\022!\n\014encoun"
    "ter_id\030\001 \001(\tR\013encounterId\022\033\n\tentity_id\030\002"
    " \001(\tR\010entityId\022*\n\004path\030\003 \003(\0132\026.api.v1alp"
    "ha1.PositionR\004path\"\334\003\n\rMovementError\022\?\n\004"
    "code\030\001 \001(\0162+.dnd5e.api.v1alpha1.Movement"
    "Error.ErrorCodeR\004code\022\030\n\007message\030\002 \001(\tR\007"
    "message\022H\n\007details\030\003 \003(\0132..dnd5e.api.v1a"
    "lpha1.MovementError.DetailsEntryR\007detail"
    "s\032:\n\014DetailsEntry\022\020\n\003key\030\001 \001(\tR\003key\022\024\n\005v"
    "alue\030\002 \001(\tR\005value:\0028\001\"\351\001\n\tErrorCode\022\032\n\026E"
    "RROR_CODE_UNSPECIFIED\020\000\022\037\n\033ERROR_CODE_IN"
    "VALID_POSITION\020\001\022$\n ERROR_CODE_INSUFFICI"
    "ENT_MOVEMENT\020\002\022\033\n\027ERROR_CODE_PATH_BLOCKE"
    "D\020\003\022 \n\034ERROR_CODE_POSITION_OCCUPIED\020\004\022\034\n"
    "\030ERROR_CODE_OUT_OF_BOUNDS\020\005\022\034\n\030ERROR_COD"
    "E_NOT_YOUR_TURN\020\006\"\266\002\n\025MoveCharacterRespo"
    "nse\022\030\n\007success\030\001 \001(\010R\007success\0227\n\005error\030\002"
    " \001(\0132!.dnd5e.api.v1alpha1.MovementErrorR"
    "\005error\022=\n\016final_position\030\003 \001(\0132\026.api.v1a"
    "lpha1.PositionR\rfinalPosition\022-\n\022movemen"
    "t_remaining\030\004 \001(\005R\021movementRemaining\022\037\n\013"
    "stop_reason\030\005 \001(\tR\nstopReason\022;\n\014updated"
    "_room\030\006 \001(\0132\030.dnd5e.api.v1alpha1.RoomR\013u"
    "pdatedRoom\"P\n\016EndTurnRequest\022!\n\014encounte"
    "r_id\030\001 \001(\tR\013encounterId\022\033\n\tentity_id\030\002 \001"
    "(\tR\010entityId\"\230\001\n\017TurnChangeEvent\022,\n\022prev"
    "ious_entity_id\030\001 \001(\tR\020previousEntityId\022$"
    "\n\016next_entity_id\030\002 \001(\tR\014nextEntityId\022\024\n\005"
    "round\030\003 \001(\005R\005round\022\033\n\tnew_round\030\004 \001(\010R\010n"
    "ewRound\"\353\002\n\017EndTurnResponse\022\030\n\007success\030\001"
    " \001(\010R\007success\022B\n\014combat_state\030\002 \001(\0132\037.dn"
    "d5e.api.v1alpha1.CombatStateR\013combatStat"
    "e\022D\n\013turn_change\030\003 \001(\0132#.dnd5e.api.v1alp"
    "ha1.TurnChangeEventR\nturnChange\022J\n\rmonst"
    "er_turns\030\004 \003(\0132%.dnd5e.api.v1alpha1.Mons"
    "terTurnResultR\014monsterTurns\022S\n\020encounter"
    "_result\030\005 \001(\0132#.dnd5e.api.v1alpha1.Encou"
    "nterResultH\000R\017encounterResult\210\001\001B\023\n\021_enc"
    "ounter_result\"\316\001\n\rAttackRequest\022!\n\014encou"
    "nter_id\030\001 \001(\tR\013encounterId\022\037\n\013attacker_i"
    "d\030\002 \001(\tR\nattackerId\022\033\n\ttarget_id\030\003 \001(\tR\010"
    "targetId\022\033\n\tweapon_id\030\004 \001(\tR\010weaponId\022\?\n"
    "\013attack_hand\030\005 \001(\0162\036.dnd5e.api.v1alpha1."
    "AttackHandR\nattackHand\"p\n\013RerollEvent\022\033\n"
    "\tdie_index\030\001 \001(\005R\010dieIndex\022\026\n\006before\030\002 \001"
    "(\005R\006before\022\024\n\005after\030\003 \001(\005R\005after\022\026\n\006reas"
    "on\030\004 \001(\tR\006reason\"\225\003\n\017DamageComponent\022\032\n\006"
    "source\030\001 \001(\tB\002\030\001R\006source\022.\n\023original_dic"
    "e_rolls\030\002 \003(\005R\021originalDiceRolls\022(\n\020fina"
    "l_dice_rolls\030\003 \003(\005R\016finalDiceRolls\0229\n\007re"
    "rolls\030\004 \003(\0132\037.dnd5e.api.v1alpha1.RerollE"
    "ventR\007rerolls\022\035\n\nflat_bonus\030\005 \001(\005R\tflatB"
    "onus\022\037\n\013damage_type\030\006 \001(\tR\ndamageType\022\037\n"
    "\013is_critical\030\007 \001(\010R\nisCritical\022<\n\nsource"
    "_ref\030\010 \001(\0132\035.dnd5e.api.v1alpha1.SourceRe"
    "fR\tsourceRef\022#\n\nmultiplier\030\t \001(\002H\000R\nmult"
    "iplier\210\001\001B\r\n\013_multiplier\"\234\001\n\017DamageBreak"
    "down\022C\n\ncomponents\030\001 \003(\0132#.dnd5e.api.v1a"
    "lpha1.DamageComponentR\ncomponents\022!\n\014abi"
    "lity_used\030\002 \001(\tR\013abilityUsed\022!\n\014total_da"
    "mage\030\003 \001(\005R\013totalDamage\"\246\002\n\014AttackResult"
    "\022\020\n\003hit\030\001 \001(\010R\003hit\022\037\n\013attack_roll\030\002 \001(\005R"
    "\nattackRoll\022!\n\014attack_total\030\003 \001(\005R\013attac"
    "kTotal\022\033\n\ttarget_ac\030\004 \001(\005R\010targetAc\022\026\n\006d"
    "amage\030\005 \001(\005R\006damage\022\037\n\013damage_type\030\006 \001(\t"
    "R\ndamageType\022\032\n\010critical\030\007 \001(\010R\010critical"
    "\022N\n\020damage_breakdown\030\010 \001(\0132#.dnd5e.api.v"
    "1alpha1.DamageBreakdownR\017damageBreakdown"
    "\"|\n\rGrantedAction\022\016\n\002id\030\001 \001(\tR\002id\022\022\n\004typ"
    "e\030\002 \001(\tR\004type\022\022\n\004name\030\003 \001(\tR\004name\022\026\n\006rea"
    "son\030\004 \001(\tR\006reason\022\033\n\tweapon_id\030\005 \001(\tR\010we"
    "aponId\"\305\002\n\016AttackResponse\022\030\n\007success\030\001 \001"
    "(\010R\007success\022\024\n\005error\030\002 \001(\tR\005error\0228\n\006res"
    "ult\030\003 \001(\0132 .dnd5e.api.v1alpha1.AttackRes"
    "ultR\006result\022B\n\014combat_state\030\004 \001(\0132\037.dnd5"
    "e.api.v1alpha1.CombatStateR\013combatState\022"
    ";\n\014updated_room\030\005 \001(\0132\030.dnd5e.api.v1alph"
    "a1.RoomR\013updatedRoom\022H\n\016granted_action\030\006"
    " \001(\0132!.dnd5e.api.v1alpha1.GrantedActionR"
    "\rgrantedAction\"Q\n\017EncounterResult\022>\n\006rea"
    "son\030\001 \001(\0162&.dnd5e.api.v1alpha1.Encounter"
    "EndReasonR\006reason\"_\n\nHealResult\022#\n\ramoun"
    "t_healed\030\001 \001(\005R\014amountHealed\022\025\n\006new_hp\030\002"
    " \001(\005R\005newHp\022\025\n\006max_hp\030\003 \001(\005R\005maxHp\"\312\002\n\025M"
    "onsterExecutedAction\022\033\n\taction_id\030\001 \001(\tR"
    "\010actionId\022F\n\013action_type\030\002 \001(\0162%.dnd5e.a"
    "pi.v1alpha1.MonsterActionTypeR\nactionTyp"
    "e\022\033\n\ttarget_id\030\003 \001(\tR\010targetId\022\030\n\007succes"
    "s\030\004 \001(\010R\007success\022G\n\rattack_result\030\005 \001(\0132"
    " .dnd5e.api.v1alpha1.AttackResultH\000R\014att"
    "ackResult\022A\n\013heal_result\030\006 \001(\0132\036.dnd5e.a"
    "pi.v1alpha1.HealResultH\000R\nhealResultB\t\n\007"
    "details\"\327\001\n\021MonsterTurnResult\022\035\n\nmonster"
    "_id\030\001 \001(\tR\tmonsterId\022!\n\014monster_name\030\002 \001"
    "(\tR\013monsterName\022C\n\007actions\030\003 \003(\0132).dnd5e"
    ".api.v1alpha1.MonsterExecutedActionR\007act"
    "ions\022;\n\rmovement_path\030\004 \003(\0132\026.api.v1alph"
    "a1.PositionR\014movementPath\"\234\001\n\026ActivateFe"
    "atureRequest\022!\n\014encounter_id\030\001 \001(\tR\013enco"
    "unterId\022!\n\014character_id\030\002 \001(\tR\013character"
    "Id\022<\n\nfeature_id\030\003 \001(\0162\035.dnd5e.api.v1alp"
    "ha1.FeatureIdR\tfeatureId\"\354\001\n\027ActivateFea"
    "tureResponse\022\030\n\007success\030\001 \001(\010R\007success\022\030"
    "\n\007message\030\002 \001(\tR\007message\022J\n\021updated_char"
    "acter\030\003 \001(\0132\035.dnd5e.api.v1alpha1.Charact"
    "erR\020updatedCharacter\022Q\n\024updated_combat_s"
    "tate\030\004 \001(\0132\037.dnd5e.api.v1alpha1.CombatSt"
    "ateR\022updatedCombatState\"\276\001\n\013PartyMember\022"
    "\033\n\tplayer_id\030\001 \001(\tR\010playerId\022;\n\tcharacte"
    "r\030\002 \001(\0132\035.dnd5e.api.v1alpha1.CharacterR\t"
    "character\022\027\n\007is_host\030\003 \001(\010R\006isHost\022\031\n\010is"
    "_ready\030\004 \001(\010R\007isReady\022!\n\014is_connected\030\005 "
    "\001(\010R\013isConnected\"=\n\026CreateEncounterReque"
    "st\022#\n\rcharacter_ids\030\001 \003(\tR\014characterIds\""
    "\207\001\n\027CreateEncounterResponse\022!\n\014encounter"
    "_id\030\001 \001(\tR\013encounterId\022\033\n\tjoin_code\030\002 \001("
    "\tR\010joinCode\022,\n\004room\030\003 \001(\0132\030.dnd5e.api.v1"
    "alpha1.RoomR\004room\"X\n\024JoinEncounterReques"
    "t\022\033\n\tjoin_code\030\001 \001(\tR\010joinCode\022#\n\rcharac"
    "ter_ids\030\002 \003(\tR\014characterIds\"\331\001\n\025JoinEnco"
    "unterResponse\022!\n\014encounter_id\030\001 \001(\tR\013enc"
    "ounterId\022,\n\004room\030\002 \001(\0132\030.dnd5e.api.v1alp"
    "ha1.RoomR\004room\0225\n\005party\030\003 \003(\0132\037.dnd5e.ap"
    "i.v1alpha1.PartyMemberR\005party\0228\n\005state\030\004"
    " \001(\0162\".dnd5e.api.v1alpha1.EncounterState"
    "R\005state\"l\n\017SetReadyRequest\022!\n\014encounter_"
    "id\030\001 \001(\tR\013encounterId\022\033\n\tplayer_id\030\002 \001(\t"
    "R\010playerId\022\031\n\010is_ready\030\003 \001(\010R\007isReady\",\n"
    "\020SetReadyResponse\022\030\n\007success\030\001 \001(\010R\007succ"
    "ess\"\361\001\n\022StartCombatRequest\022!\n\014encounter_"
    "id\030\001 \001(\tR\013encounterId\0226\n\005theme\030\002 \001(\0162 .d"
    "nd5e.api.v1alpha1.DungeonThemeR\005theme\022E\n"
    "\ndifficulty\030\003 \001(\0162%.dnd5e.api.v1alpha1.D"
    "ungeonDifficultyR\ndifficulty\0229\n\006length\030\004"
    " \001(\0162!.dnd5e.api.v1alpha1.DungeonLengthR"
    "\006length\"\246\002\n\023StartCombatResponse\022B\n\014comba"
    "t_state\030\001 \001(\0132\037.dnd5e.api.v1alpha1.Comba"
    "tStateR\013combatState\022,\n\004room\030\002 \001(\0132\030.dnd5"
    "e.api.v1alpha1.RoomR\004room\022J\n\rmonster_tur"
    "ns\030\003 \003(\0132%.dnd5e.api.v1alpha1.MonsterTur"
    "nResultR\014monsterTurns\0222\n\005doors\030\004 \003(\0132\034.d"
    "nd5e.api.v1alpha1.DoorInfoR\005doors\022\035\n\ndun"
    "geon_id\030\005 \001(\tR\tdungeonId\"W\n\025LeaveEncount"
    "erRequest\022!\n\014encounter_id\030\001 \001(\tR\013encount"
    "erId\022\033\n\tplayer_id\030\002 \001(\tR\010playerId\"2\n\026Lea"
    "veEncounterResponse\022\030\n\007success\030\001 \001(\010R\007su"
    "ccess\"^\n\034StreamEncounterEventsRequest\022!\n"
    "\014encounter_id\030\001 \001(\tR\013encounterId\022\033\n\tplay"
    "er_id\030\002 \001(\tR\010playerId\"\330\013\n\016EncounterEvent"
    "\022\031\n\010event_id\030\001 \001(\tR\007eventId\022\034\n\ttimestamp"
    "\030\002 \001(\003R\ttimestamp\022L\n\rplayer_joined\030\n \001(\013"
    "2%.dnd5e.api.v1alpha1.PlayerJoinedEventH"
    "\000R\014playerJoined\022F\n\013player_left\030\013 \001(\0132#.d"
    "nd5e.api.v1alpha1.PlayerLeftEventH\000R\npla"
    "yerLeft\022I\n\014player_ready\030\014 \001(\0132$.dnd5e.ap"
    "i.v1alpha1.PlayerReadyEventH\000R\013playerRea"
    "dy\022O\n\016combat_started\030\r \001(\0132&.dnd5e.api.v"
    "1alpha1.CombatStartedEventH\000R\rcombatStar"
    "ted\022[\n\022movement_completed\030\024 \001(\0132*.dnd5e."
    "api.v1alpha1.MovementCompletedEventH\000R\021m"
    "ovementCompleted\022R\n\017attack_resolved\030\025 \001("
    "\0132\'.dnd5e.api.v1alpha1.AttackResolvedEve"
    "ntH\000R\016attackResolved\022X\n\021feature_activate"
    "d\030\026 \001(\0132).dnd5e.api.v1alpha1.FeatureActi"
    "vatedEventH\000R\020featureActivated\022C\n\nturn_e"
    "nded\030\027 \001(\0132\".dnd5e.api.v1alpha1.TurnEnde"
    "dEventH\000R\tturnEnded\022e\n\026monster_turn_comp"
    "leted\030\030 \001(\0132-.dnd5e.api.v1alpha1.Monster"
    "TurnCompletedEventH\000R\024monsterTurnComplet"
    "ed\022I\n\014combat_ended\030\031 \001(\0132$.dnd5e.api.v1a"
    "lpha1.CombatEndedEventH\000R\013combatEnded\022^\n"
    "\023player_disconnected\030\036 \001(\0132+.dnd5e.api.v"
    "1alpha1.PlayerDisconnectedEventH\000R\022playe"
    "rDisconnected\022[\n\022player_reconnected\030\037 \001("
    "\0132*.dnd5e.api.v1alpha1.PlayerReconnected"
    "EventH\000R\021playerReconnected\022L\n\rcombat_pau"
    "sed\030  \001(\0132%.dnd5e.api.v1alpha1.CombatPau"
    "sedEventH\000R\014combatPaused\022O\n\016combat_resum"
    "ed\030! \001(\0132&.dnd5e.api.v1alpha1.CombatResu"
    "medEventH\000R\rcombatResumed\022L\n\rroom_reveal"
    "ed\030( \001(\0132%.dnd5e.api.v1alpha1.RoomReveal"
    "edEventH\000R\014roomRevealed\022R\n\017dungeon_victo"
    "ry\030) \001(\0132\'.dnd5e.api.v1alpha1.DungeonVic"
    "toryEventH\000R\016dungeonVictory\022R\n\017dungeon_f"
    "ailure\030* \001(\0132\'.dnd5e.api.v1alpha1.Dungeo"
    "nFailureEventH\000R\016dungeonFailureB\007\n\005event"
    "\"L\n\021PlayerJoinedEvent\0227\n\006member\030\001 \001(\0132\037."
    "dnd5e.api.v1alpha1.PartyMemberR\006member\"Q"
    "\n\017PlayerLeftEvent\022\033\n\tplayer_id\030\001 \001(\tR\010pl"
    "ayerId\022!\n\014character_id\030\002 \001(\tR\013characterI"
    "d\"J\n\020PlayerReadyEvent\022\033\n\tplayer_id\030\001 \001(\t"
    "R\010playerId\022\031\n\010is_ready\030\002 \001(\010R\007isReady\"\240\003"
    "\n\022CombatStartedEvent\022B\n\014combat_state\030\001 \001"
    "(\0132\037.dnd5e.api.v1alpha1.CombatStateR\013com"
    "batState\022,\n\004room\030\002 \001(\0132\030.dnd5e.api.v1alp"
    "ha1.RoomR\004room\0225\n\005party\030\003 \003(\0132\037.dnd5e.ap"
    "i.v1alpha1.PartyMemberR\005party\022B\n\010monster"
    "s\030\004 \003(\0132&.dnd5e.api.v1alpha1.MonsterComb"
    "atStateR\010monsters\0222\n\005doors\030\005 \003(\0132\034.dnd5e"
    ".api.v1alpha1.DoorInfoR\005doors\022\035\n\ndungeon"
    "_id\030\006 \001(\tR\tdungeonId\022J\n\rmonster_turns\030\007 "
    "\003(\0132%.dnd5e.api.v1alpha1.MonsterTurnResu"
    "ltR\014monsterTurns\"\255\002\n\026MovementCompletedEv"
    "ent\022\033\n\tentity_id\030\001 \001(\tR\010entityId\022*\n\004path"
    "\030\002 \003(\0132\026.api.v1alpha1.PositionR\004path\022=\n\016"
    "final_position\030\003 \001(\0132\026.api.v1alpha1.Posi"
    "tionR\rfinalPosition\022-\n\022movement_remainin"
    "g\030\004 \001(\005R\021movementRemaining\022\037\n\013stop_reaso"
    "n\030\005 \001(\tR\nstopReason\022;\n\014updated_room\030\006 \001("
    "\0132\030.dnd5e.api.v1alpha1.RoomR\013updatedRoom"
    "\"\244\003\n\023AttackResolvedEvent\022\037\n\013attacker_id\030"
    "\001 \001(\tR\nattackerId\022\033\n\ttarget_id\030\002 \001(\tR\010ta"
    "rgetId\0228\n\006result\030\003 \001(\0132 .dnd5e.api.v1alp"
    "ha1.AttackResultR\006result\022H\n\020updated_atta"
    "cker\030\004 \001(\0132\035.dnd5e.api.v1alpha1.Characte"
    "rR\017updatedAttacker\022D\n\016updated_target\030\005 \001"
    "(\0132\035.dnd5e.api.v1alpha1.CharacterR\rupdat"
    "edTarget\022;\n\014updated_room\030\006 \001(\0132\030.dnd5e.a"
    "pi.v1alpha1.RoomR\013updatedRoom\022H\n\016granted"
    "_action\030\007 \001(\0132!.dnd5e.api.v1alpha1.Grant"
    "edActionR\rgrantedAction\"\277\001\n\025FeatureActiv"
    "atedEvent\022!\n\014character_id\030\001 \001(\tR\013charact"
    "erId\022\035\n\nfeature_id\030\002 \001(\tR\tfeatureId\022\030\n\007m"
    "essage\030\003 \001(\tR\007message\022J\n\021updated_charact"
    "er\030\004 \001(\0132\035.dnd5e.api.v1alpha1.CharacterR"
    "\020updatedCharacter\"\327\001\n\016TurnEndedEvent\022D\n\013"
    "turn_change\030\001 \001(\0132#.dnd5e.api.v1alpha1.T"
    "urnChangeEventR\nturnChange\022B\n\014combat_sta"
    "te\030\002 \001(\0132\037.dnd5e.api.v1alpha1.CombatStat"
    "eR\013combatState\022;\n\014updated_room\030\003 \001(\0132\030.d"
    "nd5e.api.v1alpha1.RoomR\013updatedRoom\"\360\001\n\031"
    "MonsterTurnCompletedEvent\022H\n\014monster_tur"
    "n\030\001 \001(\0132%.dnd5e.api.v1alpha1.MonsterTurn"
    "ResultR\013monsterTurn\022L\n\022updated_character"
    "s\030\002 \003(\0132\035.dnd5e.api.v1alpha1.CharacterR\021"
    "updatedCharacters\022;\n\014updated_room\030\003 \001(\0132"
    "\030.dnd5e.api.v1alpha1.RoomR\013updatedRoom\"O"
    "\n\020CombatEndedEvent\022;\n\006result\030\001 \001(\0132#.dnd"
    "5e.api.v1alpha1.EncounterResultR\006result\""
    "Y\n\027PlayerDisconnectedEvent\022\033\n\tplayer_id\030"
    "\001 \001(\tR\010playerId\022!\n\014character_id\030\002 \001(\tR\013c"
    "haracterId\"n\n\026PlayerReconnectedEvent\022\033\n\t"
    "player_id\030\001 \001(\tR\010playerId\0227\n\006member\030\002 \001("
    "\0132\037.dnd5e.api.v1alpha1.PartyMemberR\006memb"
    "er\"a\n\021CombatPausedEvent\022\026\n\006reason\030\001 \001(\tR"
    "\006reason\0224\n\026disconnected_player_id\030\002 \001(\tR"
    "\024disconnectedPlayerId\"X\n\022CombatResumedEv"
    "ent\022B\n\014combat_state\030\001 \001(\0132\037.dnd5e.api.v1"
    "alpha1.CombatStateR\013combatState\"\375\001\n\021Room"
    "RevealedEvent\022\035\n\ndungeon_id\030\001 \001(\tR\tdunge"
    "onId\022#\n\rconnection_id\030\002 \001(\tR\014connectionI"
    "d\022,\n\004room\030\003 \001(\0132\030.dnd5e.api.v1alpha1.Roo"
    "mR\004room\022B\n\014combat_state\030\004 \001(\0132\037.dnd5e.ap"
    "i.v1alpha1.CombatStateR\013combatState\0222\n\005d"
    "oors\030\005 \003(\0132\034.dnd5e.api.v1alpha1.DoorInfo"
    "R\005doors\"\240\001\n\023DungeonVictoryEvent\022\035\n\ndunge"
    "on_id\030\001 \001(\tR\tdungeonId\022#\n\rrooms_cleared\030"
    "\002 \001(\005R\014roomsCleared\022E\n\rdungeon_state\030\003 \001"
    "(\0162 .dnd5e.api.v1alpha1.DungeonStateR\014du"
    "ngeonState\"\237\001\n\023DungeonFailureEvent\022\035\n\ndu"
    "ngeon_id\030\001 \001(\tR\tdungeonId\022\"\n\rfinal_room_"
    "id\030\002 \001(\tR\013finalRoomId\022E\n\rdungeon_state\030\003"
    " \001(\0162 .dnd5e.api.v1alpha1.DungeonStateR\014"
    "dungeonState*}\n\022EncounterEndReason\022$\n EN"
    "COUNTER_END_REASON_UNSPECIFIED\020\000\022 \n\034ENCO"
    "UNTER_END_REASON_VICTORY\020\001\022\037\n\033ENCOUNTER_"
    "END_REASON_DEFEAT\020\002*\245\001\n\016EncounterState\022\037"
    "\n\033ENCOUNTER_STATE_UNSPECIFIED\020\000\022\033\n\027ENCOU"
    "NTER_STATE_WAITING\020\001\022\032\n\026ENCOUNTER_STATE_"
    "ACTIVE\020\002\022\032\n\026ENCOUNTER_STATE_PAUSED\020\003\022\035\n\031"
    "ENCOUNTER_STATE_COMPLETED\020\0042\376\013\n\020Encounte"
    "rService\022j\n\017CreateEncounter\022*.dnd5e.api."
    "v1alpha1.CreateEncounterRequest\032+.dnd5e."
    "api.v1alpha1.CreateEncounterResponse\022d\n\r"
    "JoinEncounter\022(.dnd5e.api.v1alpha1.JoinE"
    "ncounterRequest\032).dnd5e.api.v1alpha1.Joi"
    "nEncounterResponse\022U\n\010SetReady\022#.dnd5e.a"
    "pi.v1alpha1.SetReadyRequest\032$.dnd5e.api."
    "v1alpha1.SetReadyResponse\022^\n\013StartCombat"
    "\022&.dnd5e.api.v1alpha1.StartCombatRequest"
    "\032\'.dnd5e.api.v1alpha1.StartCombatRespons"
    "e\022g\n\016LeaveEncounter\022).dnd5e.api.v1alpha1"
    ".LeaveEncounterRequest\032*.dnd5e.api.v1alp"
    "ha1.LeaveEncounterResponse\022o\n\025StreamEnco"
    "unterEvents\0220.dnd5e.api.v1alpha1.StreamE"
    "ncounterEventsRequest\032\".dnd5e.api.v1alph"
    "a1.EncounterEvent0\001\022f\n\014DungeonStart\022\'.dn"
    "d5e.api.v1alpha1.DungeonStartRequest\032(.d"
    "nd5e.api.v1alpha1.DungeonStartResponse\"\003"
    "\210\002\001\022U\n\010OpenDoor\022#.dnd5e.api.v1alpha1.Ope"
    "nDoorRequest\032$.dnd5e.api.v1alpha1.OpenDo"
    "orResponse\022g\n\016GetCombatState\022).dnd5e.api"
    ".v1alpha1.GetCombatStateRequest\032*.dnd5e."
    "api.v1alpha1.GetCombatStateResponse\022p\n\021G"
    "etEncounterState\022,.dnd5e.api.v1alpha1.Ge"
    "tEncounterStateRequest\032-.dnd5e.api.v1alp"
    "ha1.GetEncounterStateResponse\022v\n\023GetEnco"
    "unterHistory\022..dnd5e.api.v1alpha1.GetEnc"
    "ounterHistoryRequest\032/.dnd5e.api.v1alpha"
    "1.GetEncounterHistoryResponse\022d\n\rMoveCha"
    "racter\022(.dnd5e.api.v1alpha1.MoveCharacte"
    "rRequest\032).dnd5e.api.v1alpha1.MoveCharac"
    "terResponse\022R\n\007EndTurn\022\".dnd5e.api.v1alp"
    "ha1.EndTurnRequest\032#.dnd5e.api.v1alpha1."
    "EndTurnResponse\022O\n\006Attack\022!.dnd5e.api.v1"
    "alpha1.AttackRequest\032\".dnd5e.api.v1alpha"
    "1.AttackResponse\022j\n\017ActivateFeature\022*.dn"
    "d5e.api.v1alpha1.ActivateFeatureRequest\032"
    "+.dnd5e.api.v1alpha1.ActivateFeatureResp"
    "onseB\337\001\n\026com.dnd5e.api.v1alpha1B\016Encount"
    "erProtoP\001ZKgithub.com/KirkDiggler/rpg-ap"
    "i-protos/gen/go/dnd5e/api/v1alpha1;apiv1"
    "alpha1\242\002\003DAX\252\002\022Dnd5e.Api.V1alpha1\312\002\022Dnd5"
    "e\\Api\\V1alpha1\342\002\036Dnd5e\\Api\\V1alpha1\\GPBM"
    "etadata\352\002\024Dnd5e::Api::V1alpha1b\006proto3"
};
static const ::_pbi::DescriptorTable* PROTOBUF_NONNULL const
    descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_deps[4] = {
        &::descriptor_table_api_2fv1alpha1_2froom_5fcommon_2eproto,
        &::descriptor_table_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto,
        &::descriptor_table_dnd5e_2fapi_2fv1alpha1_2fcommon_2eproto,
        &::descriptor_table_dnd5e_2fapi_2fv1alpha1_2fenums_2eproto,
};
static ::absl::once_flag descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto = {
    false,
    false,
    17198,
    descriptor_table_protodef_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
    "dnd5e/api/v1alpha1/encounter.proto",
    &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_once,
    descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_deps,
    4,
    68,
    schemas,
    file_default_instances,
    TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto::offsets,
    file_level_enum_descriptors_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
    file_level_service_descriptors_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
};
namespace dnd5e {
namespace api {
namespace v1alpha1 {
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MovementError_ErrorCode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto);
  return file_level_enum_descriptors_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t MovementError_ErrorCode_internal_data_[] = {
    458752u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EncounterEndReason_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto);
  return file_level_enum_descriptors_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t EncounterEndReason_internal_data_[] = {
    196608u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EncounterState_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto);
  return file_level_enum_descriptors_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t EncounterState_internal_data_[] = {
    327680u, 0u, };
// ===================================================================

class EntityPlacement::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<EntityPlacement>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EntityPlacement, _impl_._oneof_case_);
};

void EntityPlacement::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
EntityPlacement::EntityPlacement(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EntityPlacement_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.EntityPlacement)
}
PROTOBUF_NDEBUG_INLINE EntityPlacement::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::EntityPlacement& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        entity_id_(arena, from.entity_id_),
        visual_type_{},
        _oneof_case_{from._oneof_case_[0]} {}

EntityPlacement::EntityPlacement(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const EntityPlacement& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EntityPlacement_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  EntityPlacement* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.position_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.position_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, entity_type_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, entity_type_),
           offsetof(Impl_, blocks_line_of_sight_) -
               offsetof(Impl_, entity_type_) +
               sizeof(Impl_::blocks_line_of_sight_));
  switch (visual_type_case()) {
    case VISUAL_TYPE_NOT_SET:
      break;
      case kMonsterType:
        _impl_.visual_type_.monster_type_ = from._impl_.visual_type_.monster_type_;
        break;
      case kObstacleType:
        _impl_.visual_type_.obstacle_type_ = from._impl_.visual_type_.obstacle_type_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.EntityPlacement)
}
PROTOBUF_NDEBUG_INLINE EntityPlacement::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        entity_id_(arena),
        visual_type_{},
        _oneof_case_{} {}

inline void EntityPlacement::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, position_),
           0,
           offsetof(Impl_, blocks_line_of_sight_) -
               offsetof(Impl_, position_) +
               sizeof(Impl_::blocks_line_of_sight_));
}
EntityPlacement::~EntityPlacement() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.EntityPlacement)
  SharedDtor(*this);
}
inline void EntityPlacement::SharedDtor(MessageLite& self) {
  EntityPlacement& this_ = static_cast<EntityPlacement&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.entity_id_.Destroy();
  delete this_._impl_.position_;
  if (this_.has_visual_type()) {
    this_.clear_visual_type();
  }
  this_._impl_.~Impl_();
}

void EntityPlacement::clear_visual_type() {
// @@protoc_insertion_point(one_of_clear_start:dnd5e.api.v1alpha1.EntityPlacement)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (visual_type_case()) {
    case kMonsterType: {
      // No need to clear
      break;
    }
    case kObstacleType: {
      // No need to clear
      break;
    }
    case VISUAL_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VISUAL_TYPE_NOT_SET;
}


inline void* PROTOBUF_NONNULL EntityPlacement::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) EntityPlacement(arena);
}
constexpr auto EntityPlacement::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(EntityPlacement),
                                            alignof(EntityPlacement));
}
constexpr auto EntityPlacement::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_EntityPlacement_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &EntityPlacement::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<EntityPlacement>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &EntityPlacement::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<EntityPlacement>(), &EntityPlacement::ByteSizeLong,
              &EntityPlacement::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_._cached_size_),
          false,
      },
      &EntityPlacement::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull EntityPlacement_class_data_ =
        EntityPlacement::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
EntityPlacement::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&EntityPlacement_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(EntityPlacement_class_data_.tc_table);
  return EntityPlacement_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 1, 60, 2>
EntityPlacement::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    EntityPlacement_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EntityPlacement>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string entity_id = 1 [json_name = "entityId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.entity_id_)}},
    // .dnd5e.api.v1alpha1.EntityType entity_type = 2 [json_name = "entityType"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(EntityPlacement, _impl_.entity_type_), 2>(),
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.entity_type_)}},
    // .api.v1alpha1.Position position = 3 [json_name = "position"];
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.position_)}},
    // .dnd5e.api.v1alpha1.EntitySize size = 4 [json_name = "size"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(EntityPlacement, _impl_.size_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.size_)}},
    // bool blocks_movement = 5 [json_name = "blocksMovement"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(EntityPlacement, _impl_.blocks_movement_), 4>(),
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.blocks_movement_)}},
    // bool blocks_line_of_sight = 6 [json_name = "blocksLineOfSight"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(EntityPlacement, _impl_.blocks_line_of_sight_), 5>(),
     {48, 5, 0,
      PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.blocks_line_of_sight_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string entity_id = 1 [json_name = "entityId"];
    {PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.entity_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.EntityType entity_type = 2 [json_name = "entityType"];
    {PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.entity_type_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // .api.v1alpha1.Position position = 3 [json_name = "position"];
    {PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.position_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.EntitySize size = 4 [json_name = "size"];
    {PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.size_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // bool blocks_movement = 5 [json_name = "blocksMovement"];
    {PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.blocks_movement_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool blocks_line_of_sight = 6 [json_name = "blocksLineOfSight"];
    {PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.blocks_line_of_sight_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // .dnd5e.api.v1alpha1.MonsterType monster_type = 7 [json_name = "monsterType"];
    {PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.visual_type_.monster_type_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.ObstacleType obstacle_type = 8 [json_name = "obstacleType"];
    {PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.visual_type_.obstacle_type_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::api::v1alpha1::Position>()},
  }},
  {{
    "\42\11\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.EntityPlacement"
    "entity_id"
  }},
};
PROTOBUF_NOINLINE void EntityPlacement::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.EntityPlacement)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.entity_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000003cU)) {
    ::memset(&_impl_.entity_type_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.blocks_line_of_sight_) -
        reinterpret_cast<char*>(&_impl_.entity_type_)) + sizeof(_impl_.blocks_line_of_sight_));
  }
  clear_visual_type();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL EntityPlacement::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const EntityPlacement& this_ = static_cast<const EntityPlacement&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL EntityPlacement::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const EntityPlacement& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.EntityPlacement)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string entity_id = 1 [json_name = "entityId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_entity_id().empty()) {
      const ::std::string& _s = this_._internal_entity_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.EntityPlacement.entity_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.EntityType entity_type = 2 [json_name = "entityType"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_entity_type() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          2, this_._internal_entity_type(), target);
    }
  }

  // .api.v1alpha1.Position position = 3 [json_name = "position"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.position_, this_._impl_.position_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.EntitySize size = 4 [json_name = "size"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_size() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          4, this_._internal_size(), target);
    }
  }

  // bool blocks_movement = 5 [json_name = "blocksMovement"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_blocks_movement() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          5, this_._internal_blocks_movement(), target);
    }
  }

  // bool blocks_line_of_sight = 6 [json_name = "blocksLineOfSight"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (this_._internal_blocks_line_of_sight() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          6, this_._internal_blocks_line_of_sight(), target);
    }
  }

  switch (this_.visual_type_case()) {
    case kMonsterType: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          7, this_._internal_monster_type(), target);
      break;
    }
    case kObstacleType: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          8, this_._internal_obstacle_type(), target);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.EntityPlacement)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t EntityPlacement::ByteSizeLong(const MessageLite& base) {
  const EntityPlacement& this_ = static_cast<const EntityPlacement&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t EntityPlacement::ByteSizeLong() const {
  const EntityPlacement& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.EntityPlacement)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    // string entity_id = 1 [json_name = "entityId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_entity_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_entity_id());
      }
    }
    // .api.v1alpha1.Position position = 3 [json_name = "position"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.position_);
    }
    // .dnd5e.api.v1alpha1.EntityType entity_type = 2 [json_name = "entityType"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_entity_type() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_entity_type());
      }
    }
    // .dnd5e.api.v1alpha1.EntitySize size = 4 [json_name = "size"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_size() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_size());
      }
    }
    // bool blocks_movement = 5 [json_name = "blocksMovement"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_blocks_movement() != 0) {
        total_size += 2;
      }
    }
    // bool blocks_line_of_sight = 6 [json_name = "blocksLineOfSight"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (this_._internal_blocks_line_of_sight() != 0) {
        total_size += 2;
      }
    }
  }
  switch (this_.visual_type_case()) {
    // .dnd5e.api.v1alpha1.MonsterType monster_type = 7 [json_name = "monsterType"];
    case kMonsterType: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_monster_type());
      break;
    }
    // .dnd5e.api.v1alpha1.ObstacleType obstacle_type = 8 [json_name = "obstacleType"];
    case kObstacleType: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_obstacle_type());
      break;
    }
    case VISUAL_TYPE_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void EntityPlacement::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<EntityPlacement*>(&to_msg);
  auto& from = static_cast<const EntityPlacement&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.EntityPlacement)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_entity_id().empty()) {
        _this->_internal_set_entity_id(from._internal_entity_id());
      } else {
        if (_this->_impl_.entity_id_.IsDefault()) {
          _this->_internal_set_entity_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.position_ != nullptr);
      if (_this->_impl_.position_ == nullptr) {
        _this->_impl_.position_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.position_);
      } else {
        _this->_impl_.position_->MergeFrom(*from._impl_.position_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_entity_type() != 0) {
        _this->_impl_.entity_type_ = from._impl_.entity_type_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_size() != 0) {
        _this->_impl_.size_ = from._impl_.size_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_blocks_movement() != 0) {
        _this->_impl_.blocks_movement_ = from._impl_.blocks_movement_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (from._internal_blocks_line_of_sight() != 0) {
        _this->_impl_.blocks_line_of_sight_ = from._impl_.blocks_line_of_sight_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case =
          from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_visual_type();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kMonsterType: {
        _this->_impl_.visual_type_.monster_type_ = from._impl_.visual_type_.monster_type_;
        break;
      }
      case kObstacleType: {
        _this->_impl_.visual_type_.obstacle_type_ = from._impl_.visual_type_.obstacle_type_;
        break;
      }
      case VISUAL_TYPE_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void EntityPlacement::CopyFrom(const EntityPlacement& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.EntityPlacement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EntityPlacement::InternalSwap(EntityPlacement* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.entity_id_, &other->_impl_.entity_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.blocks_line_of_sight_)
      + sizeof(EntityPlacement::_impl_.blocks_line_of_sight_)
      - PROTOBUF_FIELD_OFFSET(EntityPlacement, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
  swap(_impl_.visual_type_, other->_impl_.visual_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata EntityPlacement::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
Room_EntitiesEntry_DoNotUse::Room_EntitiesEntry_DoNotUse()
    : SuperType(Room_EntitiesEntry_DoNotUse_class_data_.base()) {}
Room_EntitiesEntry_DoNotUse::Room_EntitiesEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
    : SuperType(arena, Room_EntitiesEntry_DoNotUse_class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
Room_EntitiesEntry_DoNotUse::Room_EntitiesEntry_DoNotUse() : SuperType() {}
Room_EntitiesEntry_DoNotUse::Room_EntitiesEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
inline void* PROTOBUF_NONNULL Room_EntitiesEntry_DoNotUse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Room_EntitiesEntry_DoNotUse(arena);
}
constexpr auto Room_EntitiesEntry_DoNotUse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Room_EntitiesEntry_DoNotUse),
                                            alignof(Room_EntitiesEntry_DoNotUse));
}
constexpr auto Room_EntitiesEntry_DoNotUse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Room_EntitiesEntry_DoNotUse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Room_EntitiesEntry_DoNotUse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Room_EntitiesEntry_DoNotUse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Room_EntitiesEntry_DoNotUse::SharedDtor,
          static_cast<void (::google::protobuf::MessageLite::*)()>(&Room_EntitiesEntry_DoNotUse::ClearImpl),
              ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
              ,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Room_EntitiesEntry_DoNotUse, _impl_._cached_size_),
          false,
      },
      &Room_EntitiesEntry_DoNotUse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Room_EntitiesEntry_DoNotUse_class_data_ =
        Room_EntitiesEntry_DoNotUse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Room_EntitiesEntry_DoNotUse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Room_EntitiesEntry_DoNotUse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Room_EntitiesEntry_DoNotUse_class_data_.tc_table);
  return Room_EntitiesEntry_DoNotUse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 49, 2>
Room_EntitiesEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Room_EntitiesEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    Room_EntitiesEntry_DoNotUse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room_EntitiesEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.EntityPlacement value = 2 [json_name = "value"];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(Room_EntitiesEntry_DoNotUse, _impl_.value_)}},
    // string key = 1 [json_name = "key"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(Room_EntitiesEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1 [json_name = "key"];
    {PROTOBUF_FIELD_OFFSET(Room_EntitiesEntry_DoNotUse, _impl_.key_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.EntityPlacement value = 2 [json_name = "value"];
    {PROTOBUF_FIELD_OFFSET(Room_EntitiesEntry_DoNotUse, _impl_.value_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EntityPlacement>()},
  }},
  {{
    "\45\3\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.Room.EntitiesEntry"
    "key"
  }},
};
// ===================================================================

class Room::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Room>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Room, _impl_._has_bits_);
};

void Room::clear_walls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.walls_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
void Room::clear_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
Room::Room(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Room_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.Room)
}
PROTOBUF_NDEBUG_INLINE Room::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::Room& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        walls_{visibility, arena, from.walls_},
        id_(arena, from.id_),
        type_(arena, from.type_),
        entities_{visibility, arena, from.entities_} {}

Room::Room(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Room& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Room_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Room* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.origin_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.origin_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, width_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, width_),
           offsetof(Impl_, hex_orientation_) -
               offsetof(Impl_, width_) +
               sizeof(Impl_::hex_orientation_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.Room)
}
PROTOBUF_NDEBUG_INLINE Room::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        walls_{visibility, arena},
        id_(arena),
        type_(arena),
        entities_{visibility, arena} {}

inline void Room::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, origin_),
           0,
           offsetof(Impl_, hex_orientation_) -
               offsetof(Impl_, origin_) +
               sizeof(Impl_::hex_orientation_));
}
Room::~Room() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.Room)
  SharedDtor(*this);
}
inline void Room::SharedDtor(MessageLite& self) {
  Room& this_ = static_cast<Room&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.id_.Destroy();
  this_._impl_.type_.Destroy();
  delete this_._impl_.origin_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Room::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Room(arena);
}
constexpr auto Room::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Room, _impl_.entities_) +
          decltype(Room::_impl_.entities_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Room, _impl_.walls_) +
          decltype(Room::_impl_.walls_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(Room), alignof(Room), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Room::PlacementNew_,
                                 sizeof(Room),
                                 alignof(Room));
  }
}
constexpr auto Room::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Room_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Room::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Room>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Room::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Room>(), &Room::ByteSizeLong,
              &Room::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Room, _impl_._cached_size_),
          false,
      },
      &Room::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Room_class_data_ =
        Room::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Room::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Room_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Room_class_data_.tc_table);
  return Room_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 4, 54, 2>
Room::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Room, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    Room_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string id = 1 [json_name = "id"];
    {::_pbi::TcParser::FastUS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(Room, _impl_.id_)}},
    // string type = 2 [json_name = "type"];
    {::_pbi::TcParser::FastUS1,
     {18, 2, 0,
      PROTOBUF_FIELD_OFFSET(Room, _impl_.type_)}},
    // int32 width = 3 [json_name = "width"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Room, _impl_.width_), 4>(),
     {24, 4, 0,
      PROTOBUF_FIELD_OFFSET(Room, _impl_.width_)}},
    // int32 height = 4 [json_name = "height"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Room, _impl_.height_), 5>(),
     {32, 5, 0,
      PROTOBUF_FIELD_OFFSET(Room, _impl_.height_)}},
    // .api.v1alpha1.GridType grid_type = 5 [json_name = "gridType"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Room, _impl_.grid_type_), 6>(),
     {40, 6, 0,
      PROTOBUF_FIELD_OFFSET(Room, _impl_.grid_type_)}},
    // optional bool hex_orientation = 6 [json_name = "hexOrientation"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Room, _impl_.hex_orientation_), 7>(),
     {48, 7, 0,
      PROTOBUF_FIELD_OFFSET(Room, _impl_.hex_orientation_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .api.v1alpha1.Wall walls = 8 [json_name = "walls"];
    {::_pbi::TcParser::FastMtR1,
     {66, 0, 0,
      PROTOBUF_FIELD_OFFSET(Room, _impl_.walls_)}},
    // .api.v1alpha1.Position origin = 9 [json_name = "origin"];
    {::_pbi::TcParser::FastMtS1,
     {74, 3, 1,
      PROTOBUF_FIELD_OFFSET(Room, _impl_.origin_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string id = 1 [json_name = "id"];
    {PROTOBUF_FIELD_OFFSET(Room, _impl_.id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string type = 2 [json_name = "type"];
    {PROTOBUF_FIELD_OFFSET(Room, _impl_.type_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 width = 3 [json_name = "width"];
    {PROTOBUF_FIELD_OFFSET(Room, _impl_.width_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 height = 4 [json_name = "height"];
    {PROTOBUF_FIELD_OFFSET(Room, _impl_.height_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // .api.v1alpha1.GridType grid_type = 5 [json_name = "gridType"];
    {PROTOBUF_FIELD_OFFSET(Room, _impl_.grid_type_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // optional bool hex_orientation = 6 [json_name = "hexOrientation"];
    {PROTOBUF_FIELD_OFFSET(Room, _impl_.hex_orientation_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // map<string, .dnd5e.api.v1alpha1.EntityPlacement> entities = 7 [json_name = "entities"];
    {PROTOBUF_FIELD_OFFSET(Room, _impl_.entities_), _Internal::kHasBitsOffset + 8, 2, (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // repeated .api.v1alpha1.Wall walls = 8 [json_name = "walls"];
    {PROTOBUF_FIELD_OFFSET(Room, _impl_.walls_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .api.v1alpha1.Position origin = 9 [json_name = "origin"];
    {PROTOBUF_FIELD_OFFSET(Room, _impl_.origin_), _Internal::kHasBitsOffset + 3, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::api::v1alpha1::Wall>()},
      {::_pbi::TcParser::GetTable<::api::v1alpha1::Position>()},
      {::_pbi::TcParser::GetMapAuxInfo(
          1, 0, 9, 11, 0)},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EntityPlacement>()},
  }},
  {{
    "\27\2\4\0\0\0\0\10\0\0\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.Room"
    "id"
    "type"
    "entities"
  }},
};
PROTOBUF_NOINLINE void Room::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.Room)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.walls_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x000000f0U)) {
    ::memset(&_impl_.width_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.hex_orientation_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.hex_orientation_));
  }
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000100U)) {
    _impl_.entities_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Room::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Room& this_ = static_cast<const Room&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Room::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Room& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.Room)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string id = 1 [json_name = "id"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_id().empty()) {
      const ::std::string& _s = this_._internal_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.Room.id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string type = 2 [json_name = "type"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_type().empty()) {
      const ::std::string& _s = this_._internal_type();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.Room.type");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // int32 width = 3 [json_name = "width"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_width() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
              stream, this_._internal_width(), target);
    }
  }

  // int32 height = 4 [json_name = "height"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (this_._internal_height() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
              stream, this_._internal_height(), target);
    }
  }

  // .api.v1alpha1.GridType grid_type = 5 [json_name = "gridType"];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    if (this_._internal_grid_type() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          5, this_._internal_grid_type(), target);
    }
  }

  // optional bool hex_orientation = 6 [json_name = "hexOrientation"];
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this_._internal_hex_orientation(), target);
  }

  // map<string, .dnd5e.api.v1alpha1.EntityPlacement> entities = 7 [json_name = "entities"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000100U)) {
    if (!this_._internal_entities().empty()) {
      using MapType = ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>;
      using WireHelper = _pbi::MapEntryFuncs<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement,
                                     _pbi::WireFormatLite::TYPE_STRING,
                                     _pbi::WireFormatLite::TYPE_MESSAGE>;
      const auto& field = this_._internal_entities();

      if (stream->IsSerializationDeterministic() && field.size() > 1) {
        for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
          target = WireHelper::InternalSerialize(
              7, entry.first, entry.second, target, stream);
          ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
              entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.Room.entities");
        }
      } else {
        for (const auto& entry : field) {
          target = WireHelper::InternalSerialize(
              7, entry.first, entry.second, target, stream);
          ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
              entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.Room.entities");
        }
      }
    }
  }

  // repeated .api.v1alpha1.Wall walls = 8 [json_name = "walls"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_walls_size());
         i < n; i++) {
      const auto& repfield = this_._internal_walls().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              8, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // .api.v1alpha1.Position origin = 9 [json_name = "origin"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        9, *this_._impl_.origin_, this_._impl_.origin_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.Room)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Room::ByteSizeLong(const MessageLite& base) {
  const Room& this_ = static_cast<const Room&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Room::ByteSizeLong() const {
  const Room& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.Room)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000080U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    // repeated .api.v1alpha1.Wall walls = 8 [json_name = "walls"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_walls_size();
      for (const auto& msg : this_._internal_walls()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string id = 1 [json_name = "id"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_id());
      }
    }
    // string type = 2 [json_name = "type"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!this_._internal_type().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_type());
      }
    }
    // .api.v1alpha1.Position origin = 9 [json_name = "origin"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.origin_);
    }
    // int32 width = 3 [json_name = "width"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_width() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_width());
      }
    }
    // int32 height = 4 [json_name = "height"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (this_._internal_height() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_height());
      }
    }
    // .api.v1alpha1.GridType grid_type = 5 [json_name = "gridType"];
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (this_._internal_grid_type() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_grid_type());
      }
    }
  }
   {
    // map<string, .dnd5e.api.v1alpha1.EntityPlacement> entities = 7 [json_name = "entities"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000100U)) {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_entities_size());
      for (const auto& entry : this_._internal_entities()) {
        total_size += _pbi::MapEntryFuncs<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement,
                                       _pbi::WireFormatLite::TYPE_STRING,
                                       _pbi::WireFormatLite::TYPE_MESSAGE>::ByteSizeLong(entry.first, entry.second);
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Room::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<Room*>(&to_msg);
  auto& from = static_cast<const Room&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.Room)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_walls()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_walls());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_id().empty()) {
        _this->_internal_set_id(from._internal_id());
      } else {
        if (_this->_impl_.id_.IsDefault()) {
          _this->_internal_set_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!from._internal_type().empty()) {
        _this->_internal_set_type(from._internal_type());
      } else {
        if (_this->_impl_.type_.IsDefault()) {
          _this->_internal_set_type("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.origin_ != nullptr);
      if (_this->_impl_.origin_ == nullptr) {
        _this->_impl_.origin_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.origin_);
      } else {
        _this->_impl_.origin_->MergeFrom(*from._impl_.origin_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_width() != 0) {
        _this->_impl_.width_ = from._impl_.width_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (from._internal_height() != 0) {
        _this->_impl_.height_ = from._impl_.height_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (from._internal_grid_type() != 0) {
        _this->_impl_.grid_type_ = from._impl_.grid_type_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _this->_impl_.hex_orientation_ = from._impl_.hex_orientation_;
    }
  }
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000100U)) {
    _this->_impl_.entities_.MergeFrom(from._impl_.entities_);
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void Room::CopyFrom(const Room& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.Room)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Room::InternalSwap(Room* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.walls_.InternalSwap(&other->_impl_.walls_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, &other->_impl_.id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.type_, &other->_impl_.type_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Room, _impl_.hex_orientation_)
      + sizeof(Room::_impl_.hex_orientation_)
      - PROTOBUF_FIELD_OFFSET(Room, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
  _impl_.entities_.InternalSwap(&other->_impl_.entities_);
}

::google::protobuf::Metadata Room::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DoorInfo::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DoorInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_._has_bits_);
};

void DoorInfo::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
DoorInfo::DoorInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DoorInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.DoorInfo)
}
PROTOBUF_NDEBUG_INLINE DoorInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::DoorInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        connection_id_(arena, from.connection_id_),
        physical_hint_(arena, from.physical_hint_),
        leads_to_room_id_(arena, from.leads_to_room_id_) {}

DoorInfo::DoorInfo(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DoorInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DoorInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DoorInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.position_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.position_)
                : nullptr;
  _impl_.is_open_ = from._impl_.is_open_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.DoorInfo)
}
PROTOBUF_NDEBUG_INLINE DoorInfo::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        connection_id_(arena),
        physical_hint_(arena),
        leads_to_room_id_(arena) {}

inline void DoorInfo::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, position_),
           0,
           offsetof(Impl_, is_open_) -
               offsetof(Impl_, position_) +
               sizeof(Impl_::is_open_));
}
DoorInfo::~DoorInfo() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.DoorInfo)
  SharedDtor(*this);
}
inline void DoorInfo::SharedDtor(MessageLite& self) {
  DoorInfo& this_ = static_cast<DoorInfo&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.connection_id_.Destroy();
  this_._impl_.physical_hint_.Destroy();
  this_._impl_.leads_to_room_id_.Destroy();
  delete this_._impl_.position_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DoorInfo::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DoorInfo(arena);
}
constexpr auto DoorInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(DoorInfo),
                                            alignof(DoorInfo));
}
constexpr auto DoorInfo::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DoorInfo_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DoorInfo::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DoorInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DoorInfo::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DoorInfo>(), &DoorInfo::ByteSizeLong,
              &DoorInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_._cached_size_),
          false,
      },
      &DoorInfo::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DoorInfo_class_data_ =
        DoorInfo::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DoorInfo::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DoorInfo_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DoorInfo_class_data_.tc_table);
  return DoorInfo_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 78, 2>
DoorInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    DoorInfo_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DoorInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string connection_id = 1 [json_name = "connectionId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_.connection_id_)}},
    // .api.v1alpha1.Position position = 2 [json_name = "position"];
    {::_pbi::TcParser::FastMtS1,
     {18, 3, 0,
      PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_.position_)}},
    // string physical_hint = 3 [json_name = "physicalHint"];
    {::_pbi::TcParser::FastUS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_.physical_hint_)}},
    // bool is_open = 4 [json_name = "isOpen"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DoorInfo, _impl_.is_open_), 4>(),
     {32, 4, 0,
      PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_.is_open_)}},
    // string leads_to_room_id = 5 [json_name = "leadsToRoomId"];
    {::_pbi::TcParser::FastUS1,
     {42, 2, 0,
      PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_.leads_to_room_id_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string connection_id = 1 [json_name = "connectionId"];
    {PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_.connection_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .api.v1alpha1.Position position = 2 [json_name = "position"];
    {PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_.position_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // string physical_hint = 3 [json_name = "physicalHint"];
    {PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_.physical_hint_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool is_open = 4 [json_name = "isOpen"];
    {PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_.is_open_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // string leads_to_room_id = 5 [json_name = "leadsToRoomId"];
    {PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_.leads_to_room_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::api::v1alpha1::Position>()},
  }},
  {{
    "\33\15\0\15\0\20\0\0"
    "dnd5e.api.v1alpha1.DoorInfo"
    "connection_id"
    "physical_hint"
    "leads_to_room_id"
  }},
};
PROTOBUF_NOINLINE void DoorInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.DoorInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.connection_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.physical_hint_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.leads_to_room_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
  }
  _impl_.is_open_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DoorInfo::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DoorInfo& this_ = static_cast<const DoorInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DoorInfo::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DoorInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.DoorInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string connection_id = 1 [json_name = "connectionId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_connection_id().empty()) {
      const ::std::string& _s = this_._internal_connection_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.DoorInfo.connection_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // .api.v1alpha1.Position position = 2 [json_name = "position"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.position_, this_._impl_.position_->GetCachedSize(), target,
        stream);
  }

  // string physical_hint = 3 [json_name = "physicalHint"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_physical_hint().empty()) {
      const ::std::string& _s = this_._internal_physical_hint();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.DoorInfo.physical_hint");
      target = stream->WriteStringMaybeAliased(3, _s, target);
    }
  }

  // bool is_open = 4 [json_name = "isOpen"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_is_open() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          4, this_._internal_is_open(), target);
    }
  }

  // string leads_to_room_id = 5 [json_name = "leadsToRoomId"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_leads_to_room_id().empty()) {
      const ::std::string& _s = this_._internal_leads_to_room_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.DoorInfo.leads_to_room_id");
      target = stream->WriteStringMaybeAliased(5, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.DoorInfo)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DoorInfo::ByteSizeLong(const MessageLite& base) {
  const DoorInfo& this_ = static_cast<const DoorInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DoorInfo::ByteSizeLong() const {
  const DoorInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.DoorInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // string connection_id = 1 [json_name = "connectionId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_connection_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_connection_id());
      }
    }
    // string physical_hint = 3 [json_name = "physicalHint"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_physical_hint().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_physical_hint());
      }
    }
    // string leads_to_room_id = 5 [json_name = "leadsToRoomId"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!this_._internal_leads_to_room_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_leads_to_room_id());
      }
    }
    // .api.v1alpha1.Position position = 2 [json_name = "position"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.position_);
    }
    // bool is_open = 4 [json_name = "isOpen"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_is_open() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DoorInfo::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<DoorInfo*>(&to_msg);
  auto& from = static_cast<const DoorInfo&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.DoorInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_connection_id().empty()) {
        _this->_internal_set_connection_id(from._internal_connection_id());
      } else {
        if (_this->_impl_.connection_id_.IsDefault()) {
          _this->_internal_set_connection_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_physical_hint().empty()) {
        _this->_internal_set_physical_hint(from._internal_physical_hint());
      } else {
        if (_this->_impl_.physical_hint_.IsDefault()) {
          _this->_internal_set_physical_hint("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!from._internal_leads_to_room_id().empty()) {
        _this->_internal_set_leads_to_room_id(from._internal_leads_to_room_id());
      } else {
        if (_this->_impl_.leads_to_room_id_.IsDefault()) {
          _this->_internal_set_leads_to_room_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.position_ != nullptr);
      if (_this->_impl_.position_ == nullptr) {
        _this->_impl_.position_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.position_);
      } else {
        _this->_impl_.position_->MergeFrom(*from._impl_.position_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_is_open() != 0) {
        _this->_impl_.is_open_ = from._impl_.is_open_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void DoorInfo::CopyFrom(const DoorInfo& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.DoorInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DoorInfo::InternalSwap(DoorInfo* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.connection_id_, &other->_impl_.connection_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.physical_hint_, &other->_impl_.physical_hint_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.leads_to_room_id_, &other->_impl_.leads_to_room_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_.is_open_)
      + sizeof(DoorInfo::_impl_.is_open_)
      - PROTOBUF_FIELD_OFFSET(DoorInfo, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::google::protobuf::Metadata DoorInfo::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DungeonStartRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DungeonStartRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_._has_bits_);
};

DungeonStartRequest::DungeonStartRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DungeonStartRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.DungeonStartRequest)
}
PROTOBUF_NDEBUG_INLINE DungeonStartRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::DungeonStartRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        character_ids_{visibility, arena, from.character_ids_} {}

DungeonStartRequest::DungeonStartRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DungeonStartRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DungeonStartRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DungeonStartRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, theme_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, theme_),
           offsetof(Impl_, length_) -
               offsetof(Impl_, theme_) +
               sizeof(Impl_::length_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.DungeonStartRequest)
}
PROTOBUF_NDEBUG_INLINE DungeonStartRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        character_ids_{visibility, arena} {}

inline void DungeonStartRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, theme_),
           0,
           offsetof(Impl_, length_) -
               offsetof(Impl_, theme_) +
               sizeof(Impl_::length_));
}
DungeonStartRequest::~DungeonStartRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.DungeonStartRequest)
  SharedDtor(*this);
}
inline void DungeonStartRequest::SharedDtor(MessageLite& self) {
  DungeonStartRequest& this_ = static_cast<DungeonStartRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DungeonStartRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DungeonStartRequest(arena);
}
constexpr auto DungeonStartRequest::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_.character_ids_) +
          decltype(DungeonStartRequest::_impl_.character_ids_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(DungeonStartRequest), alignof(DungeonStartRequest), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&DungeonStartRequest::PlacementNew_,
                                 sizeof(DungeonStartRequest),
                                 alignof(DungeonStartRequest));
  }
}
constexpr auto DungeonStartRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DungeonStartRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DungeonStartRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DungeonStartRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DungeonStartRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DungeonStartRequest>(), &DungeonStartRequest::ByteSizeLong,
              &DungeonStartRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_._cached_size_),
          false,
      },
      &DungeonStartRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DungeonStartRequest_class_data_ =
        DungeonStartRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DungeonStartRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DungeonStartRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DungeonStartRequest_class_data_.tc_table);
  return DungeonStartRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 60, 2>
DungeonStartRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    DungeonStartRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DungeonStartRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.DungeonLength length = 4 [json_name = "length"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DungeonStartRequest, _impl_.length_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_.length_)}},
    // repeated string character_ids = 1 [json_name = "characterIds"];
    {::_pbi::TcParser::FastUR1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_.character_ids_)}},
    // .dnd5e.api.v1alpha1.DungeonTheme theme = 2 [json_name = "theme"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DungeonStartRequest, _impl_.theme_), 1>(),
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_.theme_)}},
    // .dnd5e.api.v1alpha1.DungeonDifficulty difficulty = 3 [json_name = "difficulty"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DungeonStartRequest, _impl_.difficulty_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_.difficulty_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated string character_ids = 1 [json_name = "characterIds"];
    {PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_.character_ids_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // .dnd5e.api.v1alpha1.DungeonTheme theme = 2 [json_name = "theme"];
    {PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_.theme_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.DungeonDifficulty difficulty = 3 [json_name = "difficulty"];
    {PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_.difficulty_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.DungeonLength length = 4 [json_name = "length"];
    {PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_.length_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
    "\46\15\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.DungeonStartRequest"
    "character_ids"
  }},
};
PROTOBUF_NOINLINE void DungeonStartRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.DungeonStartRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.character_ids_.Clear();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000eU)) {
    ::memset(&_impl_.theme_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.length_) -
        reinterpret_cast<char*>(&_impl_.theme_)) + sizeof(_impl_.length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DungeonStartRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DungeonStartRequest& this_ = static_cast<const DungeonStartRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DungeonStartRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DungeonStartRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.DungeonStartRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated string character_ids = 1 [json_name = "characterIds"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_character_ids_size(); i < n; ++i) {
      const auto& s = this_._internal_character_ids().Get(i);
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.DungeonStartRequest.character_ids");
      target = stream->WriteString(1, s, target);
    }
  }

  // .dnd5e.api.v1alpha1.DungeonTheme theme = 2 [json_name = "theme"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (this_._internal_theme() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          2, this_._internal_theme(), target);
    }
  }

  // .dnd5e.api.v1alpha1.DungeonDifficulty difficulty = 3 [json_name = "difficulty"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_difficulty() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          3, this_._internal_difficulty(), target);
    }
  }

  // .dnd5e.api.v1alpha1.DungeonLength length = 4 [json_name = "length"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_length() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          4, this_._internal_length(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.DungeonStartRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DungeonStartRequest::ByteSizeLong(const MessageLite& base) {
  const DungeonStartRequest& this_ = static_cast<const DungeonStartRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DungeonStartRequest::ByteSizeLong() const {
  const DungeonStartRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.DungeonStartRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // repeated string character_ids = 1 [json_name = "characterIds"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_character_ids().size());
      for (int i = 0, n = this_._internal_character_ids().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_character_ids().Get(i));
      }
    }
    // .dnd5e.api.v1alpha1.DungeonTheme theme = 2 [json_name = "theme"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (this_._internal_theme() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_theme());
      }
    }
    // .dnd5e.api.v1alpha1.DungeonDifficulty difficulty = 3 [json_name = "difficulty"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_difficulty() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_difficulty());
      }
    }
    // .dnd5e.api.v1alpha1.DungeonLength length = 4 [json_name = "length"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_length() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_length());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DungeonStartRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<DungeonStartRequest*>(&to_msg);
  auto& from = static_cast<const DungeonStartRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.DungeonStartRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_character_ids()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_character_ids());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (from._internal_theme() != 0) {
        _this->_impl_.theme_ = from._impl_.theme_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_difficulty() != 0) {
        _this->_impl_.difficulty_ = from._impl_.difficulty_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_length() != 0) {
        _this->_impl_.length_ = from._impl_.length_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void DungeonStartRequest::CopyFrom(const DungeonStartRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.DungeonStartRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DungeonStartRequest::InternalSwap(DungeonStartRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.character_ids_.InternalSwap(&other->_impl_.character_ids_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_.length_)
      + sizeof(DungeonStartRequest::_impl_.length_)
      - PROTOBUF_FIELD_OFFSET(DungeonStartRequest, _impl_.theme_)>(
          reinterpret_cast<char*>(&_impl_.theme_),
          reinterpret_cast<char*>(&other->_impl_.theme_));
}

::google::protobuf::Metadata DungeonStartRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DungeonStartResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DungeonStartResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_._has_bits_);
};

DungeonStartResponse::DungeonStartResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DungeonStartResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.DungeonStartResponse)
}
PROTOBUF_NDEBUG_INLINE DungeonStartResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::DungeonStartResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        monster_turns_{visibility, arena, from.monster_turns_},
        doors_{visibility, arena, from.doors_},
        dungeon_id_(arena, from.dungeon_id_),
        encounter_id_(arena, from.encounter_id_) {}

DungeonStartResponse::DungeonStartResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DungeonStartResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DungeonStartResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DungeonStartResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.room_ = (CheckHasBit(cached_has_bits, 0x00000010U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_)
                : nullptr;
  _impl_.combat_state_ = (CheckHasBit(cached_has_bits, 0x00000020U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_)
                : nullptr;
  _impl_.dungeon_state_ = from._impl_.dungeon_state_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.DungeonStartResponse)
}
PROTOBUF_NDEBUG_INLINE DungeonStartResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        monster_turns_{visibility, arena},
        doors_{visibility, arena},
        dungeon_id_(arena),
        encounter_id_(arena) {}

inline void DungeonStartResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, room_),
           0,
           offsetof(Impl_, dungeon_state_) -
               offsetof(Impl_, room_) +
               sizeof(Impl_::dungeon_state_));
}
DungeonStartResponse::~DungeonStartResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.DungeonStartResponse)
  SharedDtor(*this);
}
inline void DungeonStartResponse::SharedDtor(MessageLite& self) {
  DungeonStartResponse& this_ = static_cast<DungeonStartResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.dungeon_id_.Destroy();
  this_._impl_.encounter_id_.Destroy();
  delete this_._impl_.room_;
  delete this_._impl_.combat_state_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DungeonStartResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DungeonStartResponse(arena);
}
constexpr auto DungeonStartResponse::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.monster_turns_) +
          decltype(DungeonStartResponse::_impl_.monster_turns_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.doors_) +
          decltype(DungeonStartResponse::_impl_.doors_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(DungeonStartResponse), alignof(DungeonStartResponse), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&DungeonStartResponse::PlacementNew_,
                                 sizeof(DungeonStartResponse),
                                 alignof(DungeonStartResponse));
  }
}
constexpr auto DungeonStartResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DungeonStartResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DungeonStartResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DungeonStartResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DungeonStartResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DungeonStartResponse>(), &DungeonStartResponse::ByteSizeLong,
              &DungeonStartResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_._cached_size_),
          false,
      },
      &DungeonStartResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DungeonStartResponse_class_data_ =
        DungeonStartResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DungeonStartResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DungeonStartResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DungeonStartResponse_class_data_.tc_table);
  return DungeonStartResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 4, 70, 2>
DungeonStartResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    DungeonStartResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DungeonStartResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string dungeon_id = 1 [json_name = "dungeonId"];
    {::_pbi::TcParser::FastUS1,
     {10, 2, 0,
      PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.dungeon_id_)}},
    // string encounter_id = 2 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {18, 3, 0,
      PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.encounter_id_)}},
    // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
    {::_pbi::TcParser::FastMtS1,
     {26, 4, 0,
      PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.room_)}},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
    {::_pbi::TcParser::FastMtS1,
     {34, 5, 1,
      PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.combat_state_)}},
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 5 [json_name = "monsterTurns"];
    {::_pbi::TcParser::FastMtR1,
     {42, 0, 2,
      PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.monster_turns_)}},
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 6 [json_name = "doors"];
    {::_pbi::TcParser::FastMtR1,
     {50, 1, 3,
      PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.doors_)}},
    // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 7 [json_name = "dungeonState"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DungeonStartResponse, _impl_.dungeon_state_), 6>(),
     {56, 6, 0,
      PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.dungeon_state_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string dungeon_id = 1 [json_name = "dungeonId"];
    {PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.dungeon_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string encounter_id = 2 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.encounter_id_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
    {PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.room_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
    {PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.combat_state_), _Internal::kHasBitsOffset + 5, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 5 [json_name = "monsterTurns"];
    {PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.monster_turns_), _Internal::kHasBitsOffset + 0, 2, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 6 [json_name = "doors"];
    {PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.doors_), _Internal::kHasBitsOffset + 1, 3, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 7 [json_name = "dungeonState"];
    {PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.dungeon_state_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterTurnResult>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DoorInfo>()},
  }},
  {{
    "\47\12\14\0\0\0\0\0"
    "dnd5e.api.v1alpha1.DungeonStartResponse"
    "dungeon_id"
    "encounter_id"
  }},
};
PROTOBUF_NOINLINE void DungeonStartResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.DungeonStartResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.monster_turns_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.doors_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.dungeon_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(_impl_.room_ != nullptr);
      _impl_.room_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(_impl_.combat_state_ != nullptr);
      _impl_.combat_state_->Clear();
    }
  }
  _impl_.dungeon_state_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DungeonStartResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DungeonStartResponse& this_ = static_cast<const DungeonStartResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DungeonStartResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DungeonStartResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.DungeonStartResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string dungeon_id = 1 [json_name = "dungeonId"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_dungeon_id().empty()) {
      const ::std::string& _s = this_._internal_dungeon_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.DungeonStartResponse.dungeon_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string encounter_id = 2 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.room_, this_._impl_.room_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.combat_state_, this_._impl_.combat_state_->GetCachedSize(), target,
        stream);
  }

  // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 5 [json_name = "monsterTurns"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_monster_turns_size());
         i < n; i++) {
      const auto& repfield = this_._internal_monster_turns().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              5, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 6 [json_name = "doors"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_doors_size());
         i < n; i++) {
      const auto& repfield = this_._internal_doors().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              6, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 7 [json_name = "dungeonState"];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    if (this_._internal_dungeon_state() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          7, this_._internal_dungeon_state(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.DungeonStartResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DungeonStartResponse::ByteSizeLong(const MessageLite& base) {
  const DungeonStartResponse& this_ = static_cast<const DungeonStartResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DungeonStartResponse::ByteSizeLong() const {
  const DungeonStartResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.DungeonStartResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 5 [json_name = "monsterTurns"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_monster_turns_size();
      for (const auto& msg : this_._internal_monster_turns()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 6 [json_name = "doors"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 1UL * this_._internal_doors_size();
      for (const auto& msg : this_._internal_doors()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string dungeon_id = 1 [json_name = "dungeonId"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!this_._internal_dungeon_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_dungeon_id());
      }
    }
    // string encounter_id = 2 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.room_);
    }
    // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.combat_state_);
    }
    // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 7 [json_name = "dungeonState"];
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (this_._internal_dungeon_state() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_dungeon_state());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DungeonStartResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<DungeonStartResponse*>(&to_msg);
  auto& from = static_cast<const DungeonStartResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.DungeonStartResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_monster_turns()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_monster_turns());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_doors()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_doors());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!from._internal_dungeon_id().empty()) {
        _this->_internal_set_dungeon_id(from._internal_dungeon_id());
      } else {
        if (_this->_impl_.dungeon_id_.IsDefault()) {
          _this->_internal_set_dungeon_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(from._impl_.room_ != nullptr);
      if (_this->_impl_.room_ == nullptr) {
        _this->_impl_.room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_);
      } else {
        _this->_impl_.room_->MergeFrom(*from._impl_.room_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(from._impl_.combat_state_ != nullptr);
      if (_this->_impl_.combat_state_ == nullptr) {
        _this->_impl_.combat_state_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_);
      } else {
        _this->_impl_.combat_state_->MergeFrom(*from._impl_.combat_state_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (from._internal_dungeon_state() != 0) {
        _this->_impl_.dungeon_state_ = from._impl_.dungeon_state_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void DungeonStartResponse::CopyFrom(const DungeonStartResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.DungeonStartResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DungeonStartResponse::InternalSwap(DungeonStartResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.monster_turns_.InternalSwap(&other->_impl_.monster_turns_);
  _impl_.doors_.InternalSwap(&other->_impl_.doors_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dungeon_id_, &other->_impl_.dungeon_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.dungeon_state_)
      + sizeof(DungeonStartResponse::_impl_.dungeon_state_)
      - PROTOBUF_FIELD_OFFSET(DungeonStartResponse, _impl_.room_)>(
          reinterpret_cast<char*>(&_impl_.room_),
          reinterpret_cast<char*>(&other->_impl_.room_));
}

::google::protobuf::Metadata DungeonStartResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class OpenDoorRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<OpenDoorRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(OpenDoorRequest, _impl_._has_bits_);
};

OpenDoorRequest::OpenDoorRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, OpenDoorRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.OpenDoorRequest)
}
PROTOBUF_NDEBUG_INLINE OpenDoorRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::OpenDoorRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        dungeon_id_(arena, from.dungeon_id_),
        connection_id_(arena, from.connection_id_) {}

OpenDoorRequest::OpenDoorRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const OpenDoorRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, OpenDoorRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  OpenDoorRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.OpenDoorRequest)
}
PROTOBUF_NDEBUG_INLINE OpenDoorRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        dungeon_id_(arena),
        connection_id_(arena) {}

inline void OpenDoorRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
OpenDoorRequest::~OpenDoorRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.OpenDoorRequest)
  SharedDtor(*this);
}
inline void OpenDoorRequest::SharedDtor(MessageLite& self) {
  OpenDoorRequest& this_ = static_cast<OpenDoorRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.dungeon_id_.Destroy();
  this_._impl_.connection_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL OpenDoorRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) OpenDoorRequest(arena);
}
constexpr auto OpenDoorRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(OpenDoorRequest),
                                            alignof(OpenDoorRequest));
}
constexpr auto OpenDoorRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_OpenDoorRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &OpenDoorRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<OpenDoorRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &OpenDoorRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<OpenDoorRequest>(), &OpenDoorRequest::ByteSizeLong,
              &OpenDoorRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(OpenDoorRequest, _impl_._cached_size_),
          false,
      },
      &OpenDoorRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull OpenDoorRequest_class_data_ =
        OpenDoorRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
OpenDoorRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&OpenDoorRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(OpenDoorRequest_class_data_.tc_table);
  return OpenDoorRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 66, 2>
OpenDoorRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(OpenDoorRequest, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    OpenDoorRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::OpenDoorRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string connection_id = 2 [json_name = "connectionId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(OpenDoorRequest, _impl_.connection_id_)}},
    // string dungeon_id = 1 [json_name = "dungeonId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(OpenDoorRequest, _impl_.dungeon_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string dungeon_id = 1 [json_name = "dungeonId"];
    {PROTOBUF_FIELD_OFFSET(OpenDoorRequest, _impl_.dungeon_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string connection_id = 2 [json_name = "connectionId"];
    {PROTOBUF_FIELD_OFFSET(OpenDoorRequest, _impl_.connection_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\42\12\15\0\0\0\0\0"
    "dnd5e.api.v1alpha1.OpenDoorRequest"
    "dungeon_id"
    "connection_id"
  }},
};
PROTOBUF_NOINLINE void OpenDoorRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.OpenDoorRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.dungeon_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.connection_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL OpenDoorRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const OpenDoorRequest& this_ = static_cast<const OpenDoorRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL OpenDoorRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const OpenDoorRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.OpenDoorRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string dungeon_id = 1 [json_name = "dungeonId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_dungeon_id().empty()) {
      const ::std::string& _s = this_._internal_dungeon_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.OpenDoorRequest.dungeon_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string connection_id = 2 [json_name = "connectionId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_connection_id().empty()) {
      const ::std::string& _s = this_._internal_connection_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.OpenDoorRequest.connection_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.OpenDoorRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t OpenDoorRequest::ByteSizeLong(const MessageLite& base) {
  const OpenDoorRequest& this_ = static_cast<const OpenDoorRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t OpenDoorRequest::ByteSizeLong() const {
  const OpenDoorRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.OpenDoorRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // string dungeon_id = 1 [json_name = "dungeonId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_dungeon_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_dungeon_id());
      }
    }
    // string connection_id = 2 [json_name = "connectionId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_connection_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_connection_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void OpenDoorRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<OpenDoorRequest*>(&to_msg);
  auto& from = static_cast<const OpenDoorRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.OpenDoorRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_dungeon_id().empty()) {
        _this->_internal_set_dungeon_id(from._internal_dungeon_id());
      } else {
        if (_this->_impl_.dungeon_id_.IsDefault()) {
          _this->_internal_set_dungeon_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_connection_id().empty()) {
        _this->_internal_set_connection_id(from._internal_connection_id());
      } else {
        if (_this->_impl_.connection_id_.IsDefault()) {
          _this->_internal_set_connection_id("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void OpenDoorRequest::CopyFrom(const OpenDoorRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.OpenDoorRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void OpenDoorRequest::InternalSwap(OpenDoorRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dungeon_id_, &other->_impl_.dungeon_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.connection_id_, &other->_impl_.connection_id_, arena);
}

::google::protobuf::Metadata OpenDoorRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class OpenDoorResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<OpenDoorResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_._has_bits_);
};

OpenDoorResponse::OpenDoorResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, OpenDoorResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.OpenDoorResponse)
}
PROTOBUF_NDEBUG_INLINE OpenDoorResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::OpenDoorResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        monster_turns_{visibility, arena, from.monster_turns_},
        doors_{visibility, arena, from.doors_},
        error_(arena, from.error_),
        encounter_id_(arena, from.encounter_id_) {}

OpenDoorResponse::OpenDoorResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const OpenDoorResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, OpenDoorResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  OpenDoorResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.room_ = (CheckHasBit(cached_has_bits, 0x00000010U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_)
                : nullptr;
  _impl_.combat_state_ = (CheckHasBit(cached_has_bits, 0x00000020U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, success_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, success_),
           offsetof(Impl_, dungeon_state_) -
               offsetof(Impl_, success_) +
               sizeof(Impl_::dungeon_state_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.OpenDoorResponse)
}
PROTOBUF_NDEBUG_INLINE OpenDoorResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        monster_turns_{visibility, arena},
        doors_{visibility, arena},
        error_(arena),
        encounter_id_(arena) {}

inline void OpenDoorResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, room_),
           0,
           offsetof(Impl_, dungeon_state_) -
               offsetof(Impl_, room_) +
               sizeof(Impl_::dungeon_state_));
}
OpenDoorResponse::~OpenDoorResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.OpenDoorResponse)
  SharedDtor(*this);
}
inline void OpenDoorResponse::SharedDtor(MessageLite& self) {
  OpenDoorResponse& this_ = static_cast<OpenDoorResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.error_.Destroy();
  this_._impl_.encounter_id_.Destroy();
  delete this_._impl_.room_;
  delete this_._impl_.combat_state_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL OpenDoorResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) OpenDoorResponse(arena);
}
constexpr auto OpenDoorResponse::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.monster_turns_) +
          decltype(OpenDoorResponse::_impl_.monster_turns_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.doors_) +
          decltype(OpenDoorResponse::_impl_.doors_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(OpenDoorResponse), alignof(OpenDoorResponse), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&OpenDoorResponse::PlacementNew_,
                                 sizeof(OpenDoorResponse),
                                 alignof(OpenDoorResponse));
  }
}
constexpr auto OpenDoorResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_OpenDoorResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &OpenDoorResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<OpenDoorResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &OpenDoorResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<OpenDoorResponse>(), &OpenDoorResponse::ByteSizeLong,
              &OpenDoorResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_._cached_size_),
          false,
      },
      &OpenDoorResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull OpenDoorResponse_class_data_ =
        OpenDoorResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
OpenDoorResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&OpenDoorResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(OpenDoorResponse_class_data_.tc_table);
  return OpenDoorResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 4, 69, 2>
OpenDoorResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    OpenDoorResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::OpenDoorResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 8 [json_name = "dungeonState"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(OpenDoorResponse, _impl_.dungeon_state_), 7>(),
     {64, 7, 0,
      PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.dungeon_state_)}},
    // bool success = 1 [json_name = "success"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(OpenDoorResponse, _impl_.success_), 6>(),
     {8, 6, 0,
      PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.success_)}},
    // string error = 2 [json_name = "error"];
    {::_pbi::TcParser::FastUS1,
     {18, 2, 0,
      PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.error_)}},
    // string encounter_id = 3 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {26, 3, 0,
      PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.encounter_id_)}},
    // .dnd5e.api.v1alpha1.Room room = 4 [json_name = "room"];
    {::_pbi::TcParser::FastMtS1,
     {34, 4, 0,
      PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.room_)}},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 5 [json_name = "combatState"];
    {::_pbi::TcParser::FastMtS1,
     {42, 5, 1,
      PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.combat_state_)}},
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 6 [json_name = "monsterTurns"];
    {::_pbi::TcParser::FastMtR1,
     {50, 0, 2,
      PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.monster_turns_)}},
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 7 [json_name = "doors"];
    {::_pbi::TcParser::FastMtR1,
     {58, 1, 3,
      PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.doors_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bool success = 1 [json_name = "success"];
    {PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.success_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // string error = 2 [json_name = "error"];
    {PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.error_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string encounter_id = 3 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.encounter_id_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.Room room = 4 [json_name = "room"];
    {PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.room_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 5 [json_name = "combatState"];
    {PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.combat_state_), _Internal::kHasBitsOffset + 5, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 6 [json_name = "monsterTurns"];
    {PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.monster_turns_), _Internal::kHasBitsOffset + 0, 2, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 7 [json_name = "doors"];
    {PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.doors_), _Internal::kHasBitsOffset + 1, 3, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 8 [json_name = "dungeonState"];
    {PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.dungeon_state_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterTurnResult>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DoorInfo>()},
  }},
  {{
    "\43\0\5\14\0\0\0\0\0\0\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.OpenDoorResponse"
    "error"
    "encounter_id"
  }},
};
PROTOBUF_NOINLINE void OpenDoorResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.OpenDoorResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.monster_turns_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.doors_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.error_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(_impl_.room_ != nullptr);
      _impl_.room_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(_impl_.combat_state_ != nullptr);
      _impl_.combat_state_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x000000c0U)) {
    ::memset(&_impl_.success_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.dungeon_state_) -
        reinterpret_cast<char*>(&_impl_.success_)) + sizeof(_impl_.dungeon_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL OpenDoorResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const OpenDoorResponse& this_ = static_cast<const OpenDoorResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL OpenDoorResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const OpenDoorResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.OpenDoorResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // bool success = 1 [json_name = "success"];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    if (this_._internal_success() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          1, this_._internal_success(), target);
    }
  }

  // string error = 2 [json_name = "error"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_error().empty()) {
      const ::std::string& _s = this_._internal_error();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.OpenDoorResponse.error");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // string encounter_id = 3 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.OpenDoorResponse.encounter_id");
      target = stream->WriteStringMaybeAliased(3, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.Room room = 4 [json_name = "room"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.room_, this_._impl_.room_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.CombatState combat_state = 5 [json_name = "combatState"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.combat_state_, this_._impl_.combat_state_->GetCachedSize(), target,
        stream);
  }

  // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 6 [json_name = "monsterTurns"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_monster_turns_size());
         i < n; i++) {
      const auto& repfield = this_._internal_monster_turns().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              6, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 7 [json_name = "doors"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_doors_size());
         i < n; i++) {
      const auto& repfield = this_._internal_doors().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              7, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 8 [json_name = "dungeonState"];
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    if (this_._internal_dungeon_state() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          8, this_._internal_dungeon_state(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.OpenDoorResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t OpenDoorResponse::ByteSizeLong(const MessageLite& base) {
  const OpenDoorResponse& this_ = static_cast<const OpenDoorResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t OpenDoorResponse::ByteSizeLong() const {
  const OpenDoorResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.OpenDoorResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 6 [json_name = "monsterTurns"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_monster_turns_size();
      for (const auto& msg : this_._internal_monster_turns()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 7 [json_name = "doors"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 1UL * this_._internal_doors_size();
      for (const auto& msg : this_._internal_doors()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string error = 2 [json_name = "error"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!this_._internal_error().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_error());
      }
    }
    // string encounter_id = 3 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // .dnd5e.api.v1alpha1.Room room = 4 [json_name = "room"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.room_);
    }
    // .dnd5e.api.v1alpha1.CombatState combat_state = 5 [json_name = "combatState"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.combat_state_);
    }
    // bool success = 1 [json_name = "success"];
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (this_._internal_success() != 0) {
        total_size += 2;
      }
    }
    // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 8 [json_name = "dungeonState"];
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      if (this_._internal_dungeon_state() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_dungeon_state());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void OpenDoorResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<OpenDoorResponse*>(&to_msg);
  auto& from = static_cast<const OpenDoorResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.OpenDoorResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_monster_turns()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_monster_turns());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_doors()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_doors());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!from._internal_error().empty()) {
        _this->_internal_set_error(from._internal_error());
      } else {
        if (_this->_impl_.error_.IsDefault()) {
          _this->_internal_set_error("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(from._impl_.room_ != nullptr);
      if (_this->_impl_.room_ == nullptr) {
        _this->_impl_.room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_);
      } else {
        _this->_impl_.room_->MergeFrom(*from._impl_.room_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(from._impl_.combat_state_ != nullptr);
      if (_this->_impl_.combat_state_ == nullptr) {
        _this->_impl_.combat_state_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_);
      } else {
        _this->_impl_.combat_state_->MergeFrom(*from._impl_.combat_state_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (from._internal_success() != 0) {
        _this->_impl_.success_ = from._impl_.success_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      if (from._internal_dungeon_state() != 0) {
        _this->_impl_.dungeon_state_ = from._impl_.dungeon_state_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void OpenDoorResponse::CopyFrom(const OpenDoorResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.OpenDoorResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void OpenDoorResponse::InternalSwap(OpenDoorResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.monster_turns_.InternalSwap(&other->_impl_.monster_turns_);
  _impl_.doors_.InternalSwap(&other->_impl_.doors_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_, &other->_impl_.error_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.dungeon_state_)
      + sizeof(OpenDoorResponse::_impl_.dungeon_state_)
      - PROTOBUF_FIELD_OFFSET(OpenDoorResponse, _impl_.room_)>(
          reinterpret_cast<char*>(&_impl_.room_),
          reinterpret_cast<char*>(&other->_impl_.room_));
}

::google::protobuf::Metadata OpenDoorResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class InitiativeEntry::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<InitiativeEntry>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_._has_bits_);
};

InitiativeEntry::InitiativeEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, InitiativeEntry_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.InitiativeEntry)
}
PROTOBUF_NDEBUG_INLINE InitiativeEntry::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::InitiativeEntry& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        entity_id_(arena, from.entity_id_),
        entity_type_(arena, from.entity_type_) {}

InitiativeEntry::InitiativeEntry(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const InitiativeEntry& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, InitiativeEntry_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  InitiativeEntry* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, initiative_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, initiative_),
           offsetof(Impl_, has_acted_) -
               offsetof(Impl_, initiative_) +
               sizeof(Impl_::has_acted_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.InitiativeEntry)
}
PROTOBUF_NDEBUG_INLINE InitiativeEntry::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        entity_id_(arena),
        entity_type_(arena) {}

inline void InitiativeEntry::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, initiative_),
           0,
           offsetof(Impl_, has_acted_) -
               offsetof(Impl_, initiative_) +
               sizeof(Impl_::has_acted_));
}
InitiativeEntry::~InitiativeEntry() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.InitiativeEntry)
  SharedDtor(*this);
}
inline void InitiativeEntry::SharedDtor(MessageLite& self) {
  InitiativeEntry& this_ = static_cast<InitiativeEntry&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.entity_id_.Destroy();
  this_._impl_.entity_type_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL InitiativeEntry::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) InitiativeEntry(arena);
}
constexpr auto InitiativeEntry::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(InitiativeEntry),
                                            alignof(InitiativeEntry));
}
constexpr auto InitiativeEntry::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_InitiativeEntry_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &InitiativeEntry::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<InitiativeEntry>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &InitiativeEntry::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<InitiativeEntry>(), &InitiativeEntry::ByteSizeLong,
              &InitiativeEntry::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_._cached_size_),
          false,
      },
      &InitiativeEntry::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull InitiativeEntry_class_data_ =
        InitiativeEntry::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
InitiativeEntry::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&InitiativeEntry_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(InitiativeEntry_class_data_.tc_table);
  return InitiativeEntry_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 63, 2>
InitiativeEntry::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    InitiativeEntry_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::InitiativeEntry>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string entity_id = 1 [json_name = "entityId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_.entity_id_)}},
    // string entity_type = 2 [json_name = "entityType"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_.entity_type_)}},
    // int32 initiative = 3 [json_name = "initiative"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(InitiativeEntry, _impl_.initiative_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_.initiative_)}},
    // int32 modifier = 4 [json_name = "modifier"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(InitiativeEntry, _impl_.modifier_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_.modifier_)}},
    // bool has_acted = 5 [json_name = "hasActed"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(InitiativeEntry, _impl_.has_acted_), 4>(),
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_.has_acted_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string entity_id = 1 [json_name = "entityId"];
    {PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_.entity_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string entity_type = 2 [json_name = "entityType"];
    {PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_.entity_type_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 initiative = 3 [json_name = "initiative"];
    {PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_.initiative_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 modifier = 4 [json_name = "modifier"];
    {PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_.modifier_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // bool has_acted = 5 [json_name = "hasActed"];
    {PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_.has_acted_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\42\11\13\0\0\0\0\0"
    "dnd5e.api.v1alpha1.InitiativeEntry"
    "entity_id"
    "entity_type"
  }},
};
PROTOBUF_NOINLINE void InitiativeEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.InitiativeEntry)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.entity_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.entity_type_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000001cU)) {
    ::memset(&_impl_.initiative_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.has_acted_) -
        reinterpret_cast<char*>(&_impl_.initiative_)) + sizeof(_impl_.has_acted_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL InitiativeEntry::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const InitiativeEntry& this_ = static_cast<const InitiativeEntry&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL InitiativeEntry::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const InitiativeEntry& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.InitiativeEntry)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string entity_id = 1 [json_name = "entityId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_entity_id().empty()) {
      const ::std::string& _s = this_._internal_entity_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.InitiativeEntry.entity_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string entity_type = 2 [json_name = "entityType"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_entity_type().empty()) {
      const ::std::string& _s = this_._internal_entity_type();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.InitiativeEntry.entity_type");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // int32 initiative = 3 [json_name = "initiative"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_initiative() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
              stream, this_._internal_initiative(), target);
    }
  }

  // int32 modifier = 4 [json_name = "modifier"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_modifier() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
              stream, this_._internal_modifier(), target);
    }
  }

  // bool has_acted = 5 [json_name = "hasActed"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_has_acted() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          5, this_._internal_has_acted(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.InitiativeEntry)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t InitiativeEntry::ByteSizeLong(const MessageLite& base) {
  const InitiativeEntry& this_ = static_cast<const InitiativeEntry&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t InitiativeEntry::ByteSizeLong() const {
  const InitiativeEntry& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.InitiativeEntry)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // string entity_id = 1 [json_name = "entityId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_entity_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_entity_id());
      }
    }
    // string entity_type = 2 [json_name = "entityType"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_entity_type().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_entity_type());
      }
    }
    // int32 initiative = 3 [json_name = "initiative"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_initiative() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_initiative());
      }
    }
    // int32 modifier = 4 [json_name = "modifier"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_modifier() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_modifier());
      }
    }
    // bool has_acted = 5 [json_name = "hasActed"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_has_acted() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void InitiativeEntry::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<InitiativeEntry*>(&to_msg);
  auto& from = static_cast<const InitiativeEntry&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.InitiativeEntry)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_entity_id().empty()) {
        _this->_internal_set_entity_id(from._internal_entity_id());
      } else {
        if (_this->_impl_.entity_id_.IsDefault()) {
          _this->_internal_set_entity_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_entity_type().empty()) {
        _this->_internal_set_entity_type(from._internal_entity_type());
      } else {
        if (_this->_impl_.entity_type_.IsDefault()) {
          _this->_internal_set_entity_type("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_initiative() != 0) {
        _this->_impl_.initiative_ = from._impl_.initiative_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_modifier() != 0) {
        _this->_impl_.modifier_ = from._impl_.modifier_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_has_acted() != 0) {
        _this->_impl_.has_acted_ = from._impl_.has_acted_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void InitiativeEntry::CopyFrom(const InitiativeEntry& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.InitiativeEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void InitiativeEntry::InternalSwap(InitiativeEntry* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.entity_id_, &other->_impl_.entity_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.entity_type_, &other->_impl_.entity_type_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_.has_acted_)
      + sizeof(InitiativeEntry::_impl_.has_acted_)
      - PROTOBUF_FIELD_OFFSET(InitiativeEntry, _impl_.initiative_)>(
          reinterpret_cast<char*>(&_impl_.initiative_),
          reinterpret_cast<char*>(&other->_impl_.initiative_));
}

::google::protobuf::Metadata InitiativeEntry::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class TurnState::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<TurnState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TurnState, _impl_._has_bits_);
};

void TurnState::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
TurnState::TurnState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TurnState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.TurnState)
}
PROTOBUF_NDEBUG_INLINE TurnState::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::TurnState& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        entity_id_(arena, from.entity_id_) {}

TurnState::TurnState(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const TurnState& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TurnState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TurnState* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.position_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.position_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, movement_used_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, movement_used_),
           offsetof(Impl_, reaction_available_) -
               offsetof(Impl_, movement_used_) +
               sizeof(Impl_::reaction_available_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.TurnState)
}
PROTOBUF_NDEBUG_INLINE TurnState::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        entity_id_(arena) {}

inline void TurnState::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, position_),
           0,
           offsetof(Impl_, reaction_available_) -
               offsetof(Impl_, position_) +
               sizeof(Impl_::reaction_available_));
}
TurnState::~TurnState() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.TurnState)
  SharedDtor(*this);
}
inline void TurnState::SharedDtor(MessageLite& self) {
  TurnState& this_ = static_cast<TurnState&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.entity_id_.Destroy();
  delete this_._impl_.position_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL TurnState::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) TurnState(arena);
}
constexpr auto TurnState::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(TurnState),
                                            alignof(TurnState));
}
constexpr auto TurnState::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_TurnState_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &TurnState::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<TurnState>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &TurnState::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<TurnState>(), &TurnState::ByteSizeLong,
              &TurnState::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(TurnState, _impl_._cached_size_),
          false,
      },
      &TurnState::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull TurnState_class_data_ =
        TurnState::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
TurnState::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&TurnState_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(TurnState_class_data_.tc_table);
  return TurnState_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 1, 46, 2>
TurnState::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TurnState, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    TurnState_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::TurnState>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string entity_id = 1 [json_name = "entityId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(TurnState, _impl_.entity_id_)}},
    // int32 movement_used = 2 [json_name = "movementUsed"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(TurnState, _impl_.movement_used_), 2>(),
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(TurnState, _impl_.movement_used_)}},
    // int32 movement_max = 3 [json_name = "movementMax"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(TurnState, _impl_.movement_max_), 3>(),
     {24, 3, 0,
      PROTOBUF_FIELD_OFFSET(TurnState, _impl_.movement_max_)}},
    // bool action_used = 4 [json_name = "actionUsed"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(TurnState, _impl_.action_used_), 4>(),
     {32, 4, 0,
      PROTOBUF_FIELD_OFFSET(TurnState, _impl_.action_used_)}},
    // bool bonus_action_used = 5 [json_name = "bonusActionUsed"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(TurnState, _impl_.bonus_action_used_), 5>(),
     {40, 5, 0,
      PROTOBUF_FIELD_OFFSET(TurnState, _impl_.bonus_action_used_)}},
    // bool reaction_available = 6 [json_name = "reactionAvailable"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(TurnState, _impl_.reaction_available_), 6>(),
     {48, 6, 0,
      PROTOBUF_FIELD_OFFSET(TurnState, _impl_.reaction_available_)}},
    // .api.v1alpha1.Position position = 7 [json_name = "position"];
    {::_pbi::TcParser::FastMtS1,
     {58, 1, 0,
      PROTOBUF_FIELD_OFFSET(TurnState, _impl_.position_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string entity_id = 1 [json_name = "entityId"];
    {PROTOBUF_FIELD_OFFSET(TurnState, _impl_.entity_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 movement_used = 2 [json_name = "movementUsed"];
    {PROTOBUF_FIELD_OFFSET(TurnState, _impl_.movement_used_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 movement_max = 3 [json_name = "movementMax"];
    {PROTOBUF_FIELD_OFFSET(TurnState, _impl_.movement_max_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // bool action_used = 4 [json_name = "actionUsed"];
    {PROTOBUF_FIELD_OFFSET(TurnState, _impl_.action_used_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool bonus_action_used = 5 [json_name = "bonusActionUsed"];
    {PROTOBUF_FIELD_OFFSET(TurnState, _impl_.bonus_action_used_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool reaction_available = 6 [json_name = "reactionAvailable"];
    {PROTOBUF_FIELD_OFFSET(TurnState, _impl_.reaction_available_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // .api.v1alpha1.Position position = 7 [json_name = "position"];
    {PROTOBUF_FIELD_OFFSET(TurnState, _impl_.position_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::api::v1alpha1::Position>()},
  }},
  {{
    "\34\11\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.TurnState"
    "entity_id"
  }},
};
PROTOBUF_NOINLINE void TurnState::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.TurnState)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.entity_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000007cU)) {
    ::memset(&_impl_.movement_used_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.reaction_available_) -
        reinterpret_cast<char*>(&_impl_.movement_used_)) + sizeof(_impl_.reaction_available_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL TurnState::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const TurnState& this_ = static_cast<const TurnState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL TurnState::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const TurnState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.TurnState)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string entity_id = 1 [json_name = "entityId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_entity_id().empty()) {
      const ::std::string& _s = this_._internal_entity_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.TurnState.entity_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // int32 movement_used = 2 [json_name = "movementUsed"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_movement_used() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
              stream, this_._internal_movement_used(), target);
    }
  }

  // int32 movement_max = 3 [json_name = "movementMax"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_movement_max() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
              stream, this_._internal_movement_max(), target);
    }
  }

  // bool action_used = 4 [json_name = "actionUsed"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_action_used() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          4, this_._internal_action_used(), target);
    }
  }

  // bool bonus_action_used = 5 [json_name = "bonusActionUsed"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (this_._internal_bonus_action_used() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          5, this_._internal_bonus_action_used(), target);
    }
  }

  // bool reaction_available = 6 [json_name = "reactionAvailable"];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    if (this_._internal_reaction_available() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          6, this_._internal_reaction_available(), target);
    }
  }

  // .api.v1alpha1.Position position = 7 [json_name = "position"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        7, *this_._impl_.position_, this_._impl_.position_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.TurnState)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t TurnState::ByteSizeLong(const MessageLite& base) {
  const TurnState& this_ = static_cast<const TurnState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t TurnState::ByteSizeLong() const {
  const TurnState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.TurnState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    // string entity_id = 1 [json_name = "entityId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_entity_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_entity_id());
      }
    }
    // .api.v1alpha1.Position position = 7 [json_name = "position"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.position_);
    }
    // int32 movement_used = 2 [json_name = "movementUsed"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_movement_used() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_movement_used());
      }
    }
    // int32 movement_max = 3 [json_name = "movementMax"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_movement_max() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_movement_max());
      }
    }
    // bool action_used = 4 [json_name = "actionUsed"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_action_used() != 0) {
        total_size += 2;
      }
    }
    // bool bonus_action_used = 5 [json_name = "bonusActionUsed"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (this_._internal_bonus_action_used() != 0) {
        total_size += 2;
      }
    }
    // bool reaction_available = 6 [json_name = "reactionAvailable"];
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (this_._internal_reaction_available() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void TurnState::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<TurnState*>(&to_msg);
  auto& from = static_cast<const TurnState&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.TurnState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_entity_id().empty()) {
        _this->_internal_set_entity_id(from._internal_entity_id());
      } else {
        if (_this->_impl_.entity_id_.IsDefault()) {
          _this->_internal_set_entity_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.position_ != nullptr);
      if (_this->_impl_.position_ == nullptr) {
        _this->_impl_.position_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.position_);
      } else {
        _this->_impl_.position_->MergeFrom(*from._impl_.position_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_movement_used() != 0) {
        _this->_impl_.movement_used_ = from._impl_.movement_used_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_movement_max() != 0) {
        _this->_impl_.movement_max_ = from._impl_.movement_max_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_action_used() != 0) {
        _this->_impl_.action_used_ = from._impl_.action_used_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (from._internal_bonus_action_used() != 0) {
        _this->_impl_.bonus_action_used_ = from._impl_.bonus_action_used_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (from._internal_reaction_available() != 0) {
        _this->_impl_.reaction_available_ = from._impl_.reaction_available_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void TurnState::CopyFrom(const TurnState& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.TurnState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TurnState::InternalSwap(TurnState* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.entity_id_, &other->_impl_.entity_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TurnState, _impl_.reaction_available_)
      + sizeof(TurnState::_impl_.reaction_available_)
      - PROTOBUF_FIELD_OFFSET(TurnState, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::google::protobuf::Metadata TurnState::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CombatState::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CombatState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CombatState, _impl_._has_bits_);
};

CombatState::CombatState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CombatState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.CombatState)
}
PROTOBUF_NDEBUG_INLINE CombatState::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::CombatState& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        turn_order_{visibility, arena, from.turn_order_},
        encounter_id_(arena, from.encounter_id_) {}

CombatState::CombatState(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CombatState& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CombatState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CombatState* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.current_turn_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.current_turn_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, round_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, round_),
           offsetof(Impl_, combat_ended_) -
               offsetof(Impl_, round_) +
               sizeof(Impl_::combat_ended_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.CombatState)
}
PROTOBUF_NDEBUG_INLINE CombatState::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        turn_order_{visibility, arena},
        encounter_id_(arena) {}

inline void CombatState::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, current_turn_),
           0,
           offsetof(Impl_, combat_ended_) -
               offsetof(Impl_, current_turn_) +
               sizeof(Impl_::combat_ended_));
}
CombatState::~CombatState() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.CombatState)
  SharedDtor(*this);
}
inline void CombatState::SharedDtor(MessageLite& self) {
  CombatState& this_ = static_cast<CombatState&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  delete this_._impl_.current_turn_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CombatState::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CombatState(arena);
}
constexpr auto CombatState::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CombatState, _impl_.turn_order_) +
          decltype(CombatState::_impl_.turn_order_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(CombatState), alignof(CombatState), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CombatState::PlacementNew_,
                                 sizeof(CombatState),
                                 alignof(CombatState));
  }
}
constexpr auto CombatState::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CombatState_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CombatState::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CombatState>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CombatState::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CombatState>(), &CombatState::ByteSizeLong,
              &CombatState::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CombatState, _impl_._cached_size_),
          false,
      },
      &CombatState::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CombatState_class_data_ =
        CombatState::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CombatState::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CombatState_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CombatState_class_data_.tc_table);
  return CombatState_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 2, 51, 2>
CombatState::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CombatState, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    CombatState_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(CombatState, _impl_.encounter_id_)}},
    // int32 round = 2 [json_name = "round"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CombatState, _impl_.round_), 3>(),
     {16, 3, 0,
      PROTOBUF_FIELD_OFFSET(CombatState, _impl_.round_)}},
    // repeated .dnd5e.api.v1alpha1.InitiativeEntry turn_order = 3 [json_name = "turnOrder"];
    {::_pbi::TcParser::FastMtR1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(CombatState, _impl_.turn_order_)}},
    // int32 active_index = 4 [json_name = "activeIndex"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CombatState, _impl_.active_index_), 4>(),
     {32, 4, 0,
      PROTOBUF_FIELD_OFFSET(CombatState, _impl_.active_index_)}},
    // .dnd5e.api.v1alpha1.TurnState current_turn = 5 [json_name = "currentTurn"];
    {::_pbi::TcParser::FastMtS1,
     {42, 2, 1,
      PROTOBUF_FIELD_OFFSET(CombatState, _impl_.current_turn_)}},
    // bool combat_started = 6 [json_name = "combatStarted"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CombatState, _impl_.combat_started_), 5>(),
     {48, 5, 0,
      PROTOBUF_FIELD_OFFSET(CombatState, _impl_.combat_started_)}},
    // bool combat_ended = 7 [json_name = "combatEnded"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CombatState, _impl_.combat_ended_), 6>(),
     {56, 6, 0,
      PROTOBUF_FIELD_OFFSET(CombatState, _impl_.combat_ended_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(CombatState, _impl_.encounter_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 round = 2 [json_name = "round"];
    {PROTOBUF_FIELD_OFFSET(CombatState, _impl_.round_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // repeated .dnd5e.api.v1alpha1.InitiativeEntry turn_order = 3 [json_name = "turnOrder"];
    {PROTOBUF_FIELD_OFFSET(CombatState, _impl_.turn_order_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 active_index = 4 [json_name = "activeIndex"];
    {PROTOBUF_FIELD_OFFSET(CombatState, _impl_.active_index_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // .dnd5e.api.v1alpha1.TurnState current_turn = 5 [json_name = "currentTurn"];
    {PROTOBUF_FIELD_OFFSET(CombatState, _impl_.current_turn_), _Internal::kHasBitsOffset + 2, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool combat_started = 6 [json_name = "combatStarted"];
    {PROTOBUF_FIELD_OFFSET(CombatState, _impl_.combat_started_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool combat_ended = 7 [json_name = "combatEnded"];
    {PROTOBUF_FIELD_OFFSET(CombatState, _impl_.combat_ended_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::InitiativeEntry>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::TurnState>()},
  }},
  {{
    "\36\14\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.CombatState"
    "encounter_id"
  }},
};
PROTOBUF_NOINLINE void CombatState::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.CombatState)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.turn_order_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.current_turn_ != nullptr);
      _impl_.current_turn_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000078U)) {
    ::memset(&_impl_.round_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.combat_ended_) -
        reinterpret_cast<char*>(&_impl_.round_)) + sizeof(_impl_.combat_ended_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CombatState::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CombatState& this_ = static_cast<const CombatState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CombatState::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CombatState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.CombatState)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.CombatState.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // int32 round = 2 [json_name = "round"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_round() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
              stream, this_._internal_round(), target);
    }
  }

  // repeated .dnd5e.api.v1alpha1.InitiativeEntry turn_order = 3 [json_name = "turnOrder"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_turn_order_size());
         i < n; i++) {
      const auto& repfield = this_._internal_turn_order().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              3, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // int32 active_index = 4 [json_name = "activeIndex"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_active_index() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
              stream, this_._internal_active_index(), target);
    }
  }

  // .dnd5e.api.v1alpha1.TurnState current_turn = 5 [json_name = "currentTurn"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.current_turn_, this_._impl_.current_turn_->GetCachedSize(), target,
        stream);
  }

  // bool combat_started = 6 [json_name = "combatStarted"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (this_._internal_combat_started() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          6, this_._internal_combat_started(), target);
    }
  }

  // bool combat_ended = 7 [json_name = "combatEnded"];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    if (this_._internal_combat_ended() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          7, this_._internal_combat_ended(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.CombatState)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CombatState::ByteSizeLong(const MessageLite& base) {
  const CombatState& this_ = static_cast<const CombatState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CombatState::ByteSizeLong() const {
  const CombatState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.CombatState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    // repeated .dnd5e.api.v1alpha1.InitiativeEntry turn_order = 3 [json_name = "turnOrder"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_turn_order_size();
      for (const auto& msg : this_._internal_turn_order()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // .dnd5e.api.v1alpha1.TurnState current_turn = 5 [json_name = "currentTurn"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.current_turn_);
    }
    // int32 round = 2 [json_name = "round"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_round() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_round());
      }
    }
    // int32 active_index = 4 [json_name = "activeIndex"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_active_index() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_active_index());
      }
    }
    // bool combat_started = 6 [json_name = "combatStarted"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (this_._internal_combat_started() != 0) {
        total_size += 2;
      }
    }
    // bool combat_ended = 7 [json_name = "combatEnded"];
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (this_._internal_combat_ended() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CombatState::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CombatState*>(&to_msg);
  auto& from = static_cast<const CombatState&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.CombatState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_turn_order()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_turn_order());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.current_turn_ != nullptr);
      if (_this->_impl_.current_turn_ == nullptr) {
        _this->_impl_.current_turn_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.current_turn_);
      } else {
        _this->_impl_.current_turn_->MergeFrom(*from._impl_.current_turn_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_round() != 0) {
        _this->_impl_.round_ = from._impl_.round_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_active_index() != 0) {
        _this->_impl_.active_index_ = from._impl_.active_index_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (from._internal_combat_started() != 0) {
        _this->_impl_.combat_started_ = from._impl_.combat_started_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (from._internal_combat_ended() != 0) {
        _this->_impl_.combat_ended_ = from._impl_.combat_ended_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CombatState::CopyFrom(const CombatState& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.CombatState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CombatState::InternalSwap(CombatState* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.turn_order_.InternalSwap(&other->_impl_.turn_order_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CombatState, _impl_.combat_ended_)
      + sizeof(CombatState::_impl_.combat_ended_)
      - PROTOBUF_FIELD_OFFSET(CombatState, _impl_.current_turn_)>(
          reinterpret_cast<char*>(&_impl_.current_turn_),
          reinterpret_cast<char*>(&other->_impl_.current_turn_));
}

::google::protobuf::Metadata CombatState::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class GetCombatStateRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<GetCombatStateRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(GetCombatStateRequest, _impl_._has_bits_);
};

GetCombatStateRequest::GetCombatStateRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GetCombatStateRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.GetCombatStateRequest)
}
PROTOBUF_NDEBUG_INLINE GetCombatStateRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::GetCombatStateRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        encounter_id_(arena, from.encounter_id_) {}

GetCombatStateRequest::GetCombatStateRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const GetCombatStateRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GetCombatStateRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  GetCombatStateRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.GetCombatStateRequest)
}
PROTOBUF_NDEBUG_INLINE GetCombatStateRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        encounter_id_(arena) {}

inline void GetCombatStateRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
GetCombatStateRequest::~GetCombatStateRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.GetCombatStateRequest)
  SharedDtor(*this);
}
inline void GetCombatStateRequest::SharedDtor(MessageLite& self) {
  GetCombatStateRequest& this_ = static_cast<GetCombatStateRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL GetCombatStateRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) GetCombatStateRequest(arena);
}
constexpr auto GetCombatStateRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(GetCombatStateRequest),
                                            alignof(GetCombatStateRequest));
}
constexpr auto GetCombatStateRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_GetCombatStateRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &GetCombatStateRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<GetCombatStateRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &GetCombatStateRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<GetCombatStateRequest>(), &GetCombatStateRequest::ByteSizeLong,
              &GetCombatStateRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(GetCombatStateRequest, _impl_._cached_size_),
          false,
      },
      &GetCombatStateRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull GetCombatStateRequest_class_data_ =
        GetCombatStateRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
GetCombatStateRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&GetCombatStateRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(GetCombatStateRequest_class_data_.tc_table);
  return GetCombatStateRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 61, 2>
GetCombatStateRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GetCombatStateRequest, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    GetCombatStateRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::GetCombatStateRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(GetCombatStateRequest, _impl_.encounter_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(GetCombatStateRequest, _impl_.encounter_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\50\14\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.GetCombatStateRequest"
    "encounter_id"
  }},
};
PROTOBUF_NOINLINE void GetCombatStateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.GetCombatStateRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.encounter_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL GetCombatStateRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const GetCombatStateRequest& this_ = static_cast<const GetCombatStateRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL GetCombatStateRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const GetCombatStateRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.GetCombatStateRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.GetCombatStateRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t GetCombatStateRequest::ByteSizeLong(const MessageLite& base) {
  const GetCombatStateRequest& this_ = static_cast<const GetCombatStateRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t GetCombatStateRequest::ByteSizeLong() const {
  const GetCombatStateRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.GetCombatStateRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // string encounter_id = 1 [json_name = "encounterId"];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void GetCombatStateRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<GetCombatStateRequest*>(&to_msg);
  auto& from = static_cast<const GetCombatStateRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.GetCombatStateRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!from._internal_encounter_id().empty()) {
      _this->_internal_set_encounter_id(from._internal_encounter_id());
    } else {
      if (_this->_impl_.encounter_id_.IsDefault()) {
        _this->_internal_set_encounter_id("");
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void GetCombatStateRequest::CopyFrom(const GetCombatStateRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.GetCombatStateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void GetCombatStateRequest::InternalSwap(GetCombatStateRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
}

::google::protobuf::Metadata GetCombatStateRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class GetCombatStateResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<GetCombatStateResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(GetCombatStateResponse, _impl_._has_bits_);
};

GetCombatStateResponse::GetCombatStateResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GetCombatStateResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.GetCombatStateResponse)
}
PROTOBUF_NDEBUG_INLINE GetCombatStateResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::GetCombatStateResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

GetCombatStateResponse::GetCombatStateResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const GetCombatStateResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GetCombatStateResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  GetCombatStateResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.room_ = (CheckHasBit(cached_has_bits, 0x00000001U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_)
                : nullptr;
  _impl_.combat_state_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.GetCombatStateResponse)
}
PROTOBUF_NDEBUG_INLINE GetCombatStateResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void GetCombatStateResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, room_),
           0,
           offsetof(Impl_, combat_state_) -
               offsetof(Impl_, room_) +
               sizeof(Impl_::combat_state_));
}
GetCombatStateResponse::~GetCombatStateResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.GetCombatStateResponse)
  SharedDtor(*this);
}
inline void GetCombatStateResponse::SharedDtor(MessageLite& self) {
  GetCombatStateResponse& this_ = static_cast<GetCombatStateResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.room_;
  delete this_._impl_.combat_state_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL GetCombatStateResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) GetCombatStateResponse(arena);
}
constexpr auto GetCombatStateResponse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(GetCombatStateResponse),
                                            alignof(GetCombatStateResponse));
}
constexpr auto GetCombatStateResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_GetCombatStateResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &GetCombatStateResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<GetCombatStateResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &GetCombatStateResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<GetCombatStateResponse>(), &GetCombatStateResponse::ByteSizeLong,
              &GetCombatStateResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(GetCombatStateResponse, _impl_._cached_size_),
          false,
      },
      &GetCombatStateResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull GetCombatStateResponse_class_data_ =
        GetCombatStateResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
GetCombatStateResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&GetCombatStateResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(GetCombatStateResponse_class_data_.tc_table);
  return GetCombatStateResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2>
GetCombatStateResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GetCombatStateResponse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    GetCombatStateResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::GetCombatStateResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1,
      PROTOBUF_FIELD_OFFSET(GetCombatStateResponse, _impl_.combat_state_)}},
    // .dnd5e.api.v1alpha1.Room room = 1 [json_name = "room"];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(GetCombatStateResponse, _impl_.room_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.Room room = 1 [json_name = "room"];
    {PROTOBUF_FIELD_OFFSET(GetCombatStateResponse, _impl_.room_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
    {PROTOBUF_FIELD_OFFSET(GetCombatStateResponse, _impl_.combat_state_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void GetCombatStateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.GetCombatStateResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(_impl_.room_ != nullptr);
      _impl_.room_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.combat_state_ != nullptr);
      _impl_.combat_state_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL GetCombatStateResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const GetCombatStateResponse& this_ = static_cast<const GetCombatStateResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL GetCombatStateResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const GetCombatStateResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.GetCombatStateResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .dnd5e.api.v1alpha1.Room room = 1 [json_name = "room"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.room_, this_._impl_.room_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.combat_state_, this_._impl_.combat_state_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.GetCombatStateResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t GetCombatStateResponse::ByteSizeLong(const MessageLite& base) {
  const GetCombatStateResponse& this_ = static_cast<const GetCombatStateResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t GetCombatStateResponse::ByteSizeLong() const {
  const GetCombatStateResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.GetCombatStateResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // .dnd5e.api.v1alpha1.Room room = 1 [json_name = "room"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.room_);
    }
    // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.combat_state_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void GetCombatStateResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<GetCombatStateResponse*>(&to_msg);
  auto& from = static_cast<const GetCombatStateResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.GetCombatStateResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(from._impl_.room_ != nullptr);
      if (_this->_impl_.room_ == nullptr) {
        _this->_impl_.room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_);
      } else {
        _this->_impl_.room_->MergeFrom(*from._impl_.room_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.combat_state_ != nullptr);
      if (_this->_impl_.combat_state_ == nullptr) {
        _this->_impl_.combat_state_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_);
      } else {
        _this->_impl_.combat_state_->MergeFrom(*from._impl_.combat_state_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void GetCombatStateResponse::CopyFrom(const GetCombatStateResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.GetCombatStateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void GetCombatStateResponse::InternalSwap(GetCombatStateResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetCombatStateResponse, _impl_.combat_state_)
      + sizeof(GetCombatStateResponse::_impl_.combat_state_)
      - PROTOBUF_FIELD_OFFSET(GetCombatStateResponse, _impl_.room_)>(
          reinterpret_cast<char*>(&_impl_.room_),
          reinterpret_cast<char*>(&other->_impl_.room_));
}

::google::protobuf::Metadata GetCombatStateResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class GetEncounterStateRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<GetEncounterStateRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(GetEncounterStateRequest, _impl_._has_bits_);
};

GetEncounterStateRequest::GetEncounterStateRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GetEncounterStateRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.GetEncounterStateRequest)
}
PROTOBUF_NDEBUG_INLINE GetEncounterStateRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::GetEncounterStateRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        encounter_id_(arena, from.encounter_id_),
        player_id_(arena, from.player_id_) {}

GetEncounterStateRequest::GetEncounterStateRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const GetEncounterStateRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GetEncounterStateRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  GetEncounterStateRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.GetEncounterStateRequest)
}
PROTOBUF_NDEBUG_INLINE GetEncounterStateRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        encounter_id_(arena),
        player_id_(arena) {}

inline void GetEncounterStateRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
GetEncounterStateRequest::~GetEncounterStateRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.GetEncounterStateRequest)
  SharedDtor(*this);
}
inline void GetEncounterStateRequest::SharedDtor(MessageLite& self) {
  GetEncounterStateRequest& this_ = static_cast<GetEncounterStateRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.player_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL GetEncounterStateRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) GetEncounterStateRequest(arena);
}
constexpr auto GetEncounterStateRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(GetEncounterStateRequest),
                                            alignof(GetEncounterStateRequest));
}
constexpr auto GetEncounterStateRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_GetEncounterStateRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &GetEncounterStateRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<GetEncounterStateRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &GetEncounterStateRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<GetEncounterStateRequest>(), &GetEncounterStateRequest::ByteSizeLong,
              &GetEncounterStateRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(GetEncounterStateRequest, _impl_._cached_size_),
          false,
      },
      &GetEncounterStateRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull GetEncounterStateRequest_class_data_ =
        GetEncounterStateRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
GetEncounterStateRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&GetEncounterStateRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(GetEncounterStateRequest_class_data_.tc_table);
  return GetEncounterStateRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 73, 2>
GetEncounterStateRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GetEncounterStateRequest, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    GetEncounterStateRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::GetEncounterStateRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string player_id = 2 [json_name = "playerId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateRequest, _impl_.player_id_)}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateRequest, _impl_.encounter_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateRequest, _impl_.encounter_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string player_id = 2 [json_name = "playerId"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateRequest, _impl_.player_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\53\14\11\0\0\0\0\0"
    "dnd5e.api.v1alpha1.GetEncounterStateRequest"
    "encounter_id"
    "player_id"
  }},
};
PROTOBUF_NOINLINE void GetEncounterStateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.GetEncounterStateRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.player_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL GetEncounterStateRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const GetEncounterStateRequest& this_ = static_cast<const GetEncounterStateRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL GetEncounterStateRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const GetEncounterStateRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.GetEncounterStateRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GetEncounterStateRequest.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string player_id = 2 [json_name = "playerId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_player_id().empty()) {
      const ::std::string& _s = this_._internal_player_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GetEncounterStateRequest.player_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.GetEncounterStateRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t GetEncounterStateRequest::ByteSizeLong(const MessageLite& base) {
  const GetEncounterStateRequest& this_ = static_cast<const GetEncounterStateRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t GetEncounterStateRequest::ByteSizeLong() const {
  const GetEncounterStateRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.GetEncounterStateRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // string player_id = 2 [json_name = "playerId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_player_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_player_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void GetEncounterStateRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<GetEncounterStateRequest*>(&to_msg);
  auto& from = static_cast<const GetEncounterStateRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.GetEncounterStateRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_player_id().empty()) {
        _this->_internal_set_player_id(from._internal_player_id());
      } else {
        if (_this->_impl_.player_id_.IsDefault()) {
          _this->_internal_set_player_id("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void GetEncounterStateRequest::CopyFrom(const GetEncounterStateRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.GetEncounterStateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void GetEncounterStateRequest::InternalSwap(GetEncounterStateRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
}

::google::protobuf::Metadata GetEncounterStateRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MonsterCombatState::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MonsterCombatState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_._has_bits_);
};

MonsterCombatState::MonsterCombatState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MonsterCombatState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.MonsterCombatState)
}
PROTOBUF_NDEBUG_INLINE MonsterCombatState::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::MonsterCombatState& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        monster_id_(arena, from.monster_id_),
        monster_name_(arena, from.monster_name_) {}

MonsterCombatState::MonsterCombatState(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MonsterCombatState& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MonsterCombatState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MonsterCombatState* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, current_hit_points_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, current_hit_points_),
           offsetof(Impl_, monster_type_) -
               offsetof(Impl_, current_hit_points_) +
               sizeof(Impl_::monster_type_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.MonsterCombatState)
}
PROTOBUF_NDEBUG_INLINE MonsterCombatState::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        monster_id_(arena),
        monster_name_(arena) {}

inline void MonsterCombatState::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, current_hit_points_),
           0,
           offsetof(Impl_, monster_type_) -
               offsetof(Impl_, current_hit_points_) +
               sizeof(Impl_::monster_type_));
}
MonsterCombatState::~MonsterCombatState() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.MonsterCombatState)
  SharedDtor(*this);
}
inline void MonsterCombatState::SharedDtor(MessageLite& self) {
  MonsterCombatState& this_ = static_cast<MonsterCombatState&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.monster_id_.Destroy();
  this_._impl_.monster_name_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MonsterCombatState::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MonsterCombatState(arena);
}
constexpr auto MonsterCombatState::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(MonsterCombatState),
                                            alignof(MonsterCombatState));
}
constexpr auto MonsterCombatState::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MonsterCombatState_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MonsterCombatState::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MonsterCombatState>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MonsterCombatState::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MonsterCombatState>(), &MonsterCombatState::ByteSizeLong,
              &MonsterCombatState::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_._cached_size_),
          false,
      },
      &MonsterCombatState::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MonsterCombatState_class_data_ =
        MonsterCombatState::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MonsterCombatState::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MonsterCombatState_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MonsterCombatState_class_data_.tc_table);
  return MonsterCombatState_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 68, 2>
MonsterCombatState::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    MonsterCombatState_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterCombatState>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string monster_id = 1 [json_name = "monsterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_.monster_id_)}},
    // string monster_name = 2 [json_name = "monsterName"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_.monster_name_)}},
    // int32 current_hit_points = 3 [json_name = "currentHitPoints"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MonsterCombatState, _impl_.current_hit_points_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_.current_hit_points_)}},
    // int32 max_hit_points = 4 [json_name = "maxHitPoints"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MonsterCombatState, _impl_.max_hit_points_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_.max_hit_points_)}},
    // .dnd5e.api.v1alpha1.MonsterType monster_type = 5 [json_name = "monsterType"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MonsterCombatState, _impl_.monster_type_), 4>(),
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_.monster_type_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string monster_id = 1 [json_name = "monsterId"];
    {PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_.monster_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string monster_name = 2 [json_name = "monsterName"];
    {PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_.monster_name_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 current_hit_points = 3 [json_name = "currentHitPoints"];
    {PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_.current_hit_points_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 max_hit_points = 4 [json_name = "maxHitPoints"];
    {PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_.max_hit_points_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // .dnd5e.api.v1alpha1.MonsterType monster_type = 5 [json_name = "monsterType"];
    {PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_.monster_type_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
    "\45\12\14\0\0\0\0\0"
    "dnd5e.api.v1alpha1.MonsterCombatState"
    "monster_id"
    "monster_name"
  }},
};
PROTOBUF_NOINLINE void MonsterCombatState::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.MonsterCombatState)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.monster_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.monster_name_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000001cU)) {
    ::memset(&_impl_.current_hit_points_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.monster_type_) -
        reinterpret_cast<char*>(&_impl_.current_hit_points_)) + sizeof(_impl_.monster_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MonsterCombatState::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MonsterCombatState& this_ = static_cast<const MonsterCombatState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MonsterCombatState::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MonsterCombatState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.MonsterCombatState)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string monster_id = 1 [json_name = "monsterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_monster_id().empty()) {
      const ::std::string& _s = this_._internal_monster_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MonsterCombatState.monster_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string monster_name = 2 [json_name = "monsterName"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_monster_name().empty()) {
      const ::std::string& _s = this_._internal_monster_name();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MonsterCombatState.monster_name");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // int32 current_hit_points = 3 [json_name = "currentHitPoints"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_current_hit_points() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
              stream, this_._internal_current_hit_points(), target);
    }
  }

  // int32 max_hit_points = 4 [json_name = "maxHitPoints"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_max_hit_points() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
              stream, this_._internal_max_hit_points(), target);
    }
  }

  // .dnd5e.api.v1alpha1.MonsterType monster_type = 5 [json_name = "monsterType"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_monster_type() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          5, this_._internal_monster_type(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.MonsterCombatState)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MonsterCombatState::ByteSizeLong(const MessageLite& base) {
  const MonsterCombatState& this_ = static_cast<const MonsterCombatState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MonsterCombatState::ByteSizeLong() const {
  const MonsterCombatState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.MonsterCombatState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // string monster_id = 1 [json_name = "monsterId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_monster_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_monster_id());
      }
    }
    // string monster_name = 2 [json_name = "monsterName"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_monster_name().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_monster_name());
      }
    }
    // int32 current_hit_points = 3 [json_name = "currentHitPoints"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_current_hit_points() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_current_hit_points());
      }
    }
    // int32 max_hit_points = 4 [json_name = "maxHitPoints"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_max_hit_points() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_max_hit_points());
      }
    }
    // .dnd5e.api.v1alpha1.MonsterType monster_type = 5 [json_name = "monsterType"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_monster_type() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_monster_type());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MonsterCombatState::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<MonsterCombatState*>(&to_msg);
  auto& from = static_cast<const MonsterCombatState&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.MonsterCombatState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_monster_id().empty()) {
        _this->_internal_set_monster_id(from._internal_monster_id());
      } else {
        if (_this->_impl_.monster_id_.IsDefault()) {
          _this->_internal_set_monster_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_monster_name().empty()) {
        _this->_internal_set_monster_name(from._internal_monster_name());
      } else {
        if (_this->_impl_.monster_name_.IsDefault()) {
          _this->_internal_set_monster_name("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_current_hit_points() != 0) {
        _this->_impl_.current_hit_points_ = from._impl_.current_hit_points_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_max_hit_points() != 0) {
        _this->_impl_.max_hit_points_ = from._impl_.max_hit_points_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_monster_type() != 0) {
        _this->_impl_.monster_type_ = from._impl_.monster_type_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void MonsterCombatState::CopyFrom(const MonsterCombatState& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.MonsterCombatState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MonsterCombatState::InternalSwap(MonsterCombatState* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.monster_id_, &other->_impl_.monster_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.monster_name_, &other->_impl_.monster_name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_.monster_type_)
      + sizeof(MonsterCombatState::_impl_.monster_type_)
      - PROTOBUF_FIELD_OFFSET(MonsterCombatState, _impl_.current_hit_points_)>(
          reinterpret_cast<char*>(&_impl_.current_hit_points_),
          reinterpret_cast<char*>(&other->_impl_.current_hit_points_));
}

::google::protobuf::Metadata MonsterCombatState::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class GetEncounterStateResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<GetEncounterStateResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_._has_bits_);
};

GetEncounterStateResponse::GetEncounterStateResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GetEncounterStateResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.GetEncounterStateResponse)
}
PROTOBUF_NDEBUG_INLINE GetEncounterStateResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::GetEncounterStateResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        party_{visibility, arena, from.party_},
        monsters_{visibility, arena, from.monsters_},
        doors_{visibility, arena, from.doors_},
        encounter_id_(arena, from.encounter_id_),
        join_code_(arena, from.join_code_),
        host_id_(arena, from.host_id_),
        last_event_id_(arena, from.last_event_id_),
        dungeon_id_(arena, from.dungeon_id_) {}

GetEncounterStateResponse::GetEncounterStateResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const GetEncounterStateResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GetEncounterStateResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  GetEncounterStateResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.combat_state_ = (CheckHasBit(cached_has_bits, 0x00000100U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_)
                : nullptr;
  _impl_.room_ = (CheckHasBit(cached_has_bits, 0x00000200U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_)
                : nullptr;
  _impl_.state_ = from._impl_.state_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.GetEncounterStateResponse)
}
PROTOBUF_NDEBUG_INLINE GetEncounterStateResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        party_{visibility, arena},
        monsters_{visibility, arena},
        doors_{visibility, arena},
        encounter_id_(arena),
        join_code_(arena),
        host_id_(arena),
        last_event_id_(arena),
        dungeon_id_(arena) {}

inline void GetEncounterStateResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, combat_state_),
           0,
           offsetof(Impl_, state_) -
               offsetof(Impl_, combat_state_) +
               sizeof(Impl_::state_));
}
GetEncounterStateResponse::~GetEncounterStateResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.GetEncounterStateResponse)
  SharedDtor(*this);
}
inline void GetEncounterStateResponse::SharedDtor(MessageLite& self) {
  GetEncounterStateResponse& this_ = static_cast<GetEncounterStateResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.join_code_.Destroy();
  this_._impl_.host_id_.Destroy();
  this_._impl_.last_event_id_.Destroy();
  this_._impl_.dungeon_id_.Destroy();
  delete this_._impl_.combat_state_;
  delete this_._impl_.room_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL GetEncounterStateResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) GetEncounterStateResponse(arena);
}
constexpr auto GetEncounterStateResponse::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.party_) +
          decltype(GetEncounterStateResponse::_impl_.party_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.monsters_) +
          decltype(GetEncounterStateResponse::_impl_.monsters_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.doors_) +
          decltype(GetEncounterStateResponse::_impl_.doors_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(GetEncounterStateResponse), alignof(GetEncounterStateResponse), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&GetEncounterStateResponse::PlacementNew_,
                                 sizeof(GetEncounterStateResponse),
                                 alignof(GetEncounterStateResponse));
  }
}
constexpr auto GetEncounterStateResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_GetEncounterStateResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &GetEncounterStateResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<GetEncounterStateResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &GetEncounterStateResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<GetEncounterStateResponse>(), &GetEncounterStateResponse::ByteSizeLong,
              &GetEncounterStateResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_._cached_size_),
          false,
      },
      &GetEncounterStateResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull GetEncounterStateResponse_class_data_ =
        GetEncounterStateResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
GetEncounterStateResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&GetEncounterStateResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(GetEncounterStateResponse_class_data_.tc_table);
  return GetEncounterStateResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 5, 112, 2>
GetEncounterStateResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_._has_bits_),
    0, // no _extensions_
    11, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294965248,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    GetEncounterStateResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::GetEncounterStateResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 3, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.encounter_id_)}},
    // .dnd5e.api.v1alpha1.EncounterState state = 2 [json_name = "state"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(GetEncounterStateResponse, _impl_.state_), 10>(),
     {16, 10, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.state_)}},
    // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
    {::_pbi::TcParser::FastMtR1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.party_)}},
    // string join_code = 4 [json_name = "joinCode"];
    {::_pbi::TcParser::FastUS1,
     {34, 4, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.join_code_)}},
    // string host_id = 5 [json_name = "hostId"];
    {::_pbi::TcParser::FastUS1,
     {42, 5, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.host_id_)}},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 6 [json_name = "combatState"];
    {::_pbi::TcParser::FastMtS1,
     {50, 8, 1,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.combat_state_)}},
    // .dnd5e.api.v1alpha1.Room room = 7 [json_name = "room"];
    {::_pbi::TcParser::FastMtS1,
     {58, 9, 2,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.room_)}},
    // repeated .dnd5e.api.v1alpha1.MonsterCombatState monsters = 8 [json_name = "monsters"];
    {::_pbi::TcParser::FastMtR1,
     {66, 1, 3,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.monsters_)}},
    // string last_event_id = 9 [json_name = "lastEventId"];
    {::_pbi::TcParser::FastUS1,
     {74, 6, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.last_event_id_)}},
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 10 [json_name = "doors"];
    {::_pbi::TcParser::FastMtR1,
     {82, 2, 4,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.doors_)}},
    // string dungeon_id = 11 [json_name = "dungeonId"];
    {::_pbi::TcParser::FastUS1,
     {90, 7, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.dungeon_id_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.encounter_id_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.EncounterState state = 2 [json_name = "state"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.state_), _Internal::kHasBitsOffset + 10, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.party_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // string join_code = 4 [json_name = "joinCode"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.join_code_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string host_id = 5 [json_name = "hostId"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.host_id_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 6 [json_name = "combatState"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.combat_state_), _Internal::kHasBitsOffset + 8, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.Room room = 7 [json_name = "room"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.room_), _Internal::kHasBitsOffset + 9, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.MonsterCombatState monsters = 8 [json_name = "monsters"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.monsters_), _Internal::kHasBitsOffset + 1, 3, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // string last_event_id = 9 [json_name = "lastEventId"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.last_event_id_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 10 [json_name = "doors"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.doors_), _Internal::kHasBitsOffset + 2, 4, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // string dungeon_id = 11 [json_name = "dungeonId"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.dungeon_id_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PartyMember>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterCombatState>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DoorInfo>()},
  }},
  {{
    "\54\14\0\0\11\7\0\0\0\15\0\12\0\0\0\0"
    "dnd5e.api.v1alpha1.GetEncounterStateResponse"
    "encounter_id"
    "join_code"
    "host_id"
    "last_event_id"
    "dungeon_id"
  }},
};
PROTOBUF_NOINLINE void GetEncounterStateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.GetEncounterStateResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.party_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.monsters_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.doors_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.join_code_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _impl_.host_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _impl_.last_event_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _impl_.dungeon_id_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000300U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      ABSL_DCHECK(_impl_.combat_state_ != nullptr);
      _impl_.combat_state_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      ABSL_DCHECK(_impl_.room_ != nullptr);
      _impl_.room_->Clear();
    }
  }
  _impl_.state_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL GetEncounterStateResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const GetEncounterStateResponse& this_ = static_cast<const GetEncounterStateResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL GetEncounterStateResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const GetEncounterStateResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.GetEncounterStateResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GetEncounterStateResponse.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.EncounterState state = 2 [json_name = "state"];
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    if (this_._internal_state() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          2, this_._internal_state(), target);
    }
  }

  // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_party_size());
         i < n; i++) {
      const auto& repfield = this_._internal_party().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              3, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // string join_code = 4 [json_name = "joinCode"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (!this_._internal_join_code().empty()) {
      const ::std::string& _s = this_._internal_join_code();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GetEncounterStateResponse.join_code");
      target = stream->WriteStringMaybeAliased(4, _s, target);
    }
  }

  // string host_id = 5 [json_name = "hostId"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (!this_._internal_host_id().empty()) {
      const ::std::string& _s = this_._internal_host_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GetEncounterStateResponse.host_id");
      target = stream->WriteStringMaybeAliased(5, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.CombatState combat_state = 6 [json_name = "combatState"];
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, *this_._impl_.combat_state_, this_._impl_.combat_state_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.Room room = 7 [json_name = "room"];
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        7, *this_._impl_.room_, this_._impl_.room_->GetCachedSize(), target,
        stream);
  }

  // repeated .dnd5e.api.v1alpha1.MonsterCombatState monsters = 8 [json_name = "monsters"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_monsters_size());
         i < n; i++) {
      const auto& repfield = this_._internal_monsters().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              8, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // string last_event_id = 9 [json_name = "lastEventId"];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    if (!this_._internal_last_event_id().empty()) {
      const ::std::string& _s = this_._internal_last_event_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GetEncounterStateResponse.last_event_id");
      target = stream->WriteStringMaybeAliased(9, _s, target);
    }
  }

  // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 10 [json_name = "doors"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_doors_size());
         i < n; i++) {
      const auto& repfield = this_._internal_doors().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              10, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // string dungeon_id = 11 [json_name = "dungeonId"];
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    if (!this_._internal_dungeon_id().empty()) {
      const ::std::string& _s = this_._internal_dungeon_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GetEncounterStateResponse.dungeon_id");
      target = stream->WriteStringMaybeAliased(11, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.GetEncounterStateResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t GetEncounterStateResponse::ByteSizeLong(const MessageLite& base) {
  const GetEncounterStateResponse& this_ = static_cast<const GetEncounterStateResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t GetEncounterStateResponse::ByteSizeLong() const {
  const GetEncounterStateResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.GetEncounterStateResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_party_size();
      for (const auto& msg : this_._internal_party()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .dnd5e.api.v1alpha1.MonsterCombatState monsters = 8 [json_name = "monsters"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 1UL * this_._internal_monsters_size();
      for (const auto& msg : this_._internal_monsters()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 10 [json_name = "doors"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size += 1UL * this_._internal_doors_size();
      for (const auto& msg : this_._internal_doors()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // string join_code = 4 [json_name = "joinCode"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (!this_._internal_join_code().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_join_code());
      }
    }
    // string host_id = 5 [json_name = "hostId"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (!this_._internal_host_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_host_id());
      }
    }
    // string last_event_id = 9 [json_name = "lastEventId"];
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (!this_._internal_last_event_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_last_event_id());
      }
    }
    // string dungeon_id = 11 [json_name = "dungeonId"];
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      if (!this_._internal_dungeon_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_dungeon_id());
      }
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000700U)) {
    // .dnd5e.api.v1alpha1.CombatState combat_state = 6 [json_name = "combatState"];
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.combat_state_);
    }
    // .dnd5e.api.v1alpha1.Room room = 7 [json_name = "room"];
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.room_);
    }
    // .dnd5e.api.v1alpha1.EncounterState state = 2 [json_name = "state"];
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      if (this_._internal_state() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_state());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void GetEncounterStateResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<GetEncounterStateResponse*>(&to_msg);
  auto& from = static_cast<const GetEncounterStateResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.GetEncounterStateResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_party()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_party());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_monsters()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_monsters());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_doors()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_doors());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (!from._internal_join_code().empty()) {
        _this->_internal_set_join_code(from._internal_join_code());
      } else {
        if (_this->_impl_.join_code_.IsDefault()) {
          _this->_internal_set_join_code("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (!from._internal_host_id().empty()) {
        _this->_internal_set_host_id(from._internal_host_id());
      } else {
        if (_this->_impl_.host_id_.IsDefault()) {
          _this->_internal_set_host_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (!from._internal_last_event_id().empty()) {
        _this->_internal_set_last_event_id(from._internal_last_event_id());
      } else {
        if (_this->_impl_.last_event_id_.IsDefault()) {
          _this->_internal_set_last_event_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      if (!from._internal_dungeon_id().empty()) {
        _this->_internal_set_dungeon_id(from._internal_dungeon_id());
      } else {
        if (_this->_impl_.dungeon_id_.IsDefault()) {
          _this->_internal_set_dungeon_id("");
        }
      }
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000700U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      ABSL_DCHECK(from._impl_.combat_state_ != nullptr);
      if (_this->_impl_.combat_state_ == nullptr) {
        _this->_impl_.combat_state_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_);
      } else {
        _this->_impl_.combat_state_->MergeFrom(*from._impl_.combat_state_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      ABSL_DCHECK(from._impl_.room_ != nullptr);
      if (_this->_impl_.room_ == nullptr) {
        _this->_impl_.room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_);
      } else {
        _this->_impl_.room_->MergeFrom(*from._impl_.room_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      if (from._internal_state() != 0) {
        _this->_impl_.state_ = from._impl_.state_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void GetEncounterStateResponse::CopyFrom(const GetEncounterStateResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.GetEncounterStateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void GetEncounterStateResponse::InternalSwap(GetEncounterStateResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.party_.InternalSwap(&other->_impl_.party_);
  _impl_.monsters_.InternalSwap(&other->_impl_.monsters_);
  _impl_.doors_.InternalSwap(&other->_impl_.doors_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.join_code_, &other->_impl_.join_code_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.host_id_, &other->_impl_.host_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.last_event_id_, &other->_impl_.last_event_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dungeon_id_, &other->_impl_.dungeon_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.state_)
      + sizeof(GetEncounterStateResponse::_impl_.state_)
      - PROTOBUF_FIELD_OFFSET(GetEncounterStateResponse, _impl_.combat_state_)>(
          reinterpret_cast<char*>(&_impl_.combat_state_),
          reinterpret_cast<char*>(&other->_impl_.combat_state_));
}

::google::protobuf::Metadata GetEncounterStateResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class GetEncounterHistoryRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<GetEncounterHistoryRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(GetEncounterHistoryRequest, _impl_._has_bits_);
};

GetEncounterHistoryRequest::GetEncounterHistoryRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GetEncounterHistoryRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.GetEncounterHistoryRequest)
}
PROTOBUF_NDEBUG_INLINE GetEncounterHistoryRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::GetEncounterHistoryRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        encounter_id_(arena, from.encounter_id_),
        up_to_event_id_(arena, from.up_to_event_id_) {}

GetEncounterHistoryRequest::GetEncounterHistoryRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const GetEncounterHistoryRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GetEncounterHistoryRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  GetEncounterHistoryRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.limit_ = from._impl_.limit_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.GetEncounterHistoryRequest)
}
PROTOBUF_NDEBUG_INLINE GetEncounterHistoryRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        encounter_id_(arena),
        up_to_event_id_(arena) {}

inline void GetEncounterHistoryRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.limit_ = {};
}
GetEncounterHistoryRequest::~GetEncounterHistoryRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.GetEncounterHistoryRequest)
  SharedDtor(*this);
}
inline void GetEncounterHistoryRequest::SharedDtor(MessageLite& self) {
  GetEncounterHistoryRequest& this_ = static_cast<GetEncounterHistoryRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.up_to_event_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL GetEncounterHistoryRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) GetEncounterHistoryRequest(arena);
}
constexpr auto GetEncounterHistoryRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(GetEncounterHistoryRequest),
                                            alignof(GetEncounterHistoryRequest));
}
constexpr auto GetEncounterHistoryRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_GetEncounterHistoryRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &GetEncounterHistoryRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<GetEncounterHistoryRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &GetEncounterHistoryRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<GetEncounterHistoryRequest>(), &GetEncounterHistoryRequest::ByteSizeLong,
              &GetEncounterHistoryRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(GetEncounterHistoryRequest, _impl_._cached_size_),
          false,
      },
      &GetEncounterHistoryRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull GetEncounterHistoryRequest_class_data_ =
        GetEncounterHistoryRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
GetEncounterHistoryRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&GetEncounterHistoryRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(GetEncounterHistoryRequest_class_data_.tc_table);
  return GetEncounterHistoryRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 80, 2>
GetEncounterHistoryRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GetEncounterHistoryRequest, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    GetEncounterHistoryRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::GetEncounterHistoryRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterHistoryRequest, _impl_.encounter_id_)}},
    // string up_to_event_id = 2 [json_name = "upToEventId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterHistoryRequest, _impl_.up_to_event_id_)}},
    // int32 limit = 3 [json_name = "limit"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(GetEncounterHistoryRequest, _impl_.limit_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterHistoryRequest, _impl_.limit_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterHistoryRequest, _impl_.encounter_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string up_to_event_id = 2 [json_name = "upToEventId"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterHistoryRequest, _impl_.up_to_event_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 limit = 3 [json_name = "limit"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterHistoryRequest, _impl_.limit_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
    "\55\14\16\0\0\0\0\0"
    "dnd5e.api.v1alpha1.GetEncounterHistoryRequest"
    "encounter_id"
    "up_to_event_id"
  }},
};
PROTOBUF_NOINLINE void GetEncounterHistoryRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.GetEncounterHistoryRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.up_to_event_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.limit_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL GetEncounterHistoryRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const GetEncounterHistoryRequest& this_ = static_cast<const GetEncounterHistoryRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL GetEncounterHistoryRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const GetEncounterHistoryRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.GetEncounterHistoryRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GetEncounterHistoryRequest.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string up_to_event_id = 2 [json_name = "upToEventId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_up_to_event_id().empty()) {
      const ::std::string& _s = this_._internal_up_to_event_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GetEncounterHistoryRequest.up_to_event_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // int32 limit = 3 [json_name = "limit"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_limit() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
              stream, this_._internal_limit(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.GetEncounterHistoryRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t GetEncounterHistoryRequest::ByteSizeLong(const MessageLite& base) {
  const GetEncounterHistoryRequest& this_ = static_cast<const GetEncounterHistoryRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t GetEncounterHistoryRequest::ByteSizeLong() const {
  const GetEncounterHistoryRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.GetEncounterHistoryRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // string up_to_event_id = 2 [json_name = "upToEventId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_up_to_event_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_up_to_event_id());
      }
    }
    // int32 limit = 3 [json_name = "limit"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_limit() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_limit());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void GetEncounterHistoryRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<GetEncounterHistoryRequest*>(&to_msg);
  auto& from = static_cast<const GetEncounterHistoryRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.GetEncounterHistoryRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_up_to_event_id().empty()) {
        _this->_internal_set_up_to_event_id(from._internal_up_to_event_id());
      } else {
        if (_this->_impl_.up_to_event_id_.IsDefault()) {
          _this->_internal_set_up_to_event_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_limit() != 0) {
        _this->_impl_.limit_ = from._impl_.limit_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void GetEncounterHistoryRequest::CopyFrom(const GetEncounterHistoryRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.GetEncounterHistoryRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void GetEncounterHistoryRequest::InternalSwap(GetEncounterHistoryRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.up_to_event_id_, &other->_impl_.up_to_event_id_, arena);
  swap(_impl_.limit_, other->_impl_.limit_);
}

::google::protobuf::Metadata GetEncounterHistoryRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class GetEncounterHistoryResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<GetEncounterHistoryResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(GetEncounterHistoryResponse, _impl_._has_bits_);
};

GetEncounterHistoryResponse::GetEncounterHistoryResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GetEncounterHistoryResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.GetEncounterHistoryResponse)
}
PROTOBUF_NDEBUG_INLINE GetEncounterHistoryResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::GetEncounterHistoryResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        events_{visibility, arena, from.events_},
        last_event_id_(arena, from.last_event_id_) {}

GetEncounterHistoryResponse::GetEncounterHistoryResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const GetEncounterHistoryResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GetEncounterHistoryResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  GetEncounterHistoryResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.has_more_ = from._impl_.has_more_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.GetEncounterHistoryResponse)
}
PROTOBUF_NDEBUG_INLINE GetEncounterHistoryResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        events_{visibility, arena},
        last_event_id_(arena) {}

inline void GetEncounterHistoryResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.has_more_ = {};
}
GetEncounterHistoryResponse::~GetEncounterHistoryResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.GetEncounterHistoryResponse)
  SharedDtor(*this);
}
inline void GetEncounterHistoryResponse::SharedDtor(MessageLite& self) {
  GetEncounterHistoryResponse& this_ = static_cast<GetEncounterHistoryResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.last_event_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL GetEncounterHistoryResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) GetEncounterHistoryResponse(arena);
}
constexpr auto GetEncounterHistoryResponse::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(GetEncounterHistoryResponse, _impl_.events_) +
          decltype(GetEncounterHistoryResponse::_impl_.events_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(GetEncounterHistoryResponse), alignof(GetEncounterHistoryResponse), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&GetEncounterHistoryResponse::PlacementNew_,
                                 sizeof(GetEncounterHistoryResponse),
                                 alignof(GetEncounterHistoryResponse));
  }
}
constexpr auto GetEncounterHistoryResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_GetEncounterHistoryResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &GetEncounterHistoryResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<GetEncounterHistoryResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &GetEncounterHistoryResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<GetEncounterHistoryResponse>(), &GetEncounterHistoryResponse::ByteSizeLong,
              &GetEncounterHistoryResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(GetEncounterHistoryResponse, _impl_._cached_size_),
          false,
      },
      &GetEncounterHistoryResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull GetEncounterHistoryResponse_class_data_ =
        GetEncounterHistoryResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
GetEncounterHistoryResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&GetEncounterHistoryResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(GetEncounterHistoryResponse_class_data_.tc_table);
  return GetEncounterHistoryResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 68, 2>
GetEncounterHistoryResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GetEncounterHistoryResponse, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    GetEncounterHistoryResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::GetEncounterHistoryResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .dnd5e.api.v1alpha1.EncounterEvent events = 1 [json_name = "events"];
    {::_pbi::TcParser::FastMtR1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterHistoryResponse, _impl_.events_)}},
    // bool has_more = 2 [json_name = "hasMore"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(GetEncounterHistoryResponse, _impl_.has_more_), 2>(),
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterHistoryResponse, _impl_.has_more_)}},
    // string last_event_id = 3 [json_name = "lastEventId"];
    {::_pbi::TcParser::FastUS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(GetEncounterHistoryResponse, _impl_.last_event_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.EncounterEvent events = 1 [json_name = "events"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterHistoryResponse, _impl_.events_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool has_more = 2 [json_name = "hasMore"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterHistoryResponse, _impl_.has_more_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // string last_event_id = 3 [json_name = "lastEventId"];
    {PROTOBUF_FIELD_OFFSET(GetEncounterHistoryResponse, _impl_.last_event_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EncounterEvent>()},
  }},
  {{
    "\56\0\0\15\0\0\0\0"
    "dnd5e.api.v1alpha1.GetEncounterHistoryResponse"
    "last_event_id"
  }},
};
PROTOBUF_NOINLINE void GetEncounterHistoryResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.GetEncounterHistoryResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.events_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.last_event_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.has_more_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL GetEncounterHistoryResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const GetEncounterHistoryResponse& this_ = static_cast<const GetEncounterHistoryResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL GetEncounterHistoryResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const GetEncounterHistoryResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.GetEncounterHistoryResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated .dnd5e.api.v1alpha1.EncounterEvent events = 1 [json_name = "events"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_events_size());
         i < n; i++) {
      const auto& repfield = this_._internal_events().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              1, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // bool has_more = 2 [json_name = "hasMore"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_has_more() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          2, this_._internal_has_more(), target);
    }
  }

  // string last_event_id = 3 [json_name = "lastEventId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_last_event_id().empty()) {
      const ::std::string& _s = this_._internal_last_event_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GetEncounterHistoryResponse.last_event_id");
      target = stream->WriteStringMaybeAliased(3, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.GetEncounterHistoryResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t GetEncounterHistoryResponse::ByteSizeLong(const MessageLite& base) {
  const GetEncounterHistoryResponse& this_ = static_cast<const GetEncounterHistoryResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t GetEncounterHistoryResponse::ByteSizeLong() const {
  const GetEncounterHistoryResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.GetEncounterHistoryResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated .dnd5e.api.v1alpha1.EncounterEvent events = 1 [json_name = "events"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_events_size();
      for (const auto& msg : this_._internal_events()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string last_event_id = 3 [json_name = "lastEventId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_last_event_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_last_event_id());
      }
    }
    // bool has_more = 2 [json_name = "hasMore"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_has_more() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void GetEncounterHistoryResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<GetEncounterHistoryResponse*>(&to_msg);
  auto& from = static_cast<const GetEncounterHistoryResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.GetEncounterHistoryResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_events()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_events());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_last_event_id().empty()) {
        _this->_internal_set_last_event_id(from._internal_last_event_id());
      } else {
        if (_this->_impl_.last_event_id_.IsDefault()) {
          _this->_internal_set_last_event_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_has_more() != 0) {
        _this->_impl_.has_more_ = from._impl_.has_more_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void GetEncounterHistoryResponse::CopyFrom(const GetEncounterHistoryResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.GetEncounterHistoryResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void GetEncounterHistoryResponse::InternalSwap(GetEncounterHistoryResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.events_.InternalSwap(&other->_impl_.events_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.last_event_id_, &other->_impl_.last_event_id_, arena);
  swap(_impl_.has_more_, other->_impl_.has_more_);
}

::google::protobuf::Metadata GetEncounterHistoryResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MoveCharacterRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MoveCharacterRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MoveCharacterRequest, _impl_._has_bits_);
};

void MoveCharacterRequest::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
MoveCharacterRequest::MoveCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MoveCharacterRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.MoveCharacterRequest)
}
PROTOBUF_NDEBUG_INLINE MoveCharacterRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::MoveCharacterRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        path_{visibility, arena, from.path_},
        encounter_id_(arena, from.encounter_id_),
        entity_id_(arena, from.entity_id_) {}

MoveCharacterRequest::MoveCharacterRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MoveCharacterRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MoveCharacterRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MoveCharacterRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.MoveCharacterRequest)
}
PROTOBUF_NDEBUG_INLINE MoveCharacterRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        path_{visibility, arena},
        encounter_id_(arena),
        entity_id_(arena) {}

inline void MoveCharacterRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
MoveCharacterRequest::~MoveCharacterRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.MoveCharacterRequest)
  SharedDtor(*this);
}
inline void MoveCharacterRequest::SharedDtor(MessageLite& self) {
  MoveCharacterRequest& this_ = static_cast<MoveCharacterRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.entity_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MoveCharacterRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MoveCharacterRequest(arena);
}
constexpr auto MoveCharacterRequest::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(MoveCharacterRequest, _impl_.path_) +
          decltype(MoveCharacterRequest::_impl_.path_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(MoveCharacterRequest), alignof(MoveCharacterRequest), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&MoveCharacterRequest::PlacementNew_,
                                 sizeof(MoveCharacterRequest),
                                 alignof(MoveCharacterRequest));
  }
}
constexpr auto MoveCharacterRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MoveCharacterRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MoveCharacterRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MoveCharacterRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MoveCharacterRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MoveCharacterRequest>(), &MoveCharacterRequest::ByteSizeLong,
              &MoveCharacterRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MoveCharacterRequest, _impl_._cached_size_),
          false,
      },
      &MoveCharacterRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MoveCharacterRequest_class_data_ =
        MoveCharacterRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MoveCharacterRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MoveCharacterRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MoveCharacterRequest_class_data_.tc_table);
  return MoveCharacterRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 69, 2>
MoveCharacterRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MoveCharacterRequest, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MoveCharacterRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MoveCharacterRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(MoveCharacterRequest, _impl_.encounter_id_)}},
    // string entity_id = 2 [json_name = "entityId"];
    {::_pbi::TcParser::FastUS1,
     {18, 2, 0,
      PROTOBUF_FIELD_OFFSET(MoveCharacterRequest, _impl_.entity_id_)}},
    // repeated .api.v1alpha1.Position path = 3 [json_name = "path"];
    {::_pbi::TcParser::FastMtR1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(MoveCharacterRequest, _impl_.path_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(MoveCharacterRequest, _impl_.encounter_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string entity_id = 2 [json_name = "entityId"];
    {PROTOBUF_FIELD_OFFSET(MoveCharacterRequest, _impl_.entity_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .api.v1alpha1.Position path = 3 [json_name = "path"];
    {PROTOBUF_FIELD_OFFSET(MoveCharacterRequest, _impl_.path_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::api::v1alpha1::Position>()},
  }},
  {{
    "\47\14\11\0\0\0\0\0"
    "dnd5e.api.v1alpha1.MoveCharacterRequest"
    "encounter_id"
    "entity_id"
  }},
};
PROTOBUF_NOINLINE void MoveCharacterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.MoveCharacterRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.path_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.entity_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MoveCharacterRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MoveCharacterRequest& this_ = static_cast<const MoveCharacterRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MoveCharacterRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MoveCharacterRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.MoveCharacterRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string entity_id = 2 [json_name = "entityId"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_entity_id().empty()) {
      const ::std::string& _s = this_._internal_entity_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // repeated .api.v1alpha1.Position path = 3 [json_name = "path"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_path_size());
         i < n; i++) {
      const auto& repfield = this_._internal_path().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              3, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.MoveCharacterRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MoveCharacterRequest::ByteSizeLong(const MessageLite& base) {
  const MoveCharacterRequest& this_ = static_cast<const MoveCharacterRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MoveCharacterRequest::ByteSizeLong() const {
  const MoveCharacterRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.MoveCharacterRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated .api.v1alpha1.Position path = 3 [json_name = "path"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_path_size();
      for (const auto& msg : this_._internal_path()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // string entity_id = 2 [json_name = "entityId"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!this_._internal_entity_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_entity_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MoveCharacterRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<MoveCharacterRequest*>(&to_msg);
  auto& from = static_cast<const MoveCharacterRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.MoveCharacterRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_path()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_path());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!from._internal_entity_id().empty()) {
        _this->_internal_set_entity_id(from._internal_entity_id());
      } else {
        if (_this->_impl_.entity_id_.IsDefault()) {
          _this->_internal_set_entity_id("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void MoveCharacterRequest::CopyFrom(const MoveCharacterRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.MoveCharacterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MoveCharacterRequest::InternalSwap(MoveCharacterRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.path_.InternalSwap(&other->_impl_.path_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.entity_id_, &other->_impl_.entity_id_, arena);
}

::google::protobuf::Metadata MoveCharacterRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
MovementError_DetailsEntry_DoNotUse::MovementError_DetailsEntry_DoNotUse()
    : SuperType(MovementError_DetailsEntry_DoNotUse_class_data_.base()) {}
MovementError_DetailsEntry_DoNotUse::MovementError_DetailsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
    : SuperType(arena, MovementError_DetailsEntry_DoNotUse_class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
MovementError_DetailsEntry_DoNotUse::MovementError_DetailsEntry_DoNotUse() : SuperType() {}
MovementError_DetailsEntry_DoNotUse::MovementError_DetailsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
inline void* PROTOBUF_NONNULL MovementError_DetailsEntry_DoNotUse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MovementError_DetailsEntry_DoNotUse(arena);
}
constexpr auto MovementError_DetailsEntry_DoNotUse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(MovementError_DetailsEntry_DoNotUse),
                                            alignof(MovementError_DetailsEntry_DoNotUse));
}
constexpr auto MovementError_DetailsEntry_DoNotUse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MovementError_DetailsEntry_DoNotUse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MovementError_DetailsEntry_DoNotUse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MovementError_DetailsEntry_DoNotUse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MovementError_DetailsEntry_DoNotUse::SharedDtor,
          static_cast<void (::google::protobuf::MessageLite::*)()>(&MovementError_DetailsEntry_DoNotUse::ClearImpl),
              ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
              ,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MovementError_DetailsEntry_DoNotUse, _impl_._cached_size_),
          false,
      },
      &MovementError_DetailsEntry_DoNotUse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MovementError_DetailsEntry_DoNotUse_class_data_ =
        MovementError_DetailsEntry_DoNotUse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MovementError_DetailsEntry_DoNotUse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MovementError_DetailsEntry_DoNotUse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MovementError_DetailsEntry_DoNotUse_class_data_.tc_table);
  return MovementError_DetailsEntry_DoNotUse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 62, 2>
MovementError_DetailsEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MovementError_DetailsEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    MovementError_DetailsEntry_DoNotUse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MovementError_DetailsEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2 [json_name = "value"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(MovementError_DetailsEntry_DoNotUse, _impl_.value_)}},
    // string key = 1 [json_name = "key"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(MovementError_DetailsEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1 [json_name = "key"];
    {PROTOBUF_FIELD_OFFSET(MovementError_DetailsEntry_DoNotUse, _impl_.key_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2 [json_name = "value"];
    {PROTOBUF_FIELD_OFFSET(MovementError_DetailsEntry_DoNotUse, _impl_.value_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\55\3\5\0\0\0\0\0"
    "dnd5e.api.v1alpha1.MovementError.DetailsEntry"
    "key"
    "value"
  }},
};
// ===================================================================

class MovementError::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MovementError>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MovementError, _impl_._has_bits_);
};

MovementError::MovementError(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MovementError_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.MovementError)
}
PROTOBUF_NDEBUG_INLINE MovementError::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::MovementError& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_),
        details_{visibility, arena, from.details_} {}

MovementError::MovementError(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MovementError& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MovementError_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MovementError* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.code_ = from._impl_.code_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.MovementError)
}
PROTOBUF_NDEBUG_INLINE MovementError::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        message_(arena),
        details_{visibility, arena} {}

inline void MovementError::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.code_ = {};
}
MovementError::~MovementError() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.MovementError)
  SharedDtor(*this);
}
inline void MovementError::SharedDtor(MessageLite& self) {
  MovementError& this_ = static_cast<MovementError&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.message_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MovementError::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MovementError(arena);
}
constexpr auto MovementError::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(MovementError, _impl_.details_) +
          decltype(MovementError::_impl_.details_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(MovementError), alignof(MovementError), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&MovementError::PlacementNew_,
                                 sizeof(MovementError),
                                 alignof(MovementError));
  }
}
constexpr auto MovementError::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MovementError_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MovementError::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MovementError>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MovementError::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MovementError>(), &MovementError::ByteSizeLong,
              &MovementError::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MovementError, _impl_._cached_size_),
          false,
      },
      &MovementError::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MovementError_class_data_ =
        MovementError::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MovementError::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MovementError_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MovementError_class_data_.tc_table);
  return MovementError_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 3, 1, 55, 2>
MovementError::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MovementError, _impl_._has_bits_),
    0, // no _extensions_
    3, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MovementError_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MovementError>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string message = 2 [json_name = "message"];
    {::_pbi::TcParser::FastUS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(MovementError, _impl_.message_)}},
    // .dnd5e.api.v1alpha1.MovementError.ErrorCode code = 1 [json_name = "code"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MovementError, _impl_.code_), 1>(),
     {8, 1, 0,
      PROTOBUF_FIELD_OFFSET(MovementError, _impl_.code_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.MovementError.ErrorCode code = 1 [json_name = "code"];
    {PROTOBUF_FIELD_OFFSET(MovementError, _impl_.code_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // string message = 2 [json_name = "message"];
    {PROTOBUF_FIELD_OFFSET(MovementError, _impl_.message_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // map<string, string> details = 3 [json_name = "details"];
    {PROTOBUF_FIELD_OFFSET(MovementError, _impl_.details_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
  }},
  {{
      {::_pbi::TcParser::GetMapAuxInfo(
          1, 0, 9, 9, 0)},
  }},
  {{
    "\40\0\7\7\0\0\0\0"
    "dnd5e.api.v1alpha1.MovementError"
    "message"
    "details"
  }},
};
PROTOBUF_NOINLINE void MovementError::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.MovementError)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000006U)) {
    _impl_.code_ = 0;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.details_.Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MovementError::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MovementError& this_ = static_cast<const MovementError&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MovementError::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MovementError& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.MovementError)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .dnd5e.api.v1alpha1.MovementError.ErrorCode code = 1 [json_name = "code"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (this_._internal_code() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          1, this_._internal_code(), target);
    }
  }

  // string message = 2 [json_name = "message"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_message().empty()) {
      const ::std::string& _s = this_._internal_message();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MovementError.message");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // map<string, string> details = 3 [json_name = "details"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_details().empty()) {
      using MapType = ::google::protobuf::Map<::std::string, ::std::string>;
      using WireHelper = _pbi::MapEntryFuncs<::std::string, ::std::string,
                                     _pbi::WireFormatLite::TYPE_STRING,
                                     _pbi::WireFormatLite::TYPE_STRING>;
      const auto& field = this_._internal_details();

      if (stream->IsSerializationDeterministic() && field.size() > 1) {
        for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
          target = WireHelper::InternalSerialize(
              3, entry.first, entry.second, target, stream);
          ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
              entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MovementError.details");
          ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
              entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MovementError.details");
        }
      } else {
        for (const auto& entry : field) {
          target = WireHelper::InternalSerialize(
              3, entry.first, entry.second, target, stream);
          ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
              entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MovementError.details");
          ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
              entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MovementError.details");
        }
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.MovementError)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MovementError::ByteSizeLong(const MessageLite& base) {
  const MovementError& this_ = static_cast<const MovementError&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MovementError::ByteSizeLong() const {
  const MovementError& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.MovementError)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // string message = 2 [json_name = "message"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_message().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_message());
      }
    }
    // .dnd5e.api.v1alpha1.MovementError.ErrorCode code = 1 [json_name = "code"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (this_._internal_code() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_code());
      }
    }
    // map<string, string> details = 3 [json_name = "details"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_details_size());
      for (const auto& entry : this_._internal_details()) {
        total_size += _pbi::MapEntryFuncs<::std::string, ::std::string,
                                       _pbi::WireFormatLite::TYPE_STRING,
                                       _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MovementError::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<MovementError*>(&to_msg);
  auto& from = static_cast<const MovementError&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.MovementError)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_message().empty()) {
        _this->_internal_set_message(from._internal_message());
      } else {
        if (_this->_impl_.message_.IsDefault()) {
          _this->_internal_set_message("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (from._internal_code() != 0) {
        _this->_impl_.code_ = from._impl_.code_;
      }
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_impl_.details_.MergeFrom(from._impl_.details_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void MovementError::CopyFrom(const MovementError& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.MovementError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MovementError::InternalSwap(MovementError* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  swap(_impl_.code_, other->_impl_.code_);
  _impl_.details_.InternalSwap(&other->_impl_.details_);
}

::google::protobuf::Metadata MovementError::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MoveCharacterResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MoveCharacterResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_._has_bits_);
};

void MoveCharacterResponse::clear_final_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.final_position_ != nullptr) _impl_.final_position_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
MoveCharacterResponse::MoveCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MoveCharacterResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.MoveCharacterResponse)
}
PROTOBUF_NDEBUG_INLINE MoveCharacterResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::MoveCharacterResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        stop_reason_(arena, from.stop_reason_) {}

MoveCharacterResponse::MoveCharacterResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MoveCharacterResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MoveCharacterResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MoveCharacterResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.error_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.error_)
                : nullptr;
  _impl_.final_position_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.final_position_)
                : nullptr;
  _impl_.updated_room_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_room_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, success_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, success_),
           offsetof(Impl_, movement_remaining_) -
               offsetof(Impl_, success_) +
               sizeof(Impl_::movement_remaining_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.MoveCharacterResponse)
}
PROTOBUF_NDEBUG_INLINE MoveCharacterResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        stop_reason_(arena) {}

inline void MoveCharacterResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, error_),
           0,
           offsetof(Impl_, movement_remaining_) -
               offsetof(Impl_, error_) +
               sizeof(Impl_::movement_remaining_));
}
MoveCharacterResponse::~MoveCharacterResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.MoveCharacterResponse)
  SharedDtor(*this);
}
inline void MoveCharacterResponse::SharedDtor(MessageLite& self) {
  MoveCharacterResponse& this_ = static_cast<MoveCharacterResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.stop_reason_.Destroy();
  delete this_._impl_.error_;
  delete this_._impl_.final_position_;
  delete this_._impl_.updated_room_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MoveCharacterResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MoveCharacterResponse(arena);
}
constexpr auto MoveCharacterResponse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(MoveCharacterResponse),
                                            alignof(MoveCharacterResponse));
}
constexpr auto MoveCharacterResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MoveCharacterResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MoveCharacterResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MoveCharacterResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MoveCharacterResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MoveCharacterResponse>(), &MoveCharacterResponse::ByteSizeLong,
              &MoveCharacterResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_._cached_size_),
          false,
      },
      &MoveCharacterResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MoveCharacterResponse_class_data_ =
        MoveCharacterResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MoveCharacterResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MoveCharacterResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MoveCharacterResponse_class_data_.tc_table);
  return MoveCharacterResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 3, 60, 2>
MoveCharacterResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MoveCharacterResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MoveCharacterResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // bool success = 1 [json_name = "success"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MoveCharacterResponse, _impl_.success_), 4>(),
     {8, 4, 0,
      PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.success_)}},
    // .dnd5e.api.v1alpha1.MovementError error = 2 [json_name = "error"];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.error_)}},
    // .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 1,
      PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.final_position_)}},
    // int32 movement_remaining = 4 [json_name = "movementRemaining"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MoveCharacterResponse, _impl_.movement_remaining_), 5>(),
     {32, 5, 0,
      PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.movement_remaining_)}},
    // string stop_reason = 5 [json_name = "stopReason"];
    {::_pbi::TcParser::FastUS1,
     {42, 0, 0,
      PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.stop_reason_)}},
    // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
    {::_pbi::TcParser::FastMtS1,
     {50, 3, 2,
      PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.updated_room_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // bool success = 1 [json_name = "success"];
    {PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.success_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // .dnd5e.api.v1alpha1.MovementError error = 2 [json_name = "error"];
    {PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.error_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
    {PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.final_position_), _Internal::kHasBitsOffset + 2, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 movement_remaining = 4 [json_name = "movementRemaining"];
    {PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.movement_remaining_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // string stop_reason = 5 [json_name = "stopReason"];
    {PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.stop_reason_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
    {PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.updated_room_), _Internal::kHasBitsOffset + 3, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MovementError>()},
      {::_pbi::TcParser::GetTable<::api::v1alpha1::Position>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
  }},
  {{
    "\50\0\0\0\0\13\0\0"
    "dnd5e.api.v1alpha1.MoveCharacterResponse"
    "stop_reason"
  }},
};
PROTOBUF_NOINLINE void MoveCharacterResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.MoveCharacterResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.stop_reason_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.error_ != nullptr);
      _impl_.error_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.final_position_ != nullptr);
      _impl_.final_position_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.updated_room_ != nullptr);
      _impl_.updated_room_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000030U)) {
    ::memset(&_impl_.success_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.movement_remaining_) -
        reinterpret_cast<char*>(&_impl_.success_)) + sizeof(_impl_.movement_remaining_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MoveCharacterResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MoveCharacterResponse& this_ = static_cast<const MoveCharacterResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MoveCharacterResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MoveCharacterResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.MoveCharacterResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // bool success = 1 [json_name = "success"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_success() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          1, this_._internal_success(), target);
    }
  }

  // .dnd5e.api.v1alpha1.MovementError error = 2 [json_name = "error"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.error_, this_._impl_.error_->GetCachedSize(), target,
        stream);
  }

  // .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.final_position_, this_._impl_.final_position_->GetCachedSize(), target,
        stream);
  }

  // int32 movement_remaining = 4 [json_name = "movementRemaining"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (this_._internal_movement_remaining() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
              stream, this_._internal_movement_remaining(), target);
    }
  }

  // string stop_reason = 5 [json_name = "stopReason"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_stop_reason().empty()) {
      const ::std::string& _s = this_._internal_stop_reason();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MoveCharacterResponse.stop_reason");
      target = stream->WriteStringMaybeAliased(5, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, *this_._impl_.updated_room_, this_._impl_.updated_room_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.MoveCharacterResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MoveCharacterResponse::ByteSizeLong(const MessageLite& base) {
  const MoveCharacterResponse& this_ = static_cast<const MoveCharacterResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MoveCharacterResponse::ByteSizeLong() const {
  const MoveCharacterResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.MoveCharacterResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    // string stop_reason = 5 [json_name = "stopReason"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_stop_reason().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_stop_reason());
      }
    }
    // .dnd5e.api.v1alpha1.MovementError error = 2 [json_name = "error"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.error_);
    }
    // .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.final_position_);
    }
    // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.updated_room_);
    }
    // bool success = 1 [json_name = "success"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_success() != 0) {
        total_size += 2;
      }
    }
    // int32 movement_remaining = 4 [json_name = "movementRemaining"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (this_._internal_movement_remaining() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_movement_remaining());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MoveCharacterResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<MoveCharacterResponse*>(&to_msg);
  auto& from = static_cast<const MoveCharacterResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.MoveCharacterResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_stop_reason().empty()) {
        _this->_internal_set_stop_reason(from._internal_stop_reason());
      } else {
        if (_this->_impl_.stop_reason_.IsDefault()) {
          _this->_internal_set_stop_reason("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.error_ != nullptr);
      if (_this->_impl_.error_ == nullptr) {
        _this->_impl_.error_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.error_);
      } else {
        _this->_impl_.error_->MergeFrom(*from._impl_.error_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.final_position_ != nullptr);
      if (_this->_impl_.final_position_ == nullptr) {
        _this->_impl_.final_position_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.final_position_);
      } else {
        _this->_impl_.final_position_->MergeFrom(*from._impl_.final_position_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.updated_room_ != nullptr);
      if (_this->_impl_.updated_room_ == nullptr) {
        _this->_impl_.updated_room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_room_);
      } else {
        _this->_impl_.updated_room_->MergeFrom(*from._impl_.updated_room_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_success() != 0) {
        _this->_impl_.success_ = from._impl_.success_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (from._internal_movement_remaining() != 0) {
        _this->_impl_.movement_remaining_ = from._impl_.movement_remaining_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void MoveCharacterResponse::CopyFrom(const MoveCharacterResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.MoveCharacterResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MoveCharacterResponse::InternalSwap(MoveCharacterResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.stop_reason_, &other->_impl_.stop_reason_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.movement_remaining_)
      + sizeof(MoveCharacterResponse::_impl_.movement_remaining_)
      - PROTOBUF_FIELD_OFFSET(MoveCharacterResponse, _impl_.error_)>(
          reinterpret_cast<char*>(&_impl_.error_),
          reinterpret_cast<char*>(&other->_impl_.error_));
}

::google::protobuf::Metadata MoveCharacterResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class EndTurnRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<EndTurnRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(EndTurnRequest, _impl_._has_bits_);
};

EndTurnRequest::EndTurnRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EndTurnRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.EndTurnRequest)
}
PROTOBUF_NDEBUG_INLINE EndTurnRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::EndTurnRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        encounter_id_(arena, from.encounter_id_),
        entity_id_(arena, from.entity_id_) {}

EndTurnRequest::EndTurnRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const EndTurnRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EndTurnRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  EndTurnRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.EndTurnRequest)
}
PROTOBUF_NDEBUG_INLINE EndTurnRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        encounter_id_(arena),
        entity_id_(arena) {}

inline void EndTurnRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
EndTurnRequest::~EndTurnRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.EndTurnRequest)
  SharedDtor(*this);
}
inline void EndTurnRequest::SharedDtor(MessageLite& self) {
  EndTurnRequest& this_ = static_cast<EndTurnRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.entity_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL EndTurnRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) EndTurnRequest(arena);
}
constexpr auto EndTurnRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(EndTurnRequest),
                                            alignof(EndTurnRequest));
}
constexpr auto EndTurnRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_EndTurnRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &EndTurnRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<EndTurnRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &EndTurnRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<EndTurnRequest>(), &EndTurnRequest::ByteSizeLong,
              &EndTurnRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(EndTurnRequest, _impl_._cached_size_),
          false,
      },
      &EndTurnRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull EndTurnRequest_class_data_ =
        EndTurnRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
EndTurnRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&EndTurnRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(EndTurnRequest_class_data_.tc_table);
  return EndTurnRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 63, 2>
EndTurnRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EndTurnRequest, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    EndTurnRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EndTurnRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string entity_id = 2 [json_name = "entityId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(EndTurnRequest, _impl_.entity_id_)}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(EndTurnRequest, _impl_.encounter_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(EndTurnRequest, _impl_.encounter_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string entity_id = 2 [json_name = "entityId"];
    {PROTOBUF_FIELD_OFFSET(EndTurnRequest, _impl_.entity_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\41\14\11\0\0\0\0\0"
    "dnd5e.api.v1alpha1.EndTurnRequest"
    "encounter_id"
    "entity_id"
  }},
};
PROTOBUF_NOINLINE void EndTurnRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.EndTurnRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.entity_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL EndTurnRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const EndTurnRequest& this_ = static_cast<const EndTurnRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL EndTurnRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const EndTurnRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.EndTurnRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.EndTurnRequest.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string entity_id = 2 [json_name = "entityId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_entity_id().empty()) {
      const ::std::string& _s = this_._internal_entity_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.EndTurnRequest.entity_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.EndTurnRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t EndTurnRequest::ByteSizeLong(const MessageLite& base) {
  const EndTurnRequest& this_ = static_cast<const EndTurnRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t EndTurnRequest::ByteSizeLong() const {
  const EndTurnRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.EndTurnRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // string entity_id = 2 [json_name = "entityId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_entity_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_entity_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void EndTurnRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<EndTurnRequest*>(&to_msg);
  auto& from = static_cast<const EndTurnRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.EndTurnRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_entity_id().empty()) {
        _this->_internal_set_entity_id(from._internal_entity_id());
      } else {
        if (_this->_impl_.entity_id_.IsDefault()) {
          _this->_internal_set_entity_id("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void EndTurnRequest::CopyFrom(const EndTurnRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.EndTurnRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EndTurnRequest::InternalSwap(EndTurnRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.entity_id_, &other->_impl_.entity_id_, arena);
}

::google::protobuf::Metadata EndTurnRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class TurnChangeEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<TurnChangeEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_._has_bits_);
};

TurnChangeEvent::TurnChangeEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TurnChangeEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.TurnChangeEvent)
}
PROTOBUF_NDEBUG_INLINE TurnChangeEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::TurnChangeEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        previous_entity_id_(arena, from.previous_entity_id_),
        next_entity_id_(arena, from.next_entity_id_) {}

TurnChangeEvent::TurnChangeEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const TurnChangeEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TurnChangeEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TurnChangeEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, round_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, round_),
           offsetof(Impl_, new_round_) -
               offsetof(Impl_, round_) +
               sizeof(Impl_::new_round_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.TurnChangeEvent)
}
PROTOBUF_NDEBUG_INLINE TurnChangeEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        previous_entity_id_(arena),
        next_entity_id_(arena) {}

inline void TurnChangeEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, round_),
           0,
           offsetof(Impl_, new_round_) -
               offsetof(Impl_, round_) +
               sizeof(Impl_::new_round_));
}
TurnChangeEvent::~TurnChangeEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.TurnChangeEvent)
  SharedDtor(*this);
}
inline void TurnChangeEvent::SharedDtor(MessageLite& self) {
  TurnChangeEvent& this_ = static_cast<TurnChangeEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.previous_entity_id_.Destroy();
  this_._impl_.next_entity_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL TurnChangeEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) TurnChangeEvent(arena);
}
constexpr auto TurnChangeEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(TurnChangeEvent),
                                            alignof(TurnChangeEvent));
}
constexpr auto TurnChangeEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_TurnChangeEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &TurnChangeEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<TurnChangeEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &TurnChangeEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<TurnChangeEvent>(), &TurnChangeEvent::ByteSizeLong,
              &TurnChangeEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_._cached_size_),
          false,
      },
      &TurnChangeEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull TurnChangeEvent_class_data_ =
        TurnChangeEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
TurnChangeEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&TurnChangeEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(TurnChangeEvent_class_data_.tc_table);
  return TurnChangeEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 75, 2>
TurnChangeEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    TurnChangeEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::TurnChangeEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bool new_round = 4 [json_name = "newRound"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(TurnChangeEvent, _impl_.new_round_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_.new_round_)}},
    // string previous_entity_id = 1 [json_name = "previousEntityId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_.previous_entity_id_)}},
    // string next_entity_id = 2 [json_name = "nextEntityId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_.next_entity_id_)}},
    // int32 round = 3 [json_name = "round"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(TurnChangeEvent, _impl_.round_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_.round_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string previous_entity_id = 1 [json_name = "previousEntityId"];
    {PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_.previous_entity_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string next_entity_id = 2 [json_name = "nextEntityId"];
    {PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_.next_entity_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 round = 3 [json_name = "round"];
    {PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_.round_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // bool new_round = 4 [json_name = "newRound"];
    {PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_.new_round_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\42\22\16\0\0\0\0\0"
    "dnd5e.api.v1alpha1.TurnChangeEvent"
    "previous_entity_id"
    "next_entity_id"
  }},
};
PROTOBUF_NOINLINE void TurnChangeEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.TurnChangeEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.previous_entity_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.next_entity_id_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000cU)) {
    ::memset(&_impl_.round_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.new_round_) -
        reinterpret_cast<char*>(&_impl_.round_)) + sizeof(_impl_.new_round_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL TurnChangeEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const TurnChangeEvent& this_ = static_cast<const TurnChangeEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL TurnChangeEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const TurnChangeEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.TurnChangeEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string previous_entity_id = 1 [json_name = "previousEntityId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_previous_entity_id().empty()) {
      const ::std::string& _s = this_._internal_previous_entity_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string next_entity_id = 2 [json_name = "nextEntityId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_next_entity_id().empty()) {
      const ::std::string& _s = this_._internal_next_entity_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // int32 round = 3 [json_name = "round"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_round() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
              stream, this_._internal_round(), target);
    }
  }

  // bool new_round = 4 [json_name = "newRound"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_new_round() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          4, this_._internal_new_round(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.TurnChangeEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t TurnChangeEvent::ByteSizeLong(const MessageLite& base) {
  const TurnChangeEvent& this_ = static_cast<const TurnChangeEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t TurnChangeEvent::ByteSizeLong() const {
  const TurnChangeEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.TurnChangeEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // string previous_entity_id = 1 [json_name = "previousEntityId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_previous_entity_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_previous_entity_id());
      }
    }
    // string next_entity_id = 2 [json_name = "nextEntityId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_next_entity_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_next_entity_id());
      }
    }
    // int32 round = 3 [json_name = "round"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_round() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_round());
      }
    }
    // bool new_round = 4 [json_name = "newRound"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_new_round() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void TurnChangeEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<TurnChangeEvent*>(&to_msg);
  auto& from = static_cast<const TurnChangeEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.TurnChangeEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_previous_entity_id().empty()) {
        _this->_internal_set_previous_entity_id(from._internal_previous_entity_id());
      } else {
        if (_this->_impl_.previous_entity_id_.IsDefault()) {
          _this->_internal_set_previous_entity_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_next_entity_id().empty()) {
        _this->_internal_set_next_entity_id(from._internal_next_entity_id());
      } else {
        if (_this->_impl_.next_entity_id_.IsDefault()) {
          _this->_internal_set_next_entity_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_round() != 0) {
        _this->_impl_.round_ = from._impl_.round_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_new_round() != 0) {
        _this->_impl_.new_round_ = from._impl_.new_round_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void TurnChangeEvent::CopyFrom(const TurnChangeEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.TurnChangeEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TurnChangeEvent::InternalSwap(TurnChangeEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.previous_entity_id_, &other->_impl_.previous_entity_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.next_entity_id_, &other->_impl_.next_entity_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_.new_round_)
      + sizeof(TurnChangeEvent::_impl_.new_round_)
      - PROTOBUF_FIELD_OFFSET(TurnChangeEvent, _impl_.round_)>(
          reinterpret_cast<char*>(&_impl_.round_),
          reinterpret_cast<char*>(&other->_impl_.round_));
}

::google::protobuf::Metadata TurnChangeEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class EndTurnResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<EndTurnResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_._has_bits_);
};

EndTurnResponse::EndTurnResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EndTurnResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.EndTurnResponse)
}
PROTOBUF_NDEBUG_INLINE EndTurnResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::EndTurnResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        monster_turns_{visibility, arena, from.monster_turns_} {}

EndTurnResponse::EndTurnResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const EndTurnResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EndTurnResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  EndTurnResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.combat_state_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_)
                : nullptr;
  _impl_.turn_change_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.turn_change_)
                : nullptr;
  _impl_.encounter_result_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.encounter_result_)
                : nullptr;
  _impl_.success_ = from._impl_.success_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.EndTurnResponse)
}
PROTOBUF_NDEBUG_INLINE EndTurnResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        monster_turns_{visibility, arena} {}

inline void EndTurnResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, combat_state_),
           0,
           offsetof(Impl_, success_) -
               offsetof(Impl_, combat_state_) +
               sizeof(Impl_::success_));
}
EndTurnResponse::~EndTurnResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.EndTurnResponse)
  SharedDtor(*this);
}
inline void EndTurnResponse::SharedDtor(MessageLite& self) {
  EndTurnResponse& this_ = static_cast<EndTurnResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.combat_state_;
  delete this_._impl_.turn_change_;
  delete this_._impl_.encounter_result_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL EndTurnResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) EndTurnResponse(arena);
}
constexpr auto EndTurnResponse::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.monster_turns_) +
          decltype(EndTurnResponse::_impl_.monster_turns_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(EndTurnResponse), alignof(EndTurnResponse), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&EndTurnResponse::PlacementNew_,
                                 sizeof(EndTurnResponse),
                                 alignof(EndTurnResponse));
  }
}
constexpr auto EndTurnResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_EndTurnResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &EndTurnResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<EndTurnResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &EndTurnResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<EndTurnResponse>(), &EndTurnResponse::ByteSizeLong,
              &EndTurnResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_._cached_size_),
          false,
      },
      &EndTurnResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull EndTurnResponse_class_data_ =
        EndTurnResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
EndTurnResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&EndTurnResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(EndTurnResponse_class_data_.tc_table);
  return EndTurnResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 4, 0, 2>
EndTurnResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    EndTurnResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EndTurnResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // bool success = 1 [json_name = "success"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(EndTurnResponse, _impl_.success_), 4>(),
     {8, 4, 0,
      PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.success_)}},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.combat_state_)}},
    // .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 3 [json_name = "turnChange"];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 1,
      PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.turn_change_)}},
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 4 [json_name = "monsterTurns"];
    {::_pbi::TcParser::FastMtR1,
     {34, 0, 2,
      PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.monster_turns_)}},
    // optional .dnd5e.api.v1alpha1.EncounterResult encounter_result = 5 [json_name = "encounterResult"];
    {::_pbi::TcParser::FastMtS1,
     {42, 3, 3,
      PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.encounter_result_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // bool success = 1 [json_name = "success"];
    {PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.success_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
    {PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.combat_state_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 3 [json_name = "turnChange"];
    {PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.turn_change_), _Internal::kHasBitsOffset + 2, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 4 [json_name = "monsterTurns"];
    {PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.monster_turns_), _Internal::kHasBitsOffset + 0, 2, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .dnd5e.api.v1alpha1.EncounterResult encounter_result = 5 [json_name = "encounterResult"];
    {PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.encounter_result_), _Internal::kHasBitsOffset + 3, 3, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::TurnChangeEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterTurnResult>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EncounterResult>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void EndTurnResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.EndTurnResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.monster_turns_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.combat_state_ != nullptr);
      _impl_.combat_state_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.turn_change_ != nullptr);
      _impl_.turn_change_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.encounter_result_ != nullptr);
      _impl_.encounter_result_->Clear();
    }
  }
  _impl_.success_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL EndTurnResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const EndTurnResponse& this_ = static_cast<const EndTurnResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL EndTurnResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const EndTurnResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.EndTurnResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // bool success = 1 [json_name = "success"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_success() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          1, this_._internal_success(), target);
    }
  }

  // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.combat_state_, this_._impl_.combat_state_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 3 [json_name = "turnChange"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.turn_change_, this_._impl_.turn_change_->GetCachedSize(), target,
        stream);
  }

  // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 4 [json_name = "monsterTurns"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_monster_turns_size());
         i < n; i++) {
      const auto& repfield = this_._internal_monster_turns().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              4, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // optional .dnd5e.api.v1alpha1.EncounterResult encounter_result = 5 [json_name = "encounterResult"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.encounter_result_, this_._impl_.encounter_result_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.EndTurnResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t EndTurnResponse::ByteSizeLong(const MessageLite& base) {
  const EndTurnResponse& this_ = static_cast<const EndTurnResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t EndTurnResponse::ByteSizeLong() const {
  const EndTurnResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.EndTurnResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 4 [json_name = "monsterTurns"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_monster_turns_size();
      for (const auto& msg : this_._internal_monster_turns()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.combat_state_);
    }
    // .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 3 [json_name = "turnChange"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.turn_change_);
    }
    // optional .dnd5e.api.v1alpha1.EncounterResult encounter_result = 5 [json_name = "encounterResult"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.encounter_result_);
    }
    // bool success = 1 [json_name = "success"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_success() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void EndTurnResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<EndTurnResponse*>(&to_msg);
  auto& from = static_cast<const EndTurnResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.EndTurnResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_monster_turns()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_monster_turns());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.combat_state_ != nullptr);
      if (_this->_impl_.combat_state_ == nullptr) {
        _this->_impl_.combat_state_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_);
      } else {
        _this->_impl_.combat_state_->MergeFrom(*from._impl_.combat_state_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.turn_change_ != nullptr);
      if (_this->_impl_.turn_change_ == nullptr) {
        _this->_impl_.turn_change_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.turn_change_);
      } else {
        _this->_impl_.turn_change_->MergeFrom(*from._impl_.turn_change_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.encounter_result_ != nullptr);
      if (_this->_impl_.encounter_result_ == nullptr) {
        _this->_impl_.encounter_result_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.encounter_result_);
      } else {
        _this->_impl_.encounter_result_->MergeFrom(*from._impl_.encounter_result_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_success() != 0) {
        _this->_impl_.success_ = from._impl_.success_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void EndTurnResponse::CopyFrom(const EndTurnResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.EndTurnResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EndTurnResponse::InternalSwap(EndTurnResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.monster_turns_.InternalSwap(&other->_impl_.monster_turns_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.success_)
      + sizeof(EndTurnResponse::_impl_.success_)
      - PROTOBUF_FIELD_OFFSET(EndTurnResponse, _impl_.combat_state_)>(
          reinterpret_cast<char*>(&_impl_.combat_state_),
          reinterpret_cast<char*>(&other->_impl_.combat_state_));
}

::google::protobuf::Metadata EndTurnResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AttackRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AttackRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_._has_bits_);
};

AttackRequest::AttackRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AttackRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.AttackRequest)
}
PROTOBUF_NDEBUG_INLINE AttackRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::AttackRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        encounter_id_(arena, from.encounter_id_),
        attacker_id_(arena, from.attacker_id_),
        target_id_(arena, from.target_id_),
        weapon_id_(arena, from.weapon_id_) {}

AttackRequest::AttackRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const AttackRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AttackRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AttackRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.attack_hand_ = from._impl_.attack_hand_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.AttackRequest)
}
PROTOBUF_NDEBUG_INLINE AttackRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        encounter_id_(arena),
        attacker_id_(arena),
        target_id_(arena),
        weapon_id_(arena) {}

inline void AttackRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.attack_hand_ = {};
}
AttackRequest::~AttackRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.AttackRequest)
  SharedDtor(*this);
}
inline void AttackRequest::SharedDtor(MessageLite& self) {
  AttackRequest& this_ = static_cast<AttackRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.attacker_id_.Destroy();
  this_._impl_.target_id_.Destroy();
  this_._impl_.weapon_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AttackRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AttackRequest(arena);
}
constexpr auto AttackRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(AttackRequest),
                                            alignof(AttackRequest));
}
constexpr auto AttackRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_AttackRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AttackRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<AttackRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AttackRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<AttackRequest>(), &AttackRequest::ByteSizeLong,
              &AttackRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_._cached_size_),
          false,
      },
      &AttackRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull AttackRequest_class_data_ =
        AttackRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AttackRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&AttackRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(AttackRequest_class_data_.tc_table);
  return AttackRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 82, 2>
AttackRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    AttackRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::AttackRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_.encounter_id_)}},
    // string attacker_id = 2 [json_name = "attackerId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_.attacker_id_)}},
    // string target_id = 3 [json_name = "targetId"];
    {::_pbi::TcParser::FastUS1,
     {26, 2, 0,
      PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_.target_id_)}},
    // string weapon_id = 4 [json_name = "weaponId"];
    {::_pbi::TcParser::FastUS1,
     {34, 3, 0,
      PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_.weapon_id_)}},
    // .dnd5e.api.v1alpha1.AttackHand attack_hand = 5 [json_name = "attackHand"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AttackRequest, _impl_.attack_hand_), 4>(),
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_.attack_hand_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_.encounter_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string attacker_id = 2 [json_name = "attackerId"];
    {PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_.attacker_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string target_id = 3 [json_name = "targetId"];
    {PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_.target_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string weapon_id = 4 [json_name = "weaponId"];
    {PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_.weapon_id_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.AttackHand attack_hand = 5 [json_name = "attackHand"];
    {PROTOBUF_FIELD_OFFSET(AttackRequest, _impl_.attack_hand_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
    "\40\14\13\11\11\0\0\0"
    "dnd5e.api.v1alpha1.AttackRequest"
    "encounter_id"
    "attacker_id"
    "target_id"
    "weapon_id"
  }},
};
PROTOBUF_NOINLINE void AttackRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.AttackRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.attacker_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.target_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.weapon_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.attack_hand_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AttackRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AttackRequest& this_ = static_cast<const AttackRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AttackRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AttackRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.AttackRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.AttackRequest.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string attacker_id = 2 [json_name = "attackerId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_attacker_id().empty()) {
      const ::std::string& _s = this_._internal_attacker_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.AttackRequest.attacker_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // string target_id = 3 [json_name = "targetId"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_target_id().empty()) {
      const ::std::string& _s = this_._internal_target_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.AttackRequest.target_id");
      target = stream->WriteStringMaybeAliased(3, _s, target);
    }
  }

  // string weapon_id = 4 [json_name = "weaponId"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (!this_._internal_weapon_id().empty()) {
      const ::std::string& _s = this_._internal_weapon_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.AttackRequest.weapon_id");
      target = stream->WriteStringMaybeAliased(4, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.AttackHand attack_hand = 5 [json_name = "attackHand"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_attack_hand() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          5, this_._internal_attack_hand(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.AttackRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AttackRequest::ByteSizeLong(const MessageLite& base) {
  const AttackRequest& this_ = static_cast<const AttackRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AttackRequest::ByteSizeLong() const {
  const AttackRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.AttackRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // string attacker_id = 2 [json_name = "attackerId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_attacker_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_attacker_id());
      }
    }
    // string target_id = 3 [json_name = "targetId"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!this_._internal_target_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_target_id());
      }
    }
    // string weapon_id = 4 [json_name = "weaponId"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!this_._internal_weapon_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_weapon_id());
      }
    }
    // .dnd5e.api.v1alpha1.AttackHand attack_hand = 5 [json_name = "attackHand"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_attack_hand() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_attack_hand());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void AttackRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<AttackRequest*>(&to_msg);
  auto& from = static_cast<const AttackRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.AttackRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_attacker_id().empty()) {
        _this->_internal_set_attacker_id(from._internal_attacker_id());
      } else {
        if (_this->_impl_.attacker_id_.IsDefault()) {
          _this->_internal_set_attacker_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!from._internal_target_id().empty()) {
        _this->_internal_set_target_id(from._internal_target_id());
      } else {
        if (_this->_impl_.target_id_.IsDefault()) {
          _this->_internal_set_target_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!from._internal_weapon_id().empty()) {
        _this->_internal_set_weapon_id(from._internal_weapon_id());
      } else {
        if (_this->_impl_.weapon_id_.IsDefault()) {
          _this->_internal_set_weapon_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_attack_hand() != 0) {
        _this->_impl_.attack_hand_ = from._impl_.attack_hand_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void AttackRequest::CopyFrom(const AttackRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.AttackRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AttackRequest::InternalSwap(AttackRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.attacker_id_, &other->_impl_.attacker_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.target_id_, &other->_impl_.target_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.weapon_id_, &other->_impl_.weapon_id_, arena);
  swap(_impl_.attack_hand_, other->_impl_.attack_hand_);
}

::google::protobuf::Metadata AttackRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RerollEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RerollEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_._has_bits_);
};

RerollEvent::RerollEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RerollEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.RerollEvent)
}
PROTOBUF_NDEBUG_INLINE RerollEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::RerollEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        reason_(arena, from.reason_) {}

RerollEvent::RerollEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RerollEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RerollEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RerollEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, die_index_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, die_index_),
           offsetof(Impl_, after_) -
               offsetof(Impl_, die_index_) +
               sizeof(Impl_::after_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.RerollEvent)
}
PROTOBUF_NDEBUG_INLINE RerollEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        reason_(arena) {}

inline void RerollEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, die_index_),
           0,
           offsetof(Impl_, after_) -
               offsetof(Impl_, die_index_) +
               sizeof(Impl_::after_));
}
RerollEvent::~RerollEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.RerollEvent)
  SharedDtor(*this);
}
inline void RerollEvent::SharedDtor(MessageLite& self) {
  RerollEvent& this_ = static_cast<RerollEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.reason_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RerollEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RerollEvent(arena);
}
constexpr auto RerollEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(RerollEvent),
                                            alignof(RerollEvent));
}
constexpr auto RerollEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RerollEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RerollEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RerollEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RerollEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RerollEvent>(), &RerollEvent::ByteSizeLong,
              &RerollEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_._cached_size_),
          false,
      },
      &RerollEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RerollEvent_class_data_ =
        RerollEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RerollEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RerollEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RerollEvent_class_data_.tc_table);
  return RerollEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 45, 2>
RerollEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    RerollEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::RerollEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string reason = 4 [json_name = "reason"];
    {::_pbi::TcParser::FastUS1,
     {34, 0, 0,
      PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_.reason_)}},
    // int32 die_index = 1 [json_name = "dieIndex"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(RerollEvent, _impl_.die_index_), 1>(),
     {8, 1, 0,
      PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_.die_index_)}},
    // int32 before = 2 [json_name = "before"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(RerollEvent, _impl_.before_), 2>(),
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_.before_)}},
    // int32 after = 3 [json_name = "after"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(RerollEvent, _impl_.after_), 3>(),
     {24, 3, 0,
      PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_.after_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 die_index = 1 [json_name = "dieIndex"];
    {PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_.die_index_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 before = 2 [json_name = "before"];
    {PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_.before_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 after = 3 [json_name = "after"];
    {PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_.after_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // string reason = 4 [json_name = "reason"];
    {PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_.reason_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\36\0\0\0\6\0\0\0"
    "dnd5e.api.v1alpha1.RerollEvent"
    "reason"
  }},
};
PROTOBUF_NOINLINE void RerollEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.RerollEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.reason_.ClearNonDefaultToEmpty();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000eU)) {
    ::memset(&_impl_.die_index_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.after_) -
        reinterpret_cast<char*>(&_impl_.die_index_)) + sizeof(_impl_.after_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RerollEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RerollEvent& this_ = static_cast<const RerollEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RerollEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RerollEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.RerollEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // int32 die_index = 1 [json_name = "dieIndex"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (this_._internal_die_index() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
              stream, this_._internal_die_index(), target);
    }
  }

  // int32 before = 2 [json_name = "before"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_before() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
              stream, this_._internal_before(), target);
    }
  }

  // int32 after = 3 [json_name = "after"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_after() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
              stream, this_._internal_after(), target);
    }
  }

  // string reason = 4 [json_name = "reason"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_reason().empty()) {
      const ::std::string& _s = this_._internal_reason();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.RerollEvent.reason");
      target = stream->WriteStringMaybeAliased(4, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.RerollEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RerollEvent::ByteSizeLong(const MessageLite& base) {
  const RerollEvent& this_ = static_cast<const RerollEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RerollEvent::ByteSizeLong() const {
  const RerollEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.RerollEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // string reason = 4 [json_name = "reason"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_reason().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_reason());
      }
    }
    // int32 die_index = 1 [json_name = "dieIndex"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (this_._internal_die_index() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_die_index());
      }
    }
    // int32 before = 2 [json_name = "before"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_before() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_before());
      }
    }
    // int32 after = 3 [json_name = "after"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_after() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_after());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RerollEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<RerollEvent*>(&to_msg);
  auto& from = static_cast<const RerollEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.RerollEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_reason().empty()) {
        _this->_internal_set_reason(from._internal_reason());
      } else {
        if (_this->_impl_.reason_.IsDefault()) {
          _this->_internal_set_reason("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (from._internal_die_index() != 0) {
        _this->_impl_.die_index_ = from._impl_.die_index_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_before() != 0) {
        _this->_impl_.before_ = from._impl_.before_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_after() != 0) {
        _this->_impl_.after_ = from._impl_.after_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void RerollEvent::CopyFrom(const RerollEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.RerollEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RerollEvent::InternalSwap(RerollEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reason_, &other->_impl_.reason_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_.after_)
      + sizeof(RerollEvent::_impl_.after_)
      - PROTOBUF_FIELD_OFFSET(RerollEvent, _impl_.die_index_)>(
          reinterpret_cast<char*>(&_impl_.die_index_),
          reinterpret_cast<char*>(&other->_impl_.die_index_));
}

::google::protobuf::Metadata RerollEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DamageComponent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DamageComponent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_._has_bits_);
};

void DamageComponent::clear_source_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_ref_ != nullptr) _impl_.source_ref_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
DamageComponent::DamageComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DamageComponent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.DamageComponent)
}
PROTOBUF_NDEBUG_INLINE DamageComponent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::DamageComponent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        original_dice_rolls_{visibility, arena, from.original_dice_rolls_},
        _original_dice_rolls_cached_byte_size_{0},
        final_dice_rolls_{visibility, arena, from.final_dice_rolls_},
        _final_dice_rolls_cached_byte_size_{0},
        rerolls_{visibility, arena, from.rerolls_},
        source_(arena, from.source_),
        damage_type_(arena, from.damage_type_) {}

DamageComponent::DamageComponent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DamageComponent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DamageComponent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DamageComponent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.source_ref_ = (CheckHasBit(cached_has_bits, 0x00000020U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.source_ref_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, flat_bonus_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, flat_bonus_),
           offsetof(Impl_, multiplier_) -
               offsetof(Impl_, flat_bonus_) +
               sizeof(Impl_::multiplier_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.DamageComponent)
}
PROTOBUF_NDEBUG_INLINE DamageComponent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        original_dice_rolls_{visibility, arena},
        _original_dice_rolls_cached_byte_size_{0},
        final_dice_rolls_{visibility, arena},
        _final_dice_rolls_cached_byte_size_{0},
        rerolls_{visibility, arena},
        source_(arena),
        damage_type_(arena) {}

inline void DamageComponent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, source_ref_),
           0,
           offsetof(Impl_, multiplier_) -
               offsetof(Impl_, source_ref_) +
               sizeof(Impl_::multiplier_));
}
DamageComponent::~DamageComponent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.DamageComponent)
  SharedDtor(*this);
}
inline void DamageComponent::SharedDtor(MessageLite& self) {
  DamageComponent& this_ = static_cast<DamageComponent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.source_.Destroy();
  this_._impl_.damage_type_.Destroy();
  delete this_._impl_.source_ref_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DamageComponent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DamageComponent(arena);
}
constexpr auto DamageComponent::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.original_dice_rolls_) +
          decltype(DamageComponent::_impl_.original_dice_rolls_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.final_dice_rolls_) +
          decltype(DamageComponent::_impl_.final_dice_rolls_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.rerolls_) +
          decltype(DamageComponent::_impl_.rerolls_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(DamageComponent), alignof(DamageComponent), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&DamageComponent::PlacementNew_,
                                 sizeof(DamageComponent),
                                 alignof(DamageComponent));
  }
}
constexpr auto DamageComponent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DamageComponent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DamageComponent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DamageComponent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DamageComponent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DamageComponent>(), &DamageComponent::ByteSizeLong,
              &DamageComponent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_._cached_size_),
          false,
      },
      &DamageComponent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DamageComponent_class_data_ =
        DamageComponent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DamageComponent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DamageComponent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DamageComponent_class_data_.tc_table);
  return DamageComponent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 2, 68, 2>
DamageComponent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    DamageComponent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DamageComponent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string source = 1 [json_name = "source", deprecated = true];
    {::_pbi::TcParser::FastUS1,
     {10, 3, 0,
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.source_)}},
    // repeated int32 original_dice_rolls = 2 [json_name = "originalDiceRolls"];
    {::_pbi::TcParser::FastV32P1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.original_dice_rolls_)}},
    // repeated int32 final_dice_rolls = 3 [json_name = "finalDiceRolls"];
    {::_pbi::TcParser::FastV32P1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.final_dice_rolls_)}},
    // repeated .dnd5e.api.v1alpha1.RerollEvent rerolls = 4 [json_name = "rerolls"];
    {::_pbi::TcParser::FastMtR1,
     {34, 2, 0,
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.rerolls_)}},
    // int32 flat_bonus = 5 [json_name = "flatBonus"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DamageComponent, _impl_.flat_bonus_), 6>(),
     {40, 6, 0,
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.flat_bonus_)}},
    // string damage_type = 6 [json_name = "damageType"];
    {::_pbi::TcParser::FastUS1,
     {50, 4, 0,
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.damage_type_)}},
    // bool is_critical = 7 [json_name = "isCritical"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DamageComponent, _impl_.is_critical_), 7>(),
     {56, 7, 0,
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.is_critical_)}},
    // .dnd5e.api.v1alpha1.SourceRef source_ref = 8 [json_name = "sourceRef"];
    {::_pbi::TcParser::FastMtS1,
     {66, 5, 1,
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.source_ref_)}},
    // optional float multiplier = 9 [json_name = "multiplier"];
    {::_pbi::TcParser::FastF32S1,
     {77, 8, 0,
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.multiplier_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string source = 1 [json_name = "source", deprecated = true];
    {PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.source_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated int32 original_dice_rolls = 2 [json_name = "originalDiceRolls"];
    {PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.original_dice_rolls_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int32 final_dice_rolls = 3 [json_name = "finalDiceRolls"];
    {PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.final_dice_rolls_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated .dnd5e.api.v1alpha1.RerollEvent rerolls = 4 [json_name = "rerolls"];
    {PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.rerolls_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 flat_bonus = 5 [json_name = "flatBonus"];
    {PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.flat_bonus_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // string damage_type = 6 [json_name = "damageType"];
    {PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.damage_type_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool is_critical = 7 [json_name = "isCritical"];
    {PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.is_critical_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // .dnd5e.api.v1alpha1.SourceRef source_ref = 8 [json_name = "sourceRef"];
    {PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.source_ref_), _Internal::kHasBitsOffset + 5, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional float multiplier = 9 [json_name = "multiplier"];
    {PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.multiplier_), _Internal::kHasBitsOffset + 8, 0, (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::RerollEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SourceRef>()},
  }},
  {{
    "\42\6\0\0\0\0\13\0\0\0\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.DamageComponent"
    "source"
    "damage_type"
  }},
};
PROTOBUF_NOINLINE void DamageComponent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.DamageComponent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.original_dice_rolls_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.final_dice_rolls_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.rerolls_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.source_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.damage_type_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(_impl_.source_ref_ != nullptr);
      _impl_.source_ref_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x000000c0U)) {
    ::memset(&_impl_.flat_bonus_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_critical_) -
        reinterpret_cast<char*>(&_impl_.flat_bonus_)) + sizeof(_impl_.is_critical_));
  }
  _impl_.multiplier_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DamageComponent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DamageComponent& this_ = static_cast<const DamageComponent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DamageComponent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DamageComponent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.DamageComponent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string source = 1 [json_name = "source", deprecated = true];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (!this_._internal_source().empty()) {
      const ::std::string& _s = this_._internal_source();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.DamageComponent.source");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // repeated int32 original_dice_rolls = 2 [json_name = "originalDiceRolls"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._original_dice_rolls_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            2, this_._internal_original_dice_rolls(), byte_size, target);
      }
    }
  }

  // repeated int32 final_dice_rolls = 3 [json_name = "finalDiceRolls"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._final_dice_rolls_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            3, this_._internal_final_dice_rolls(), byte_size, target);
      }
    }
  }

  // repeated .dnd5e.api.v1alpha1.RerollEvent rerolls = 4 [json_name = "rerolls"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_rerolls_size());
         i < n; i++) {
      const auto& repfield = this_._internal_rerolls().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              4, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // int32 flat_bonus = 5 [json_name = "flatBonus"];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    if (this_._internal_flat_bonus() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<5>(
              stream, this_._internal_flat_bonus(), target);
    }
  }

  // string damage_type = 6 [json_name = "damageType"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (!this_._internal_damage_type().empty()) {
      const ::std::string& _s = this_._internal_damage_type();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.DamageComponent.damage_type");
      target = stream->WriteStringMaybeAliased(6, _s, target);
    }
  }

  // bool is_critical = 7 [json_name = "isCritical"];
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    if (this_._internal_is_critical() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          7, this_._internal_is_critical(), target);
    }
  }

  // .dnd5e.api.v1alpha1.SourceRef source_ref = 8 [json_name = "sourceRef"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        8, *this_._impl_.source_ref_, this_._impl_.source_ref_->GetCachedSize(), target,
        stream);
  }

  // optional float multiplier = 9 [json_name = "multiplier"];
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this_._internal_multiplier(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.DamageComponent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DamageComponent::ByteSizeLong(const MessageLite& base) {
  const DamageComponent& this_ = static_cast<const DamageComponent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DamageComponent::ByteSizeLong() const {
  const DamageComponent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.DamageComponent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000100U & cached_has_bits) * 5;
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // repeated int32 original_dice_rolls = 2 [json_name = "originalDiceRolls"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_original_dice_rolls(), 1,
              this_._impl_._original_dice_rolls_cached_byte_size_);
    }
    // repeated int32 final_dice_rolls = 3 [json_name = "finalDiceRolls"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_final_dice_rolls(), 1,
              this_._impl_._final_dice_rolls_cached_byte_size_);
    }
    // repeated .dnd5e.api.v1alpha1.RerollEvent rerolls = 4 [json_name = "rerolls"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size += 1UL * this_._internal_rerolls_size();
      for (const auto& msg : this_._internal_rerolls()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string source = 1 [json_name = "source", deprecated = true];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!this_._internal_source().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_source());
      }
    }
    // string damage_type = 6 [json_name = "damageType"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (!this_._internal_damage_type().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_damage_type());
      }
    }
    // .dnd5e.api.v1alpha1.SourceRef source_ref = 8 [json_name = "sourceRef"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.source_ref_);
    }
    // int32 flat_bonus = 5 [json_name = "flatBonus"];
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (this_._internal_flat_bonus() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_flat_bonus());
      }
    }
    // bool is_critical = 7 [json_name = "isCritical"];
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      if (this_._internal_is_critical() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DamageComponent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<DamageComponent*>(&to_msg);
  auto& from = static_cast<const DamageComponent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.DamageComponent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_original_dice_rolls()->MergeFrom(from._internal_original_dice_rolls());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_final_dice_rolls()->MergeFrom(from._internal_final_dice_rolls());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_rerolls()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_rerolls());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!from._internal_source().empty()) {
        _this->_internal_set_source(from._internal_source());
      } else {
        if (_this->_impl_.source_.IsDefault()) {
          _this->_internal_set_source("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (!from._internal_damage_type().empty()) {
        _this->_internal_set_damage_type(from._internal_damage_type());
      } else {
        if (_this->_impl_.damage_type_.IsDefault()) {
          _this->_internal_set_damage_type("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(from._impl_.source_ref_ != nullptr);
      if (_this->_impl_.source_ref_ == nullptr) {
        _this->_impl_.source_ref_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.source_ref_);
      } else {
        _this->_impl_.source_ref_->MergeFrom(*from._impl_.source_ref_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (from._internal_flat_bonus() != 0) {
        _this->_impl_.flat_bonus_ = from._impl_.flat_bonus_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      if (from._internal_is_critical() != 0) {
        _this->_impl_.is_critical_ = from._impl_.is_critical_;
      }
    }
  }
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    _this->_impl_.multiplier_ = from._impl_.multiplier_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void DamageComponent::CopyFrom(const DamageComponent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.DamageComponent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DamageComponent::InternalSwap(DamageComponent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.original_dice_rolls_.InternalSwap(&other->_impl_.original_dice_rolls_);
  _impl_.final_dice_rolls_.InternalSwap(&other->_impl_.final_dice_rolls_);
  _impl_.rerolls_.InternalSwap(&other->_impl_.rerolls_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.source_, &other->_impl_.source_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.damage_type_, &other->_impl_.damage_type_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.multiplier_)
      + sizeof(DamageComponent::_impl_.multiplier_)
      - PROTOBUF_FIELD_OFFSET(DamageComponent, _impl_.source_ref_)>(
          reinterpret_cast<char*>(&_impl_.source_ref_),
          reinterpret_cast<char*>(&other->_impl_.source_ref_));
}

::google::protobuf::Metadata DamageComponent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DamageBreakdown::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DamageBreakdown>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DamageBreakdown, _impl_._has_bits_);
};

DamageBreakdown::DamageBreakdown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DamageBreakdown_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.DamageBreakdown)
}
PROTOBUF_NDEBUG_INLINE DamageBreakdown::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::DamageBreakdown& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        components_{visibility, arena, from.components_},
        ability_used_(arena, from.ability_used_) {}

DamageBreakdown::DamageBreakdown(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DamageBreakdown& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DamageBreakdown_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DamageBreakdown* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.total_damage_ = from._impl_.total_damage_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.DamageBreakdown)
}
PROTOBUF_NDEBUG_INLINE DamageBreakdown::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        components_{visibility, arena},
        ability_used_(arena) {}

inline void DamageBreakdown::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.total_damage_ = {};
}
DamageBreakdown::~DamageBreakdown() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.DamageBreakdown)
  SharedDtor(*this);
}
inline void DamageBreakdown::SharedDtor(MessageLite& self) {
  DamageBreakdown& this_ = static_cast<DamageBreakdown&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.ability_used_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DamageBreakdown::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DamageBreakdown(arena);
}
constexpr auto DamageBreakdown::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(DamageBreakdown, _impl_.components_) +
          decltype(DamageBreakdown::_impl_.components_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(DamageBreakdown), alignof(DamageBreakdown), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&DamageBreakdown::PlacementNew_,
                                 sizeof(DamageBreakdown),
                                 alignof(DamageBreakdown));
  }
}
constexpr auto DamageBreakdown::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DamageBreakdown_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DamageBreakdown::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DamageBreakdown>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DamageBreakdown::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DamageBreakdown>(), &DamageBreakdown::ByteSizeLong,
              &DamageBreakdown::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DamageBreakdown, _impl_._cached_size_),
          false,
      },
      &DamageBreakdown::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DamageBreakdown_class_data_ =
        DamageBreakdown::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DamageBreakdown::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DamageBreakdown_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DamageBreakdown_class_data_.tc_table);
  return DamageBreakdown_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 55, 2>
DamageBreakdown::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DamageBreakdown, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    DamageBreakdown_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DamageBreakdown>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .dnd5e.api.v1alpha1.DamageComponent components = 1 [json_name = "components"];
    {::_pbi::TcParser::FastMtR1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(DamageBreakdown, _impl_.components_)}},
    // string ability_used = 2 [json_name = "abilityUsed"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(DamageBreakdown, _impl_.ability_used_)}},
    // int32 total_damage = 3 [json_name = "totalDamage"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DamageBreakdown, _impl_.total_damage_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(DamageBreakdown, _impl_.total_damage_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .dnd5e.api.v1alpha1.DamageComponent components = 1 [json_name = "components"];
    {PROTOBUF_FIELD_OFFSET(DamageBreakdown, _impl_.components_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // string ability_used = 2 [json_name = "abilityUsed"];
    {PROTOBUF_FIELD_OFFSET(DamageBreakdown, _impl_.ability_used_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 total_damage = 3 [json_name = "totalDamage"];
    {PROTOBUF_FIELD_OFFSET(DamageBreakdown, _impl_.total_damage_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DamageComponent>()},
  }},
  {{
    "\42\0\14\0\0\0\0\0"
    "dnd5e.api.v1alpha1.DamageBreakdown"
    "ability_used"
  }},
};
PROTOBUF_NOINLINE void DamageBreakdown::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.DamageBreakdown)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.components_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.ability_used_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.total_damage_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DamageBreakdown::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DamageBreakdown& this_ = static_cast<const DamageBreakdown&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DamageBreakdown::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DamageBreakdown& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.DamageBreakdown)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated .dnd5e.api.v1alpha1.DamageComponent components = 1 [json_name = "components"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_components_size());
         i < n; i++) {
      const auto& repfield = this_._internal_components().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              1, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // string ability_used = 2 [json_name = "abilityUsed"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_ability_used().empty()) {
      const ::std::string& _s = this_._internal_ability_used();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.DamageBreakdown.ability_used");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // int32 total_damage = 3 [json_name = "totalDamage"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_total_damage() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
              stream, this_._internal_total_damage(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.DamageBreakdown)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DamageBreakdown::ByteSizeLong(const MessageLite& base) {
  const DamageBreakdown& this_ = static_cast<const DamageBreakdown&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DamageBreakdown::ByteSizeLong() const {
  const DamageBreakdown& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.DamageBreakdown)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated .dnd5e.api.v1alpha1.DamageComponent components = 1 [json_name = "components"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_components_size();
      for (const auto& msg : this_._internal_components()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string ability_used = 2 [json_name = "abilityUsed"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_ability_used().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_ability_used());
      }
    }
    // int32 total_damage = 3 [json_name = "totalDamage"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_total_damage() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_total_damage());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DamageBreakdown::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<DamageBreakdown*>(&to_msg);
  auto& from = static_cast<const DamageBreakdown&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.DamageBreakdown)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_components()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_components());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_ability_used().empty()) {
        _this->_internal_set_ability_used(from._internal_ability_used());
      } else {
        if (_this->_impl_.ability_used_.IsDefault()) {
          _this->_internal_set_ability_used("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_total_damage() != 0) {
        _this->_impl_.total_damage_ = from._impl_.total_damage_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void DamageBreakdown::CopyFrom(const DamageBreakdown& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.DamageBreakdown)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DamageBreakdown::InternalSwap(DamageBreakdown* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.components_.InternalSwap(&other->_impl_.components_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ability_used_, &other->_impl_.ability_used_, arena);
  swap(_impl_.total_damage_, other->_impl_.total_damage_);
}

::google::protobuf::Metadata DamageBreakdown::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AttackResult::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AttackResult>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AttackResult, _impl_._has_bits_);
};

AttackResult::AttackResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AttackResult_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.AttackResult)
}
PROTOBUF_NDEBUG_INLINE AttackResult::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::AttackResult& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        damage_type_(arena, from.damage_type_) {}

AttackResult::AttackResult(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const AttackResult& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AttackResult_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AttackResult* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.damage_breakdown_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.damage_breakdown_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, attack_roll_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, attack_roll_),
           offsetof(Impl_, damage_) -
               offsetof(Impl_, attack_roll_) +
               sizeof(Impl_::damage_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.AttackResult)
}
PROTOBUF_NDEBUG_INLINE AttackResult::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        damage_type_(arena) {}

inline void AttackResult::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, damage_breakdown_),
           0,
           offsetof(Impl_, damage_) -
               offsetof(Impl_, damage_breakdown_) +
               sizeof(Impl_::damage_));
}
AttackResult::~AttackResult() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.AttackResult)
  SharedDtor(*this);
}
inline void AttackResult::SharedDtor(MessageLite& self) {
  AttackResult& this_ = static_cast<AttackResult&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.damage_type_.Destroy();
  delete this_._impl_.damage_breakdown_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AttackResult::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AttackResult(arena);
}
constexpr auto AttackResult::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(AttackResult),
                                            alignof(AttackResult));
}
constexpr auto AttackResult::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_AttackResult_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AttackResult::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<AttackResult>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AttackResult::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<AttackResult>(), &AttackResult::ByteSizeLong,
              &AttackResult::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AttackResult, _impl_._cached_size_),
          false,
      },
      &AttackResult::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull AttackResult_class_data_ =
        AttackResult::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AttackResult::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&AttackResult_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(AttackResult_class_data_.tc_table);
  return AttackResult_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 1, 59, 2>
AttackResult::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AttackResult, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    AttackResult_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::AttackResult>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.DamageBreakdown damage_breakdown = 8 [json_name = "damageBreakdown"];
    {::_pbi::TcParser::FastMtS1,
     {66, 1, 0,
      PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.damage_breakdown_)}},
    // bool hit = 1 [json_name = "hit"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AttackResult, _impl_.hit_), 5>(),
     {8, 5, 0,
      PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.hit_)}},
    // int32 attack_roll = 2 [json_name = "attackRoll"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AttackResult, _impl_.attack_roll_), 2>(),
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.attack_roll_)}},
    // int32 attack_total = 3 [json_name = "attackTotal"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AttackResult, _impl_.attack_total_), 3>(),
     {24, 3, 0,
      PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.attack_total_)}},
    // int32 target_ac = 4 [json_name = "targetAc"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AttackResult, _impl_.target_ac_), 4>(),
     {32, 4, 0,
      PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.target_ac_)}},
    // int32 damage = 5 [json_name = "damage"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AttackResult, _impl_.damage_), 7>(),
     {40, 7, 0,
      PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.damage_)}},
    // string damage_type = 6 [json_name = "damageType"];
    {::_pbi::TcParser::FastUS1,
     {50, 0, 0,
      PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.damage_type_)}},
    // bool critical = 7 [json_name = "critical"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AttackResult, _impl_.critical_), 6>(),
     {56, 6, 0,
      PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.critical_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bool hit = 1 [json_name = "hit"];
    {PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.hit_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // int32 attack_roll = 2 [json_name = "attackRoll"];
    {PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.attack_roll_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 attack_total = 3 [json_name = "attackTotal"];
    {PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.attack_total_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 target_ac = 4 [json_name = "targetAc"];
    {PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.target_ac_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 damage = 5 [json_name = "damage"];
    {PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.damage_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // string damage_type = 6 [json_name = "damageType"];
    {PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.damage_type_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool critical = 7 [json_name = "critical"];
    {PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.critical_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // .dnd5e.api.v1alpha1.DamageBreakdown damage_breakdown = 8 [json_name = "damageBreakdown"];
    {PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.damage_breakdown_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DamageBreakdown>()},
  }},
  {{
    "\37\0\0\0\0\0\13\0\0\0\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.AttackResult"
    "damage_type"
  }},
};
PROTOBUF_NOINLINE void AttackResult::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.AttackResult)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.damage_type_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.damage_breakdown_ != nullptr);
      _impl_.damage_breakdown_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x000000fcU)) {
    ::memset(&_impl_.attack_roll_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.damage_) -
        reinterpret_cast<char*>(&_impl_.attack_roll_)) + sizeof(_impl_.damage_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AttackResult::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AttackResult& this_ = static_cast<const AttackResult&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AttackResult::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AttackResult& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.AttackResult)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // bool hit = 1 [json_name = "hit"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (this_._internal_hit() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          1, this_._internal_hit(), target);
    }
  }

  // int32 attack_roll = 2 [json_name = "attackRoll"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_attack_roll() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
              stream, this_._internal_attack_roll(), target);
    }
  }

  // int32 attack_total = 3 [json_name = "attackTotal"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_attack_total() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
              stream, this_._internal_attack_total(), target);
    }
  }

  // int32 target_ac = 4 [json_name = "targetAc"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_target_ac() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
              stream, this_._internal_target_ac(), target);
    }
  }

  // int32 damage = 5 [json_name = "damage"];
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    if (this_._internal_damage() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<5>(
              stream, this_._internal_damage(), target);
    }
  }

  // string damage_type = 6 [json_name = "damageType"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_damage_type().empty()) {
      const ::std::string& _s = this_._internal_damage_type();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.AttackResult.damage_type");
      target = stream->WriteStringMaybeAliased(6, _s, target);
    }
  }

  // bool critical = 7 [json_name = "critical"];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    if (this_._internal_critical() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          7, this_._internal_critical(), target);
    }
  }

  // .dnd5e.api.v1alpha1.DamageBreakdown damage_breakdown = 8 [json_name = "damageBreakdown"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        8, *this_._impl_.damage_breakdown_, this_._impl_.damage_breakdown_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.AttackResult)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AttackResult::ByteSizeLong(const MessageLite& base) {
  const AttackResult& this_ = static_cast<const AttackResult&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AttackResult::ByteSizeLong() const {
  const AttackResult& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.AttackResult)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // string damage_type = 6 [json_name = "damageType"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_damage_type().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_damage_type());
      }
    }
    // .dnd5e.api.v1alpha1.DamageBreakdown damage_breakdown = 8 [json_name = "damageBreakdown"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.damage_breakdown_);
    }
    // int32 attack_roll = 2 [json_name = "attackRoll"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_attack_roll() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_attack_roll());
      }
    }
    // int32 attack_total = 3 [json_name = "attackTotal"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_attack_total() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_attack_total());
      }
    }
    // int32 target_ac = 4 [json_name = "targetAc"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_target_ac() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_target_ac());
      }
    }
    // bool hit = 1 [json_name = "hit"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (this_._internal_hit() != 0) {
        total_size += 2;
      }
    }
    // bool critical = 7 [json_name = "critical"];
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (this_._internal_critical() != 0) {
        total_size += 2;
      }
    }
    // int32 damage = 5 [json_name = "damage"];
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      if (this_._internal_damage() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_damage());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void AttackResult::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<AttackResult*>(&to_msg);
  auto& from = static_cast<const AttackResult&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.AttackResult)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_damage_type().empty()) {
        _this->_internal_set_damage_type(from._internal_damage_type());
      } else {
        if (_this->_impl_.damage_type_.IsDefault()) {
          _this->_internal_set_damage_type("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.damage_breakdown_ != nullptr);
      if (_this->_impl_.damage_breakdown_ == nullptr) {
        _this->_impl_.damage_breakdown_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.damage_breakdown_);
      } else {
        _this->_impl_.damage_breakdown_->MergeFrom(*from._impl_.damage_breakdown_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_attack_roll() != 0) {
        _this->_impl_.attack_roll_ = from._impl_.attack_roll_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_attack_total() != 0) {
        _this->_impl_.attack_total_ = from._impl_.attack_total_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_target_ac() != 0) {
        _this->_impl_.target_ac_ = from._impl_.target_ac_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (from._internal_hit() != 0) {
        _this->_impl_.hit_ = from._impl_.hit_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (from._internal_critical() != 0) {
        _this->_impl_.critical_ = from._impl_.critical_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      if (from._internal_damage() != 0) {
        _this->_impl_.damage_ = from._impl_.damage_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void AttackResult::CopyFrom(const AttackResult& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.AttackResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AttackResult::InternalSwap(AttackResult* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.damage_type_, &other->_impl_.damage_type_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.damage_)
      + sizeof(AttackResult::_impl_.damage_)
      - PROTOBUF_FIELD_OFFSET(AttackResult, _impl_.damage_breakdown_)>(
          reinterpret_cast<char*>(&_impl_.damage_breakdown_),
          reinterpret_cast<char*>(&other->_impl_.damage_breakdown_));
}

::google::protobuf::Metadata AttackResult::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class GrantedAction::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<GrantedAction>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_._has_bits_);
};

GrantedAction::GrantedAction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GrantedAction_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.GrantedAction)
}
PROTOBUF_NDEBUG_INLINE GrantedAction::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::GrantedAction& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        id_(arena, from.id_),
        type_(arena, from.type_),
        name_(arena, from.name_),
        reason_(arena, from.reason_),
        weapon_id_(arena, from.weapon_id_) {}

GrantedAction::GrantedAction(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const GrantedAction& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GrantedAction_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  GrantedAction* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.GrantedAction)
}
PROTOBUF_NDEBUG_INLINE GrantedAction::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        id_(arena),
        type_(arena),
        name_(arena),
        reason_(arena),
        weapon_id_(arena) {}

inline void GrantedAction::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
GrantedAction::~GrantedAction() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.GrantedAction)
  SharedDtor(*this);
}
inline void GrantedAction::SharedDtor(MessageLite& self) {
  GrantedAction& this_ = static_cast<GrantedAction&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.id_.Destroy();
  this_._impl_.type_.Destroy();
  this_._impl_.name_.Destroy();
  this_._impl_.reason_.Destroy();
  this_._impl_.weapon_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL GrantedAction::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) GrantedAction(arena);
}
constexpr auto GrantedAction::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(GrantedAction),
                                            alignof(GrantedAction));
}
constexpr auto GrantedAction::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_GrantedAction_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &GrantedAction::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<GrantedAction>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &GrantedAction::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<GrantedAction>(), &GrantedAction::ByteSizeLong,
              &GrantedAction::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_._cached_size_),
          false,
      },
      &GrantedAction::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull GrantedAction_class_data_ =
        GrantedAction::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
GrantedAction::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&GrantedAction_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(GrantedAction_class_data_.tc_table);
  return GrantedAction_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 66, 2>
GrantedAction::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    GrantedAction_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::GrantedAction>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string id = 1 [json_name = "id"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_.id_)}},
    // string type = 2 [json_name = "type"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_.type_)}},
    // string name = 3 [json_name = "name"];
    {::_pbi::TcParser::FastUS1,
     {26, 2, 0,
      PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_.name_)}},
    // string reason = 4 [json_name = "reason"];
    {::_pbi::TcParser::FastUS1,
     {34, 3, 0,
      PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_.reason_)}},
    // string weapon_id = 5 [json_name = "weaponId"];
    {::_pbi::TcParser::FastUS1,
     {42, 4, 0,
      PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_.weapon_id_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string id = 1 [json_name = "id"];
    {PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_.id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string type = 2 [json_name = "type"];
    {PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_.type_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string name = 3 [json_name = "name"];
    {PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_.name_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string reason = 4 [json_name = "reason"];
    {PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_.reason_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string weapon_id = 5 [json_name = "weaponId"];
    {PROTOBUF_FIELD_OFFSET(GrantedAction, _impl_.weapon_id_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\40\2\4\4\6\11\0\0"
    "dnd5e.api.v1alpha1.GrantedAction"
    "id"
    "type"
    "name"
    "reason"
    "weapon_id"
  }},
};
PROTOBUF_NOINLINE void GrantedAction::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.GrantedAction)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.weapon_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL GrantedAction::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const GrantedAction& this_ = static_cast<const GrantedAction&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL GrantedAction::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const GrantedAction& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.GrantedAction)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string id = 1 [json_name = "id"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_id().empty()) {
      const ::std::string& _s = this_._internal_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GrantedAction.id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string type = 2 [json_name = "type"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_type().empty()) {
      const ::std::string& _s = this_._internal_type();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GrantedAction.type");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // string name = 3 [json_name = "name"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_name().empty()) {
      const ::std::string& _s = this_._internal_name();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GrantedAction.name");
      target = stream->WriteStringMaybeAliased(3, _s, target);
    }
  }

  // string reason = 4 [json_name = "reason"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (!this_._internal_reason().empty()) {
      const ::std::string& _s = this_._internal_reason();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GrantedAction.reason");
      target = stream->WriteStringMaybeAliased(4, _s, target);
    }
  }

  // string weapon_id = 5 [json_name = "weaponId"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (!this_._internal_weapon_id().empty()) {
      const ::std::string& _s = this_._internal_weapon_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.GrantedAction.weapon_id");
      target = stream->WriteStringMaybeAliased(5, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.GrantedAction)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t GrantedAction::ByteSizeLong(const MessageLite& base) {
  const GrantedAction& this_ = static_cast<const GrantedAction&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t GrantedAction::ByteSizeLong() const {
  const GrantedAction& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.GrantedAction)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // string id = 1 [json_name = "id"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_id());
      }
    }
    // string type = 2 [json_name = "type"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_type().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_type());
      }
    }
    // string name = 3 [json_name = "name"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!this_._internal_name().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_name());
      }
    }
    // string reason = 4 [json_name = "reason"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!this_._internal_reason().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_reason());
      }
    }
    // string weapon_id = 5 [json_name = "weaponId"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (!this_._internal_weapon_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_weapon_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void GrantedAction::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<GrantedAction*>(&to_msg);
  auto& from = static_cast<const GrantedAction&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.GrantedAction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_id().empty()) {
        _this->_internal_set_id(from._internal_id());
      } else {
        if (_this->_impl_.id_.IsDefault()) {
          _this->_internal_set_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_type().empty()) {
        _this->_internal_set_type(from._internal_type());
      } else {
        if (_this->_impl_.type_.IsDefault()) {
          _this->_internal_set_type("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!from._internal_name().empty()) {
        _this->_internal_set_name(from._internal_name());
      } else {
        if (_this->_impl_.name_.IsDefault()) {
          _this->_internal_set_name("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!from._internal_reason().empty()) {
        _this->_internal_set_reason(from._internal_reason());
      } else {
        if (_this->_impl_.reason_.IsDefault()) {
          _this->_internal_set_reason("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (!from._internal_weapon_id().empty()) {
        _this->_internal_set_weapon_id(from._internal_weapon_id());
      } else {
        if (_this->_impl_.weapon_id_.IsDefault()) {
          _this->_internal_set_weapon_id("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void GrantedAction::CopyFrom(const GrantedAction& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.GrantedAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void GrantedAction::InternalSwap(GrantedAction* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, &other->_impl_.id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.type_, &other->_impl_.type_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reason_, &other->_impl_.reason_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.weapon_id_, &other->_impl_.weapon_id_, arena);
}

::google::protobuf::Metadata GrantedAction::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AttackResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AttackResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_._has_bits_);
};

AttackResponse::AttackResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AttackResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.AttackResponse)
}
PROTOBUF_NDEBUG_INLINE AttackResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::AttackResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        error_(arena, from.error_) {}

AttackResponse::AttackResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const AttackResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AttackResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AttackResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.result_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.result_)
                : nullptr;
  _impl_.combat_state_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_)
                : nullptr;
  _impl_.updated_room_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_room_)
                : nullptr;
  _impl_.granted_action_ = (CheckHasBit(cached_has_bits, 0x00000010U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.granted_action_)
                : nullptr;
  _impl_.success_ = from._impl_.success_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.AttackResponse)
}
PROTOBUF_NDEBUG_INLINE AttackResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        error_(arena) {}

inline void AttackResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, result_),
           0,
           offsetof(Impl_, success_) -
               offsetof(Impl_, result_) +
               sizeof(Impl_::success_));
}
AttackResponse::~AttackResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.AttackResponse)
  SharedDtor(*this);
}
inline void AttackResponse::SharedDtor(MessageLite& self) {
  AttackResponse& this_ = static_cast<AttackResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.error_.Destroy();
  delete this_._impl_.result_;
  delete this_._impl_.combat_state_;
  delete this_._impl_.updated_room_;
  delete this_._impl_.granted_action_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AttackResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AttackResponse(arena);
}
constexpr auto AttackResponse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(AttackResponse),
                                            alignof(AttackResponse));
}
constexpr auto AttackResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_AttackResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AttackResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<AttackResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AttackResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<AttackResponse>(), &AttackResponse::ByteSizeLong,
              &AttackResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_._cached_size_),
          false,
      },
      &AttackResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull AttackResponse_class_data_ =
        AttackResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AttackResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&AttackResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(AttackResponse_class_data_.tc_table);
  return AttackResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 4, 47, 2>
AttackResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    AttackResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::AttackResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // bool success = 1 [json_name = "success"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AttackResponse, _impl_.success_), 5>(),
     {8, 5, 0,
      PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.success_)}},
    // string error = 2 [json_name = "error"];
    {::_pbi::TcParser::FastUS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.error_)}},
    // .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.result_)}},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 1,
      PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.combat_state_)}},
    // .dnd5e.api.v1alpha1.Room updated_room = 5 [json_name = "updatedRoom"];
    {::_pbi::TcParser::FastMtS1,
     {42, 3, 2,
      PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.updated_room_)}},
    // .dnd5e.api.v1alpha1.GrantedAction granted_action = 6 [json_name = "grantedAction"];
    {::_pbi::TcParser::FastMtS1,
     {50, 4, 3,
      PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.granted_action_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // bool success = 1 [json_name = "success"];
    {PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.success_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // string error = 2 [json_name = "error"];
    {PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.error_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
    {PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.result_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
    {PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.combat_state_), _Internal::kHasBitsOffset + 2, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.Room updated_room = 5 [json_name = "updatedRoom"];
    {PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.updated_room_), _Internal::kHasBitsOffset + 3, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.GrantedAction granted_action = 6 [json_name = "grantedAction"];
    {PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.granted_action_), _Internal::kHasBitsOffset + 4, 3, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::AttackResult>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::GrantedAction>()},
  }},
  {{
    "\41\0\5\0\0\0\0\0"
    "dnd5e.api.v1alpha1.AttackResponse"
    "error"
  }},
};
PROTOBUF_NOINLINE void AttackResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.AttackResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.error_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.result_ != nullptr);
      _impl_.result_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.combat_state_ != nullptr);
      _impl_.combat_state_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.updated_room_ != nullptr);
      _impl_.updated_room_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(_impl_.granted_action_ != nullptr);
      _impl_.granted_action_->Clear();
    }
  }
  _impl_.success_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AttackResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AttackResponse& this_ = static_cast<const AttackResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AttackResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AttackResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.AttackResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // bool success = 1 [json_name = "success"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (this_._internal_success() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          1, this_._internal_success(), target);
    }
  }

  // string error = 2 [json_name = "error"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_error().empty()) {
      const ::std::string& _s = this_._internal_error();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.AttackResponse.error");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.result_, this_._impl_.result_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.combat_state_, this_._impl_.combat_state_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.Room updated_room = 5 [json_name = "updatedRoom"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.updated_room_, this_._impl_.updated_room_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.GrantedAction granted_action = 6 [json_name = "grantedAction"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, *this_._impl_.granted_action_, this_._impl_.granted_action_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.AttackResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AttackResponse::ByteSizeLong(const MessageLite& base) {
  const AttackResponse& this_ = static_cast<const AttackResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AttackResponse::ByteSizeLong() const {
  const AttackResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.AttackResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    // string error = 2 [json_name = "error"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_error().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_error());
      }
    }
    // .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.result_);
    }
    // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.combat_state_);
    }
    // .dnd5e.api.v1alpha1.Room updated_room = 5 [json_name = "updatedRoom"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.updated_room_);
    }
    // .dnd5e.api.v1alpha1.GrantedAction granted_action = 6 [json_name = "grantedAction"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.granted_action_);
    }
    // bool success = 1 [json_name = "success"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (this_._internal_success() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void AttackResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<AttackResponse*>(&to_msg);
  auto& from = static_cast<const AttackResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.AttackResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_error().empty()) {
        _this->_internal_set_error(from._internal_error());
      } else {
        if (_this->_impl_.error_.IsDefault()) {
          _this->_internal_set_error("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.result_ != nullptr);
      if (_this->_impl_.result_ == nullptr) {
        _this->_impl_.result_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.result_);
      } else {
        _this->_impl_.result_->MergeFrom(*from._impl_.result_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.combat_state_ != nullptr);
      if (_this->_impl_.combat_state_ == nullptr) {
        _this->_impl_.combat_state_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_);
      } else {
        _this->_impl_.combat_state_->MergeFrom(*from._impl_.combat_state_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.updated_room_ != nullptr);
      if (_this->_impl_.updated_room_ == nullptr) {
        _this->_impl_.updated_room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_room_);
      } else {
        _this->_impl_.updated_room_->MergeFrom(*from._impl_.updated_room_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(from._impl_.granted_action_ != nullptr);
      if (_this->_impl_.granted_action_ == nullptr) {
        _this->_impl_.granted_action_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.granted_action_);
      } else {
        _this->_impl_.granted_action_->MergeFrom(*from._impl_.granted_action_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (from._internal_success() != 0) {
        _this->_impl_.success_ = from._impl_.success_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void AttackResponse::CopyFrom(const AttackResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.AttackResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AttackResponse::InternalSwap(AttackResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_, &other->_impl_.error_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.success_)
      + sizeof(AttackResponse::_impl_.success_)
      - PROTOBUF_FIELD_OFFSET(AttackResponse, _impl_.result_)>(
          reinterpret_cast<char*>(&_impl_.result_),
          reinterpret_cast<char*>(&other->_impl_.result_));
}

::google::protobuf::Metadata AttackResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class EncounterResult::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<EncounterResult>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(EncounterResult, _impl_._has_bits_);
};

EncounterResult::EncounterResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EncounterResult_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.EncounterResult)
}
EncounterResult::EncounterResult(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EncounterResult& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EncounterResult_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE EncounterResult::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void EncounterResult::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.reason_ = {};
}
EncounterResult::~EncounterResult() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.EncounterResult)
  SharedDtor(*this);
}
inline void EncounterResult::SharedDtor(MessageLite& self) {
  EncounterResult& this_ = static_cast<EncounterResult&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL EncounterResult::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) EncounterResult(arena);
}
constexpr auto EncounterResult::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(EncounterResult),
                                            alignof(EncounterResult));
}
constexpr auto EncounterResult::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_EncounterResult_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &EncounterResult::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<EncounterResult>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &EncounterResult::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<EncounterResult>(), &EncounterResult::ByteSizeLong,
              &EncounterResult::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(EncounterResult, _impl_._cached_size_),
          false,
      },
      &EncounterResult::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull EncounterResult_class_data_ =
        EncounterResult::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
EncounterResult::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&EncounterResult_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(EncounterResult_class_data_.tc_table);
  return EncounterResult_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
EncounterResult::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EncounterResult, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    EncounterResult_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EncounterResult>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.EncounterEndReason reason = 1 [json_name = "reason"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(EncounterResult, _impl_.reason_), 0>(),
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(EncounterResult, _impl_.reason_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.EncounterEndReason reason = 1 [json_name = "reason"];
    {PROTOBUF_FIELD_OFFSET(EncounterResult, _impl_.reason_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void EncounterResult::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.EncounterResult)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reason_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL EncounterResult::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const EncounterResult& this_ = static_cast<const EncounterResult&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL EncounterResult::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const EncounterResult& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.EncounterResult)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .dnd5e.api.v1alpha1.EncounterEndReason reason = 1 [json_name = "reason"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (this_._internal_reason() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          1, this_._internal_reason(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.EncounterResult)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t EncounterResult::ByteSizeLong(const MessageLite& base) {
  const EncounterResult& this_ = static_cast<const EncounterResult&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t EncounterResult::ByteSizeLong() const {
  const EncounterResult& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.EncounterResult)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // .dnd5e.api.v1alpha1.EncounterEndReason reason = 1 [json_name = "reason"];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (this_._internal_reason() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_reason());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void EncounterResult::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<EncounterResult*>(&to_msg);
  auto& from = static_cast<const EncounterResult&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.EncounterResult)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (from._internal_reason() != 0) {
      _this->_impl_.reason_ = from._impl_.reason_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void EncounterResult::CopyFrom(const EncounterResult& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.EncounterResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EncounterResult::InternalSwap(EncounterResult* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.reason_, other->_impl_.reason_);
}

::google::protobuf::Metadata EncounterResult::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HealResult::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<HealResult>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HealResult, _impl_._has_bits_);
};

HealResult::HealResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HealResult_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.HealResult)
}
HealResult::HealResult(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HealResult& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, HealResult_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE HealResult::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void HealResult::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, amount_healed_),
           0,
           offsetof(Impl_, max_hp_) -
               offsetof(Impl_, amount_healed_) +
               sizeof(Impl_::max_hp_));
}
HealResult::~HealResult() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.HealResult)
  SharedDtor(*this);
}
inline void HealResult::SharedDtor(MessageLite& self) {
  HealResult& this_ = static_cast<HealResult&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL HealResult::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) HealResult(arena);
}
constexpr auto HealResult::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HealResult),
                                            alignof(HealResult));
}
constexpr auto HealResult::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_HealResult_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &HealResult::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<HealResult>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &HealResult::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<HealResult>(), &HealResult::ByteSizeLong,
              &HealResult::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(HealResult, _impl_._cached_size_),
          false,
      },
      &HealResult::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull HealResult_class_data_ =
        HealResult::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
HealResult::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&HealResult_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(HealResult_class_data_.tc_table);
  return HealResult_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
HealResult::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HealResult, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    HealResult_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::HealResult>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int32 amount_healed = 1 [json_name = "amountHealed"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HealResult, _impl_.amount_healed_), 0>(),
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(HealResult, _impl_.amount_healed_)}},
    // int32 new_hp = 2 [json_name = "newHp"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HealResult, _impl_.new_hp_), 1>(),
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(HealResult, _impl_.new_hp_)}},
    // int32 max_hp = 3 [json_name = "maxHp"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HealResult, _impl_.max_hp_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(HealResult, _impl_.max_hp_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 amount_healed = 1 [json_name = "amountHealed"];
    {PROTOBUF_FIELD_OFFSET(HealResult, _impl_.amount_healed_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 new_hp = 2 [json_name = "newHp"];
    {PROTOBUF_FIELD_OFFSET(HealResult, _impl_.new_hp_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 max_hp = 3 [json_name = "maxHp"];
    {PROTOBUF_FIELD_OFFSET(HealResult, _impl_.max_hp_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void HealResult::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.HealResult)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    ::memset(&_impl_.amount_healed_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_hp_) -
        reinterpret_cast<char*>(&_impl_.amount_healed_)) + sizeof(_impl_.max_hp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL HealResult::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const HealResult& this_ = static_cast<const HealResult&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL HealResult::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const HealResult& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.HealResult)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // int32 amount_healed = 1 [json_name = "amountHealed"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (this_._internal_amount_healed() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
              stream, this_._internal_amount_healed(), target);
    }
  }

  // int32 new_hp = 2 [json_name = "newHp"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (this_._internal_new_hp() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
              stream, this_._internal_new_hp(), target);
    }
  }

  // int32 max_hp = 3 [json_name = "maxHp"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_max_hp() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
              stream, this_._internal_max_hp(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.HealResult)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t HealResult::ByteSizeLong(const MessageLite& base) {
  const HealResult& this_ = static_cast<const HealResult&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t HealResult::ByteSizeLong() const {
  const HealResult& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.HealResult)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // int32 amount_healed = 1 [json_name = "amountHealed"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (this_._internal_amount_healed() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_amount_healed());
      }
    }
    // int32 new_hp = 2 [json_name = "newHp"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (this_._internal_new_hp() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_new_hp());
      }
    }
    // int32 max_hp = 3 [json_name = "maxHp"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_max_hp() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_max_hp());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void HealResult::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<HealResult*>(&to_msg);
  auto& from = static_cast<const HealResult&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.HealResult)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (from._internal_amount_healed() != 0) {
        _this->_impl_.amount_healed_ = from._impl_.amount_healed_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (from._internal_new_hp() != 0) {
        _this->_impl_.new_hp_ = from._impl_.new_hp_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_max_hp() != 0) {
        _this->_impl_.max_hp_ = from._impl_.max_hp_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void HealResult::CopyFrom(const HealResult& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.HealResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HealResult::InternalSwap(HealResult* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HealResult, _impl_.max_hp_)
      + sizeof(HealResult::_impl_.max_hp_)
      - PROTOBUF_FIELD_OFFSET(HealResult, _impl_.amount_healed_)>(
          reinterpret_cast<char*>(&_impl_.amount_healed_),
          reinterpret_cast<char*>(&other->_impl_.amount_healed_));
}

::google::protobuf::Metadata HealResult::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MonsterExecutedAction::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MonsterExecutedAction>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::MonsterExecutedAction, _impl_._oneof_case_);
};

void MonsterExecutedAction::set_allocated_attack_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE attack_result) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_details();
  if (attack_result) {
    ::google::protobuf::Arena* submessage_arena = attack_result->GetArena();
    if (message_arena != submessage_arena) {
      attack_result = ::google::protobuf::internal::GetOwnedMessage(message_arena, attack_result, submessage_arena);
    }
    set_has_attack_result();
    _impl_.details_.attack_result_ = attack_result;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MonsterExecutedAction.attack_result)
}
void MonsterExecutedAction::set_allocated_heal_result(::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NULLABLE heal_result) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_details();
  if (heal_result) {
    ::google::protobuf::Arena* submessage_arena = heal_result->GetArena();
    if (message_arena != submessage_arena) {
      heal_result = ::google::protobuf::internal::GetOwnedMessage(message_arena, heal_result, submessage_arena);
    }
    set_has_heal_result();
    _impl_.details_.heal_result_ = heal_result;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MonsterExecutedAction.heal_result)
}
MonsterExecutedAction::MonsterExecutedAction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MonsterExecutedAction_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.MonsterExecutedAction)
}
PROTOBUF_NDEBUG_INLINE MonsterExecutedAction::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::MonsterExecutedAction& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        action_id_(arena, from.action_id_),
        target_id_(arena, from.target_id_),
        details_{},
        _oneof_case_{from._oneof_case_[0]} {}

MonsterExecutedAction::MonsterExecutedAction(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MonsterExecutedAction& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MonsterExecutedAction_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MonsterExecutedAction* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, action_type_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, action_type_),
           offsetof(Impl_, success_) -
               offsetof(Impl_, action_type_) +
               sizeof(Impl_::success_));
  switch (details_case()) {
    case DETAILS_NOT_SET:
      break;
      case kAttackResult:
        _impl_.details_.attack_result_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.details_.attack_result_);
        break;
      case kHealResult:
        _impl_.details_.heal_result_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.details_.heal_result_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.MonsterExecutedAction)
}
PROTOBUF_NDEBUG_INLINE MonsterExecutedAction::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        action_id_(arena),
        target_id_(arena),
        details_{},
        _oneof_case_{} {}

inline void MonsterExecutedAction::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, action_type_),
           0,
           offsetof(Impl_, success_) -
               offsetof(Impl_, action_type_) +
               sizeof(Impl_::success_));
}
MonsterExecutedAction::~MonsterExecutedAction() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.MonsterExecutedAction)
  SharedDtor(*this);
}
inline void MonsterExecutedAction::SharedDtor(MessageLite& self) {
  MonsterExecutedAction& this_ = static_cast<MonsterExecutedAction&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.action_id_.Destroy();
  this_._impl_.target_id_.Destroy();
  if (this_.has_details()) {
    this_.clear_details();
  }
  this_._impl_.~Impl_();
}

void MonsterExecutedAction::clear_details() {
// @@protoc_insertion_point(one_of_clear_start:dnd5e.api.v1alpha1.MonsterExecutedAction)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (details_case()) {
    case kAttackResult: {
      if (GetArena() == nullptr) {
        delete _impl_.details_.attack_result_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.details_.attack_result_);
      }
      break;
    }
    case kHealResult: {
      if (GetArena() == nullptr) {
        delete _impl_.details_.heal_result_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.details_.heal_result_);
      }
      break;
    }
    case DETAILS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = DETAILS_NOT_SET;
}


inline void* PROTOBUF_NONNULL MonsterExecutedAction::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MonsterExecutedAction(arena);
}
constexpr auto MonsterExecutedAction::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(MonsterExecutedAction),
                                            alignof(MonsterExecutedAction));
}
constexpr auto MonsterExecutedAction::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MonsterExecutedAction_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MonsterExecutedAction::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MonsterExecutedAction>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MonsterExecutedAction::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MonsterExecutedAction>(), &MonsterExecutedAction::ByteSizeLong,
              &MonsterExecutedAction::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_._cached_size_),
          false,
      },
      &MonsterExecutedAction::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MonsterExecutedAction_class_data_ =
        MonsterExecutedAction::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MonsterExecutedAction::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MonsterExecutedAction_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MonsterExecutedAction_class_data_.tc_table);
  return MonsterExecutedAction_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 6, 2, 67, 2>
MonsterExecutedAction::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_._has_bits_),
    0, // no _extensions_
    6, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MonsterExecutedAction_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterExecutedAction>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bool success = 4 [json_name = "success"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MonsterExecutedAction, _impl_.success_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_.success_)}},
    // string action_id = 1 [json_name = "actionId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_.action_id_)}},
    // .dnd5e.api.v1alpha1.MonsterActionType action_type = 2 [json_name = "actionType"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MonsterExecutedAction, _impl_.action_type_), 2>(),
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_.action_type_)}},
    // string target_id = 3 [json_name = "targetId"];
    {::_pbi::TcParser::FastUS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_.target_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string action_id = 1 [json_name = "actionId"];
    {PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_.action_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.MonsterActionType action_type = 2 [json_name = "actionType"];
    {PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_.action_type_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // string target_id = 3 [json_name = "targetId"];
    {PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_.target_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool success = 4 [json_name = "success"];
    {PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_.success_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // .dnd5e.api.v1alpha1.AttackResult attack_result = 5 [json_name = "attackResult"];
    {PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_.details_.attack_result_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.HealResult heal_result = 6 [json_name = "healResult"];
    {PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_.details_.heal_result_), _Internal::kOneofCaseOffset + 0, 1, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::AttackResult>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::HealResult>()},
  }},
  {{
    "\50\11\0\11\0\0\0\0"
    "dnd5e.api.v1alpha1.MonsterExecutedAction"
    "action_id"
    "target_id"
  }},
};
PROTOBUF_NOINLINE void MonsterExecutedAction::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.MonsterExecutedAction)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.action_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.target_id_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000cU)) {
    ::memset(&_impl_.action_type_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.success_) -
        reinterpret_cast<char*>(&_impl_.action_type_)) + sizeof(_impl_.success_));
  }
  clear_details();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MonsterExecutedAction::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MonsterExecutedAction& this_ = static_cast<const MonsterExecutedAction&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MonsterExecutedAction::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MonsterExecutedAction& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.MonsterExecutedAction)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string action_id = 1 [json_name = "actionId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_action_id().empty()) {
      const ::std::string& _s = this_._internal_action_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MonsterExecutedAction.action_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.MonsterActionType action_type = 2 [json_name = "actionType"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_action_type() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          2, this_._internal_action_type(), target);
    }
  }

  // string target_id = 3 [json_name = "targetId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_target_id().empty()) {
      const ::std::string& _s = this_._internal_target_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MonsterExecutedAction.target_id");
      target = stream->WriteStringMaybeAliased(3, _s, target);
    }
  }

  // bool success = 4 [json_name = "success"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_success() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          4, this_._internal_success(), target);
    }
  }

  switch (this_.details_case()) {
    case kAttackResult: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *this_._impl_.details_.attack_result_, this_._impl_.details_.attack_result_->GetCachedSize(), target,
          stream);
      break;
    }
    case kHealResult: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *this_._impl_.details_.heal_result_, this_._impl_.details_.heal_result_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.MonsterExecutedAction)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MonsterExecutedAction::ByteSizeLong(const MessageLite& base) {
  const MonsterExecutedAction& this_ = static_cast<const MonsterExecutedAction&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MonsterExecutedAction::ByteSizeLong() const {
  const MonsterExecutedAction& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.MonsterExecutedAction)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // string action_id = 1 [json_name = "actionId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_action_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_action_id());
      }
    }
    // string target_id = 3 [json_name = "targetId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_target_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_target_id());
      }
    }
    // .dnd5e.api.v1alpha1.MonsterActionType action_type = 2 [json_name = "actionType"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_action_type() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_action_type());
      }
    }
    // bool success = 4 [json_name = "success"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_success() != 0) {
        total_size += 2;
      }
    }
  }
  switch (this_.details_case()) {
    // .dnd5e.api.v1alpha1.AttackResult attack_result = 5 [json_name = "attackResult"];
    case kAttackResult: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.details_.attack_result_);
      break;
    }
    // .dnd5e.api.v1alpha1.HealResult heal_result = 6 [json_name = "healResult"];
    case kHealResult: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.details_.heal_result_);
      break;
    }
    case DETAILS_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MonsterExecutedAction::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<MonsterExecutedAction*>(&to_msg);
  auto& from = static_cast<const MonsterExecutedAction&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.MonsterExecutedAction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_action_id().empty()) {
        _this->_internal_set_action_id(from._internal_action_id());
      } else {
        if (_this->_impl_.action_id_.IsDefault()) {
          _this->_internal_set_action_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_target_id().empty()) {
        _this->_internal_set_target_id(from._internal_target_id());
      } else {
        if (_this->_impl_.target_id_.IsDefault()) {
          _this->_internal_set_target_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_action_type() != 0) {
        _this->_impl_.action_type_ = from._impl_.action_type_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_success() != 0) {
        _this->_impl_.success_ = from._impl_.success_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case =
          from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_details();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kAttackResult: {
        if (oneof_needs_init) {
          _this->_impl_.details_.attack_result_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.details_.attack_result_);
        } else {
          _this->_impl_.details_.attack_result_->MergeFrom(*from._impl_.details_.attack_result_);
        }
        break;
      }
      case kHealResult: {
        if (oneof_needs_init) {
          _this->_impl_.details_.heal_result_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.details_.heal_result_);
        } else {
          _this->_impl_.details_.heal_result_->MergeFrom(*from._impl_.details_.heal_result_);
        }
        break;
      }
      case DETAILS_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void MonsterExecutedAction::CopyFrom(const MonsterExecutedAction& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.MonsterExecutedAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MonsterExecutedAction::InternalSwap(MonsterExecutedAction* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.action_id_, &other->_impl_.action_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.target_id_, &other->_impl_.target_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_.success_)
      + sizeof(MonsterExecutedAction::_impl_.success_)
      - PROTOBUF_FIELD_OFFSET(MonsterExecutedAction, _impl_.action_type_)>(
          reinterpret_cast<char*>(&_impl_.action_type_),
          reinterpret_cast<char*>(&other->_impl_.action_type_));
  swap(_impl_.details_, other->_impl_.details_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata MonsterExecutedAction::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MonsterTurnResult::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MonsterTurnResult>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_._has_bits_);
};

void MonsterTurnResult::clear_movement_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_path_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
MonsterTurnResult::MonsterTurnResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MonsterTurnResult_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.MonsterTurnResult)
}
PROTOBUF_NDEBUG_INLINE MonsterTurnResult::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::MonsterTurnResult& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        actions_{visibility, arena, from.actions_},
        movement_path_{visibility, arena, from.movement_path_},
        monster_id_(arena, from.monster_id_),
        monster_name_(arena, from.monster_name_) {}

MonsterTurnResult::MonsterTurnResult(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MonsterTurnResult& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MonsterTurnResult_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MonsterTurnResult* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.MonsterTurnResult)
}
PROTOBUF_NDEBUG_INLINE MonsterTurnResult::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        actions_{visibility, arena},
        movement_path_{visibility, arena},
        monster_id_(arena),
        monster_name_(arena) {}

inline void MonsterTurnResult::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
MonsterTurnResult::~MonsterTurnResult() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.MonsterTurnResult)
  SharedDtor(*this);
}
inline void MonsterTurnResult::SharedDtor(MessageLite& self) {
  MonsterTurnResult& this_ = static_cast<MonsterTurnResult&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.monster_id_.Destroy();
  this_._impl_.monster_name_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MonsterTurnResult::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MonsterTurnResult(arena);
}
constexpr auto MonsterTurnResult::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_.actions_) +
          decltype(MonsterTurnResult::_impl_.actions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_.movement_path_) +
          decltype(MonsterTurnResult::_impl_.movement_path_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(MonsterTurnResult), alignof(MonsterTurnResult), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&MonsterTurnResult::PlacementNew_,
                                 sizeof(MonsterTurnResult),
                                 alignof(MonsterTurnResult));
  }
}
constexpr auto MonsterTurnResult::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MonsterTurnResult_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MonsterTurnResult::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MonsterTurnResult>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MonsterTurnResult::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MonsterTurnResult>(), &MonsterTurnResult::ByteSizeLong,
              &MonsterTurnResult::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_._cached_size_),
          false,
      },
      &MonsterTurnResult::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MonsterTurnResult_class_data_ =
        MonsterTurnResult::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MonsterTurnResult::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MonsterTurnResult_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MonsterTurnResult_class_data_.tc_table);
  return MonsterTurnResult_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 67, 2>
MonsterTurnResult::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MonsterTurnResult_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterTurnResult>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .api.v1alpha1.Position movement_path = 4 [json_name = "movementPath"];
    {::_pbi::TcParser::FastMtR1,
     {34, 1, 1,
      PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_.movement_path_)}},
    // string monster_id = 1 [json_name = "monsterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 2, 0,
      PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_.monster_id_)}},
    // string monster_name = 2 [json_name = "monsterName"];
    {::_pbi::TcParser::FastUS1,
     {18, 3, 0,
      PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_.monster_name_)}},
    // repeated .dnd5e.api.v1alpha1.MonsterExecutedAction actions = 3 [json_name = "actions"];
    {::_pbi::TcParser::FastMtR1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_.actions_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string monster_id = 1 [json_name = "monsterId"];
    {PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_.monster_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string monster_name = 2 [json_name = "monsterName"];
    {PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_.monster_name_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .dnd5e.api.v1alpha1.MonsterExecutedAction actions = 3 [json_name = "actions"];
    {PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_.actions_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .api.v1alpha1.Position movement_path = 4 [json_name = "movementPath"];
    {PROTOBUF_FIELD_OFFSET(MonsterTurnResult, _impl_.movement_path_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterExecutedAction>()},
      {::_pbi::TcParser::GetTable<::api::v1alpha1::Position>()},
  }},
  {{
    "\44\12\14\0\0\0\0\0"
    "dnd5e.api.v1alpha1.MonsterTurnResult"
    "monster_id"
    "monster_name"
  }},
};
PROTOBUF_NOINLINE void MonsterTurnResult::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.MonsterTurnResult)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.actions_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.movement_path_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.monster_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.monster_name_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MonsterTurnResult::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MonsterTurnResult& this_ = static_cast<const MonsterTurnResult&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MonsterTurnResult::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MonsterTurnResult& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.MonsterTurnResult)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string monster_id = 1 [json_name = "monsterId"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_monster_id().empty()) {
      const ::std::string& _s = this_._internal_monster_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MonsterTurnResult.monster_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string monster_name = 2 [json_name = "monsterName"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (!this_._internal_monster_name().empty()) {
      const ::std::string& _s = this_._internal_monster_name();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MonsterTurnResult.monster_name");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // repeated .dnd5e.api.v1alpha1.MonsterExecutedAction actions = 3 [json_name = "actions"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_actions_size());
         i < n; i++) {
      const auto& repfield = this_._internal_actions().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              3, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // repeated .api.v1alpha1.Position movement_path = 4 [json_name = "movementPath"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_movement_path_size());
         i < n; i++) {
      const auto& repfield = this_._internal_movement_path().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              4, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.MonsterTurnResult)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MonsterTurnResult::ByteSizeLong(const MessageLite& base) {
  const MonsterTurnResult& this_ = static_cast<const MonsterTurnResult&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MonsterTurnResult::ByteSizeLong() const {
  const MonsterTurnResult& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.MonsterTurnResult)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // repeated .dnd5e.api.v1alpha1.MonsterExecutedAction actions = 3 [json_name = "actions"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_actions_size();
      for (const auto& msg : this_._internal_actions()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .api.v1alpha1.Position movement_path = 4 [json_name = "movementPath"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 1UL * this_._internal_movement_path_size();
      for (const auto& msg : this_._internal_movement_path()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string monster_id = 1 [json_name = "monsterId"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!this_._internal_monster_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_monster_id());
      }
    }
    // string monster_name = 2 [json_name = "monsterName"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!this_._internal_monster_name().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_monster_name());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MonsterTurnResult::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<MonsterTurnResult*>(&to_msg);
  auto& from = static_cast<const MonsterTurnResult&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.MonsterTurnResult)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_actions()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_actions());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_movement_path()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_movement_path());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!from._internal_monster_id().empty()) {
        _this->_internal_set_monster_id(from._internal_monster_id());
      } else {
        if (_this->_impl_.monster_id_.IsDefault()) {
          _this->_internal_set_monster_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (!from._internal_monster_name().empty()) {
        _this->_internal_set_monster_name(from._internal_monster_name());
      } else {
        if (_this->_impl_.monster_name_.IsDefault()) {
          _this->_internal_set_monster_name("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void MonsterTurnResult::CopyFrom(const MonsterTurnResult& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.MonsterTurnResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MonsterTurnResult::InternalSwap(MonsterTurnResult* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.actions_.InternalSwap(&other->_impl_.actions_);
  _impl_.movement_path_.InternalSwap(&other->_impl_.movement_path_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.monster_id_, &other->_impl_.monster_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.monster_name_, &other->_impl_.monster_name_, arena);
}

::google::protobuf::Metadata MonsterTurnResult::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ActivateFeatureRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ActivateFeatureRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ActivateFeatureRequest, _impl_._has_bits_);
};

ActivateFeatureRequest::ActivateFeatureRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ActivateFeatureRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.ActivateFeatureRequest)
}
PROTOBUF_NDEBUG_INLINE ActivateFeatureRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::ActivateFeatureRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        encounter_id_(arena, from.encounter_id_),
        character_id_(arena, from.character_id_) {}

ActivateFeatureRequest::ActivateFeatureRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ActivateFeatureRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ActivateFeatureRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ActivateFeatureRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.feature_id_ = from._impl_.feature_id_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.ActivateFeatureRequest)
}
PROTOBUF_NDEBUG_INLINE ActivateFeatureRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        encounter_id_(arena),
        character_id_(arena) {}

inline void ActivateFeatureRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.feature_id_ = {};
}
ActivateFeatureRequest::~ActivateFeatureRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.ActivateFeatureRequest)
  SharedDtor(*this);
}
inline void ActivateFeatureRequest::SharedDtor(MessageLite& self) {
  ActivateFeatureRequest& this_ = static_cast<ActivateFeatureRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.character_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ActivateFeatureRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ActivateFeatureRequest(arena);
}
constexpr auto ActivateFeatureRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ActivateFeatureRequest),
                                            alignof(ActivateFeatureRequest));
}
constexpr auto ActivateFeatureRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ActivateFeatureRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ActivateFeatureRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ActivateFeatureRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ActivateFeatureRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ActivateFeatureRequest>(), &ActivateFeatureRequest::ByteSizeLong,
              &ActivateFeatureRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ActivateFeatureRequest, _impl_._cached_size_),
          false,
      },
      &ActivateFeatureRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ActivateFeatureRequest_class_data_ =
        ActivateFeatureRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ActivateFeatureRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ActivateFeatureRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ActivateFeatureRequest_class_data_.tc_table);
  return ActivateFeatureRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 74, 2>
ActivateFeatureRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ActivateFeatureRequest, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ActivateFeatureRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ActivateFeatureRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(ActivateFeatureRequest, _impl_.encounter_id_)}},
    // string character_id = 2 [json_name = "characterId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(ActivateFeatureRequest, _impl_.character_id_)}},
    // .dnd5e.api.v1alpha1.FeatureId feature_id = 3 [json_name = "featureId"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ActivateFeatureRequest, _impl_.feature_id_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(ActivateFeatureRequest, _impl_.feature_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(ActivateFeatureRequest, _impl_.encounter_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string character_id = 2 [json_name = "characterId"];
    {PROTOBUF_FIELD_OFFSET(ActivateFeatureRequest, _impl_.character_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.FeatureId feature_id = 3 [json_name = "featureId"];
    {PROTOBUF_FIELD_OFFSET(ActivateFeatureRequest, _impl_.feature_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
    "\51\14\14\0\0\0\0\0"
    "dnd5e.api.v1alpha1.ActivateFeatureRequest"
    "encounter_id"
    "character_id"
  }},
};
PROTOBUF_NOINLINE void ActivateFeatureRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.ActivateFeatureRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.character_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.feature_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ActivateFeatureRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ActivateFeatureRequest& this_ = static_cast<const ActivateFeatureRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ActivateFeatureRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ActivateFeatureRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.ActivateFeatureRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.ActivateFeatureRequest.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string character_id = 2 [json_name = "characterId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_character_id().empty()) {
      const ::std::string& _s = this_._internal_character_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.ActivateFeatureRequest.character_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.FeatureId feature_id = 3 [json_name = "featureId"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_feature_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          3, this_._internal_feature_id(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.ActivateFeatureRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ActivateFeatureRequest::ByteSizeLong(const MessageLite& base) {
  const ActivateFeatureRequest& this_ = static_cast<const ActivateFeatureRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ActivateFeatureRequest::ByteSizeLong() const {
  const ActivateFeatureRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.ActivateFeatureRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // string character_id = 2 [json_name = "characterId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_character_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_character_id());
      }
    }
    // .dnd5e.api.v1alpha1.FeatureId feature_id = 3 [json_name = "featureId"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_feature_id() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_feature_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ActivateFeatureRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ActivateFeatureRequest*>(&to_msg);
  auto& from = static_cast<const ActivateFeatureRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.ActivateFeatureRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_character_id().empty()) {
        _this->_internal_set_character_id(from._internal_character_id());
      } else {
        if (_this->_impl_.character_id_.IsDefault()) {
          _this->_internal_set_character_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_feature_id() != 0) {
        _this->_impl_.feature_id_ = from._impl_.feature_id_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ActivateFeatureRequest::CopyFrom(const ActivateFeatureRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.ActivateFeatureRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ActivateFeatureRequest::InternalSwap(ActivateFeatureRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.character_id_, &other->_impl_.character_id_, arena);
  swap(_impl_.feature_id_, other->_impl_.feature_id_);
}

::google::protobuf::Metadata ActivateFeatureRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ActivateFeatureResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ActivateFeatureResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_._has_bits_);
};

void ActivateFeatureResponse::clear_updated_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_character_ != nullptr) _impl_.updated_character_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
ActivateFeatureResponse::ActivateFeatureResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ActivateFeatureResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.ActivateFeatureResponse)
}
PROTOBUF_NDEBUG_INLINE ActivateFeatureResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::ActivateFeatureResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_) {}

ActivateFeatureResponse::ActivateFeatureResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ActivateFeatureResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ActivateFeatureResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ActivateFeatureResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.updated_character_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_character_)
                : nullptr;
  _impl_.updated_combat_state_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_combat_state_)
                : nullptr;
  _impl_.success_ = from._impl_.success_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.ActivateFeatureResponse)
}
PROTOBUF_NDEBUG_INLINE ActivateFeatureResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        message_(arena) {}

inline void ActivateFeatureResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, updated_character_),
           0,
           offsetof(Impl_, success_) -
               offsetof(Impl_, updated_character_) +
               sizeof(Impl_::success_));
}
ActivateFeatureResponse::~ActivateFeatureResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.ActivateFeatureResponse)
  SharedDtor(*this);
}
inline void ActivateFeatureResponse::SharedDtor(MessageLite& self) {
  ActivateFeatureResponse& this_ = static_cast<ActivateFeatureResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.message_.Destroy();
  delete this_._impl_.updated_character_;
  delete this_._impl_.updated_combat_state_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ActivateFeatureResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ActivateFeatureResponse(arena);
}
constexpr auto ActivateFeatureResponse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ActivateFeatureResponse),
                                            alignof(ActivateFeatureResponse));
}
constexpr auto ActivateFeatureResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ActivateFeatureResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ActivateFeatureResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ActivateFeatureResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ActivateFeatureResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ActivateFeatureResponse>(), &ActivateFeatureResponse::ByteSizeLong,
              &ActivateFeatureResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_._cached_size_),
          false,
      },
      &ActivateFeatureResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ActivateFeatureResponse_class_data_ =
        ActivateFeatureResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ActivateFeatureResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ActivateFeatureResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ActivateFeatureResponse_class_data_.tc_table);
  return ActivateFeatureResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 58, 2>
ActivateFeatureResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ActivateFeatureResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::ActivateFeatureResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.CombatState updated_combat_state = 4 [json_name = "updatedCombatState"];
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 1,
      PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_.updated_combat_state_)}},
    // bool success = 1 [json_name = "success"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ActivateFeatureResponse, _impl_.success_), 3>(),
     {8, 3, 0,
      PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_.success_)}},
    // string message = 2 [json_name = "message"];
    {::_pbi::TcParser::FastUS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_.message_)}},
    // .dnd5e.api.v1alpha1.Character updated_character = 3 [json_name = "updatedCharacter"];
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_.updated_character_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bool success = 1 [json_name = "success"];
    {PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_.success_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // string message = 2 [json_name = "message"];
    {PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_.message_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.Character updated_character = 3 [json_name = "updatedCharacter"];
    {PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_.updated_character_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.CombatState updated_combat_state = 4 [json_name = "updatedCombatState"];
    {PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_.updated_combat_state_), _Internal::kHasBitsOffset + 2, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Character>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>()},
  }},
  {{
    "\52\0\7\0\0\0\0\0"
    "dnd5e.api.v1alpha1.ActivateFeatureResponse"
    "message"
  }},
};
PROTOBUF_NOINLINE void ActivateFeatureResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.ActivateFeatureResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.updated_character_ != nullptr);
      _impl_.updated_character_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.updated_combat_state_ != nullptr);
      _impl_.updated_combat_state_->Clear();
    }
  }
  _impl_.success_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ActivateFeatureResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ActivateFeatureResponse& this_ = static_cast<const ActivateFeatureResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ActivateFeatureResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ActivateFeatureResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.ActivateFeatureResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // bool success = 1 [json_name = "success"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_success() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          1, this_._internal_success(), target);
    }
  }

  // string message = 2 [json_name = "message"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_message().empty()) {
      const ::std::string& _s = this_._internal_message();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.ActivateFeatureResponse.message");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.Character updated_character = 3 [json_name = "updatedCharacter"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.updated_character_, this_._impl_.updated_character_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.CombatState updated_combat_state = 4 [json_name = "updatedCombatState"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.updated_combat_state_, this_._impl_.updated_combat_state_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.ActivateFeatureResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ActivateFeatureResponse::ByteSizeLong(const MessageLite& base) {
  const ActivateFeatureResponse& this_ = static_cast<const ActivateFeatureResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ActivateFeatureResponse::ByteSizeLong() const {
  const ActivateFeatureResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.ActivateFeatureResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // string message = 2 [json_name = "message"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_message().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_message());
      }
    }
    // .dnd5e.api.v1alpha1.Character updated_character = 3 [json_name = "updatedCharacter"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.updated_character_);
    }
    // .dnd5e.api.v1alpha1.CombatState updated_combat_state = 4 [json_name = "updatedCombatState"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.updated_combat_state_);
    }
    // bool success = 1 [json_name = "success"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_success() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ActivateFeatureResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ActivateFeatureResponse*>(&to_msg);
  auto& from = static_cast<const ActivateFeatureResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.ActivateFeatureResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_message().empty()) {
        _this->_internal_set_message(from._internal_message());
      } else {
        if (_this->_impl_.message_.IsDefault()) {
          _this->_internal_set_message("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.updated_character_ != nullptr);
      if (_this->_impl_.updated_character_ == nullptr) {
        _this->_impl_.updated_character_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_character_);
      } else {
        _this->_impl_.updated_character_->MergeFrom(*from._impl_.updated_character_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.updated_combat_state_ != nullptr);
      if (_this->_impl_.updated_combat_state_ == nullptr) {
        _this->_impl_.updated_combat_state_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_combat_state_);
      } else {
        _this->_impl_.updated_combat_state_->MergeFrom(*from._impl_.updated_combat_state_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_success() != 0) {
        _this->_impl_.success_ = from._impl_.success_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ActivateFeatureResponse::CopyFrom(const ActivateFeatureResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.ActivateFeatureResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ActivateFeatureResponse::InternalSwap(ActivateFeatureResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_.success_)
      + sizeof(ActivateFeatureResponse::_impl_.success_)
      - PROTOBUF_FIELD_OFFSET(ActivateFeatureResponse, _impl_.updated_character_)>(
          reinterpret_cast<char*>(&_impl_.updated_character_),
          reinterpret_cast<char*>(&other->_impl_.updated_character_));
}

::google::protobuf::Metadata ActivateFeatureResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PartyMember::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PartyMember>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PartyMember, _impl_._has_bits_);
};

void PartyMember::clear_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ != nullptr) _impl_.character_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
PartyMember::PartyMember(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PartyMember_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.PartyMember)
}
PROTOBUF_NDEBUG_INLINE PartyMember::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::PartyMember& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        player_id_(arena, from.player_id_) {}

PartyMember::PartyMember(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PartyMember& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PartyMember_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PartyMember* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.character_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.character_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, is_host_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, is_host_),
           offsetof(Impl_, is_connected_) -
               offsetof(Impl_, is_host_) +
               sizeof(Impl_::is_connected_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.PartyMember)
}
PROTOBUF_NDEBUG_INLINE PartyMember::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        player_id_(arena) {}

inline void PartyMember::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, character_),
           0,
           offsetof(Impl_, is_connected_) -
               offsetof(Impl_, character_) +
               sizeof(Impl_::is_connected_));
}
PartyMember::~PartyMember() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.PartyMember)
  SharedDtor(*this);
}
inline void PartyMember::SharedDtor(MessageLite& self) {
  PartyMember& this_ = static_cast<PartyMember&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.player_id_.Destroy();
  delete this_._impl_.character_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PartyMember::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PartyMember(arena);
}
constexpr auto PartyMember::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PartyMember),
                                            alignof(PartyMember));
}
constexpr auto PartyMember::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PartyMember_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PartyMember::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PartyMember>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PartyMember::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PartyMember>(), &PartyMember::ByteSizeLong,
              &PartyMember::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PartyMember, _impl_._cached_size_),
          false,
      },
      &PartyMember::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PartyMember_class_data_ =
        PartyMember::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PartyMember::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PartyMember_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PartyMember_class_data_.tc_table);
  return PartyMember_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 48, 2>
PartyMember::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PartyMember, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PartyMember_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PartyMember>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string player_id = 1 [json_name = "playerId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(PartyMember, _impl_.player_id_)}},
    // .dnd5e.api.v1alpha1.Character character = 2 [json_name = "character"];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(PartyMember, _impl_.character_)}},
    // bool is_host = 3 [json_name = "isHost"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(PartyMember, _impl_.is_host_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(PartyMember, _impl_.is_host_)}},
    // bool is_ready = 4 [json_name = "isReady"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(PartyMember, _impl_.is_ready_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(PartyMember, _impl_.is_ready_)}},
    // bool is_connected = 5 [json_name = "isConnected"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(PartyMember, _impl_.is_connected_), 4>(),
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(PartyMember, _impl_.is_connected_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1 [json_name = "playerId"];
    {PROTOBUF_FIELD_OFFSET(PartyMember, _impl_.player_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.Character character = 2 [json_name = "character"];
    {PROTOBUF_FIELD_OFFSET(PartyMember, _impl_.character_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool is_host = 3 [json_name = "isHost"];
    {PROTOBUF_FIELD_OFFSET(PartyMember, _impl_.is_host_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool is_ready = 4 [json_name = "isReady"];
    {PROTOBUF_FIELD_OFFSET(PartyMember, _impl_.is_ready_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool is_connected = 5 [json_name = "isConnected"];
    {PROTOBUF_FIELD_OFFSET(PartyMember, _impl_.is_connected_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Character>()},
  }},
  {{
    "\36\11\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.PartyMember"
    "player_id"
  }},
};
PROTOBUF_NOINLINE void PartyMember::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.PartyMember)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.player_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.character_ != nullptr);
      _impl_.character_->Clear();
    }
  }
  ::memset(&_impl_.is_host_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.is_connected_) -
      reinterpret_cast<char*>(&_impl_.is_host_)) + sizeof(_impl_.is_connected_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PartyMember::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PartyMember& this_ = static_cast<const PartyMember&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PartyMember::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PartyMember& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.PartyMember)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string player_id = 1 [json_name = "playerId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_player_id().empty()) {
      const ::std::string& _s = this_._internal_player_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.PartyMember.player_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.Character character = 2 [json_name = "character"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.character_, this_._impl_.character_->GetCachedSize(), target,
        stream);
  }

  // bool is_host = 3 [json_name = "isHost"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_is_host() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          3, this_._internal_is_host(), target);
    }
  }

  // bool is_ready = 4 [json_name = "isReady"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_is_ready() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          4, this_._internal_is_ready(), target);
    }
  }

  // bool is_connected = 5 [json_name = "isConnected"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_is_connected() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          5, this_._internal_is_connected(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.PartyMember)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PartyMember::ByteSizeLong(const MessageLite& base) {
  const PartyMember& this_ = static_cast<const PartyMember&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PartyMember::ByteSizeLong() const {
  const PartyMember& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.PartyMember)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // string player_id = 1 [json_name = "playerId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_player_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_player_id());
      }
    }
    // .dnd5e.api.v1alpha1.Character character = 2 [json_name = "character"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.character_);
    }
    // bool is_host = 3 [json_name = "isHost"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_is_host() != 0) {
        total_size += 2;
      }
    }
    // bool is_ready = 4 [json_name = "isReady"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_is_ready() != 0) {
        total_size += 2;
      }
    }
    // bool is_connected = 5 [json_name = "isConnected"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_is_connected() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PartyMember::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PartyMember*>(&to_msg);
  auto& from = static_cast<const PartyMember&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.PartyMember)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_player_id().empty()) {
        _this->_internal_set_player_id(from._internal_player_id());
      } else {
        if (_this->_impl_.player_id_.IsDefault()) {
          _this->_internal_set_player_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.character_ != nullptr);
      if (_this->_impl_.character_ == nullptr) {
        _this->_impl_.character_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.character_);
      } else {
        _this->_impl_.character_->MergeFrom(*from._impl_.character_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_is_host() != 0) {
        _this->_impl_.is_host_ = from._impl_.is_host_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_is_ready() != 0) {
        _this->_impl_.is_ready_ = from._impl_.is_ready_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_is_connected() != 0) {
        _this->_impl_.is_connected_ = from._impl_.is_connected_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void PartyMember::CopyFrom(const PartyMember& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.PartyMember)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PartyMember::InternalSwap(PartyMember* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PartyMember, _impl_.is_connected_)
      + sizeof(PartyMember::_impl_.is_connected_)
      - PROTOBUF_FIELD_OFFSET(PartyMember, _impl_.character_)>(
          reinterpret_cast<char*>(&_impl_.character_),
          reinterpret_cast<char*>(&other->_impl_.character_));
}

::google::protobuf::Metadata PartyMember::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CreateEncounterRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CreateEncounterRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CreateEncounterRequest, _impl_._has_bits_);
};

CreateEncounterRequest::CreateEncounterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CreateEncounterRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.CreateEncounterRequest)
}
PROTOBUF_NDEBUG_INLINE CreateEncounterRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::CreateEncounterRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        character_ids_{visibility, arena, from.character_ids_} {}

CreateEncounterRequest::CreateEncounterRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CreateEncounterRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CreateEncounterRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CreateEncounterRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.CreateEncounterRequest)
}
PROTOBUF_NDEBUG_INLINE CreateEncounterRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        character_ids_{visibility, arena} {}

inline void CreateEncounterRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
CreateEncounterRequest::~CreateEncounterRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.CreateEncounterRequest)
  SharedDtor(*this);
}
inline void CreateEncounterRequest::SharedDtor(MessageLite& self) {
  CreateEncounterRequest& this_ = static_cast<CreateEncounterRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CreateEncounterRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CreateEncounterRequest(arena);
}
constexpr auto CreateEncounterRequest::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CreateEncounterRequest, _impl_.character_ids_) +
          decltype(CreateEncounterRequest::_impl_.character_ids_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(CreateEncounterRequest), alignof(CreateEncounterRequest), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CreateEncounterRequest::PlacementNew_,
                                 sizeof(CreateEncounterRequest),
                                 alignof(CreateEncounterRequest));
  }
}
constexpr auto CreateEncounterRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CreateEncounterRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CreateEncounterRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CreateEncounterRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CreateEncounterRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CreateEncounterRequest>(), &CreateEncounterRequest::ByteSizeLong,
              &CreateEncounterRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CreateEncounterRequest, _impl_._cached_size_),
          false,
      },
      &CreateEncounterRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CreateEncounterRequest_class_data_ =
        CreateEncounterRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CreateEncounterRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CreateEncounterRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CreateEncounterRequest_class_data_.tc_table);
  return CreateEncounterRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 63, 2>
CreateEncounterRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CreateEncounterRequest, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    CreateEncounterRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CreateEncounterRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated string character_ids = 1 [json_name = "characterIds"];
    {::_pbi::TcParser::FastUR1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(CreateEncounterRequest, _impl_.character_ids_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated string character_ids = 1 [json_name = "characterIds"];
    {PROTOBUF_FIELD_OFFSET(CreateEncounterRequest, _impl_.character_ids_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
  }},
  // no aux_entries
  {{
    "\51\15\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.CreateEncounterRequest"
    "character_ids"
  }},
};
PROTOBUF_NOINLINE void CreateEncounterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.CreateEncounterRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.character_ids_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CreateEncounterRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CreateEncounterRequest& this_ = static_cast<const CreateEncounterRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CreateEncounterRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CreateEncounterRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.CreateEncounterRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated string character_ids = 1 [json_name = "characterIds"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_character_ids_size(); i < n; ++i) {
      const auto& s = this_._internal_character_ids().Get(i);
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.CreateEncounterRequest.character_ids");
      target = stream->WriteString(1, s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.CreateEncounterRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CreateEncounterRequest::ByteSizeLong(const MessageLite& base) {
  const CreateEncounterRequest& this_ = static_cast<const CreateEncounterRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CreateEncounterRequest::ByteSizeLong() const {
  const CreateEncounterRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.CreateEncounterRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated string character_ids = 1 [json_name = "characterIds"];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_character_ids().size());
      for (int i = 0, n = this_._internal_character_ids().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_character_ids().Get(i));
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CreateEncounterRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CreateEncounterRequest*>(&to_msg);
  auto& from = static_cast<const CreateEncounterRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.CreateEncounterRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_character_ids()->InternalMergeFromWithArena(
        ::google::protobuf::MessageLite::internal_visibility(), arena,
        from._internal_character_ids());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CreateEncounterRequest::CopyFrom(const CreateEncounterRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.CreateEncounterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CreateEncounterRequest::InternalSwap(CreateEncounterRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.character_ids_.InternalSwap(&other->_impl_.character_ids_);
}

::google::protobuf::Metadata CreateEncounterRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CreateEncounterResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CreateEncounterResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CreateEncounterResponse, _impl_._has_bits_);
};

CreateEncounterResponse::CreateEncounterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CreateEncounterResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.CreateEncounterResponse)
}
PROTOBUF_NDEBUG_INLINE CreateEncounterResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::CreateEncounterResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        encounter_id_(arena, from.encounter_id_),
        join_code_(arena, from.join_code_) {}

CreateEncounterResponse::CreateEncounterResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CreateEncounterResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CreateEncounterResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CreateEncounterResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.room_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.CreateEncounterResponse)
}
PROTOBUF_NDEBUG_INLINE CreateEncounterResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        encounter_id_(arena),
        join_code_(arena) {}

inline void CreateEncounterResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.room_ = {};
}
CreateEncounterResponse::~CreateEncounterResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.CreateEncounterResponse)
  SharedDtor(*this);
}
inline void CreateEncounterResponse::SharedDtor(MessageLite& self) {
  CreateEncounterResponse& this_ = static_cast<CreateEncounterResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.join_code_.Destroy();
  delete this_._impl_.room_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CreateEncounterResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CreateEncounterResponse(arena);
}
constexpr auto CreateEncounterResponse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(CreateEncounterResponse),
                                            alignof(CreateEncounterResponse));
}
constexpr auto CreateEncounterResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CreateEncounterResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CreateEncounterResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CreateEncounterResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CreateEncounterResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CreateEncounterResponse>(), &CreateEncounterResponse::ByteSizeLong,
              &CreateEncounterResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CreateEncounterResponse, _impl_._cached_size_),
          false,
      },
      &CreateEncounterResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CreateEncounterResponse_class_data_ =
        CreateEncounterResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CreateEncounterResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CreateEncounterResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CreateEncounterResponse_class_data_.tc_table);
  return CreateEncounterResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 72, 2>
CreateEncounterResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CreateEncounterResponse, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    CreateEncounterResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CreateEncounterResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(CreateEncounterResponse, _impl_.encounter_id_)}},
    // string join_code = 2 [json_name = "joinCode"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(CreateEncounterResponse, _impl_.join_code_)}},
    // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 0,
      PROTOBUF_FIELD_OFFSET(CreateEncounterResponse, _impl_.room_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(CreateEncounterResponse, _impl_.encounter_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string join_code = 2 [json_name = "joinCode"];
    {PROTOBUF_FIELD_OFFSET(CreateEncounterResponse, _impl_.join_code_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
    {PROTOBUF_FIELD_OFFSET(CreateEncounterResponse, _impl_.room_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
  }},
  {{
    "\52\14\11\0\0\0\0\0"
    "dnd5e.api.v1alpha1.CreateEncounterResponse"
    "encounter_id"
    "join_code"
  }},
};
PROTOBUF_NOINLINE void CreateEncounterResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.CreateEncounterResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.join_code_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.room_ != nullptr);
      _impl_.room_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CreateEncounterResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CreateEncounterResponse& this_ = static_cast<const CreateEncounterResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CreateEncounterResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CreateEncounterResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.CreateEncounterResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.CreateEncounterResponse.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string join_code = 2 [json_name = "joinCode"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_join_code().empty()) {
      const ::std::string& _s = this_._internal_join_code();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.CreateEncounterResponse.join_code");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.room_, this_._impl_.room_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.CreateEncounterResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CreateEncounterResponse::ByteSizeLong(const MessageLite& base) {
  const CreateEncounterResponse& this_ = static_cast<const CreateEncounterResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CreateEncounterResponse::ByteSizeLong() const {
  const CreateEncounterResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.CreateEncounterResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // string join_code = 2 [json_name = "joinCode"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_join_code().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_join_code());
      }
    }
    // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.room_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CreateEncounterResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CreateEncounterResponse*>(&to_msg);
  auto& from = static_cast<const CreateEncounterResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.CreateEncounterResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_join_code().empty()) {
        _this->_internal_set_join_code(from._internal_join_code());
      } else {
        if (_this->_impl_.join_code_.IsDefault()) {
          _this->_internal_set_join_code("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.room_ != nullptr);
      if (_this->_impl_.room_ == nullptr) {
        _this->_impl_.room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_);
      } else {
        _this->_impl_.room_->MergeFrom(*from._impl_.room_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CreateEncounterResponse::CopyFrom(const CreateEncounterResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.CreateEncounterResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CreateEncounterResponse::InternalSwap(CreateEncounterResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.join_code_, &other->_impl_.join_code_, arena);
  swap(_impl_.room_, other->_impl_.room_);
}

::google::protobuf::Metadata CreateEncounterResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class JoinEncounterRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<JoinEncounterRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(JoinEncounterRequest, _impl_._has_bits_);
};

JoinEncounterRequest::JoinEncounterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, JoinEncounterRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.JoinEncounterRequest)
}
PROTOBUF_NDEBUG_INLINE JoinEncounterRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::JoinEncounterRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        character_ids_{visibility, arena, from.character_ids_},
        join_code_(arena, from.join_code_) {}

JoinEncounterRequest::JoinEncounterRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const JoinEncounterRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, JoinEncounterRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  JoinEncounterRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.JoinEncounterRequest)
}
PROTOBUF_NDEBUG_INLINE JoinEncounterRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        character_ids_{visibility, arena},
        join_code_(arena) {}

inline void JoinEncounterRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
JoinEncounterRequest::~JoinEncounterRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.JoinEncounterRequest)
  SharedDtor(*this);
}
inline void JoinEncounterRequest::SharedDtor(MessageLite& self) {
  JoinEncounterRequest& this_ = static_cast<JoinEncounterRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.join_code_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL JoinEncounterRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) JoinEncounterRequest(arena);
}
constexpr auto JoinEncounterRequest::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(JoinEncounterRequest, _impl_.character_ids_) +
          decltype(JoinEncounterRequest::_impl_.character_ids_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(JoinEncounterRequest), alignof(JoinEncounterRequest), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&JoinEncounterRequest::PlacementNew_,
                                 sizeof(JoinEncounterRequest),
                                 alignof(JoinEncounterRequest));
  }
}
constexpr auto JoinEncounterRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_JoinEncounterRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &JoinEncounterRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<JoinEncounterRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &JoinEncounterRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<JoinEncounterRequest>(), &JoinEncounterRequest::ByteSizeLong,
              &JoinEncounterRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(JoinEncounterRequest, _impl_._cached_size_),
          false,
      },
      &JoinEncounterRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull JoinEncounterRequest_class_data_ =
        JoinEncounterRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
JoinEncounterRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&JoinEncounterRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(JoinEncounterRequest_class_data_.tc_table);
  return JoinEncounterRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 70, 2>
JoinEncounterRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(JoinEncounterRequest, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    JoinEncounterRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::JoinEncounterRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated string character_ids = 2 [json_name = "characterIds"];
    {::_pbi::TcParser::FastUR1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(JoinEncounterRequest, _impl_.character_ids_)}},
    // string join_code = 1 [json_name = "joinCode"];
    {::_pbi::TcParser::FastUS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(JoinEncounterRequest, _impl_.join_code_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string join_code = 1 [json_name = "joinCode"];
    {PROTOBUF_FIELD_OFFSET(JoinEncounterRequest, _impl_.join_code_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated string character_ids = 2 [json_name = "characterIds"];
    {PROTOBUF_FIELD_OFFSET(JoinEncounterRequest, _impl_.character_ids_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
  }},
  // no aux_entries
  {{
    "\47\11\15\0\0\0\0\0"
    "dnd5e.api.v1alpha1.JoinEncounterRequest"
    "join_code"
    "character_ids"
  }},
};
PROTOBUF_NOINLINE void JoinEncounterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.JoinEncounterRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.character_ids_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.join_code_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL JoinEncounterRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const JoinEncounterRequest& this_ = static_cast<const JoinEncounterRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL JoinEncounterRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const JoinEncounterRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.JoinEncounterRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string join_code = 1 [json_name = "joinCode"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_join_code().empty()) {
      const ::std::string& _s = this_._internal_join_code();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.JoinEncounterRequest.join_code");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // repeated string character_ids = 2 [json_name = "characterIds"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_character_ids_size(); i < n; ++i) {
      const auto& s = this_._internal_character_ids().Get(i);
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.JoinEncounterRequest.character_ids");
      target = stream->WriteString(2, s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.JoinEncounterRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t JoinEncounterRequest::ByteSizeLong(const MessageLite& base) {
  const JoinEncounterRequest& this_ = static_cast<const JoinEncounterRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t JoinEncounterRequest::ByteSizeLong() const {
  const JoinEncounterRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.JoinEncounterRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated string character_ids = 2 [json_name = "characterIds"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_character_ids().size());
      for (int i = 0, n = this_._internal_character_ids().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_character_ids().Get(i));
      }
    }
    // string join_code = 1 [json_name = "joinCode"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_join_code().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_join_code());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void JoinEncounterRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<JoinEncounterRequest*>(&to_msg);
  auto& from = static_cast<const JoinEncounterRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.JoinEncounterRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_character_ids()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_character_ids());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_join_code().empty()) {
        _this->_internal_set_join_code(from._internal_join_code());
      } else {
        if (_this->_impl_.join_code_.IsDefault()) {
          _this->_internal_set_join_code("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void JoinEncounterRequest::CopyFrom(const JoinEncounterRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.JoinEncounterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void JoinEncounterRequest::InternalSwap(JoinEncounterRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.character_ids_.InternalSwap(&other->_impl_.character_ids_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.join_code_, &other->_impl_.join_code_, arena);
}

::google::protobuf::Metadata JoinEncounterRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class JoinEncounterResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<JoinEncounterResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_._has_bits_);
};

JoinEncounterResponse::JoinEncounterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, JoinEncounterResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.JoinEncounterResponse)
}
PROTOBUF_NDEBUG_INLINE JoinEncounterResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::JoinEncounterResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        party_{visibility, arena, from.party_},
        encounter_id_(arena, from.encounter_id_) {}

JoinEncounterResponse::JoinEncounterResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const JoinEncounterResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, JoinEncounterResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  JoinEncounterResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.room_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_)
                : nullptr;
  _impl_.state_ = from._impl_.state_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.JoinEncounterResponse)
}
PROTOBUF_NDEBUG_INLINE JoinEncounterResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        party_{visibility, arena},
        encounter_id_(arena) {}

inline void JoinEncounterResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, room_),
           0,
           offsetof(Impl_, state_) -
               offsetof(Impl_, room_) +
               sizeof(Impl_::state_));
}
JoinEncounterResponse::~JoinEncounterResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.JoinEncounterResponse)
  SharedDtor(*this);
}
inline void JoinEncounterResponse::SharedDtor(MessageLite& self) {
  JoinEncounterResponse& this_ = static_cast<JoinEncounterResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  delete this_._impl_.room_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL JoinEncounterResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) JoinEncounterResponse(arena);
}
constexpr auto JoinEncounterResponse::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_.party_) +
          decltype(JoinEncounterResponse::_impl_.party_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(JoinEncounterResponse), alignof(JoinEncounterResponse), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&JoinEncounterResponse::PlacementNew_,
                                 sizeof(JoinEncounterResponse),
                                 alignof(JoinEncounterResponse));
  }
}
constexpr auto JoinEncounterResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_JoinEncounterResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &JoinEncounterResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<JoinEncounterResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &JoinEncounterResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<JoinEncounterResponse>(), &JoinEncounterResponse::ByteSizeLong,
              &JoinEncounterResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_._cached_size_),
          false,
      },
      &JoinEncounterResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull JoinEncounterResponse_class_data_ =
        JoinEncounterResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
JoinEncounterResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&JoinEncounterResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(JoinEncounterResponse_class_data_.tc_table);
  return JoinEncounterResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 61, 2>
JoinEncounterResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    JoinEncounterResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::JoinEncounterResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.EncounterState state = 4 [json_name = "state"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(JoinEncounterResponse, _impl_.state_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_.state_)}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_.encounter_id_)}},
    // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
    {::_pbi::TcParser::FastMtS1,
     {18, 2, 0,
      PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_.room_)}},
    // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
    {::_pbi::TcParser::FastMtR1,
     {26, 0, 1,
      PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_.party_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_.encounter_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
    {PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_.room_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
    {PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_.party_), _Internal::kHasBitsOffset + 0, 1, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.EncounterState state = 4 [json_name = "state"];
    {PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_.state_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PartyMember>()},
  }},
  {{
    "\50\14\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.JoinEncounterResponse"
    "encounter_id"
  }},
};
PROTOBUF_NOINLINE void JoinEncounterResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.JoinEncounterResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.party_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.room_ != nullptr);
      _impl_.room_->Clear();
    }
  }
  _impl_.state_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL JoinEncounterResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const JoinEncounterResponse& this_ = static_cast<const JoinEncounterResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL JoinEncounterResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const JoinEncounterResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.JoinEncounterResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.JoinEncounterResponse.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.room_, this_._impl_.room_->GetCachedSize(), target,
        stream);
  }

  // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_party_size());
         i < n; i++) {
      const auto& repfield = this_._internal_party().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              3, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // .dnd5e.api.v1alpha1.EncounterState state = 4 [json_name = "state"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_state() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          4, this_._internal_state(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.JoinEncounterResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t JoinEncounterResponse::ByteSizeLong(const MessageLite& base) {
  const JoinEncounterResponse& this_ = static_cast<const JoinEncounterResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t JoinEncounterResponse::ByteSizeLong() const {
  const JoinEncounterResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.JoinEncounterResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_party_size();
      for (const auto& msg : this_._internal_party()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.room_);
    }
    // .dnd5e.api.v1alpha1.EncounterState state = 4 [json_name = "state"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_state() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_state());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void JoinEncounterResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<JoinEncounterResponse*>(&to_msg);
  auto& from = static_cast<const JoinEncounterResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.JoinEncounterResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_party()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_party());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.room_ != nullptr);
      if (_this->_impl_.room_ == nullptr) {
        _this->_impl_.room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_);
      } else {
        _this->_impl_.room_->MergeFrom(*from._impl_.room_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_state() != 0) {
        _this->_impl_.state_ = from._impl_.state_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void JoinEncounterResponse::CopyFrom(const JoinEncounterResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.JoinEncounterResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void JoinEncounterResponse::InternalSwap(JoinEncounterResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.party_.InternalSwap(&other->_impl_.party_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_.state_)
      + sizeof(JoinEncounterResponse::_impl_.state_)
      - PROTOBUF_FIELD_OFFSET(JoinEncounterResponse, _impl_.room_)>(
          reinterpret_cast<char*>(&_impl_.room_),
          reinterpret_cast<char*>(&other->_impl_.room_));
}

::google::protobuf::Metadata JoinEncounterResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SetReadyRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<SetReadyRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SetReadyRequest, _impl_._has_bits_);
};

SetReadyRequest::SetReadyRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SetReadyRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.SetReadyRequest)
}
PROTOBUF_NDEBUG_INLINE SetReadyRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::SetReadyRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        encounter_id_(arena, from.encounter_id_),
        player_id_(arena, from.player_id_) {}

SetReadyRequest::SetReadyRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const SetReadyRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SetReadyRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SetReadyRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.is_ready_ = from._impl_.is_ready_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.SetReadyRequest)
}
PROTOBUF_NDEBUG_INLINE SetReadyRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        encounter_id_(arena),
        player_id_(arena) {}

inline void SetReadyRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.is_ready_ = {};
}
SetReadyRequest::~SetReadyRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.SetReadyRequest)
  SharedDtor(*this);
}
inline void SetReadyRequest::SharedDtor(MessageLite& self) {
  SetReadyRequest& this_ = static_cast<SetReadyRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.player_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SetReadyRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SetReadyRequest(arena);
}
constexpr auto SetReadyRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(SetReadyRequest),
                                            alignof(SetReadyRequest));
}
constexpr auto SetReadyRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SetReadyRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SetReadyRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SetReadyRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SetReadyRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SetReadyRequest>(), &SetReadyRequest::ByteSizeLong,
              &SetReadyRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SetReadyRequest, _impl_._cached_size_),
          false,
      },
      &SetReadyRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SetReadyRequest_class_data_ =
        SetReadyRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SetReadyRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SetReadyRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SetReadyRequest_class_data_.tc_table);
  return SetReadyRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 64, 2>
SetReadyRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SetReadyRequest, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SetReadyRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SetReadyRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(SetReadyRequest, _impl_.encounter_id_)}},
    // string player_id = 2 [json_name = "playerId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(SetReadyRequest, _impl_.player_id_)}},
    // bool is_ready = 3 [json_name = "isReady"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SetReadyRequest, _impl_.is_ready_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(SetReadyRequest, _impl_.is_ready_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(SetReadyRequest, _impl_.encounter_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string player_id = 2 [json_name = "playerId"];
    {PROTOBUF_FIELD_OFFSET(SetReadyRequest, _impl_.player_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool is_ready = 3 [json_name = "isReady"];
    {PROTOBUF_FIELD_OFFSET(SetReadyRequest, _impl_.is_ready_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\42\14\11\0\0\0\0\0"
    "dnd5e.api.v1alpha1.SetReadyRequest"
    "encounter_id"
    "player_id"
  }},
};
PROTOBUF_NOINLINE void SetReadyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.SetReadyRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.player_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.is_ready_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SetReadyRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SetReadyRequest& this_ = static_cast<const SetReadyRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SetReadyRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SetReadyRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.SetReadyRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.SetReadyRequest.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string player_id = 2 [json_name = "playerId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_player_id().empty()) {
      const ::std::string& _s = this_._internal_player_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.SetReadyRequest.player_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // bool is_ready = 3 [json_name = "isReady"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_is_ready() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          3, this_._internal_is_ready(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.SetReadyRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SetReadyRequest::ByteSizeLong(const MessageLite& base) {
  const SetReadyRequest& this_ = static_cast<const SetReadyRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SetReadyRequest::ByteSizeLong() const {
  const SetReadyRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.SetReadyRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // string player_id = 2 [json_name = "playerId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_player_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_player_id());
      }
    }
    // bool is_ready = 3 [json_name = "isReady"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_is_ready() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SetReadyRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<SetReadyRequest*>(&to_msg);
  auto& from = static_cast<const SetReadyRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.SetReadyRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_player_id().empty()) {
        _this->_internal_set_player_id(from._internal_player_id());
      } else {
        if (_this->_impl_.player_id_.IsDefault()) {
          _this->_internal_set_player_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_is_ready() != 0) {
        _this->_impl_.is_ready_ = from._impl_.is_ready_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void SetReadyRequest::CopyFrom(const SetReadyRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.SetReadyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SetReadyRequest::InternalSwap(SetReadyRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
  swap(_impl_.is_ready_, other->_impl_.is_ready_);
}

::google::protobuf::Metadata SetReadyRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SetReadyResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<SetReadyResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SetReadyResponse, _impl_._has_bits_);
};

SetReadyResponse::SetReadyResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SetReadyResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.SetReadyResponse)
}
SetReadyResponse::SetReadyResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SetReadyResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SetReadyResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE SetReadyResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void SetReadyResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.success_ = {};
}
SetReadyResponse::~SetReadyResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.SetReadyResponse)
  SharedDtor(*this);
}
inline void SetReadyResponse::SharedDtor(MessageLite& self) {
  SetReadyResponse& this_ = static_cast<SetReadyResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SetReadyResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SetReadyResponse(arena);
}
constexpr auto SetReadyResponse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(SetReadyResponse),
                                            alignof(SetReadyResponse));
}
constexpr auto SetReadyResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SetReadyResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SetReadyResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SetReadyResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SetReadyResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SetReadyResponse>(), &SetReadyResponse::ByteSizeLong,
              &SetReadyResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SetReadyResponse, _impl_._cached_size_),
          false,
      },
      &SetReadyResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SetReadyResponse_class_data_ =
        SetReadyResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SetReadyResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SetReadyResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SetReadyResponse_class_data_.tc_table);
  return SetReadyResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
SetReadyResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SetReadyResponse, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SetReadyResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::SetReadyResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bool success = 1 [json_name = "success"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SetReadyResponse, _impl_.success_), 0>(),
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(SetReadyResponse, _impl_.success_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bool success = 1 [json_name = "success"];
    {PROTOBUF_FIELD_OFFSET(SetReadyResponse, _impl_.success_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void SetReadyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.SetReadyResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.success_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SetReadyResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SetReadyResponse& this_ = static_cast<const SetReadyResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SetReadyResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SetReadyResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.SetReadyResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // bool success = 1 [json_name = "success"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (this_._internal_success() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          1, this_._internal_success(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.SetReadyResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SetReadyResponse::ByteSizeLong(const MessageLite& base) {
  const SetReadyResponse& this_ = static_cast<const SetReadyResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SetReadyResponse::ByteSizeLong() const {
  const SetReadyResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.SetReadyResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // bool success = 1 [json_name = "success"];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (this_._internal_success() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SetReadyResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<SetReadyResponse*>(&to_msg);
  auto& from = static_cast<const SetReadyResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.SetReadyResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (from._internal_success() != 0) {
      _this->_impl_.success_ = from._impl_.success_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void SetReadyResponse::CopyFrom(const SetReadyResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.SetReadyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SetReadyResponse::InternalSwap(SetReadyResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.success_, other->_impl_.success_);
}

::google::protobuf::Metadata SetReadyResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class StartCombatRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<StartCombatRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_._has_bits_);
};

StartCombatRequest::StartCombatRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, StartCombatRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.StartCombatRequest)
}
PROTOBUF_NDEBUG_INLINE StartCombatRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::StartCombatRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        encounter_id_(arena, from.encounter_id_) {}

StartCombatRequest::StartCombatRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const StartCombatRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, StartCombatRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  StartCombatRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, theme_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, theme_),
           offsetof(Impl_, length_) -
               offsetof(Impl_, theme_) +
               sizeof(Impl_::length_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.StartCombatRequest)
}
PROTOBUF_NDEBUG_INLINE StartCombatRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        encounter_id_(arena) {}

inline void StartCombatRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, theme_),
           0,
           offsetof(Impl_, length_) -
               offsetof(Impl_, theme_) +
               sizeof(Impl_::length_));
}
StartCombatRequest::~StartCombatRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.StartCombatRequest)
  SharedDtor(*this);
}
inline void StartCombatRequest::SharedDtor(MessageLite& self) {
  StartCombatRequest& this_ = static_cast<StartCombatRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL StartCombatRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) StartCombatRequest(arena);
}
constexpr auto StartCombatRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(StartCombatRequest),
                                            alignof(StartCombatRequest));
}
constexpr auto StartCombatRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_StartCombatRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &StartCombatRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<StartCombatRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &StartCombatRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<StartCombatRequest>(), &StartCombatRequest::ByteSizeLong,
              &StartCombatRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_._cached_size_),
          false,
      },
      &StartCombatRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull StartCombatRequest_class_data_ =
        StartCombatRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
StartCombatRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&StartCombatRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(StartCombatRequest_class_data_.tc_table);
  return StartCombatRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 58, 2>
StartCombatRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    StartCombatRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::StartCombatRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.DungeonLength length = 4 [json_name = "length"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(StartCombatRequest, _impl_.length_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_.length_)}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_.encounter_id_)}},
    // .dnd5e.api.v1alpha1.DungeonTheme theme = 2 [json_name = "theme"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(StartCombatRequest, _impl_.theme_), 1>(),
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_.theme_)}},
    // .dnd5e.api.v1alpha1.DungeonDifficulty difficulty = 3 [json_name = "difficulty"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(StartCombatRequest, _impl_.difficulty_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_.difficulty_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_.encounter_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.DungeonTheme theme = 2 [json_name = "theme"];
    {PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_.theme_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.DungeonDifficulty difficulty = 3 [json_name = "difficulty"];
    {PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_.difficulty_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // .dnd5e.api.v1alpha1.DungeonLength length = 4 [json_name = "length"];
    {PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_.length_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
    "\45\14\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.StartCombatRequest"
    "encounter_id"
  }},
};
PROTOBUF_NOINLINE void StartCombatRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.StartCombatRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.encounter_id_.ClearNonDefaultToEmpty();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000eU)) {
    ::memset(&_impl_.theme_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.length_) -
        reinterpret_cast<char*>(&_impl_.theme_)) + sizeof(_impl_.length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL StartCombatRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const StartCombatRequest& this_ = static_cast<const StartCombatRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL StartCombatRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const StartCombatRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.StartCombatRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.StartCombatRequest.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.DungeonTheme theme = 2 [json_name = "theme"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (this_._internal_theme() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          2, this_._internal_theme(), target);
    }
  }

  // .dnd5e.api.v1alpha1.DungeonDifficulty difficulty = 3 [json_name = "difficulty"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_difficulty() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          3, this_._internal_difficulty(), target);
    }
  }

  // .dnd5e.api.v1alpha1.DungeonLength length = 4 [json_name = "length"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_length() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          4, this_._internal_length(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.StartCombatRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t StartCombatRequest::ByteSizeLong(const MessageLite& base) {
  const StartCombatRequest& this_ = static_cast<const StartCombatRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t StartCombatRequest::ByteSizeLong() const {
  const StartCombatRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.StartCombatRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // .dnd5e.api.v1alpha1.DungeonTheme theme = 2 [json_name = "theme"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (this_._internal_theme() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_theme());
      }
    }
    // .dnd5e.api.v1alpha1.DungeonDifficulty difficulty = 3 [json_name = "difficulty"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_difficulty() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_difficulty());
      }
    }
    // .dnd5e.api.v1alpha1.DungeonLength length = 4 [json_name = "length"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_length() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_length());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void StartCombatRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<StartCombatRequest*>(&to_msg);
  auto& from = static_cast<const StartCombatRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.StartCombatRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (from._internal_theme() != 0) {
        _this->_impl_.theme_ = from._impl_.theme_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_difficulty() != 0) {
        _this->_impl_.difficulty_ = from._impl_.difficulty_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_length() != 0) {
        _this->_impl_.length_ = from._impl_.length_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void StartCombatRequest::CopyFrom(const StartCombatRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.StartCombatRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void StartCombatRequest::InternalSwap(StartCombatRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_.length_)
      + sizeof(StartCombatRequest::_impl_.length_)
      - PROTOBUF_FIELD_OFFSET(StartCombatRequest, _impl_.theme_)>(
          reinterpret_cast<char*>(&_impl_.theme_),
          reinterpret_cast<char*>(&other->_impl_.theme_));
}

::google::protobuf::Metadata StartCombatRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class StartCombatResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<StartCombatResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_._has_bits_);
};

StartCombatResponse::StartCombatResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, StartCombatResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.StartCombatResponse)
}
PROTOBUF_NDEBUG_INLINE StartCombatResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::StartCombatResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        monster_turns_{visibility, arena, from.monster_turns_},
        doors_{visibility, arena, from.doors_},
        dungeon_id_(arena, from.dungeon_id_) {}

StartCombatResponse::StartCombatResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const StartCombatResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, StartCombatResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  StartCombatResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.combat_state_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_)
                : nullptr;
  _impl_.room_ = (CheckHasBit(cached_has_bits, 0x00000010U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.StartCombatResponse)
}
PROTOBUF_NDEBUG_INLINE StartCombatResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        monster_turns_{visibility, arena},
        doors_{visibility, arena},
        dungeon_id_(arena) {}

inline void StartCombatResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, combat_state_),
           0,
           offsetof(Impl_, room_) -
               offsetof(Impl_, combat_state_) +
               sizeof(Impl_::room_));
}
StartCombatResponse::~StartCombatResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.StartCombatResponse)
  SharedDtor(*this);
}
inline void StartCombatResponse::SharedDtor(MessageLite& self) {
  StartCombatResponse& this_ = static_cast<StartCombatResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.dungeon_id_.Destroy();
  delete this_._impl_.combat_state_;
  delete this_._impl_.room_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL StartCombatResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) StartCombatResponse(arena);
}
constexpr auto StartCombatResponse::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.monster_turns_) +
          decltype(StartCombatResponse::_impl_.monster_turns_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.doors_) +
          decltype(StartCombatResponse::_impl_.doors_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(StartCombatResponse), alignof(StartCombatResponse), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&StartCombatResponse::PlacementNew_,
                                 sizeof(StartCombatResponse),
                                 alignof(StartCombatResponse));
  }
}
constexpr auto StartCombatResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_StartCombatResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &StartCombatResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<StartCombatResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &StartCombatResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<StartCombatResponse>(), &StartCombatResponse::ByteSizeLong,
              &StartCombatResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_._cached_size_),
          false,
      },
      &StartCombatResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull StartCombatResponse_class_data_ =
        StartCombatResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
StartCombatResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&StartCombatResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(StartCombatResponse_class_data_.tc_table);
  return StartCombatResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 4, 57, 2>
StartCombatResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    StartCombatResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::StartCombatResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
    {::_pbi::TcParser::FastMtS1,
     {10, 3, 0,
      PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.combat_state_)}},
    // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
    {::_pbi::TcParser::FastMtS1,
     {18, 4, 1,
      PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.room_)}},
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 3 [json_name = "monsterTurns"];
    {::_pbi::TcParser::FastMtR1,
     {26, 0, 2,
      PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.monster_turns_)}},
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 4 [json_name = "doors"];
    {::_pbi::TcParser::FastMtR1,
     {34, 1, 3,
      PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.doors_)}},
    // string dungeon_id = 5 [json_name = "dungeonId"];
    {::_pbi::TcParser::FastUS1,
     {42, 2, 0,
      PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.dungeon_id_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
    {PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.combat_state_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
    {PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.room_), _Internal::kHasBitsOffset + 4, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 3 [json_name = "monsterTurns"];
    {PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.monster_turns_), _Internal::kHasBitsOffset + 0, 2, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 4 [json_name = "doors"];
    {PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.doors_), _Internal::kHasBitsOffset + 1, 3, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // string dungeon_id = 5 [json_name = "dungeonId"];
    {PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.dungeon_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterTurnResult>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DoorInfo>()},
  }},
  {{
    "\46\0\0\0\0\12\0\0"
    "dnd5e.api.v1alpha1.StartCombatResponse"
    "dungeon_id"
  }},
};
PROTOBUF_NOINLINE void StartCombatResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.StartCombatResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.monster_turns_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.doors_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.dungeon_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.combat_state_ != nullptr);
      _impl_.combat_state_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(_impl_.room_ != nullptr);
      _impl_.room_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL StartCombatResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const StartCombatResponse& this_ = static_cast<const StartCombatResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL StartCombatResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const StartCombatResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.StartCombatResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.combat_state_, this_._impl_.combat_state_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.room_, this_._impl_.room_->GetCachedSize(), target,
        stream);
  }

  // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 3 [json_name = "monsterTurns"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_monster_turns_size());
         i < n; i++) {
      const auto& repfield = this_._internal_monster_turns().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              3, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 4 [json_name = "doors"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_doors_size());
         i < n; i++) {
      const auto& repfield = this_._internal_doors().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              4, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // string dungeon_id = 5 [json_name = "dungeonId"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_dungeon_id().empty()) {
      const ::std::string& _s = this_._internal_dungeon_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.StartCombatResponse.dungeon_id");
      target = stream->WriteStringMaybeAliased(5, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.StartCombatResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t StartCombatResponse::ByteSizeLong(const MessageLite& base) {
  const StartCombatResponse& this_ = static_cast<const StartCombatResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t StartCombatResponse::ByteSizeLong() const {
  const StartCombatResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.StartCombatResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 3 [json_name = "monsterTurns"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_monster_turns_size();
      for (const auto& msg : this_._internal_monster_turns()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 4 [json_name = "doors"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 1UL * this_._internal_doors_size();
      for (const auto& msg : this_._internal_doors()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string dungeon_id = 5 [json_name = "dungeonId"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!this_._internal_dungeon_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_dungeon_id());
      }
    }
    // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.combat_state_);
    }
    // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.room_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void StartCombatResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<StartCombatResponse*>(&to_msg);
  auto& from = static_cast<const StartCombatResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.StartCombatResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_monster_turns()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_monster_turns());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_doors()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_doors());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!from._internal_dungeon_id().empty()) {
        _this->_internal_set_dungeon_id(from._internal_dungeon_id());
      } else {
        if (_this->_impl_.dungeon_id_.IsDefault()) {
          _this->_internal_set_dungeon_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.combat_state_ != nullptr);
      if (_this->_impl_.combat_state_ == nullptr) {
        _this->_impl_.combat_state_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_);
      } else {
        _this->_impl_.combat_state_->MergeFrom(*from._impl_.combat_state_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(from._impl_.room_ != nullptr);
      if (_this->_impl_.room_ == nullptr) {
        _this->_impl_.room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_);
      } else {
        _this->_impl_.room_->MergeFrom(*from._impl_.room_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void StartCombatResponse::CopyFrom(const StartCombatResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.StartCombatResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void StartCombatResponse::InternalSwap(StartCombatResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.monster_turns_.InternalSwap(&other->_impl_.monster_turns_);
  _impl_.doors_.InternalSwap(&other->_impl_.doors_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dungeon_id_, &other->_impl_.dungeon_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.room_)
      + sizeof(StartCombatResponse::_impl_.room_)
      - PROTOBUF_FIELD_OFFSET(StartCombatResponse, _impl_.combat_state_)>(
          reinterpret_cast<char*>(&_impl_.combat_state_),
          reinterpret_cast<char*>(&other->_impl_.combat_state_));
}

::google::protobuf::Metadata StartCombatResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LeaveEncounterRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<LeaveEncounterRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LeaveEncounterRequest, _impl_._has_bits_);
};

LeaveEncounterRequest::LeaveEncounterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LeaveEncounterRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.LeaveEncounterRequest)
}
PROTOBUF_NDEBUG_INLINE LeaveEncounterRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::LeaveEncounterRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        encounter_id_(arena, from.encounter_id_),
        player_id_(arena, from.player_id_) {}

LeaveEncounterRequest::LeaveEncounterRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const LeaveEncounterRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LeaveEncounterRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LeaveEncounterRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.LeaveEncounterRequest)
}
PROTOBUF_NDEBUG_INLINE LeaveEncounterRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        encounter_id_(arena),
        player_id_(arena) {}

inline void LeaveEncounterRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
LeaveEncounterRequest::~LeaveEncounterRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.LeaveEncounterRequest)
  SharedDtor(*this);
}
inline void LeaveEncounterRequest::SharedDtor(MessageLite& self) {
  LeaveEncounterRequest& this_ = static_cast<LeaveEncounterRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.player_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL LeaveEncounterRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) LeaveEncounterRequest(arena);
}
constexpr auto LeaveEncounterRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(LeaveEncounterRequest),
                                            alignof(LeaveEncounterRequest));
}
constexpr auto LeaveEncounterRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_LeaveEncounterRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &LeaveEncounterRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<LeaveEncounterRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &LeaveEncounterRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<LeaveEncounterRequest>(), &LeaveEncounterRequest::ByteSizeLong,
              &LeaveEncounterRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(LeaveEncounterRequest, _impl_._cached_size_),
          false,
      },
      &LeaveEncounterRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull LeaveEncounterRequest_class_data_ =
        LeaveEncounterRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
LeaveEncounterRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&LeaveEncounterRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(LeaveEncounterRequest_class_data_.tc_table);
  return LeaveEncounterRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 70, 2>
LeaveEncounterRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LeaveEncounterRequest, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    LeaveEncounterRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::LeaveEncounterRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string player_id = 2 [json_name = "playerId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(LeaveEncounterRequest, _impl_.player_id_)}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(LeaveEncounterRequest, _impl_.encounter_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(LeaveEncounterRequest, _impl_.encounter_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string player_id = 2 [json_name = "playerId"];
    {PROTOBUF_FIELD_OFFSET(LeaveEncounterRequest, _impl_.player_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\50\14\11\0\0\0\0\0"
    "dnd5e.api.v1alpha1.LeaveEncounterRequest"
    "encounter_id"
    "player_id"
  }},
};
PROTOBUF_NOINLINE void LeaveEncounterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.LeaveEncounterRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.player_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL LeaveEncounterRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const LeaveEncounterRequest& this_ = static_cast<const LeaveEncounterRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL LeaveEncounterRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const LeaveEncounterRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.LeaveEncounterRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.LeaveEncounterRequest.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string player_id = 2 [json_name = "playerId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_player_id().empty()) {
      const ::std::string& _s = this_._internal_player_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.LeaveEncounterRequest.player_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.LeaveEncounterRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t LeaveEncounterRequest::ByteSizeLong(const MessageLite& base) {
  const LeaveEncounterRequest& this_ = static_cast<const LeaveEncounterRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t LeaveEncounterRequest::ByteSizeLong() const {
  const LeaveEncounterRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.LeaveEncounterRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // string player_id = 2 [json_name = "playerId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_player_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_player_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void LeaveEncounterRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<LeaveEncounterRequest*>(&to_msg);
  auto& from = static_cast<const LeaveEncounterRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.LeaveEncounterRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_player_id().empty()) {
        _this->_internal_set_player_id(from._internal_player_id());
      } else {
        if (_this->_impl_.player_id_.IsDefault()) {
          _this->_internal_set_player_id("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void LeaveEncounterRequest::CopyFrom(const LeaveEncounterRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.LeaveEncounterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LeaveEncounterRequest::InternalSwap(LeaveEncounterRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
}

::google::protobuf::Metadata LeaveEncounterRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LeaveEncounterResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<LeaveEncounterResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LeaveEncounterResponse, _impl_._has_bits_);
};

LeaveEncounterResponse::LeaveEncounterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LeaveEncounterResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.LeaveEncounterResponse)
}
LeaveEncounterResponse::LeaveEncounterResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LeaveEncounterResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LeaveEncounterResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE LeaveEncounterResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void LeaveEncounterResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.success_ = {};
}
LeaveEncounterResponse::~LeaveEncounterResponse() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.LeaveEncounterResponse)
  SharedDtor(*this);
}
inline void LeaveEncounterResponse::SharedDtor(MessageLite& self) {
  LeaveEncounterResponse& this_ = static_cast<LeaveEncounterResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL LeaveEncounterResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) LeaveEncounterResponse(arena);
}
constexpr auto LeaveEncounterResponse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(LeaveEncounterResponse),
                                            alignof(LeaveEncounterResponse));
}
constexpr auto LeaveEncounterResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_LeaveEncounterResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &LeaveEncounterResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<LeaveEncounterResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &LeaveEncounterResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<LeaveEncounterResponse>(), &LeaveEncounterResponse::ByteSizeLong,
              &LeaveEncounterResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(LeaveEncounterResponse, _impl_._cached_size_),
          false,
      },
      &LeaveEncounterResponse::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull LeaveEncounterResponse_class_data_ =
        LeaveEncounterResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
LeaveEncounterResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&LeaveEncounterResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(LeaveEncounterResponse_class_data_.tc_table);
  return LeaveEncounterResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
LeaveEncounterResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LeaveEncounterResponse, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    LeaveEncounterResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::LeaveEncounterResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bool success = 1 [json_name = "success"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(LeaveEncounterResponse, _impl_.success_), 0>(),
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(LeaveEncounterResponse, _impl_.success_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bool success = 1 [json_name = "success"];
    {PROTOBUF_FIELD_OFFSET(LeaveEncounterResponse, _impl_.success_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void LeaveEncounterResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.LeaveEncounterResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.success_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL LeaveEncounterResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const LeaveEncounterResponse& this_ = static_cast<const LeaveEncounterResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL LeaveEncounterResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const LeaveEncounterResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.LeaveEncounterResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // bool success = 1 [json_name = "success"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (this_._internal_success() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          1, this_._internal_success(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.LeaveEncounterResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t LeaveEncounterResponse::ByteSizeLong(const MessageLite& base) {
  const LeaveEncounterResponse& this_ = static_cast<const LeaveEncounterResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t LeaveEncounterResponse::ByteSizeLong() const {
  const LeaveEncounterResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.LeaveEncounterResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // bool success = 1 [json_name = "success"];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (this_._internal_success() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void LeaveEncounterResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<LeaveEncounterResponse*>(&to_msg);
  auto& from = static_cast<const LeaveEncounterResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.LeaveEncounterResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (from._internal_success() != 0) {
      _this->_impl_.success_ = from._impl_.success_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void LeaveEncounterResponse::CopyFrom(const LeaveEncounterResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.LeaveEncounterResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LeaveEncounterResponse::InternalSwap(LeaveEncounterResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.success_, other->_impl_.success_);
}

::google::protobuf::Metadata LeaveEncounterResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class StreamEncounterEventsRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<StreamEncounterEventsRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(StreamEncounterEventsRequest, _impl_._has_bits_);
};

StreamEncounterEventsRequest::StreamEncounterEventsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, StreamEncounterEventsRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.StreamEncounterEventsRequest)
}
PROTOBUF_NDEBUG_INLINE StreamEncounterEventsRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::StreamEncounterEventsRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        encounter_id_(arena, from.encounter_id_),
        player_id_(arena, from.player_id_) {}

StreamEncounterEventsRequest::StreamEncounterEventsRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const StreamEncounterEventsRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, StreamEncounterEventsRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  StreamEncounterEventsRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.StreamEncounterEventsRequest)
}
PROTOBUF_NDEBUG_INLINE StreamEncounterEventsRequest::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        encounter_id_(arena),
        player_id_(arena) {}

inline void StreamEncounterEventsRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
StreamEncounterEventsRequest::~StreamEncounterEventsRequest() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.StreamEncounterEventsRequest)
  SharedDtor(*this);
}
inline void StreamEncounterEventsRequest::SharedDtor(MessageLite& self) {
  StreamEncounterEventsRequest& this_ = static_cast<StreamEncounterEventsRequest&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.encounter_id_.Destroy();
  this_._impl_.player_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL StreamEncounterEventsRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) StreamEncounterEventsRequest(arena);
}
constexpr auto StreamEncounterEventsRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(StreamEncounterEventsRequest),
                                            alignof(StreamEncounterEventsRequest));
}
constexpr auto StreamEncounterEventsRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_StreamEncounterEventsRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &StreamEncounterEventsRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<StreamEncounterEventsRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &StreamEncounterEventsRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<StreamEncounterEventsRequest>(), &StreamEncounterEventsRequest::ByteSizeLong,
              &StreamEncounterEventsRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(StreamEncounterEventsRequest, _impl_._cached_size_),
          false,
      },
      &StreamEncounterEventsRequest::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull StreamEncounterEventsRequest_class_data_ =
        StreamEncounterEventsRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
StreamEncounterEventsRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&StreamEncounterEventsRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(StreamEncounterEventsRequest_class_data_.tc_table);
  return StreamEncounterEventsRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 77, 2>
StreamEncounterEventsRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(StreamEncounterEventsRequest, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    StreamEncounterEventsRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::StreamEncounterEventsRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string player_id = 2 [json_name = "playerId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(StreamEncounterEventsRequest, _impl_.player_id_)}},
    // string encounter_id = 1 [json_name = "encounterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(StreamEncounterEventsRequest, _impl_.encounter_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string encounter_id = 1 [json_name = "encounterId"];
    {PROTOBUF_FIELD_OFFSET(StreamEncounterEventsRequest, _impl_.encounter_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string player_id = 2 [json_name = "playerId"];
    {PROTOBUF_FIELD_OFFSET(StreamEncounterEventsRequest, _impl_.player_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\57\14\11\0\0\0\0\0"
    "dnd5e.api.v1alpha1.StreamEncounterEventsRequest"
    "encounter_id"
    "player_id"
  }},
};
PROTOBUF_NOINLINE void StreamEncounterEventsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.StreamEncounterEventsRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.encounter_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.player_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL StreamEncounterEventsRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const StreamEncounterEventsRequest& this_ = static_cast<const StreamEncounterEventsRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL StreamEncounterEventsRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const StreamEncounterEventsRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.StreamEncounterEventsRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string encounter_id = 1 [json_name = "encounterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_encounter_id().empty()) {
      const ::std::string& _s = this_._internal_encounter_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.StreamEncounterEventsRequest.encounter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string player_id = 2 [json_name = "playerId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_player_id().empty()) {
      const ::std::string& _s = this_._internal_player_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.StreamEncounterEventsRequest.player_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.StreamEncounterEventsRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t StreamEncounterEventsRequest::ByteSizeLong(const MessageLite& base) {
  const StreamEncounterEventsRequest& this_ = static_cast<const StreamEncounterEventsRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t StreamEncounterEventsRequest::ByteSizeLong() const {
  const StreamEncounterEventsRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.StreamEncounterEventsRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // string encounter_id = 1 [json_name = "encounterId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_encounter_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_encounter_id());
      }
    }
    // string player_id = 2 [json_name = "playerId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_player_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_player_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void StreamEncounterEventsRequest::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<StreamEncounterEventsRequest*>(&to_msg);
  auto& from = static_cast<const StreamEncounterEventsRequest&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.StreamEncounterEventsRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_encounter_id().empty()) {
        _this->_internal_set_encounter_id(from._internal_encounter_id());
      } else {
        if (_this->_impl_.encounter_id_.IsDefault()) {
          _this->_internal_set_encounter_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_player_id().empty()) {
        _this->_internal_set_player_id(from._internal_player_id());
      } else {
        if (_this->_impl_.player_id_.IsDefault()) {
          _this->_internal_set_player_id("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void StreamEncounterEventsRequest::CopyFrom(const StreamEncounterEventsRequest& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.StreamEncounterEventsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void StreamEncounterEventsRequest::InternalSwap(StreamEncounterEventsRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encounter_id_, &other->_impl_.encounter_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
}

::google::protobuf::Metadata StreamEncounterEventsRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class EncounterEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<EncounterEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::dnd5e::api::v1alpha1::EncounterEvent, _impl_._oneof_case_);
};

void EncounterEvent::set_allocated_player_joined(::dnd5e::api::v1alpha1::PlayerJoinedEvent* PROTOBUF_NULLABLE player_joined) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (player_joined) {
    ::google::protobuf::Arena* submessage_arena = player_joined->GetArena();
    if (message_arena != submessage_arena) {
      player_joined = ::google::protobuf::internal::GetOwnedMessage(message_arena, player_joined, submessage_arena);
    }
    set_has_player_joined();
    _impl_.event_.player_joined_ = player_joined;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.player_joined)
}
void EncounterEvent::set_allocated_player_left(::dnd5e::api::v1alpha1::PlayerLeftEvent* PROTOBUF_NULLABLE player_left) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (player_left) {
    ::google::protobuf::Arena* submessage_arena = player_left->GetArena();
    if (message_arena != submessage_arena) {
      player_left = ::google::protobuf::internal::GetOwnedMessage(message_arena, player_left, submessage_arena);
    }
    set_has_player_left();
    _impl_.event_.player_left_ = player_left;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.player_left)
}
void EncounterEvent::set_allocated_player_ready(::dnd5e::api::v1alpha1::PlayerReadyEvent* PROTOBUF_NULLABLE player_ready) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (player_ready) {
    ::google::protobuf::Arena* submessage_arena = player_ready->GetArena();
    if (message_arena != submessage_arena) {
      player_ready = ::google::protobuf::internal::GetOwnedMessage(message_arena, player_ready, submessage_arena);
    }
    set_has_player_ready();
    _impl_.event_.player_ready_ = player_ready;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.player_ready)
}
void EncounterEvent::set_allocated_combat_started(::dnd5e::api::v1alpha1::CombatStartedEvent* PROTOBUF_NULLABLE combat_started) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (combat_started) {
    ::google::protobuf::Arena* submessage_arena = combat_started->GetArena();
    if (message_arena != submessage_arena) {
      combat_started = ::google::protobuf::internal::GetOwnedMessage(message_arena, combat_started, submessage_arena);
    }
    set_has_combat_started();
    _impl_.event_.combat_started_ = combat_started;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.combat_started)
}
void EncounterEvent::set_allocated_movement_completed(::dnd5e::api::v1alpha1::MovementCompletedEvent* PROTOBUF_NULLABLE movement_completed) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (movement_completed) {
    ::google::protobuf::Arena* submessage_arena = movement_completed->GetArena();
    if (message_arena != submessage_arena) {
      movement_completed = ::google::protobuf::internal::GetOwnedMessage(message_arena, movement_completed, submessage_arena);
    }
    set_has_movement_completed();
    _impl_.event_.movement_completed_ = movement_completed;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.movement_completed)
}
void EncounterEvent::set_allocated_attack_resolved(::dnd5e::api::v1alpha1::AttackResolvedEvent* PROTOBUF_NULLABLE attack_resolved) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (attack_resolved) {
    ::google::protobuf::Arena* submessage_arena = attack_resolved->GetArena();
    if (message_arena != submessage_arena) {
      attack_resolved = ::google::protobuf::internal::GetOwnedMessage(message_arena, attack_resolved, submessage_arena);
    }
    set_has_attack_resolved();
    _impl_.event_.attack_resolved_ = attack_resolved;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.attack_resolved)
}
void EncounterEvent::set_allocated_feature_activated(::dnd5e::api::v1alpha1::FeatureActivatedEvent* PROTOBUF_NULLABLE feature_activated) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (feature_activated) {
    ::google::protobuf::Arena* submessage_arena = feature_activated->GetArena();
    if (message_arena != submessage_arena) {
      feature_activated = ::google::protobuf::internal::GetOwnedMessage(message_arena, feature_activated, submessage_arena);
    }
    set_has_feature_activated();
    _impl_.event_.feature_activated_ = feature_activated;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.feature_activated)
}
void EncounterEvent::set_allocated_turn_ended(::dnd5e::api::v1alpha1::TurnEndedEvent* PROTOBUF_NULLABLE turn_ended) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (turn_ended) {
    ::google::protobuf::Arena* submessage_arena = turn_ended->GetArena();
    if (message_arena != submessage_arena) {
      turn_ended = ::google::protobuf::internal::GetOwnedMessage(message_arena, turn_ended, submessage_arena);
    }
    set_has_turn_ended();
    _impl_.event_.turn_ended_ = turn_ended;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.turn_ended)
}
void EncounterEvent::set_allocated_monster_turn_completed(::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* PROTOBUF_NULLABLE monster_turn_completed) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (monster_turn_completed) {
    ::google::protobuf::Arena* submessage_arena = monster_turn_completed->GetArena();
    if (message_arena != submessage_arena) {
      monster_turn_completed = ::google::protobuf::internal::GetOwnedMessage(message_arena, monster_turn_completed, submessage_arena);
    }
    set_has_monster_turn_completed();
    _impl_.event_.monster_turn_completed_ = monster_turn_completed;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.monster_turn_completed)
}
void EncounterEvent::set_allocated_combat_ended(::dnd5e::api::v1alpha1::CombatEndedEvent* PROTOBUF_NULLABLE combat_ended) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (combat_ended) {
    ::google::protobuf::Arena* submessage_arena = combat_ended->GetArena();
    if (message_arena != submessage_arena) {
      combat_ended = ::google::protobuf::internal::GetOwnedMessage(message_arena, combat_ended, submessage_arena);
    }
    set_has_combat_ended();
    _impl_.event_.combat_ended_ = combat_ended;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.combat_ended)
}
void EncounterEvent::set_allocated_player_disconnected(::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* PROTOBUF_NULLABLE player_disconnected) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (player_disconnected) {
    ::google::protobuf::Arena* submessage_arena = player_disconnected->GetArena();
    if (message_arena != submessage_arena) {
      player_disconnected = ::google::protobuf::internal::GetOwnedMessage(message_arena, player_disconnected, submessage_arena);
    }
    set_has_player_disconnected();
    _impl_.event_.player_disconnected_ = player_disconnected;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.player_disconnected)
}
void EncounterEvent::set_allocated_player_reconnected(::dnd5e::api::v1alpha1::PlayerReconnectedEvent* PROTOBUF_NULLABLE player_reconnected) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (player_reconnected) {
    ::google::protobuf::Arena* submessage_arena = player_reconnected->GetArena();
    if (message_arena != submessage_arena) {
      player_reconnected = ::google::protobuf::internal::GetOwnedMessage(message_arena, player_reconnected, submessage_arena);
    }
    set_has_player_reconnected();
    _impl_.event_.player_reconnected_ = player_reconnected;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.player_reconnected)
}
void EncounterEvent::set_allocated_combat_paused(::dnd5e::api::v1alpha1::CombatPausedEvent* PROTOBUF_NULLABLE combat_paused) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (combat_paused) {
    ::google::protobuf::Arena* submessage_arena = combat_paused->GetArena();
    if (message_arena != submessage_arena) {
      combat_paused = ::google::protobuf::internal::GetOwnedMessage(message_arena, combat_paused, submessage_arena);
    }
    set_has_combat_paused();
    _impl_.event_.combat_paused_ = combat_paused;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.combat_paused)
}
void EncounterEvent::set_allocated_combat_resumed(::dnd5e::api::v1alpha1::CombatResumedEvent* PROTOBUF_NULLABLE combat_resumed) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (combat_resumed) {
    ::google::protobuf::Arena* submessage_arena = combat_resumed->GetArena();
    if (message_arena != submessage_arena) {
      combat_resumed = ::google::protobuf::internal::GetOwnedMessage(message_arena, combat_resumed, submessage_arena);
    }
    set_has_combat_resumed();
    _impl_.event_.combat_resumed_ = combat_resumed;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.combat_resumed)
}
void EncounterEvent::set_allocated_room_revealed(::dnd5e::api::v1alpha1::RoomRevealedEvent* PROTOBUF_NULLABLE room_revealed) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (room_revealed) {
    ::google::protobuf::Arena* submessage_arena = room_revealed->GetArena();
    if (message_arena != submessage_arena) {
      room_revealed = ::google::protobuf::internal::GetOwnedMessage(message_arena, room_revealed, submessage_arena);
    }
    set_has_room_revealed();
    _impl_.event_.room_revealed_ = room_revealed;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.room_revealed)
}
void EncounterEvent::set_allocated_dungeon_victory(::dnd5e::api::v1alpha1::DungeonVictoryEvent* PROTOBUF_NULLABLE dungeon_victory) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (dungeon_victory) {
    ::google::protobuf::Arena* submessage_arena = dungeon_victory->GetArena();
    if (message_arena != submessage_arena) {
      dungeon_victory = ::google::protobuf::internal::GetOwnedMessage(message_arena, dungeon_victory, submessage_arena);
    }
    set_has_dungeon_victory();
    _impl_.event_.dungeon_victory_ = dungeon_victory;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.dungeon_victory)
}
void EncounterEvent::set_allocated_dungeon_failure(::dnd5e::api::v1alpha1::DungeonFailureEvent* PROTOBUF_NULLABLE dungeon_failure) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_event();
  if (dungeon_failure) {
    ::google::protobuf::Arena* submessage_arena = dungeon_failure->GetArena();
    if (message_arena != submessage_arena) {
      dungeon_failure = ::google::protobuf::internal::GetOwnedMessage(message_arena, dungeon_failure, submessage_arena);
    }
    set_has_dungeon_failure();
    _impl_.event_.dungeon_failure_ = dungeon_failure;
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.dungeon_failure)
}
EncounterEvent::EncounterEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EncounterEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.EncounterEvent)
}
PROTOBUF_NDEBUG_INLINE EncounterEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::EncounterEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        event_id_(arena, from.event_id_),
        event_{},
        _oneof_case_{from._oneof_case_[0]} {}

EncounterEvent::EncounterEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const EncounterEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EncounterEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  EncounterEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.timestamp_ = from._impl_.timestamp_;
  switch (event_case()) {
    case EVENT_NOT_SET:
      break;
      case kPlayerJoined:
        _impl_.event_.player_joined_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.player_joined_);
        break;
      case kPlayerLeft:
        _impl_.event_.player_left_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.player_left_);
        break;
      case kPlayerReady:
        _impl_.event_.player_ready_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.player_ready_);
        break;
      case kCombatStarted:
        _impl_.event_.combat_started_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.combat_started_);
        break;
      case kMovementCompleted:
        _impl_.event_.movement_completed_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.movement_completed_);
        break;
      case kAttackResolved:
        _impl_.event_.attack_resolved_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.attack_resolved_);
        break;
      case kFeatureActivated:
        _impl_.event_.feature_activated_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.feature_activated_);
        break;
      case kTurnEnded:
        _impl_.event_.turn_ended_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.turn_ended_);
        break;
      case kMonsterTurnCompleted:
        _impl_.event_.monster_turn_completed_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.monster_turn_completed_);
        break;
      case kCombatEnded:
        _impl_.event_.combat_ended_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.combat_ended_);
        break;
      case kPlayerDisconnected:
        _impl_.event_.player_disconnected_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.player_disconnected_);
        break;
      case kPlayerReconnected:
        _impl_.event_.player_reconnected_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.player_reconnected_);
        break;
      case kCombatPaused:
        _impl_.event_.combat_paused_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.combat_paused_);
        break;
      case kCombatResumed:
        _impl_.event_.combat_resumed_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.combat_resumed_);
        break;
      case kRoomRevealed:
        _impl_.event_.room_revealed_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.room_revealed_);
        break;
      case kDungeonVictory:
        _impl_.event_.dungeon_victory_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.dungeon_victory_);
        break;
      case kDungeonFailure:
        _impl_.event_.dungeon_failure_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.dungeon_failure_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.EncounterEvent)
}
PROTOBUF_NDEBUG_INLINE EncounterEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        event_id_(arena),
        event_{},
        _oneof_case_{} {}

inline void EncounterEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.timestamp_ = {};
}
EncounterEvent::~EncounterEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.EncounterEvent)
  SharedDtor(*this);
}
inline void EncounterEvent::SharedDtor(MessageLite& self) {
  EncounterEvent& this_ = static_cast<EncounterEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.event_id_.Destroy();
  if (this_.has_event()) {
    this_.clear_event();
  }
  this_._impl_.~Impl_();
}

void EncounterEvent::clear_event() {
// @@protoc_insertion_point(one_of_clear_start:dnd5e.api.v1alpha1.EncounterEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (event_case()) {
    case kPlayerJoined: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.player_joined_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_joined_);
      }
      break;
    }
    case kPlayerLeft: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.player_left_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_left_);
      }
      break;
    }
    case kPlayerReady: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.player_ready_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_ready_);
      }
      break;
    }
    case kCombatStarted: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.combat_started_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.combat_started_);
      }
      break;
    }
    case kMovementCompleted: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.movement_completed_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.movement_completed_);
      }
      break;
    }
    case kAttackResolved: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.attack_resolved_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.attack_resolved_);
      }
      break;
    }
    case kFeatureActivated: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.feature_activated_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.feature_activated_);
      }
      break;
    }
    case kTurnEnded: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.turn_ended_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.turn_ended_);
      }
      break;
    }
    case kMonsterTurnCompleted: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.monster_turn_completed_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.monster_turn_completed_);
      }
      break;
    }
    case kCombatEnded: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.combat_ended_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.combat_ended_);
      }
      break;
    }
    case kPlayerDisconnected: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.player_disconnected_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_disconnected_);
      }
      break;
    }
    case kPlayerReconnected: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.player_reconnected_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_reconnected_);
      }
      break;
    }
    case kCombatPaused: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.combat_paused_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.combat_paused_);
      }
      break;
    }
    case kCombatResumed: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.combat_resumed_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.combat_resumed_);
      }
      break;
    }
    case kRoomRevealed: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.room_revealed_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.room_revealed_);
      }
      break;
    }
    case kDungeonVictory: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.dungeon_victory_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.dungeon_victory_);
      }
      break;
    }
    case kDungeonFailure: {
      if (GetArena() == nullptr) {
        delete _impl_.event_.dungeon_failure_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.dungeon_failure_);
      }
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}


inline void* PROTOBUF_NONNULL EncounterEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) EncounterEvent(arena);
}
constexpr auto EncounterEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(EncounterEvent),
                                            alignof(EncounterEvent));
}
constexpr auto EncounterEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_EncounterEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &EncounterEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<EncounterEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &EncounterEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<EncounterEvent>(), &EncounterEvent::ByteSizeLong,
              &EncounterEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_._cached_size_),
          false,
      },
      &EncounterEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull EncounterEvent_class_data_ =
        EncounterEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
EncounterEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&EncounterEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(EncounterEvent_class_data_.tc_table);
  return EncounterEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 19, 17, 66, 7>
EncounterEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_._has_bits_),
    0, // no _extensions_
    42, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    503833084,  // skipmap
    offsetof(decltype(_table_), field_entries),
    19,  // num_field_entries
    17,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    EncounterEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EncounterEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // int64 timestamp = 2 [json_name = "timestamp"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(EncounterEvent, _impl_.timestamp_), 1>(),
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.timestamp_)}},
    // string event_id = 1 [json_name = "eventId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_id_)}},
  }}, {{
    33, 0, 1,
    64638, 15,
    65535, 65535
  }}, {{
    // string event_id = 1 [json_name = "eventId"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int64 timestamp = 2 [json_name = "timestamp"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.timestamp_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // .dnd5e.api.v1alpha1.PlayerJoinedEvent player_joined = 10 [json_name = "playerJoined"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.player_joined_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.PlayerLeftEvent player_left = 11 [json_name = "playerLeft"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.player_left_), _Internal::kOneofCaseOffset + 0, 1, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.PlayerReadyEvent player_ready = 12 [json_name = "playerReady"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.player_ready_), _Internal::kOneofCaseOffset + 0, 2, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.CombatStartedEvent combat_started = 13 [json_name = "combatStarted"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.combat_started_), _Internal::kOneofCaseOffset + 0, 3, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.MovementCompletedEvent movement_completed = 20 [json_name = "movementCompleted"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.movement_completed_), _Internal::kOneofCaseOffset + 0, 4, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.AttackResolvedEvent attack_resolved = 21 [json_name = "attackResolved"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.attack_resolved_), _Internal::kOneofCaseOffset + 0, 5, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.FeatureActivatedEvent feature_activated = 22 [json_name = "featureActivated"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.feature_activated_), _Internal::kOneofCaseOffset + 0, 6, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.TurnEndedEvent turn_ended = 23 [json_name = "turnEnded"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.turn_ended_), _Internal::kOneofCaseOffset + 0, 7, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.MonsterTurnCompletedEvent monster_turn_completed = 24 [json_name = "monsterTurnCompleted"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.monster_turn_completed_), _Internal::kOneofCaseOffset + 0, 8, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.CombatEndedEvent combat_ended = 25 [json_name = "combatEnded"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.combat_ended_), _Internal::kOneofCaseOffset + 0, 9, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.PlayerDisconnectedEvent player_disconnected = 30 [json_name = "playerDisconnected"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.player_disconnected_), _Internal::kOneofCaseOffset + 0, 10, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.PlayerReconnectedEvent player_reconnected = 31 [json_name = "playerReconnected"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.player_reconnected_), _Internal::kOneofCaseOffset + 0, 11, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.CombatPausedEvent combat_paused = 32 [json_name = "combatPaused"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.combat_paused_), _Internal::kOneofCaseOffset + 0, 12, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.CombatResumedEvent combat_resumed = 33 [json_name = "combatResumed"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.combat_resumed_), _Internal::kOneofCaseOffset + 0, 13, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.RoomRevealedEvent room_revealed = 40 [json_name = "roomRevealed"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.room_revealed_), _Internal::kOneofCaseOffset + 0, 14, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.DungeonVictoryEvent dungeon_victory = 41 [json_name = "dungeonVictory"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.dungeon_victory_), _Internal::kOneofCaseOffset + 0, 15, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.DungeonFailureEvent dungeon_failure = 42 [json_name = "dungeonFailure"];
    {PROTOBUF_FIELD_OFFSET(EncounterEvent, _impl_.event_.dungeon_failure_), _Internal::kOneofCaseOffset + 0, 16, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PlayerJoinedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PlayerLeftEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PlayerReadyEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatStartedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MovementCompletedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::AttackResolvedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::FeatureActivatedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::TurnEndedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatEndedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PlayerDisconnectedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PlayerReconnectedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatPausedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatResumedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::RoomRevealedEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DungeonVictoryEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DungeonFailureEvent>()},
  }},
  {{
    "\41\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.EncounterEvent"
    "event_id"
  }},
};
PROTOBUF_NOINLINE void EncounterEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.EncounterEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.event_id_.ClearNonDefaultToEmpty();
  }
  _impl_.timestamp_ = ::int64_t{0};
  clear_event();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL EncounterEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const EncounterEvent& this_ = static_cast<const EncounterEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL EncounterEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const EncounterEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.EncounterEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string event_id = 1 [json_name = "eventId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_event_id().empty()) {
      const ::std::string& _s = this_._internal_event_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.EncounterEvent.event_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // int64 timestamp = 2 [json_name = "timestamp"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (this_._internal_timestamp() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<2>(
              stream, this_._internal_timestamp(), target);
    }
  }

  switch (this_.event_case()) {
    case kPlayerJoined: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          10, *this_._impl_.event_.player_joined_, this_._impl_.event_.player_joined_->GetCachedSize(), target,
          stream);
      break;
    }
    case kPlayerLeft: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          11, *this_._impl_.event_.player_left_, this_._impl_.event_.player_left_->GetCachedSize(), target,
          stream);
      break;
    }
    case kPlayerReady: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          12, *this_._impl_.event_.player_ready_, this_._impl_.event_.player_ready_->GetCachedSize(), target,
          stream);
      break;
    }
    case kCombatStarted: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          13, *this_._impl_.event_.combat_started_, this_._impl_.event_.combat_started_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMovementCompleted: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          20, *this_._impl_.event_.movement_completed_, this_._impl_.event_.movement_completed_->GetCachedSize(), target,
          stream);
      break;
    }
    case kAttackResolved: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          21, *this_._impl_.event_.attack_resolved_, this_._impl_.event_.attack_resolved_->GetCachedSize(), target,
          stream);
      break;
    }
    case kFeatureActivated: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          22, *this_._impl_.event_.feature_activated_, this_._impl_.event_.feature_activated_->GetCachedSize(), target,
          stream);
      break;
    }
    case kTurnEnded: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          23, *this_._impl_.event_.turn_ended_, this_._impl_.event_.turn_ended_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMonsterTurnCompleted: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          24, *this_._impl_.event_.monster_turn_completed_, this_._impl_.event_.monster_turn_completed_->GetCachedSize(), target,
          stream);
      break;
    }
    case kCombatEnded: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          25, *this_._impl_.event_.combat_ended_, this_._impl_.event_.combat_ended_->GetCachedSize(), target,
          stream);
      break;
    }
    case kPlayerDisconnected: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          30, *this_._impl_.event_.player_disconnected_, this_._impl_.event_.player_disconnected_->GetCachedSize(), target,
          stream);
      break;
    }
    case kPlayerReconnected: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          31, *this_._impl_.event_.player_reconnected_, this_._impl_.event_.player_reconnected_->GetCachedSize(), target,
          stream);
      break;
    }
    case kCombatPaused: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          32, *this_._impl_.event_.combat_paused_, this_._impl_.event_.combat_paused_->GetCachedSize(), target,
          stream);
      break;
    }
    case kCombatResumed: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          33, *this_._impl_.event_.combat_resumed_, this_._impl_.event_.combat_resumed_->GetCachedSize(), target,
          stream);
      break;
    }
    case kRoomRevealed: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          40, *this_._impl_.event_.room_revealed_, this_._impl_.event_.room_revealed_->GetCachedSize(), target,
          stream);
      break;
    }
    case kDungeonVictory: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          41, *this_._impl_.event_.dungeon_victory_, this_._impl_.event_.dungeon_victory_->GetCachedSize(), target,
          stream);
      break;
    }
    case kDungeonFailure: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          42, *this_._impl_.event_.dungeon_failure_, this_._impl_.event_.dungeon_failure_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.EncounterEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t EncounterEvent::ByteSizeLong(const MessageLite& base) {
  const EncounterEvent& this_ = static_cast<const EncounterEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t EncounterEvent::ByteSizeLong() const {
  const EncounterEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.EncounterEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // string event_id = 1 [json_name = "eventId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_event_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_event_id());
      }
    }
    // int64 timestamp = 2 [json_name = "timestamp"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (this_._internal_timestamp() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_timestamp());
      }
    }
  }
  switch (this_.event_case()) {
    // .dnd5e.api.v1alpha1.PlayerJoinedEvent player_joined = 10 [json_name = "playerJoined"];
    case kPlayerJoined: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.player_joined_);
      break;
    }
    // .dnd5e.api.v1alpha1.PlayerLeftEvent player_left = 11 [json_name = "playerLeft"];
    case kPlayerLeft: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.player_left_);
      break;
    }
    // .dnd5e.api.v1alpha1.PlayerReadyEvent player_ready = 12 [json_name = "playerReady"];
    case kPlayerReady: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.player_ready_);
      break;
    }
    // .dnd5e.api.v1alpha1.CombatStartedEvent combat_started = 13 [json_name = "combatStarted"];
    case kCombatStarted: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.combat_started_);
      break;
    }
    // .dnd5e.api.v1alpha1.MovementCompletedEvent movement_completed = 20 [json_name = "movementCompleted"];
    case kMovementCompleted: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.movement_completed_);
      break;
    }
    // .dnd5e.api.v1alpha1.AttackResolvedEvent attack_resolved = 21 [json_name = "attackResolved"];
    case kAttackResolved: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.attack_resolved_);
      break;
    }
    // .dnd5e.api.v1alpha1.FeatureActivatedEvent feature_activated = 22 [json_name = "featureActivated"];
    case kFeatureActivated: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.feature_activated_);
      break;
    }
    // .dnd5e.api.v1alpha1.TurnEndedEvent turn_ended = 23 [json_name = "turnEnded"];
    case kTurnEnded: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.turn_ended_);
      break;
    }
    // .dnd5e.api.v1alpha1.MonsterTurnCompletedEvent monster_turn_completed = 24 [json_name = "monsterTurnCompleted"];
    case kMonsterTurnCompleted: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.monster_turn_completed_);
      break;
    }
    // .dnd5e.api.v1alpha1.CombatEndedEvent combat_ended = 25 [json_name = "combatEnded"];
    case kCombatEnded: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.combat_ended_);
      break;
    }
    // .dnd5e.api.v1alpha1.PlayerDisconnectedEvent player_disconnected = 30 [json_name = "playerDisconnected"];
    case kPlayerDisconnected: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.player_disconnected_);
      break;
    }
    // .dnd5e.api.v1alpha1.PlayerReconnectedEvent player_reconnected = 31 [json_name = "playerReconnected"];
    case kPlayerReconnected: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.player_reconnected_);
      break;
    }
    // .dnd5e.api.v1alpha1.CombatPausedEvent combat_paused = 32 [json_name = "combatPaused"];
    case kCombatPaused: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.combat_paused_);
      break;
    }
    // .dnd5e.api.v1alpha1.CombatResumedEvent combat_resumed = 33 [json_name = "combatResumed"];
    case kCombatResumed: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.combat_resumed_);
      break;
    }
    // .dnd5e.api.v1alpha1.RoomRevealedEvent room_revealed = 40 [json_name = "roomRevealed"];
    case kRoomRevealed: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.room_revealed_);
      break;
    }
    // .dnd5e.api.v1alpha1.DungeonVictoryEvent dungeon_victory = 41 [json_name = "dungeonVictory"];
    case kDungeonVictory: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.dungeon_victory_);
      break;
    }
    // .dnd5e.api.v1alpha1.DungeonFailureEvent dungeon_failure = 42 [json_name = "dungeonFailure"];
    case kDungeonFailure: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.event_.dungeon_failure_);
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void EncounterEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<EncounterEvent*>(&to_msg);
  auto& from = static_cast<const EncounterEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.EncounterEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_event_id().empty()) {
        _this->_internal_set_event_id(from._internal_event_id());
      } else {
        if (_this->_impl_.event_id_.IsDefault()) {
          _this->_internal_set_event_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (from._internal_timestamp() != 0) {
        _this->_impl_.timestamp_ = from._impl_.timestamp_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case =
          from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_event();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kPlayerJoined: {
        if (oneof_needs_init) {
          _this->_impl_.event_.player_joined_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.player_joined_);
        } else {
          _this->_impl_.event_.player_joined_->MergeFrom(*from._impl_.event_.player_joined_);
        }
        break;
      }
      case kPlayerLeft: {
        if (oneof_needs_init) {
          _this->_impl_.event_.player_left_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.player_left_);
        } else {
          _this->_impl_.event_.player_left_->MergeFrom(*from._impl_.event_.player_left_);
        }
        break;
      }
      case kPlayerReady: {
        if (oneof_needs_init) {
          _this->_impl_.event_.player_ready_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.player_ready_);
        } else {
          _this->_impl_.event_.player_ready_->MergeFrom(*from._impl_.event_.player_ready_);
        }
        break;
      }
      case kCombatStarted: {
        if (oneof_needs_init) {
          _this->_impl_.event_.combat_started_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.combat_started_);
        } else {
          _this->_impl_.event_.combat_started_->MergeFrom(*from._impl_.event_.combat_started_);
        }
        break;
      }
      case kMovementCompleted: {
        if (oneof_needs_init) {
          _this->_impl_.event_.movement_completed_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.movement_completed_);
        } else {
          _this->_impl_.event_.movement_completed_->MergeFrom(*from._impl_.event_.movement_completed_);
        }
        break;
      }
      case kAttackResolved: {
        if (oneof_needs_init) {
          _this->_impl_.event_.attack_resolved_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.attack_resolved_);
        } else {
          _this->_impl_.event_.attack_resolved_->MergeFrom(*from._impl_.event_.attack_resolved_);
        }
        break;
      }
      case kFeatureActivated: {
        if (oneof_needs_init) {
          _this->_impl_.event_.feature_activated_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.feature_activated_);
        } else {
          _this->_impl_.event_.feature_activated_->MergeFrom(*from._impl_.event_.feature_activated_);
        }
        break;
      }
      case kTurnEnded: {
        if (oneof_needs_init) {
          _this->_impl_.event_.turn_ended_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.turn_ended_);
        } else {
          _this->_impl_.event_.turn_ended_->MergeFrom(*from._impl_.event_.turn_ended_);
        }
        break;
      }
      case kMonsterTurnCompleted: {
        if (oneof_needs_init) {
          _this->_impl_.event_.monster_turn_completed_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.monster_turn_completed_);
        } else {
          _this->_impl_.event_.monster_turn_completed_->MergeFrom(*from._impl_.event_.monster_turn_completed_);
        }
        break;
      }
      case kCombatEnded: {
        if (oneof_needs_init) {
          _this->_impl_.event_.combat_ended_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.combat_ended_);
        } else {
          _this->_impl_.event_.combat_ended_->MergeFrom(*from._impl_.event_.combat_ended_);
        }
        break;
      }
      case kPlayerDisconnected: {
        if (oneof_needs_init) {
          _this->_impl_.event_.player_disconnected_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.player_disconnected_);
        } else {
          _this->_impl_.event_.player_disconnected_->MergeFrom(*from._impl_.event_.player_disconnected_);
        }
        break;
      }
      case kPlayerReconnected: {
        if (oneof_needs_init) {
          _this->_impl_.event_.player_reconnected_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.player_reconnected_);
        } else {
          _this->_impl_.event_.player_reconnected_->MergeFrom(*from._impl_.event_.player_reconnected_);
        }
        break;
      }
      case kCombatPaused: {
        if (oneof_needs_init) {
          _this->_impl_.event_.combat_paused_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.combat_paused_);
        } else {
          _this->_impl_.event_.combat_paused_->MergeFrom(*from._impl_.event_.combat_paused_);
        }
        break;
      }
      case kCombatResumed: {
        if (oneof_needs_init) {
          _this->_impl_.event_.combat_resumed_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.combat_resumed_);
        } else {
          _this->_impl_.event_.combat_resumed_->MergeFrom(*from._impl_.event_.combat_resumed_);
        }
        break;
      }
      case kRoomRevealed: {
        if (oneof_needs_init) {
          _this->_impl_.event_.room_revealed_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.room_revealed_);
        } else {
          _this->_impl_.event_.room_revealed_->MergeFrom(*from._impl_.event_.room_revealed_);
        }
        break;
      }
      case kDungeonVictory: {
        if (oneof_needs_init) {
          _this->_impl_.event_.dungeon_victory_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.dungeon_victory_);
        } else {
          _this->_impl_.event_.dungeon_victory_->MergeFrom(*from._impl_.event_.dungeon_victory_);
        }
        break;
      }
      case kDungeonFailure: {
        if (oneof_needs_init) {
          _this->_impl_.event_.dungeon_failure_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.event_.dungeon_failure_);
        } else {
          _this->_impl_.event_.dungeon_failure_->MergeFrom(*from._impl_.event_.dungeon_failure_);
        }
        break;
      }
      case EVENT_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void EncounterEvent::CopyFrom(const EncounterEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.EncounterEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EncounterEvent::InternalSwap(EncounterEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.event_id_, &other->_impl_.event_id_, arena);
  swap(_impl_.timestamp_, other->_impl_.timestamp_);
  swap(_impl_.event_, other->_impl_.event_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata EncounterEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PlayerJoinedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PlayerJoinedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PlayerJoinedEvent, _impl_._has_bits_);
};

PlayerJoinedEvent::PlayerJoinedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PlayerJoinedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.PlayerJoinedEvent)
}
PROTOBUF_NDEBUG_INLINE PlayerJoinedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::PlayerJoinedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

PlayerJoinedEvent::PlayerJoinedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PlayerJoinedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PlayerJoinedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PlayerJoinedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.member_ = (CheckHasBit(cached_has_bits, 0x00000001U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.member_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.PlayerJoinedEvent)
}
PROTOBUF_NDEBUG_INLINE PlayerJoinedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void PlayerJoinedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.member_ = {};
}
PlayerJoinedEvent::~PlayerJoinedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.PlayerJoinedEvent)
  SharedDtor(*this);
}
inline void PlayerJoinedEvent::SharedDtor(MessageLite& self) {
  PlayerJoinedEvent& this_ = static_cast<PlayerJoinedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.member_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PlayerJoinedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PlayerJoinedEvent(arena);
}
constexpr auto PlayerJoinedEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(PlayerJoinedEvent),
                                            alignof(PlayerJoinedEvent));
}
constexpr auto PlayerJoinedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PlayerJoinedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PlayerJoinedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PlayerJoinedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PlayerJoinedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PlayerJoinedEvent>(), &PlayerJoinedEvent::ByteSizeLong,
              &PlayerJoinedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PlayerJoinedEvent, _impl_._cached_size_),
          false,
      },
      &PlayerJoinedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PlayerJoinedEvent_class_data_ =
        PlayerJoinedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PlayerJoinedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PlayerJoinedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PlayerJoinedEvent_class_data_.tc_table);
  return PlayerJoinedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2>
PlayerJoinedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PlayerJoinedEvent, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PlayerJoinedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PlayerJoinedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.PartyMember member = 1 [json_name = "member"];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(PlayerJoinedEvent, _impl_.member_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.PartyMember member = 1 [json_name = "member"];
    {PROTOBUF_FIELD_OFFSET(PlayerJoinedEvent, _impl_.member_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PartyMember>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PlayerJoinedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.PlayerJoinedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    ABSL_DCHECK(_impl_.member_ != nullptr);
    _impl_.member_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PlayerJoinedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PlayerJoinedEvent& this_ = static_cast<const PlayerJoinedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PlayerJoinedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PlayerJoinedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.PlayerJoinedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .dnd5e.api.v1alpha1.PartyMember member = 1 [json_name = "member"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.member_, this_._impl_.member_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.PlayerJoinedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PlayerJoinedEvent::ByteSizeLong(const MessageLite& base) {
  const PlayerJoinedEvent& this_ = static_cast<const PlayerJoinedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PlayerJoinedEvent::ByteSizeLong() const {
  const PlayerJoinedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.PlayerJoinedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // .dnd5e.api.v1alpha1.PartyMember member = 1 [json_name = "member"];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.member_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PlayerJoinedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PlayerJoinedEvent*>(&to_msg);
  auto& from = static_cast<const PlayerJoinedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.PlayerJoinedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    ABSL_DCHECK(from._impl_.member_ != nullptr);
    if (_this->_impl_.member_ == nullptr) {
      _this->_impl_.member_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.member_);
    } else {
      _this->_impl_.member_->MergeFrom(*from._impl_.member_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void PlayerJoinedEvent::CopyFrom(const PlayerJoinedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.PlayerJoinedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PlayerJoinedEvent::InternalSwap(PlayerJoinedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.member_, other->_impl_.member_);
}

::google::protobuf::Metadata PlayerJoinedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PlayerLeftEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PlayerLeftEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PlayerLeftEvent, _impl_._has_bits_);
};

PlayerLeftEvent::PlayerLeftEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PlayerLeftEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.PlayerLeftEvent)
}
PROTOBUF_NDEBUG_INLINE PlayerLeftEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::PlayerLeftEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        player_id_(arena, from.player_id_),
        character_id_(arena, from.character_id_) {}

PlayerLeftEvent::PlayerLeftEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PlayerLeftEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PlayerLeftEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PlayerLeftEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.PlayerLeftEvent)
}
PROTOBUF_NDEBUG_INLINE PlayerLeftEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        player_id_(arena),
        character_id_(arena) {}

inline void PlayerLeftEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
PlayerLeftEvent::~PlayerLeftEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.PlayerLeftEvent)
  SharedDtor(*this);
}
inline void PlayerLeftEvent::SharedDtor(MessageLite& self) {
  PlayerLeftEvent& this_ = static_cast<PlayerLeftEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.player_id_.Destroy();
  this_._impl_.character_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PlayerLeftEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PlayerLeftEvent(arena);
}
constexpr auto PlayerLeftEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PlayerLeftEvent),
                                            alignof(PlayerLeftEvent));
}
constexpr auto PlayerLeftEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PlayerLeftEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PlayerLeftEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PlayerLeftEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PlayerLeftEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PlayerLeftEvent>(), &PlayerLeftEvent::ByteSizeLong,
              &PlayerLeftEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PlayerLeftEvent, _impl_._cached_size_),
          false,
      },
      &PlayerLeftEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PlayerLeftEvent_class_data_ =
        PlayerLeftEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PlayerLeftEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PlayerLeftEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PlayerLeftEvent_class_data_.tc_table);
  return PlayerLeftEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 64, 2>
PlayerLeftEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PlayerLeftEvent, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    PlayerLeftEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PlayerLeftEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string character_id = 2 [json_name = "characterId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(PlayerLeftEvent, _impl_.character_id_)}},
    // string player_id = 1 [json_name = "playerId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(PlayerLeftEvent, _impl_.player_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1 [json_name = "playerId"];
    {PROTOBUF_FIELD_OFFSET(PlayerLeftEvent, _impl_.player_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string character_id = 2 [json_name = "characterId"];
    {PROTOBUF_FIELD_OFFSET(PlayerLeftEvent, _impl_.character_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\42\11\14\0\0\0\0\0"
    "dnd5e.api.v1alpha1.PlayerLeftEvent"
    "player_id"
    "character_id"
  }},
};
PROTOBUF_NOINLINE void PlayerLeftEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.PlayerLeftEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.player_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.character_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PlayerLeftEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PlayerLeftEvent& this_ = static_cast<const PlayerLeftEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PlayerLeftEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PlayerLeftEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.PlayerLeftEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string player_id = 1 [json_name = "playerId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_player_id().empty()) {
      const ::std::string& _s = this_._internal_player_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.PlayerLeftEvent.player_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string character_id = 2 [json_name = "characterId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_character_id().empty()) {
      const ::std::string& _s = this_._internal_character_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.PlayerLeftEvent.character_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.PlayerLeftEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PlayerLeftEvent::ByteSizeLong(const MessageLite& base) {
  const PlayerLeftEvent& this_ = static_cast<const PlayerLeftEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PlayerLeftEvent::ByteSizeLong() const {
  const PlayerLeftEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.PlayerLeftEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // string player_id = 1 [json_name = "playerId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_player_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_player_id());
      }
    }
    // string character_id = 2 [json_name = "characterId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_character_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_character_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PlayerLeftEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PlayerLeftEvent*>(&to_msg);
  auto& from = static_cast<const PlayerLeftEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.PlayerLeftEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_player_id().empty()) {
        _this->_internal_set_player_id(from._internal_player_id());
      } else {
        if (_this->_impl_.player_id_.IsDefault()) {
          _this->_internal_set_player_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_character_id().empty()) {
        _this->_internal_set_character_id(from._internal_character_id());
      } else {
        if (_this->_impl_.character_id_.IsDefault()) {
          _this->_internal_set_character_id("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void PlayerLeftEvent::CopyFrom(const PlayerLeftEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.PlayerLeftEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PlayerLeftEvent::InternalSwap(PlayerLeftEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.character_id_, &other->_impl_.character_id_, arena);
}

::google::protobuf::Metadata PlayerLeftEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PlayerReadyEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PlayerReadyEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PlayerReadyEvent, _impl_._has_bits_);
};

PlayerReadyEvent::PlayerReadyEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PlayerReadyEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.PlayerReadyEvent)
}
PROTOBUF_NDEBUG_INLINE PlayerReadyEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::PlayerReadyEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        player_id_(arena, from.player_id_) {}

PlayerReadyEvent::PlayerReadyEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PlayerReadyEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PlayerReadyEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PlayerReadyEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.is_ready_ = from._impl_.is_ready_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.PlayerReadyEvent)
}
PROTOBUF_NDEBUG_INLINE PlayerReadyEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        player_id_(arena) {}

inline void PlayerReadyEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.is_ready_ = {};
}
PlayerReadyEvent::~PlayerReadyEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.PlayerReadyEvent)
  SharedDtor(*this);
}
inline void PlayerReadyEvent::SharedDtor(MessageLite& self) {
  PlayerReadyEvent& this_ = static_cast<PlayerReadyEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.player_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PlayerReadyEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PlayerReadyEvent(arena);
}
constexpr auto PlayerReadyEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PlayerReadyEvent),
                                            alignof(PlayerReadyEvent));
}
constexpr auto PlayerReadyEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PlayerReadyEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PlayerReadyEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PlayerReadyEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PlayerReadyEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PlayerReadyEvent>(), &PlayerReadyEvent::ByteSizeLong,
              &PlayerReadyEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PlayerReadyEvent, _impl_._cached_size_),
          false,
      },
      &PlayerReadyEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PlayerReadyEvent_class_data_ =
        PlayerReadyEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PlayerReadyEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PlayerReadyEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PlayerReadyEvent_class_data_.tc_table);
  return PlayerReadyEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 53, 2>
PlayerReadyEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PlayerReadyEvent, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    PlayerReadyEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PlayerReadyEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bool is_ready = 2 [json_name = "isReady"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(PlayerReadyEvent, _impl_.is_ready_), 1>(),
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(PlayerReadyEvent, _impl_.is_ready_)}},
    // string player_id = 1 [json_name = "playerId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(PlayerReadyEvent, _impl_.player_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1 [json_name = "playerId"];
    {PROTOBUF_FIELD_OFFSET(PlayerReadyEvent, _impl_.player_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool is_ready = 2 [json_name = "isReady"];
    {PROTOBUF_FIELD_OFFSET(PlayerReadyEvent, _impl_.is_ready_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\43\11\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.PlayerReadyEvent"
    "player_id"
  }},
};
PROTOBUF_NOINLINE void PlayerReadyEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.PlayerReadyEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.player_id_.ClearNonDefaultToEmpty();
  }
  _impl_.is_ready_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PlayerReadyEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PlayerReadyEvent& this_ = static_cast<const PlayerReadyEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PlayerReadyEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PlayerReadyEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.PlayerReadyEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string player_id = 1 [json_name = "playerId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_player_id().empty()) {
      const ::std::string& _s = this_._internal_player_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.PlayerReadyEvent.player_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // bool is_ready = 2 [json_name = "isReady"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (this_._internal_is_ready() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          2, this_._internal_is_ready(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.PlayerReadyEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PlayerReadyEvent::ByteSizeLong(const MessageLite& base) {
  const PlayerReadyEvent& this_ = static_cast<const PlayerReadyEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PlayerReadyEvent::ByteSizeLong() const {
  const PlayerReadyEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.PlayerReadyEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // string player_id = 1 [json_name = "playerId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_player_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_player_id());
      }
    }
    // bool is_ready = 2 [json_name = "isReady"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (this_._internal_is_ready() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PlayerReadyEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PlayerReadyEvent*>(&to_msg);
  auto& from = static_cast<const PlayerReadyEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.PlayerReadyEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_player_id().empty()) {
        _this->_internal_set_player_id(from._internal_player_id());
      } else {
        if (_this->_impl_.player_id_.IsDefault()) {
          _this->_internal_set_player_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (from._internal_is_ready() != 0) {
        _this->_impl_.is_ready_ = from._impl_.is_ready_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void PlayerReadyEvent::CopyFrom(const PlayerReadyEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.PlayerReadyEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PlayerReadyEvent::InternalSwap(PlayerReadyEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
  swap(_impl_.is_ready_, other->_impl_.is_ready_);
}

::google::protobuf::Metadata PlayerReadyEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CombatStartedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CombatStartedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_._has_bits_);
};

CombatStartedEvent::CombatStartedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CombatStartedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.CombatStartedEvent)
}
PROTOBUF_NDEBUG_INLINE CombatStartedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::CombatStartedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        party_{visibility, arena, from.party_},
        monsters_{visibility, arena, from.monsters_},
        doors_{visibility, arena, from.doors_},
        monster_turns_{visibility, arena, from.monster_turns_},
        dungeon_id_(arena, from.dungeon_id_) {}

CombatStartedEvent::CombatStartedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CombatStartedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CombatStartedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CombatStartedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.combat_state_ = (CheckHasBit(cached_has_bits, 0x00000020U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_)
                : nullptr;
  _impl_.room_ = (CheckHasBit(cached_has_bits, 0x00000040U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.CombatStartedEvent)
}
PROTOBUF_NDEBUG_INLINE CombatStartedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        party_{visibility, arena},
        monsters_{visibility, arena},
        doors_{visibility, arena},
        monster_turns_{visibility, arena},
        dungeon_id_(arena) {}

inline void CombatStartedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, combat_state_),
           0,
           offsetof(Impl_, room_) -
               offsetof(Impl_, combat_state_) +
               sizeof(Impl_::room_));
}
CombatStartedEvent::~CombatStartedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.CombatStartedEvent)
  SharedDtor(*this);
}
inline void CombatStartedEvent::SharedDtor(MessageLite& self) {
  CombatStartedEvent& this_ = static_cast<CombatStartedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.dungeon_id_.Destroy();
  delete this_._impl_.combat_state_;
  delete this_._impl_.room_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CombatStartedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CombatStartedEvent(arena);
}
constexpr auto CombatStartedEvent::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.party_) +
          decltype(CombatStartedEvent::_impl_.party_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.monsters_) +
          decltype(CombatStartedEvent::_impl_.monsters_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.doors_) +
          decltype(CombatStartedEvent::_impl_.doors_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.monster_turns_) +
          decltype(CombatStartedEvent::_impl_.monster_turns_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(CombatStartedEvent), alignof(CombatStartedEvent), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CombatStartedEvent::PlacementNew_,
                                 sizeof(CombatStartedEvent),
                                 alignof(CombatStartedEvent));
  }
}
constexpr auto CombatStartedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CombatStartedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CombatStartedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CombatStartedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CombatStartedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CombatStartedEvent>(), &CombatStartedEvent::ByteSizeLong,
              &CombatStartedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_._cached_size_),
          false,
      },
      &CombatStartedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CombatStartedEvent_class_data_ =
        CombatStartedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CombatStartedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CombatStartedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CombatStartedEvent_class_data_.tc_table);
  return CombatStartedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 6, 56, 2>
CombatStartedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    CombatStartedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatStartedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
    {::_pbi::TcParser::FastMtS1,
     {10, 5, 0,
      PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.combat_state_)}},
    // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
    {::_pbi::TcParser::FastMtS1,
     {18, 6, 1,
      PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.room_)}},
    // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
    {::_pbi::TcParser::FastMtR1,
     {26, 0, 2,
      PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.party_)}},
    // repeated .dnd5e.api.v1alpha1.MonsterCombatState monsters = 4 [json_name = "monsters"];
    {::_pbi::TcParser::FastMtR1,
     {34, 1, 3,
      PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.monsters_)}},
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 5 [json_name = "doors"];
    {::_pbi::TcParser::FastMtR1,
     {42, 2, 4,
      PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.doors_)}},
    // string dungeon_id = 6 [json_name = "dungeonId"];
    {::_pbi::TcParser::FastUS1,
     {50, 4, 0,
      PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.dungeon_id_)}},
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 7 [json_name = "monsterTurns"];
    {::_pbi::TcParser::FastMtR1,
     {58, 3, 5,
      PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.monster_turns_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
    {PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.combat_state_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
    {PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.room_), _Internal::kHasBitsOffset + 6, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
    {PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.party_), _Internal::kHasBitsOffset + 0, 2, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.MonsterCombatState monsters = 4 [json_name = "monsters"];
    {PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.monsters_), _Internal::kHasBitsOffset + 1, 3, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 5 [json_name = "doors"];
    {PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.doors_), _Internal::kHasBitsOffset + 2, 4, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // string dungeon_id = 6 [json_name = "dungeonId"];
    {PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.dungeon_id_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 7 [json_name = "monsterTurns"];
    {PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.monster_turns_), _Internal::kHasBitsOffset + 3, 5, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PartyMember>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterCombatState>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DoorInfo>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterTurnResult>()},
  }},
  {{
    "\45\0\0\0\0\0\12\0"
    "dnd5e.api.v1alpha1.CombatStartedEvent"
    "dungeon_id"
  }},
};
PROTOBUF_NOINLINE void CombatStartedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.CombatStartedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.party_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.monsters_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.doors_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      _impl_.monster_turns_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.dungeon_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(_impl_.combat_state_ != nullptr);
      _impl_.combat_state_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(_impl_.room_ != nullptr);
      _impl_.room_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CombatStartedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CombatStartedEvent& this_ = static_cast<const CombatStartedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CombatStartedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CombatStartedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.CombatStartedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.combat_state_, this_._impl_.combat_state_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.room_, this_._impl_.room_->GetCachedSize(), target,
        stream);
  }

  // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_party_size());
         i < n; i++) {
      const auto& repfield = this_._internal_party().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              3, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // repeated .dnd5e.api.v1alpha1.MonsterCombatState monsters = 4 [json_name = "monsters"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_monsters_size());
         i < n; i++) {
      const auto& repfield = this_._internal_monsters().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              4, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 5 [json_name = "doors"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_doors_size());
         i < n; i++) {
      const auto& repfield = this_._internal_doors().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              5, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // string dungeon_id = 6 [json_name = "dungeonId"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (!this_._internal_dungeon_id().empty()) {
      const ::std::string& _s = this_._internal_dungeon_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.CombatStartedEvent.dungeon_id");
      target = stream->WriteStringMaybeAliased(6, _s, target);
    }
  }

  // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 7 [json_name = "monsterTurns"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_monster_turns_size());
         i < n; i++) {
      const auto& repfield = this_._internal_monster_turns().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              7, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.CombatStartedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CombatStartedEvent::ByteSizeLong(const MessageLite& base) {
  const CombatStartedEvent& this_ = static_cast<const CombatStartedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CombatStartedEvent::ByteSizeLong() const {
  const CombatStartedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.CombatStartedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_party_size();
      for (const auto& msg : this_._internal_party()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .dnd5e.api.v1alpha1.MonsterCombatState monsters = 4 [json_name = "monsters"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 1UL * this_._internal_monsters_size();
      for (const auto& msg : this_._internal_monsters()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 5 [json_name = "doors"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size += 1UL * this_._internal_doors_size();
      for (const auto& msg : this_._internal_doors()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 7 [json_name = "monsterTurns"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      total_size += 1UL * this_._internal_monster_turns_size();
      for (const auto& msg : this_._internal_monster_turns()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string dungeon_id = 6 [json_name = "dungeonId"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (!this_._internal_dungeon_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_dungeon_id());
      }
    }
    // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.combat_state_);
    }
    // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.room_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CombatStartedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CombatStartedEvent*>(&to_msg);
  auto& from = static_cast<const CombatStartedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.CombatStartedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_party()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_party());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_monsters()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_monsters());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_doors()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_doors());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      _this->_internal_mutable_monster_turns()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_monster_turns());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (!from._internal_dungeon_id().empty()) {
        _this->_internal_set_dungeon_id(from._internal_dungeon_id());
      } else {
        if (_this->_impl_.dungeon_id_.IsDefault()) {
          _this->_internal_set_dungeon_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(from._impl_.combat_state_ != nullptr);
      if (_this->_impl_.combat_state_ == nullptr) {
        _this->_impl_.combat_state_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_);
      } else {
        _this->_impl_.combat_state_->MergeFrom(*from._impl_.combat_state_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(from._impl_.room_ != nullptr);
      if (_this->_impl_.room_ == nullptr) {
        _this->_impl_.room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_);
      } else {
        _this->_impl_.room_->MergeFrom(*from._impl_.room_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CombatStartedEvent::CopyFrom(const CombatStartedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.CombatStartedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CombatStartedEvent::InternalSwap(CombatStartedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.party_.InternalSwap(&other->_impl_.party_);
  _impl_.monsters_.InternalSwap(&other->_impl_.monsters_);
  _impl_.doors_.InternalSwap(&other->_impl_.doors_);
  _impl_.monster_turns_.InternalSwap(&other->_impl_.monster_turns_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dungeon_id_, &other->_impl_.dungeon_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.room_)
      + sizeof(CombatStartedEvent::_impl_.room_)
      - PROTOBUF_FIELD_OFFSET(CombatStartedEvent, _impl_.combat_state_)>(
          reinterpret_cast<char*>(&_impl_.combat_state_),
          reinterpret_cast<char*>(&other->_impl_.combat_state_));
}

::google::protobuf::Metadata CombatStartedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MovementCompletedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MovementCompletedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_._has_bits_);
};

void MovementCompletedEvent::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
void MovementCompletedEvent::clear_final_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.final_position_ != nullptr) _impl_.final_position_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
MovementCompletedEvent::MovementCompletedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MovementCompletedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.MovementCompletedEvent)
}
PROTOBUF_NDEBUG_INLINE MovementCompletedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::MovementCompletedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        path_{visibility, arena, from.path_},
        entity_id_(arena, from.entity_id_),
        stop_reason_(arena, from.stop_reason_) {}

MovementCompletedEvent::MovementCompletedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MovementCompletedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MovementCompletedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MovementCompletedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.final_position_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.final_position_)
                : nullptr;
  _impl_.updated_room_ = (CheckHasBit(cached_has_bits, 0x00000010U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_room_)
                : nullptr;
  _impl_.movement_remaining_ = from._impl_.movement_remaining_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.MovementCompletedEvent)
}
PROTOBUF_NDEBUG_INLINE MovementCompletedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        path_{visibility, arena},
        entity_id_(arena),
        stop_reason_(arena) {}

inline void MovementCompletedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, final_position_),
           0,
           offsetof(Impl_, movement_remaining_) -
               offsetof(Impl_, final_position_) +
               sizeof(Impl_::movement_remaining_));
}
MovementCompletedEvent::~MovementCompletedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.MovementCompletedEvent)
  SharedDtor(*this);
}
inline void MovementCompletedEvent::SharedDtor(MessageLite& self) {
  MovementCompletedEvent& this_ = static_cast<MovementCompletedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.entity_id_.Destroy();
  this_._impl_.stop_reason_.Destroy();
  delete this_._impl_.final_position_;
  delete this_._impl_.updated_room_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MovementCompletedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MovementCompletedEvent(arena);
}
constexpr auto MovementCompletedEvent::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.path_) +
          decltype(MovementCompletedEvent::_impl_.path_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(MovementCompletedEvent), alignof(MovementCompletedEvent), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&MovementCompletedEvent::PlacementNew_,
                                 sizeof(MovementCompletedEvent),
                                 alignof(MovementCompletedEvent));
  }
}
constexpr auto MovementCompletedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MovementCompletedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MovementCompletedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MovementCompletedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MovementCompletedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MovementCompletedEvent>(), &MovementCompletedEvent::ByteSizeLong,
              &MovementCompletedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_._cached_size_),
          false,
      },
      &MovementCompletedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MovementCompletedEvent_class_data_ =
        MovementCompletedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MovementCompletedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MovementCompletedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MovementCompletedEvent_class_data_.tc_table);
  return MovementCompletedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 3, 70, 2>
MovementCompletedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MovementCompletedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MovementCompletedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string entity_id = 1 [json_name = "entityId"];
    {::_pbi::TcParser::FastUS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.entity_id_)}},
    // repeated .api.v1alpha1.Position path = 2 [json_name = "path"];
    {::_pbi::TcParser::FastMtR1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.path_)}},
    // .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
    {::_pbi::TcParser::FastMtS1,
     {26, 3, 1,
      PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.final_position_)}},
    // int32 movement_remaining = 4 [json_name = "movementRemaining"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MovementCompletedEvent, _impl_.movement_remaining_), 5>(),
     {32, 5, 0,
      PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.movement_remaining_)}},
    // string stop_reason = 5 [json_name = "stopReason"];
    {::_pbi::TcParser::FastUS1,
     {42, 2, 0,
      PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.stop_reason_)}},
    // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
    {::_pbi::TcParser::FastMtS1,
     {50, 4, 2,
      PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.updated_room_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string entity_id = 1 [json_name = "entityId"];
    {PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.entity_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .api.v1alpha1.Position path = 2 [json_name = "path"];
    {PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.path_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
    {PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.final_position_), _Internal::kHasBitsOffset + 3, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 movement_remaining = 4 [json_name = "movementRemaining"];
    {PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.movement_remaining_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // string stop_reason = 5 [json_name = "stopReason"];
    {PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.stop_reason_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
    {PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.updated_room_), _Internal::kHasBitsOffset + 4, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::api::v1alpha1::Position>()},
      {::_pbi::TcParser::GetTable<::api::v1alpha1::Position>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
  }},
  {{
    "\51\11\0\0\0\13\0\0"
    "dnd5e.api.v1alpha1.MovementCompletedEvent"
    "entity_id"
    "stop_reason"
  }},
};
PROTOBUF_NOINLINE void MovementCompletedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.MovementCompletedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.path_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.entity_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.stop_reason_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.final_position_ != nullptr);
      _impl_.final_position_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(_impl_.updated_room_ != nullptr);
      _impl_.updated_room_->Clear();
    }
  }
  _impl_.movement_remaining_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MovementCompletedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MovementCompletedEvent& this_ = static_cast<const MovementCompletedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MovementCompletedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MovementCompletedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.MovementCompletedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string entity_id = 1 [json_name = "entityId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_entity_id().empty()) {
      const ::std::string& _s = this_._internal_entity_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MovementCompletedEvent.entity_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // repeated .api.v1alpha1.Position path = 2 [json_name = "path"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_path_size());
         i < n; i++) {
      const auto& repfield = this_._internal_path().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              2, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.final_position_, this_._impl_.final_position_->GetCachedSize(), target,
        stream);
  }

  // int32 movement_remaining = 4 [json_name = "movementRemaining"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (this_._internal_movement_remaining() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
              stream, this_._internal_movement_remaining(), target);
    }
  }

  // string stop_reason = 5 [json_name = "stopReason"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_stop_reason().empty()) {
      const ::std::string& _s = this_._internal_stop_reason();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.MovementCompletedEvent.stop_reason");
      target = stream->WriteStringMaybeAliased(5, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, *this_._impl_.updated_room_, this_._impl_.updated_room_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.MovementCompletedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MovementCompletedEvent::ByteSizeLong(const MessageLite& base) {
  const MovementCompletedEvent& this_ = static_cast<const MovementCompletedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MovementCompletedEvent::ByteSizeLong() const {
  const MovementCompletedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.MovementCompletedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    // repeated .api.v1alpha1.Position path = 2 [json_name = "path"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_path_size();
      for (const auto& msg : this_._internal_path()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string entity_id = 1 [json_name = "entityId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_entity_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_entity_id());
      }
    }
    // string stop_reason = 5 [json_name = "stopReason"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!this_._internal_stop_reason().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_stop_reason());
      }
    }
    // .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.final_position_);
    }
    // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.updated_room_);
    }
    // int32 movement_remaining = 4 [json_name = "movementRemaining"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (this_._internal_movement_remaining() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_movement_remaining());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MovementCompletedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<MovementCompletedEvent*>(&to_msg);
  auto& from = static_cast<const MovementCompletedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.MovementCompletedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_path()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_path());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_entity_id().empty()) {
        _this->_internal_set_entity_id(from._internal_entity_id());
      } else {
        if (_this->_impl_.entity_id_.IsDefault()) {
          _this->_internal_set_entity_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!from._internal_stop_reason().empty()) {
        _this->_internal_set_stop_reason(from._internal_stop_reason());
      } else {
        if (_this->_impl_.stop_reason_.IsDefault()) {
          _this->_internal_set_stop_reason("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.final_position_ != nullptr);
      if (_this->_impl_.final_position_ == nullptr) {
        _this->_impl_.final_position_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.final_position_);
      } else {
        _this->_impl_.final_position_->MergeFrom(*from._impl_.final_position_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(from._impl_.updated_room_ != nullptr);
      if (_this->_impl_.updated_room_ == nullptr) {
        _this->_impl_.updated_room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_room_);
      } else {
        _this->_impl_.updated_room_->MergeFrom(*from._impl_.updated_room_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (from._internal_movement_remaining() != 0) {
        _this->_impl_.movement_remaining_ = from._impl_.movement_remaining_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void MovementCompletedEvent::CopyFrom(const MovementCompletedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.MovementCompletedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MovementCompletedEvent::InternalSwap(MovementCompletedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.path_.InternalSwap(&other->_impl_.path_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.entity_id_, &other->_impl_.entity_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.stop_reason_, &other->_impl_.stop_reason_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.movement_remaining_)
      + sizeof(MovementCompletedEvent::_impl_.movement_remaining_)
      - PROTOBUF_FIELD_OFFSET(MovementCompletedEvent, _impl_.final_position_)>(
          reinterpret_cast<char*>(&_impl_.final_position_),
          reinterpret_cast<char*>(&other->_impl_.final_position_));
}

::google::protobuf::Metadata MovementCompletedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AttackResolvedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AttackResolvedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_._has_bits_);
};

void AttackResolvedEvent::clear_updated_attacker() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_attacker_ != nullptr) _impl_.updated_attacker_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
void AttackResolvedEvent::clear_updated_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_target_ != nullptr) _impl_.updated_target_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
AttackResolvedEvent::AttackResolvedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AttackResolvedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.AttackResolvedEvent)
}
PROTOBUF_NDEBUG_INLINE AttackResolvedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::AttackResolvedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        attacker_id_(arena, from.attacker_id_),
        target_id_(arena, from.target_id_) {}

AttackResolvedEvent::AttackResolvedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const AttackResolvedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AttackResolvedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AttackResolvedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.result_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.result_)
                : nullptr;
  _impl_.updated_attacker_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_attacker_)
                : nullptr;
  _impl_.updated_target_ = (CheckHasBit(cached_has_bits, 0x00000010U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_target_)
                : nullptr;
  _impl_.updated_room_ = (CheckHasBit(cached_has_bits, 0x00000020U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_room_)
                : nullptr;
  _impl_.granted_action_ = (CheckHasBit(cached_has_bits, 0x00000040U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.granted_action_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.AttackResolvedEvent)
}
PROTOBUF_NDEBUG_INLINE AttackResolvedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        attacker_id_(arena),
        target_id_(arena) {}

inline void AttackResolvedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, result_),
           0,
           offsetof(Impl_, granted_action_) -
               offsetof(Impl_, result_) +
               sizeof(Impl_::granted_action_));
}
AttackResolvedEvent::~AttackResolvedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.AttackResolvedEvent)
  SharedDtor(*this);
}
inline void AttackResolvedEvent::SharedDtor(MessageLite& self) {
  AttackResolvedEvent& this_ = static_cast<AttackResolvedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.attacker_id_.Destroy();
  this_._impl_.target_id_.Destroy();
  delete this_._impl_.result_;
  delete this_._impl_.updated_attacker_;
  delete this_._impl_.updated_target_;
  delete this_._impl_.updated_room_;
  delete this_._impl_.granted_action_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AttackResolvedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AttackResolvedEvent(arena);
}
constexpr auto AttackResolvedEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(AttackResolvedEvent),
                                            alignof(AttackResolvedEvent));
}
constexpr auto AttackResolvedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_AttackResolvedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AttackResolvedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<AttackResolvedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AttackResolvedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<AttackResolvedEvent>(), &AttackResolvedEvent::ByteSizeLong,
              &AttackResolvedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_._cached_size_),
          false,
      },
      &AttackResolvedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull AttackResolvedEvent_class_data_ =
        AttackResolvedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AttackResolvedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&AttackResolvedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(AttackResolvedEvent_class_data_.tc_table);
  return AttackResolvedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 5, 67, 2>
AttackResolvedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    AttackResolvedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::AttackResolvedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string attacker_id = 1 [json_name = "attackerId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.attacker_id_)}},
    // string target_id = 2 [json_name = "targetId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.target_id_)}},
    // .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 0,
      PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.result_)}},
    // .dnd5e.api.v1alpha1.Character updated_attacker = 4 [json_name = "updatedAttacker"];
    {::_pbi::TcParser::FastMtS1,
     {34, 3, 1,
      PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.updated_attacker_)}},
    // .dnd5e.api.v1alpha1.Character updated_target = 5 [json_name = "updatedTarget"];
    {::_pbi::TcParser::FastMtS1,
     {42, 4, 2,
      PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.updated_target_)}},
    // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
    {::_pbi::TcParser::FastMtS1,
     {50, 5, 3,
      PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.updated_room_)}},
    // .dnd5e.api.v1alpha1.GrantedAction granted_action = 7 [json_name = "grantedAction"];
    {::_pbi::TcParser::FastMtS1,
     {58, 6, 4,
      PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.granted_action_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string attacker_id = 1 [json_name = "attackerId"];
    {PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.attacker_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string target_id = 2 [json_name = "targetId"];
    {PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.target_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
    {PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.result_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.Character updated_attacker = 4 [json_name = "updatedAttacker"];
    {PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.updated_attacker_), _Internal::kHasBitsOffset + 3, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.Character updated_target = 5 [json_name = "updatedTarget"];
    {PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.updated_target_), _Internal::kHasBitsOffset + 4, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
    {PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.updated_room_), _Internal::kHasBitsOffset + 5, 3, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.GrantedAction granted_action = 7 [json_name = "grantedAction"];
    {PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.granted_action_), _Internal::kHasBitsOffset + 6, 4, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::AttackResult>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Character>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Character>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::GrantedAction>()},
  }},
  {{
    "\46\13\11\0\0\0\0\0"
    "dnd5e.api.v1alpha1.AttackResolvedEvent"
    "attacker_id"
    "target_id"
  }},
};
PROTOBUF_NOINLINE void AttackResolvedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.AttackResolvedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.attacker_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.target_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.result_ != nullptr);
      _impl_.result_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.updated_attacker_ != nullptr);
      _impl_.updated_attacker_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(_impl_.updated_target_ != nullptr);
      _impl_.updated_target_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(_impl_.updated_room_ != nullptr);
      _impl_.updated_room_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(_impl_.granted_action_ != nullptr);
      _impl_.granted_action_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AttackResolvedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AttackResolvedEvent& this_ = static_cast<const AttackResolvedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AttackResolvedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AttackResolvedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.AttackResolvedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string attacker_id = 1 [json_name = "attackerId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_attacker_id().empty()) {
      const ::std::string& _s = this_._internal_attacker_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.AttackResolvedEvent.attacker_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string target_id = 2 [json_name = "targetId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_target_id().empty()) {
      const ::std::string& _s = this_._internal_target_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.AttackResolvedEvent.target_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.result_, this_._impl_.result_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.Character updated_attacker = 4 [json_name = "updatedAttacker"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.updated_attacker_, this_._impl_.updated_attacker_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.Character updated_target = 5 [json_name = "updatedTarget"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.updated_target_, this_._impl_.updated_target_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, *this_._impl_.updated_room_, this_._impl_.updated_room_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.GrantedAction granted_action = 7 [json_name = "grantedAction"];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        7, *this_._impl_.granted_action_, this_._impl_.granted_action_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.AttackResolvedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AttackResolvedEvent::ByteSizeLong(const MessageLite& base) {
  const AttackResolvedEvent& this_ = static_cast<const AttackResolvedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AttackResolvedEvent::ByteSizeLong() const {
  const AttackResolvedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.AttackResolvedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    // string attacker_id = 1 [json_name = "attackerId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_attacker_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_attacker_id());
      }
    }
    // string target_id = 2 [json_name = "targetId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_target_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_target_id());
      }
    }
    // .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.result_);
    }
    // .dnd5e.api.v1alpha1.Character updated_attacker = 4 [json_name = "updatedAttacker"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.updated_attacker_);
    }
    // .dnd5e.api.v1alpha1.Character updated_target = 5 [json_name = "updatedTarget"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.updated_target_);
    }
    // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.updated_room_);
    }
    // .dnd5e.api.v1alpha1.GrantedAction granted_action = 7 [json_name = "grantedAction"];
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.granted_action_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void AttackResolvedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<AttackResolvedEvent*>(&to_msg);
  auto& from = static_cast<const AttackResolvedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.AttackResolvedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_attacker_id().empty()) {
        _this->_internal_set_attacker_id(from._internal_attacker_id());
      } else {
        if (_this->_impl_.attacker_id_.IsDefault()) {
          _this->_internal_set_attacker_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_target_id().empty()) {
        _this->_internal_set_target_id(from._internal_target_id());
      } else {
        if (_this->_impl_.target_id_.IsDefault()) {
          _this->_internal_set_target_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.result_ != nullptr);
      if (_this->_impl_.result_ == nullptr) {
        _this->_impl_.result_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.result_);
      } else {
        _this->_impl_.result_->MergeFrom(*from._impl_.result_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.updated_attacker_ != nullptr);
      if (_this->_impl_.updated_attacker_ == nullptr) {
        _this->_impl_.updated_attacker_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_attacker_);
      } else {
        _this->_impl_.updated_attacker_->MergeFrom(*from._impl_.updated_attacker_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(from._impl_.updated_target_ != nullptr);
      if (_this->_impl_.updated_target_ == nullptr) {
        _this->_impl_.updated_target_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_target_);
      } else {
        _this->_impl_.updated_target_->MergeFrom(*from._impl_.updated_target_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(from._impl_.updated_room_ != nullptr);
      if (_this->_impl_.updated_room_ == nullptr) {
        _this->_impl_.updated_room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_room_);
      } else {
        _this->_impl_.updated_room_->MergeFrom(*from._impl_.updated_room_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(from._impl_.granted_action_ != nullptr);
      if (_this->_impl_.granted_action_ == nullptr) {
        _this->_impl_.granted_action_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.granted_action_);
      } else {
        _this->_impl_.granted_action_->MergeFrom(*from._impl_.granted_action_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void AttackResolvedEvent::CopyFrom(const AttackResolvedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.AttackResolvedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AttackResolvedEvent::InternalSwap(AttackResolvedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.attacker_id_, &other->_impl_.attacker_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.target_id_, &other->_impl_.target_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.granted_action_)
      + sizeof(AttackResolvedEvent::_impl_.granted_action_)
      - PROTOBUF_FIELD_OFFSET(AttackResolvedEvent, _impl_.result_)>(
          reinterpret_cast<char*>(&_impl_.result_),
          reinterpret_cast<char*>(&other->_impl_.result_));
}

::google::protobuf::Metadata AttackResolvedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class FeatureActivatedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<FeatureActivatedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(FeatureActivatedEvent, _impl_._has_bits_);
};

void FeatureActivatedEvent::clear_updated_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_character_ != nullptr) _impl_.updated_character_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
FeatureActivatedEvent::FeatureActivatedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FeatureActivatedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.FeatureActivatedEvent)
}
PROTOBUF_NDEBUG_INLINE FeatureActivatedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::FeatureActivatedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        character_id_(arena, from.character_id_),
        feature_id_(arena, from.feature_id_),
        message_(arena, from.message_) {}

FeatureActivatedEvent::FeatureActivatedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const FeatureActivatedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FeatureActivatedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  FeatureActivatedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.updated_character_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_character_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.FeatureActivatedEvent)
}
PROTOBUF_NDEBUG_INLINE FeatureActivatedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        character_id_(arena),
        feature_id_(arena),
        message_(arena) {}

inline void FeatureActivatedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.updated_character_ = {};
}
FeatureActivatedEvent::~FeatureActivatedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.FeatureActivatedEvent)
  SharedDtor(*this);
}
inline void FeatureActivatedEvent::SharedDtor(MessageLite& self) {
  FeatureActivatedEvent& this_ = static_cast<FeatureActivatedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.character_id_.Destroy();
  this_._impl_.feature_id_.Destroy();
  this_._impl_.message_.Destroy();
  delete this_._impl_.updated_character_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL FeatureActivatedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) FeatureActivatedEvent(arena);
}
constexpr auto FeatureActivatedEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(FeatureActivatedEvent),
                                            alignof(FeatureActivatedEvent));
}
constexpr auto FeatureActivatedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_FeatureActivatedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &FeatureActivatedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<FeatureActivatedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &FeatureActivatedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<FeatureActivatedEvent>(), &FeatureActivatedEvent::ByteSizeLong,
              &FeatureActivatedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(FeatureActivatedEvent, _impl_._cached_size_),
          false,
      },
      &FeatureActivatedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull FeatureActivatedEvent_class_data_ =
        FeatureActivatedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
FeatureActivatedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&FeatureActivatedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(FeatureActivatedEvent_class_data_.tc_table);
  return FeatureActivatedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 78, 2>
FeatureActivatedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FeatureActivatedEvent, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    FeatureActivatedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::FeatureActivatedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.Character updated_character = 4 [json_name = "updatedCharacter"];
    {::_pbi::TcParser::FastMtS1,
     {34, 3, 0,
      PROTOBUF_FIELD_OFFSET(FeatureActivatedEvent, _impl_.updated_character_)}},
    // string character_id = 1 [json_name = "characterId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(FeatureActivatedEvent, _impl_.character_id_)}},
    // string feature_id = 2 [json_name = "featureId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(FeatureActivatedEvent, _impl_.feature_id_)}},
    // string message = 3 [json_name = "message"];
    {::_pbi::TcParser::FastUS1,
     {26, 2, 0,
      PROTOBUF_FIELD_OFFSET(FeatureActivatedEvent, _impl_.message_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string character_id = 1 [json_name = "characterId"];
    {PROTOBUF_FIELD_OFFSET(FeatureActivatedEvent, _impl_.character_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string feature_id = 2 [json_name = "featureId"];
    {PROTOBUF_FIELD_OFFSET(FeatureActivatedEvent, _impl_.feature_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string message = 3 [json_name = "message"];
    {PROTOBUF_FIELD_OFFSET(FeatureActivatedEvent, _impl_.message_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.Character updated_character = 4 [json_name = "updatedCharacter"];
    {PROTOBUF_FIELD_OFFSET(FeatureActivatedEvent, _impl_.updated_character_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Character>()},
  }},
  {{
    "\50\14\12\7\0\0\0\0"
    "dnd5e.api.v1alpha1.FeatureActivatedEvent"
    "character_id"
    "feature_id"
    "message"
  }},
};
PROTOBUF_NOINLINE void FeatureActivatedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.FeatureActivatedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.character_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.feature_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.updated_character_ != nullptr);
      _impl_.updated_character_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL FeatureActivatedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const FeatureActivatedEvent& this_ = static_cast<const FeatureActivatedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL FeatureActivatedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const FeatureActivatedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.FeatureActivatedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string character_id = 1 [json_name = "characterId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_character_id().empty()) {
      const ::std::string& _s = this_._internal_character_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.FeatureActivatedEvent.character_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string feature_id = 2 [json_name = "featureId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_feature_id().empty()) {
      const ::std::string& _s = this_._internal_feature_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.FeatureActivatedEvent.feature_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // string message = 3 [json_name = "message"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_message().empty()) {
      const ::std::string& _s = this_._internal_message();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.FeatureActivatedEvent.message");
      target = stream->WriteStringMaybeAliased(3, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.Character updated_character = 4 [json_name = "updatedCharacter"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.updated_character_, this_._impl_.updated_character_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.FeatureActivatedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t FeatureActivatedEvent::ByteSizeLong(const MessageLite& base) {
  const FeatureActivatedEvent& this_ = static_cast<const FeatureActivatedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t FeatureActivatedEvent::ByteSizeLong() const {
  const FeatureActivatedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.FeatureActivatedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // string character_id = 1 [json_name = "characterId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_character_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_character_id());
      }
    }
    // string feature_id = 2 [json_name = "featureId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_feature_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_feature_id());
      }
    }
    // string message = 3 [json_name = "message"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!this_._internal_message().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_message());
      }
    }
    // .dnd5e.api.v1alpha1.Character updated_character = 4 [json_name = "updatedCharacter"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.updated_character_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void FeatureActivatedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<FeatureActivatedEvent*>(&to_msg);
  auto& from = static_cast<const FeatureActivatedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.FeatureActivatedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_character_id().empty()) {
        _this->_internal_set_character_id(from._internal_character_id());
      } else {
        if (_this->_impl_.character_id_.IsDefault()) {
          _this->_internal_set_character_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_feature_id().empty()) {
        _this->_internal_set_feature_id(from._internal_feature_id());
      } else {
        if (_this->_impl_.feature_id_.IsDefault()) {
          _this->_internal_set_feature_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!from._internal_message().empty()) {
        _this->_internal_set_message(from._internal_message());
      } else {
        if (_this->_impl_.message_.IsDefault()) {
          _this->_internal_set_message("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.updated_character_ != nullptr);
      if (_this->_impl_.updated_character_ == nullptr) {
        _this->_impl_.updated_character_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_character_);
      } else {
        _this->_impl_.updated_character_->MergeFrom(*from._impl_.updated_character_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void FeatureActivatedEvent::CopyFrom(const FeatureActivatedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.FeatureActivatedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void FeatureActivatedEvent::InternalSwap(FeatureActivatedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.character_id_, &other->_impl_.character_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.feature_id_, &other->_impl_.feature_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  swap(_impl_.updated_character_, other->_impl_.updated_character_);
}

::google::protobuf::Metadata FeatureActivatedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class TurnEndedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<TurnEndedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TurnEndedEvent, _impl_._has_bits_);
};

TurnEndedEvent::TurnEndedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TurnEndedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.TurnEndedEvent)
}
PROTOBUF_NDEBUG_INLINE TurnEndedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::TurnEndedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

TurnEndedEvent::TurnEndedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const TurnEndedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TurnEndedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TurnEndedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.turn_change_ = (CheckHasBit(cached_has_bits, 0x00000001U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.turn_change_)
                : nullptr;
  _impl_.combat_state_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_)
                : nullptr;
  _impl_.updated_room_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_room_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.TurnEndedEvent)
}
PROTOBUF_NDEBUG_INLINE TurnEndedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void TurnEndedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, turn_change_),
           0,
           offsetof(Impl_, updated_room_) -
               offsetof(Impl_, turn_change_) +
               sizeof(Impl_::updated_room_));
}
TurnEndedEvent::~TurnEndedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.TurnEndedEvent)
  SharedDtor(*this);
}
inline void TurnEndedEvent::SharedDtor(MessageLite& self) {
  TurnEndedEvent& this_ = static_cast<TurnEndedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.turn_change_;
  delete this_._impl_.combat_state_;
  delete this_._impl_.updated_room_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL TurnEndedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) TurnEndedEvent(arena);
}
constexpr auto TurnEndedEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(TurnEndedEvent),
                                            alignof(TurnEndedEvent));
}
constexpr auto TurnEndedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_TurnEndedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &TurnEndedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<TurnEndedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &TurnEndedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<TurnEndedEvent>(), &TurnEndedEvent::ByteSizeLong,
              &TurnEndedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(TurnEndedEvent, _impl_._cached_size_),
          false,
      },
      &TurnEndedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull TurnEndedEvent_class_data_ =
        TurnEndedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
TurnEndedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&TurnEndedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(TurnEndedEvent_class_data_.tc_table);
  return TurnEndedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
TurnEndedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TurnEndedEvent, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    TurnEndedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::TurnEndedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 1 [json_name = "turnChange"];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(TurnEndedEvent, _impl_.turn_change_)}},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1,
      PROTOBUF_FIELD_OFFSET(TurnEndedEvent, _impl_.combat_state_)}},
    // .dnd5e.api.v1alpha1.Room updated_room = 3 [json_name = "updatedRoom"];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2,
      PROTOBUF_FIELD_OFFSET(TurnEndedEvent, _impl_.updated_room_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 1 [json_name = "turnChange"];
    {PROTOBUF_FIELD_OFFSET(TurnEndedEvent, _impl_.turn_change_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
    {PROTOBUF_FIELD_OFFSET(TurnEndedEvent, _impl_.combat_state_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.Room updated_room = 3 [json_name = "updatedRoom"];
    {PROTOBUF_FIELD_OFFSET(TurnEndedEvent, _impl_.updated_room_), _Internal::kHasBitsOffset + 2, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::TurnChangeEvent>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void TurnEndedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.TurnEndedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(_impl_.turn_change_ != nullptr);
      _impl_.turn_change_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.combat_state_ != nullptr);
      _impl_.combat_state_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.updated_room_ != nullptr);
      _impl_.updated_room_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL TurnEndedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const TurnEndedEvent& this_ = static_cast<const TurnEndedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL TurnEndedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const TurnEndedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.TurnEndedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 1 [json_name = "turnChange"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.turn_change_, this_._impl_.turn_change_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.combat_state_, this_._impl_.combat_state_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.Room updated_room = 3 [json_name = "updatedRoom"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.updated_room_, this_._impl_.updated_room_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.TurnEndedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t TurnEndedEvent::ByteSizeLong(const MessageLite& base) {
  const TurnEndedEvent& this_ = static_cast<const TurnEndedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t TurnEndedEvent::ByteSizeLong() const {
  const TurnEndedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.TurnEndedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 1 [json_name = "turnChange"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.turn_change_);
    }
    // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.combat_state_);
    }
    // .dnd5e.api.v1alpha1.Room updated_room = 3 [json_name = "updatedRoom"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.updated_room_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void TurnEndedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<TurnEndedEvent*>(&to_msg);
  auto& from = static_cast<const TurnEndedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.TurnEndedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(from._impl_.turn_change_ != nullptr);
      if (_this->_impl_.turn_change_ == nullptr) {
        _this->_impl_.turn_change_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.turn_change_);
      } else {
        _this->_impl_.turn_change_->MergeFrom(*from._impl_.turn_change_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.combat_state_ != nullptr);
      if (_this->_impl_.combat_state_ == nullptr) {
        _this->_impl_.combat_state_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_);
      } else {
        _this->_impl_.combat_state_->MergeFrom(*from._impl_.combat_state_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.updated_room_ != nullptr);
      if (_this->_impl_.updated_room_ == nullptr) {
        _this->_impl_.updated_room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_room_);
      } else {
        _this->_impl_.updated_room_->MergeFrom(*from._impl_.updated_room_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void TurnEndedEvent::CopyFrom(const TurnEndedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.TurnEndedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TurnEndedEvent::InternalSwap(TurnEndedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TurnEndedEvent, _impl_.updated_room_)
      + sizeof(TurnEndedEvent::_impl_.updated_room_)
      - PROTOBUF_FIELD_OFFSET(TurnEndedEvent, _impl_.turn_change_)>(
          reinterpret_cast<char*>(&_impl_.turn_change_),
          reinterpret_cast<char*>(&other->_impl_.turn_change_));
}

::google::protobuf::Metadata TurnEndedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MonsterTurnCompletedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MonsterTurnCompletedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MonsterTurnCompletedEvent, _impl_._has_bits_);
};

void MonsterTurnCompletedEvent::clear_updated_characters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_characters_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
MonsterTurnCompletedEvent::MonsterTurnCompletedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MonsterTurnCompletedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent)
}
PROTOBUF_NDEBUG_INLINE MonsterTurnCompletedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        updated_characters_{visibility, arena, from.updated_characters_} {}

MonsterTurnCompletedEvent::MonsterTurnCompletedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MonsterTurnCompletedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MonsterTurnCompletedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MonsterTurnCompletedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.monster_turn_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.monster_turn_)
                : nullptr;
  _impl_.updated_room_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_room_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent)
}
PROTOBUF_NDEBUG_INLINE MonsterTurnCompletedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        updated_characters_{visibility, arena} {}

inline void MonsterTurnCompletedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, monster_turn_),
           0,
           offsetof(Impl_, updated_room_) -
               offsetof(Impl_, monster_turn_) +
               sizeof(Impl_::updated_room_));
}
MonsterTurnCompletedEvent::~MonsterTurnCompletedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent)
  SharedDtor(*this);
}
inline void MonsterTurnCompletedEvent::SharedDtor(MessageLite& self) {
  MonsterTurnCompletedEvent& this_ = static_cast<MonsterTurnCompletedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.monster_turn_;
  delete this_._impl_.updated_room_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MonsterTurnCompletedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MonsterTurnCompletedEvent(arena);
}
constexpr auto MonsterTurnCompletedEvent::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(MonsterTurnCompletedEvent, _impl_.updated_characters_) +
          decltype(MonsterTurnCompletedEvent::_impl_.updated_characters_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(MonsterTurnCompletedEvent), alignof(MonsterTurnCompletedEvent), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&MonsterTurnCompletedEvent::PlacementNew_,
                                 sizeof(MonsterTurnCompletedEvent),
                                 alignof(MonsterTurnCompletedEvent));
  }
}
constexpr auto MonsterTurnCompletedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MonsterTurnCompletedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MonsterTurnCompletedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MonsterTurnCompletedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MonsterTurnCompletedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MonsterTurnCompletedEvent>(), &MonsterTurnCompletedEvent::ByteSizeLong,
              &MonsterTurnCompletedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MonsterTurnCompletedEvent, _impl_._cached_size_),
          false,
      },
      &MonsterTurnCompletedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MonsterTurnCompletedEvent_class_data_ =
        MonsterTurnCompletedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MonsterTurnCompletedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MonsterTurnCompletedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MonsterTurnCompletedEvent_class_data_.tc_table);
  return MonsterTurnCompletedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
MonsterTurnCompletedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MonsterTurnCompletedEvent, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MonsterTurnCompletedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .dnd5e.api.v1alpha1.MonsterTurnResult monster_turn = 1 [json_name = "monsterTurn"];
    {::_pbi::TcParser::FastMtS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(MonsterTurnCompletedEvent, _impl_.monster_turn_)}},
    // repeated .dnd5e.api.v1alpha1.Character updated_characters = 2 [json_name = "updatedCharacters"];
    {::_pbi::TcParser::FastMtR1,
     {18, 0, 1,
      PROTOBUF_FIELD_OFFSET(MonsterTurnCompletedEvent, _impl_.updated_characters_)}},
    // .dnd5e.api.v1alpha1.Room updated_room = 3 [json_name = "updatedRoom"];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2,
      PROTOBUF_FIELD_OFFSET(MonsterTurnCompletedEvent, _impl_.updated_room_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.MonsterTurnResult monster_turn = 1 [json_name = "monsterTurn"];
    {PROTOBUF_FIELD_OFFSET(MonsterTurnCompletedEvent, _impl_.monster_turn_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.Character updated_characters = 2 [json_name = "updatedCharacters"];
    {PROTOBUF_FIELD_OFFSET(MonsterTurnCompletedEvent, _impl_.updated_characters_), _Internal::kHasBitsOffset + 0, 1, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.Room updated_room = 3 [json_name = "updatedRoom"];
    {PROTOBUF_FIELD_OFFSET(MonsterTurnCompletedEvent, _impl_.updated_room_), _Internal::kHasBitsOffset + 2, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::MonsterTurnResult>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Character>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void MonsterTurnCompletedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.updated_characters_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.monster_turn_ != nullptr);
      _impl_.monster_turn_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.updated_room_ != nullptr);
      _impl_.updated_room_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MonsterTurnCompletedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MonsterTurnCompletedEvent& this_ = static_cast<const MonsterTurnCompletedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MonsterTurnCompletedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MonsterTurnCompletedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .dnd5e.api.v1alpha1.MonsterTurnResult monster_turn = 1 [json_name = "monsterTurn"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.monster_turn_, this_._impl_.monster_turn_->GetCachedSize(), target,
        stream);
  }

  // repeated .dnd5e.api.v1alpha1.Character updated_characters = 2 [json_name = "updatedCharacters"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_updated_characters_size());
         i < n; i++) {
      const auto& repfield = this_._internal_updated_characters().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              2, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // .dnd5e.api.v1alpha1.Room updated_room = 3 [json_name = "updatedRoom"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.updated_room_, this_._impl_.updated_room_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MonsterTurnCompletedEvent::ByteSizeLong(const MessageLite& base) {
  const MonsterTurnCompletedEvent& this_ = static_cast<const MonsterTurnCompletedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MonsterTurnCompletedEvent::ByteSizeLong() const {
  const MonsterTurnCompletedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated .dnd5e.api.v1alpha1.Character updated_characters = 2 [json_name = "updatedCharacters"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_updated_characters_size();
      for (const auto& msg : this_._internal_updated_characters()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // .dnd5e.api.v1alpha1.MonsterTurnResult monster_turn = 1 [json_name = "monsterTurn"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.monster_turn_);
    }
    // .dnd5e.api.v1alpha1.Room updated_room = 3 [json_name = "updatedRoom"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.updated_room_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MonsterTurnCompletedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<MonsterTurnCompletedEvent*>(&to_msg);
  auto& from = static_cast<const MonsterTurnCompletedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_updated_characters()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_updated_characters());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.monster_turn_ != nullptr);
      if (_this->_impl_.monster_turn_ == nullptr) {
        _this->_impl_.monster_turn_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.monster_turn_);
      } else {
        _this->_impl_.monster_turn_->MergeFrom(*from._impl_.monster_turn_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.updated_room_ != nullptr);
      if (_this->_impl_.updated_room_ == nullptr) {
        _this->_impl_.updated_room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.updated_room_);
      } else {
        _this->_impl_.updated_room_->MergeFrom(*from._impl_.updated_room_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void MonsterTurnCompletedEvent::CopyFrom(const MonsterTurnCompletedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MonsterTurnCompletedEvent::InternalSwap(MonsterTurnCompletedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.updated_characters_.InternalSwap(&other->_impl_.updated_characters_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MonsterTurnCompletedEvent, _impl_.updated_room_)
      + sizeof(MonsterTurnCompletedEvent::_impl_.updated_room_)
      - PROTOBUF_FIELD_OFFSET(MonsterTurnCompletedEvent, _impl_.monster_turn_)>(
          reinterpret_cast<char*>(&_impl_.monster_turn_),
          reinterpret_cast<char*>(&other->_impl_.monster_turn_));
}

::google::protobuf::Metadata MonsterTurnCompletedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CombatEndedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CombatEndedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CombatEndedEvent, _impl_._has_bits_);
};

CombatEndedEvent::CombatEndedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CombatEndedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.CombatEndedEvent)
}
PROTOBUF_NDEBUG_INLINE CombatEndedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::CombatEndedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

CombatEndedEvent::CombatEndedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CombatEndedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CombatEndedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CombatEndedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.result_ = (CheckHasBit(cached_has_bits, 0x00000001U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.result_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.CombatEndedEvent)
}
PROTOBUF_NDEBUG_INLINE CombatEndedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void CombatEndedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.result_ = {};
}
CombatEndedEvent::~CombatEndedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.CombatEndedEvent)
  SharedDtor(*this);
}
inline void CombatEndedEvent::SharedDtor(MessageLite& self) {
  CombatEndedEvent& this_ = static_cast<CombatEndedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.result_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CombatEndedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CombatEndedEvent(arena);
}
constexpr auto CombatEndedEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(CombatEndedEvent),
                                            alignof(CombatEndedEvent));
}
constexpr auto CombatEndedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CombatEndedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CombatEndedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CombatEndedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CombatEndedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CombatEndedEvent>(), &CombatEndedEvent::ByteSizeLong,
              &CombatEndedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CombatEndedEvent, _impl_._cached_size_),
          false,
      },
      &CombatEndedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CombatEndedEvent_class_data_ =
        CombatEndedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CombatEndedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CombatEndedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CombatEndedEvent_class_data_.tc_table);
  return CombatEndedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2>
CombatEndedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CombatEndedEvent, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    CombatEndedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatEndedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.EncounterResult result = 1 [json_name = "result"];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(CombatEndedEvent, _impl_.result_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.EncounterResult result = 1 [json_name = "result"];
    {PROTOBUF_FIELD_OFFSET(CombatEndedEvent, _impl_.result_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::EncounterResult>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void CombatEndedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.CombatEndedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    ABSL_DCHECK(_impl_.result_ != nullptr);
    _impl_.result_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CombatEndedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CombatEndedEvent& this_ = static_cast<const CombatEndedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CombatEndedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CombatEndedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.CombatEndedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .dnd5e.api.v1alpha1.EncounterResult result = 1 [json_name = "result"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.result_, this_._impl_.result_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.CombatEndedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CombatEndedEvent::ByteSizeLong(const MessageLite& base) {
  const CombatEndedEvent& this_ = static_cast<const CombatEndedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CombatEndedEvent::ByteSizeLong() const {
  const CombatEndedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.CombatEndedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // .dnd5e.api.v1alpha1.EncounterResult result = 1 [json_name = "result"];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.result_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CombatEndedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CombatEndedEvent*>(&to_msg);
  auto& from = static_cast<const CombatEndedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.CombatEndedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    ABSL_DCHECK(from._impl_.result_ != nullptr);
    if (_this->_impl_.result_ == nullptr) {
      _this->_impl_.result_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.result_);
    } else {
      _this->_impl_.result_->MergeFrom(*from._impl_.result_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CombatEndedEvent::CopyFrom(const CombatEndedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.CombatEndedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CombatEndedEvent::InternalSwap(CombatEndedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::google::protobuf::Metadata CombatEndedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PlayerDisconnectedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PlayerDisconnectedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PlayerDisconnectedEvent, _impl_._has_bits_);
};

PlayerDisconnectedEvent::PlayerDisconnectedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PlayerDisconnectedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.PlayerDisconnectedEvent)
}
PROTOBUF_NDEBUG_INLINE PlayerDisconnectedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        player_id_(arena, from.player_id_),
        character_id_(arena, from.character_id_) {}

PlayerDisconnectedEvent::PlayerDisconnectedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PlayerDisconnectedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PlayerDisconnectedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PlayerDisconnectedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.PlayerDisconnectedEvent)
}
PROTOBUF_NDEBUG_INLINE PlayerDisconnectedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        player_id_(arena),
        character_id_(arena) {}

inline void PlayerDisconnectedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
PlayerDisconnectedEvent::~PlayerDisconnectedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.PlayerDisconnectedEvent)
  SharedDtor(*this);
}
inline void PlayerDisconnectedEvent::SharedDtor(MessageLite& self) {
  PlayerDisconnectedEvent& this_ = static_cast<PlayerDisconnectedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.player_id_.Destroy();
  this_._impl_.character_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PlayerDisconnectedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PlayerDisconnectedEvent(arena);
}
constexpr auto PlayerDisconnectedEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PlayerDisconnectedEvent),
                                            alignof(PlayerDisconnectedEvent));
}
constexpr auto PlayerDisconnectedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PlayerDisconnectedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PlayerDisconnectedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PlayerDisconnectedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PlayerDisconnectedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PlayerDisconnectedEvent>(), &PlayerDisconnectedEvent::ByteSizeLong,
              &PlayerDisconnectedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PlayerDisconnectedEvent, _impl_._cached_size_),
          false,
      },
      &PlayerDisconnectedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PlayerDisconnectedEvent_class_data_ =
        PlayerDisconnectedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PlayerDisconnectedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PlayerDisconnectedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PlayerDisconnectedEvent_class_data_.tc_table);
  return PlayerDisconnectedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 72, 2>
PlayerDisconnectedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PlayerDisconnectedEvent, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    PlayerDisconnectedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PlayerDisconnectedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string character_id = 2 [json_name = "characterId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(PlayerDisconnectedEvent, _impl_.character_id_)}},
    // string player_id = 1 [json_name = "playerId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(PlayerDisconnectedEvent, _impl_.player_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1 [json_name = "playerId"];
    {PROTOBUF_FIELD_OFFSET(PlayerDisconnectedEvent, _impl_.player_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string character_id = 2 [json_name = "characterId"];
    {PROTOBUF_FIELD_OFFSET(PlayerDisconnectedEvent, _impl_.character_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\52\11\14\0\0\0\0\0"
    "dnd5e.api.v1alpha1.PlayerDisconnectedEvent"
    "player_id"
    "character_id"
  }},
};
PROTOBUF_NOINLINE void PlayerDisconnectedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.PlayerDisconnectedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.player_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.character_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PlayerDisconnectedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PlayerDisconnectedEvent& this_ = static_cast<const PlayerDisconnectedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PlayerDisconnectedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PlayerDisconnectedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.PlayerDisconnectedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string player_id = 1 [json_name = "playerId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_player_id().empty()) {
      const ::std::string& _s = this_._internal_player_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.PlayerDisconnectedEvent.player_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string character_id = 2 [json_name = "characterId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_character_id().empty()) {
      const ::std::string& _s = this_._internal_character_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.PlayerDisconnectedEvent.character_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.PlayerDisconnectedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PlayerDisconnectedEvent::ByteSizeLong(const MessageLite& base) {
  const PlayerDisconnectedEvent& this_ = static_cast<const PlayerDisconnectedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PlayerDisconnectedEvent::ByteSizeLong() const {
  const PlayerDisconnectedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.PlayerDisconnectedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // string player_id = 1 [json_name = "playerId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_player_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_player_id());
      }
    }
    // string character_id = 2 [json_name = "characterId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_character_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_character_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PlayerDisconnectedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PlayerDisconnectedEvent*>(&to_msg);
  auto& from = static_cast<const PlayerDisconnectedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.PlayerDisconnectedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_player_id().empty()) {
        _this->_internal_set_player_id(from._internal_player_id());
      } else {
        if (_this->_impl_.player_id_.IsDefault()) {
          _this->_internal_set_player_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_character_id().empty()) {
        _this->_internal_set_character_id(from._internal_character_id());
      } else {
        if (_this->_impl_.character_id_.IsDefault()) {
          _this->_internal_set_character_id("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void PlayerDisconnectedEvent::CopyFrom(const PlayerDisconnectedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.PlayerDisconnectedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PlayerDisconnectedEvent::InternalSwap(PlayerDisconnectedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.character_id_, &other->_impl_.character_id_, arena);
}

::google::protobuf::Metadata PlayerDisconnectedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PlayerReconnectedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PlayerReconnectedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PlayerReconnectedEvent, _impl_._has_bits_);
};

PlayerReconnectedEvent::PlayerReconnectedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PlayerReconnectedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.PlayerReconnectedEvent)
}
PROTOBUF_NDEBUG_INLINE PlayerReconnectedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::PlayerReconnectedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        player_id_(arena, from.player_id_) {}

PlayerReconnectedEvent::PlayerReconnectedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PlayerReconnectedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PlayerReconnectedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PlayerReconnectedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.member_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.member_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.PlayerReconnectedEvent)
}
PROTOBUF_NDEBUG_INLINE PlayerReconnectedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        player_id_(arena) {}

inline void PlayerReconnectedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.member_ = {};
}
PlayerReconnectedEvent::~PlayerReconnectedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.PlayerReconnectedEvent)
  SharedDtor(*this);
}
inline void PlayerReconnectedEvent::SharedDtor(MessageLite& self) {
  PlayerReconnectedEvent& this_ = static_cast<PlayerReconnectedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.player_id_.Destroy();
  delete this_._impl_.member_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PlayerReconnectedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PlayerReconnectedEvent(arena);
}
constexpr auto PlayerReconnectedEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PlayerReconnectedEvent),
                                            alignof(PlayerReconnectedEvent));
}
constexpr auto PlayerReconnectedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PlayerReconnectedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PlayerReconnectedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PlayerReconnectedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PlayerReconnectedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PlayerReconnectedEvent>(), &PlayerReconnectedEvent::ByteSizeLong,
              &PlayerReconnectedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PlayerReconnectedEvent, _impl_._cached_size_),
          false,
      },
      &PlayerReconnectedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PlayerReconnectedEvent_class_data_ =
        PlayerReconnectedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PlayerReconnectedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PlayerReconnectedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PlayerReconnectedEvent_class_data_.tc_table);
  return PlayerReconnectedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 59, 2>
PlayerReconnectedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PlayerReconnectedEvent, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PlayerReconnectedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PlayerReconnectedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.PartyMember member = 2 [json_name = "member"];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(PlayerReconnectedEvent, _impl_.member_)}},
    // string player_id = 1 [json_name = "playerId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(PlayerReconnectedEvent, _impl_.player_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1 [json_name = "playerId"];
    {PROTOBUF_FIELD_OFFSET(PlayerReconnectedEvent, _impl_.player_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.PartyMember member = 2 [json_name = "member"];
    {PROTOBUF_FIELD_OFFSET(PlayerReconnectedEvent, _impl_.member_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::PartyMember>()},
  }},
  {{
    "\51\11\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.PlayerReconnectedEvent"
    "player_id"
  }},
};
PROTOBUF_NOINLINE void PlayerReconnectedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.PlayerReconnectedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.player_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.member_ != nullptr);
      _impl_.member_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PlayerReconnectedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PlayerReconnectedEvent& this_ = static_cast<const PlayerReconnectedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PlayerReconnectedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PlayerReconnectedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.PlayerReconnectedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string player_id = 1 [json_name = "playerId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_player_id().empty()) {
      const ::std::string& _s = this_._internal_player_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.PlayerReconnectedEvent.player_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.PartyMember member = 2 [json_name = "member"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.member_, this_._impl_.member_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.PlayerReconnectedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PlayerReconnectedEvent::ByteSizeLong(const MessageLite& base) {
  const PlayerReconnectedEvent& this_ = static_cast<const PlayerReconnectedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PlayerReconnectedEvent::ByteSizeLong() const {
  const PlayerReconnectedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.PlayerReconnectedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // string player_id = 1 [json_name = "playerId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_player_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_player_id());
      }
    }
    // .dnd5e.api.v1alpha1.PartyMember member = 2 [json_name = "member"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.member_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PlayerReconnectedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PlayerReconnectedEvent*>(&to_msg);
  auto& from = static_cast<const PlayerReconnectedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.PlayerReconnectedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_player_id().empty()) {
        _this->_internal_set_player_id(from._internal_player_id());
      } else {
        if (_this->_impl_.player_id_.IsDefault()) {
          _this->_internal_set_player_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.member_ != nullptr);
      if (_this->_impl_.member_ == nullptr) {
        _this->_impl_.member_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.member_);
      } else {
        _this->_impl_.member_->MergeFrom(*from._impl_.member_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void PlayerReconnectedEvent::CopyFrom(const PlayerReconnectedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.PlayerReconnectedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PlayerReconnectedEvent::InternalSwap(PlayerReconnectedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
  swap(_impl_.member_, other->_impl_.member_);
}

::google::protobuf::Metadata PlayerReconnectedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CombatPausedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CombatPausedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CombatPausedEvent, _impl_._has_bits_);
};

CombatPausedEvent::CombatPausedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CombatPausedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.CombatPausedEvent)
}
PROTOBUF_NDEBUG_INLINE CombatPausedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::CombatPausedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        reason_(arena, from.reason_),
        disconnected_player_id_(arena, from.disconnected_player_id_) {}

CombatPausedEvent::CombatPausedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CombatPausedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CombatPausedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CombatPausedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.CombatPausedEvent)
}
PROTOBUF_NDEBUG_INLINE CombatPausedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        reason_(arena),
        disconnected_player_id_(arena) {}

inline void CombatPausedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
CombatPausedEvent::~CombatPausedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.CombatPausedEvent)
  SharedDtor(*this);
}
inline void CombatPausedEvent::SharedDtor(MessageLite& self) {
  CombatPausedEvent& this_ = static_cast<CombatPausedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.reason_.Destroy();
  this_._impl_.disconnected_player_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CombatPausedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CombatPausedEvent(arena);
}
constexpr auto CombatPausedEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(CombatPausedEvent),
                                            alignof(CombatPausedEvent));
}
constexpr auto CombatPausedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CombatPausedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CombatPausedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CombatPausedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CombatPausedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CombatPausedEvent>(), &CombatPausedEvent::ByteSizeLong,
              &CombatPausedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CombatPausedEvent, _impl_._cached_size_),
          false,
      },
      &CombatPausedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CombatPausedEvent_class_data_ =
        CombatPausedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CombatPausedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CombatPausedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CombatPausedEvent_class_data_.tc_table);
  return CombatPausedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 73, 2>
CombatPausedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CombatPausedEvent, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    CombatPausedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatPausedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string disconnected_player_id = 2 [json_name = "disconnectedPlayerId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(CombatPausedEvent, _impl_.disconnected_player_id_)}},
    // string reason = 1 [json_name = "reason"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(CombatPausedEvent, _impl_.reason_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string reason = 1 [json_name = "reason"];
    {PROTOBUF_FIELD_OFFSET(CombatPausedEvent, _impl_.reason_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string disconnected_player_id = 2 [json_name = "disconnectedPlayerId"];
    {PROTOBUF_FIELD_OFFSET(CombatPausedEvent, _impl_.disconnected_player_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\44\6\26\0\0\0\0\0"
    "dnd5e.api.v1alpha1.CombatPausedEvent"
    "reason"
    "disconnected_player_id"
  }},
};
PROTOBUF_NOINLINE void CombatPausedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.CombatPausedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.disconnected_player_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CombatPausedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CombatPausedEvent& this_ = static_cast<const CombatPausedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CombatPausedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CombatPausedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.CombatPausedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string reason = 1 [json_name = "reason"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_reason().empty()) {
      const ::std::string& _s = this_._internal_reason();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.CombatPausedEvent.reason");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string disconnected_player_id = 2 [json_name = "disconnectedPlayerId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_disconnected_player_id().empty()) {
      const ::std::string& _s = this_._internal_disconnected_player_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.CombatPausedEvent.disconnected_player_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.CombatPausedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CombatPausedEvent::ByteSizeLong(const MessageLite& base) {
  const CombatPausedEvent& this_ = static_cast<const CombatPausedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CombatPausedEvent::ByteSizeLong() const {
  const CombatPausedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.CombatPausedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // string reason = 1 [json_name = "reason"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_reason().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_reason());
      }
    }
    // string disconnected_player_id = 2 [json_name = "disconnectedPlayerId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_disconnected_player_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_disconnected_player_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CombatPausedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CombatPausedEvent*>(&to_msg);
  auto& from = static_cast<const CombatPausedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.CombatPausedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_reason().empty()) {
        _this->_internal_set_reason(from._internal_reason());
      } else {
        if (_this->_impl_.reason_.IsDefault()) {
          _this->_internal_set_reason("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_disconnected_player_id().empty()) {
        _this->_internal_set_disconnected_player_id(from._internal_disconnected_player_id());
      } else {
        if (_this->_impl_.disconnected_player_id_.IsDefault()) {
          _this->_internal_set_disconnected_player_id("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CombatPausedEvent::CopyFrom(const CombatPausedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.CombatPausedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CombatPausedEvent::InternalSwap(CombatPausedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reason_, &other->_impl_.reason_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.disconnected_player_id_, &other->_impl_.disconnected_player_id_, arena);
}

::google::protobuf::Metadata CombatPausedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CombatResumedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CombatResumedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CombatResumedEvent, _impl_._has_bits_);
};

CombatResumedEvent::CombatResumedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CombatResumedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.CombatResumedEvent)
}
PROTOBUF_NDEBUG_INLINE CombatResumedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::CombatResumedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

CombatResumedEvent::CombatResumedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CombatResumedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CombatResumedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CombatResumedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.combat_state_ = (CheckHasBit(cached_has_bits, 0x00000001U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.CombatResumedEvent)
}
PROTOBUF_NDEBUG_INLINE CombatResumedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void CombatResumedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.combat_state_ = {};
}
CombatResumedEvent::~CombatResumedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.CombatResumedEvent)
  SharedDtor(*this);
}
inline void CombatResumedEvent::SharedDtor(MessageLite& self) {
  CombatResumedEvent& this_ = static_cast<CombatResumedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.combat_state_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CombatResumedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CombatResumedEvent(arena);
}
constexpr auto CombatResumedEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(CombatResumedEvent),
                                            alignof(CombatResumedEvent));
}
constexpr auto CombatResumedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CombatResumedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CombatResumedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CombatResumedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CombatResumedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CombatResumedEvent>(), &CombatResumedEvent::ByteSizeLong,
              &CombatResumedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CombatResumedEvent, _impl_._cached_size_),
          false,
      },
      &CombatResumedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CombatResumedEvent_class_data_ =
        CombatResumedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CombatResumedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CombatResumedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CombatResumedEvent_class_data_.tc_table);
  return CombatResumedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2>
CombatResumedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CombatResumedEvent, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    CombatResumedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatResumedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(CombatResumedEvent, _impl_.combat_state_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
    {PROTOBUF_FIELD_OFFSET(CombatResumedEvent, _impl_.combat_state_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void CombatResumedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.CombatResumedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    ABSL_DCHECK(_impl_.combat_state_ != nullptr);
    _impl_.combat_state_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CombatResumedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CombatResumedEvent& this_ = static_cast<const CombatResumedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CombatResumedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CombatResumedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.CombatResumedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.combat_state_, this_._impl_.combat_state_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.CombatResumedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CombatResumedEvent::ByteSizeLong(const MessageLite& base) {
  const CombatResumedEvent& this_ = static_cast<const CombatResumedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CombatResumedEvent::ByteSizeLong() const {
  const CombatResumedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.CombatResumedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.combat_state_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CombatResumedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CombatResumedEvent*>(&to_msg);
  auto& from = static_cast<const CombatResumedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.CombatResumedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    ABSL_DCHECK(from._impl_.combat_state_ != nullptr);
    if (_this->_impl_.combat_state_ == nullptr) {
      _this->_impl_.combat_state_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_);
    } else {
      _this->_impl_.combat_state_->MergeFrom(*from._impl_.combat_state_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CombatResumedEvent::CopyFrom(const CombatResumedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.CombatResumedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CombatResumedEvent::InternalSwap(CombatResumedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.combat_state_, other->_impl_.combat_state_);
}

::google::protobuf::Metadata CombatResumedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RoomRevealedEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RoomRevealedEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_._has_bits_);
};

RoomRevealedEvent::RoomRevealedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RoomRevealedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.RoomRevealedEvent)
}
PROTOBUF_NDEBUG_INLINE RoomRevealedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::RoomRevealedEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        doors_{visibility, arena, from.doors_},
        dungeon_id_(arena, from.dungeon_id_),
        connection_id_(arena, from.connection_id_) {}

RoomRevealedEvent::RoomRevealedEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RoomRevealedEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RoomRevealedEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RoomRevealedEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.room_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_)
                : nullptr;
  _impl_.combat_state_ = (CheckHasBit(cached_has_bits, 0x00000010U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.RoomRevealedEvent)
}
PROTOBUF_NDEBUG_INLINE RoomRevealedEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        doors_{visibility, arena},
        dungeon_id_(arena),
        connection_id_(arena) {}

inline void RoomRevealedEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, room_),
           0,
           offsetof(Impl_, combat_state_) -
               offsetof(Impl_, room_) +
               sizeof(Impl_::combat_state_));
}
RoomRevealedEvent::~RoomRevealedEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.RoomRevealedEvent)
  SharedDtor(*this);
}
inline void RoomRevealedEvent::SharedDtor(MessageLite& self) {
  RoomRevealedEvent& this_ = static_cast<RoomRevealedEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.dungeon_id_.Destroy();
  this_._impl_.connection_id_.Destroy();
  delete this_._impl_.room_;
  delete this_._impl_.combat_state_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RoomRevealedEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RoomRevealedEvent(arena);
}
constexpr auto RoomRevealedEvent::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.doors_) +
          decltype(RoomRevealedEvent::_impl_.doors_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(RoomRevealedEvent), alignof(RoomRevealedEvent), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&RoomRevealedEvent::PlacementNew_,
                                 sizeof(RoomRevealedEvent),
                                 alignof(RoomRevealedEvent));
  }
}
constexpr auto RoomRevealedEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RoomRevealedEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RoomRevealedEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RoomRevealedEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RoomRevealedEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RoomRevealedEvent>(), &RoomRevealedEvent::ByteSizeLong,
              &RoomRevealedEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_._cached_size_),
          false,
      },
      &RoomRevealedEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RoomRevealedEvent_class_data_ =
        RoomRevealedEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RoomRevealedEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RoomRevealedEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RoomRevealedEvent_class_data_.tc_table);
  return RoomRevealedEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 3, 68, 2>
RoomRevealedEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RoomRevealedEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::RoomRevealedEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string dungeon_id = 1 [json_name = "dungeonId"];
    {::_pbi::TcParser::FastUS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.dungeon_id_)}},
    // string connection_id = 2 [json_name = "connectionId"];
    {::_pbi::TcParser::FastUS1,
     {18, 2, 0,
      PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.connection_id_)}},
    // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
    {::_pbi::TcParser::FastMtS1,
     {26, 3, 0,
      PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.room_)}},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
    {::_pbi::TcParser::FastMtS1,
     {34, 4, 1,
      PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.combat_state_)}},
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 5 [json_name = "doors"];
    {::_pbi::TcParser::FastMtR1,
     {42, 0, 2,
      PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.doors_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string dungeon_id = 1 [json_name = "dungeonId"];
    {PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.dungeon_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string connection_id = 2 [json_name = "connectionId"];
    {PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.connection_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
    {PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.room_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
    {PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.combat_state_), _Internal::kHasBitsOffset + 4, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 5 [json_name = "doors"];
    {PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.doors_), _Internal::kHasBitsOffset + 0, 2, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::Room>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::CombatState>()},
      {::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DoorInfo>()},
  }},
  {{
    "\44\12\15\0\0\0\0\0"
    "dnd5e.api.v1alpha1.RoomRevealedEvent"
    "dungeon_id"
    "connection_id"
  }},
};
PROTOBUF_NOINLINE void RoomRevealedEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.RoomRevealedEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.doors_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.dungeon_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.connection_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.room_ != nullptr);
      _impl_.room_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(_impl_.combat_state_ != nullptr);
      _impl_.combat_state_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RoomRevealedEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RoomRevealedEvent& this_ = static_cast<const RoomRevealedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RoomRevealedEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RoomRevealedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.RoomRevealedEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string dungeon_id = 1 [json_name = "dungeonId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_dungeon_id().empty()) {
      const ::std::string& _s = this_._internal_dungeon_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.RoomRevealedEvent.dungeon_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string connection_id = 2 [json_name = "connectionId"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (!this_._internal_connection_id().empty()) {
      const ::std::string& _s = this_._internal_connection_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.RoomRevealedEvent.connection_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.room_, this_._impl_.room_->GetCachedSize(), target,
        stream);
  }

  // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.combat_state_, this_._impl_.combat_state_->GetCachedSize(), target,
        stream);
  }

  // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 5 [json_name = "doors"];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_doors_size());
         i < n; i++) {
      const auto& repfield = this_._internal_doors().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              5, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.RoomRevealedEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RoomRevealedEvent::ByteSizeLong(const MessageLite& base) {
  const RoomRevealedEvent& this_ = static_cast<const RoomRevealedEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RoomRevealedEvent::ByteSizeLong() const {
  const RoomRevealedEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.RoomRevealedEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 5 [json_name = "doors"];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_doors_size();
      for (const auto& msg : this_._internal_doors()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string dungeon_id = 1 [json_name = "dungeonId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_dungeon_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_dungeon_id());
      }
    }
    // string connection_id = 2 [json_name = "connectionId"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!this_._internal_connection_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_connection_id());
      }
    }
    // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.room_);
    }
    // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.combat_state_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RoomRevealedEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<RoomRevealedEvent*>(&to_msg);
  auto& from = static_cast<const RoomRevealedEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.RoomRevealedEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_doors()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_doors());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_dungeon_id().empty()) {
        _this->_internal_set_dungeon_id(from._internal_dungeon_id());
      } else {
        if (_this->_impl_.dungeon_id_.IsDefault()) {
          _this->_internal_set_dungeon_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (!from._internal_connection_id().empty()) {
        _this->_internal_set_connection_id(from._internal_connection_id());
      } else {
        if (_this->_impl_.connection_id_.IsDefault()) {
          _this->_internal_set_connection_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.room_ != nullptr);
      if (_this->_impl_.room_ == nullptr) {
        _this->_impl_.room_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.room_);
      } else {
        _this->_impl_.room_->MergeFrom(*from._impl_.room_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(from._impl_.combat_state_ != nullptr);
      if (_this->_impl_.combat_state_ == nullptr) {
        _this->_impl_.combat_state_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.combat_state_);
      } else {
        _this->_impl_.combat_state_->MergeFrom(*from._impl_.combat_state_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void RoomRevealedEvent::CopyFrom(const RoomRevealedEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.RoomRevealedEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RoomRevealedEvent::InternalSwap(RoomRevealedEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.doors_.InternalSwap(&other->_impl_.doors_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dungeon_id_, &other->_impl_.dungeon_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.connection_id_, &other->_impl_.connection_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.combat_state_)
      + sizeof(RoomRevealedEvent::_impl_.combat_state_)
      - PROTOBUF_FIELD_OFFSET(RoomRevealedEvent, _impl_.room_)>(
          reinterpret_cast<char*>(&_impl_.room_),
          reinterpret_cast<char*>(&other->_impl_.room_));
}

::google::protobuf::Metadata RoomRevealedEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DungeonVictoryEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DungeonVictoryEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DungeonVictoryEvent, _impl_._has_bits_);
};

DungeonVictoryEvent::DungeonVictoryEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DungeonVictoryEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.DungeonVictoryEvent)
}
PROTOBUF_NDEBUG_INLINE DungeonVictoryEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::DungeonVictoryEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        dungeon_id_(arena, from.dungeon_id_) {}

DungeonVictoryEvent::DungeonVictoryEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DungeonVictoryEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DungeonVictoryEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DungeonVictoryEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, rooms_cleared_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, rooms_cleared_),
           offsetof(Impl_, dungeon_state_) -
               offsetof(Impl_, rooms_cleared_) +
               sizeof(Impl_::dungeon_state_));

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.DungeonVictoryEvent)
}
PROTOBUF_NDEBUG_INLINE DungeonVictoryEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        dungeon_id_(arena) {}

inline void DungeonVictoryEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, rooms_cleared_),
           0,
           offsetof(Impl_, dungeon_state_) -
               offsetof(Impl_, rooms_cleared_) +
               sizeof(Impl_::dungeon_state_));
}
DungeonVictoryEvent::~DungeonVictoryEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.DungeonVictoryEvent)
  SharedDtor(*this);
}
inline void DungeonVictoryEvent::SharedDtor(MessageLite& self) {
  DungeonVictoryEvent& this_ = static_cast<DungeonVictoryEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.dungeon_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DungeonVictoryEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DungeonVictoryEvent(arena);
}
constexpr auto DungeonVictoryEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(DungeonVictoryEvent),
                                            alignof(DungeonVictoryEvent));
}
constexpr auto DungeonVictoryEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DungeonVictoryEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DungeonVictoryEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DungeonVictoryEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DungeonVictoryEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DungeonVictoryEvent>(), &DungeonVictoryEvent::ByteSizeLong,
              &DungeonVictoryEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DungeonVictoryEvent, _impl_._cached_size_),
          false,
      },
      &DungeonVictoryEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DungeonVictoryEvent_class_data_ =
        DungeonVictoryEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DungeonVictoryEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DungeonVictoryEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DungeonVictoryEvent_class_data_.tc_table);
  return DungeonVictoryEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 57, 2>
DungeonVictoryEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DungeonVictoryEvent, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    DungeonVictoryEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DungeonVictoryEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string dungeon_id = 1 [json_name = "dungeonId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(DungeonVictoryEvent, _impl_.dungeon_id_)}},
    // int32 rooms_cleared = 2 [json_name = "roomsCleared"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DungeonVictoryEvent, _impl_.rooms_cleared_), 1>(),
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(DungeonVictoryEvent, _impl_.rooms_cleared_)}},
    // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 3 [json_name = "dungeonState"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DungeonVictoryEvent, _impl_.dungeon_state_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(DungeonVictoryEvent, _impl_.dungeon_state_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string dungeon_id = 1 [json_name = "dungeonId"];
    {PROTOBUF_FIELD_OFFSET(DungeonVictoryEvent, _impl_.dungeon_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 rooms_cleared = 2 [json_name = "roomsCleared"];
    {PROTOBUF_FIELD_OFFSET(DungeonVictoryEvent, _impl_.rooms_cleared_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 3 [json_name = "dungeonState"];
    {PROTOBUF_FIELD_OFFSET(DungeonVictoryEvent, _impl_.dungeon_state_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
    "\46\12\0\0\0\0\0\0"
    "dnd5e.api.v1alpha1.DungeonVictoryEvent"
    "dungeon_id"
  }},
};
PROTOBUF_NOINLINE void DungeonVictoryEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.DungeonVictoryEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.dungeon_id_.ClearNonDefaultToEmpty();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000006U)) {
    ::memset(&_impl_.rooms_cleared_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.dungeon_state_) -
        reinterpret_cast<char*>(&_impl_.rooms_cleared_)) + sizeof(_impl_.dungeon_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DungeonVictoryEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DungeonVictoryEvent& this_ = static_cast<const DungeonVictoryEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DungeonVictoryEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DungeonVictoryEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.DungeonVictoryEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string dungeon_id = 1 [json_name = "dungeonId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_dungeon_id().empty()) {
      const ::std::string& _s = this_._internal_dungeon_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.DungeonVictoryEvent.dungeon_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // int32 rooms_cleared = 2 [json_name = "roomsCleared"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (this_._internal_rooms_cleared() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
              stream, this_._internal_rooms_cleared(), target);
    }
  }

  // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 3 [json_name = "dungeonState"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_dungeon_state() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          3, this_._internal_dungeon_state(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.DungeonVictoryEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DungeonVictoryEvent::ByteSizeLong(const MessageLite& base) {
  const DungeonVictoryEvent& this_ = static_cast<const DungeonVictoryEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DungeonVictoryEvent::ByteSizeLong() const {
  const DungeonVictoryEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.DungeonVictoryEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // string dungeon_id = 1 [json_name = "dungeonId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_dungeon_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_dungeon_id());
      }
    }
    // int32 rooms_cleared = 2 [json_name = "roomsCleared"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (this_._internal_rooms_cleared() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_rooms_cleared());
      }
    }
    // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 3 [json_name = "dungeonState"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_dungeon_state() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_dungeon_state());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DungeonVictoryEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<DungeonVictoryEvent*>(&to_msg);
  auto& from = static_cast<const DungeonVictoryEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.DungeonVictoryEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_dungeon_id().empty()) {
        _this->_internal_set_dungeon_id(from._internal_dungeon_id());
      } else {
        if (_this->_impl_.dungeon_id_.IsDefault()) {
          _this->_internal_set_dungeon_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (from._internal_rooms_cleared() != 0) {
        _this->_impl_.rooms_cleared_ = from._impl_.rooms_cleared_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_dungeon_state() != 0) {
        _this->_impl_.dungeon_state_ = from._impl_.dungeon_state_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void DungeonVictoryEvent::CopyFrom(const DungeonVictoryEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.DungeonVictoryEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DungeonVictoryEvent::InternalSwap(DungeonVictoryEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dungeon_id_, &other->_impl_.dungeon_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DungeonVictoryEvent, _impl_.dungeon_state_)
      + sizeof(DungeonVictoryEvent::_impl_.dungeon_state_)
      - PROTOBUF_FIELD_OFFSET(DungeonVictoryEvent, _impl_.rooms_cleared_)>(
          reinterpret_cast<char*>(&_impl_.rooms_cleared_),
          reinterpret_cast<char*>(&other->_impl_.rooms_cleared_));
}

::google::protobuf::Metadata DungeonVictoryEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DungeonFailureEvent::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DungeonFailureEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DungeonFailureEvent, _impl_._has_bits_);
};

DungeonFailureEvent::DungeonFailureEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DungeonFailureEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:dnd5e.api.v1alpha1.DungeonFailureEvent)
}
PROTOBUF_NDEBUG_INLINE DungeonFailureEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::dnd5e::api::v1alpha1::DungeonFailureEvent& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        dungeon_id_(arena, from.dungeon_id_),
        final_room_id_(arena, from.final_room_id_) {}

DungeonFailureEvent::DungeonFailureEvent(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DungeonFailureEvent& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DungeonFailureEvent_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DungeonFailureEvent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.dungeon_state_ = from._impl_.dungeon_state_;

  // @@protoc_insertion_point(copy_constructor:dnd5e.api.v1alpha1.DungeonFailureEvent)
}
PROTOBUF_NDEBUG_INLINE DungeonFailureEvent::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        dungeon_id_(arena),
        final_room_id_(arena) {}

inline void DungeonFailureEvent::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.dungeon_state_ = {};
}
DungeonFailureEvent::~DungeonFailureEvent() {
  // @@protoc_insertion_point(destructor:dnd5e.api.v1alpha1.DungeonFailureEvent)
  SharedDtor(*this);
}
inline void DungeonFailureEvent::SharedDtor(MessageLite& self) {
  DungeonFailureEvent& this_ = static_cast<DungeonFailureEvent&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.dungeon_id_.Destroy();
  this_._impl_.final_room_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DungeonFailureEvent::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DungeonFailureEvent(arena);
}
constexpr auto DungeonFailureEvent::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(DungeonFailureEvent),
                                            alignof(DungeonFailureEvent));
}
constexpr auto DungeonFailureEvent::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DungeonFailureEvent_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DungeonFailureEvent::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DungeonFailureEvent>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DungeonFailureEvent::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DungeonFailureEvent>(), &DungeonFailureEvent::ByteSizeLong,
              &DungeonFailureEvent::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DungeonFailureEvent, _impl_._cached_size_),
          false,
      },
      &DungeonFailureEvent::kDescriptorMethods,
      &descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DungeonFailureEvent_class_data_ =
        DungeonFailureEvent::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DungeonFailureEvent::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DungeonFailureEvent_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DungeonFailureEvent_class_data_.tc_table);
  return DungeonFailureEvent_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 70, 2>
DungeonFailureEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DungeonFailureEvent, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    DungeonFailureEvent_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::dnd5e::api::v1alpha1::DungeonFailureEvent>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string dungeon_id = 1 [json_name = "dungeonId"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(DungeonFailureEvent, _impl_.dungeon_id_)}},
    // string final_room_id = 2 [json_name = "finalRoomId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(DungeonFailureEvent, _impl_.final_room_id_)}},
    // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 3 [json_name = "dungeonState"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DungeonFailureEvent, _impl_.dungeon_state_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(DungeonFailureEvent, _impl_.dungeon_state_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string dungeon_id = 1 [json_name = "dungeonId"];
    {PROTOBUF_FIELD_OFFSET(DungeonFailureEvent, _impl_.dungeon_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string final_room_id = 2 [json_name = "finalRoomId"];
    {PROTOBUF_FIELD_OFFSET(DungeonFailureEvent, _impl_.final_room_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 3 [json_name = "dungeonState"];
    {PROTOBUF_FIELD_OFFSET(DungeonFailureEvent, _impl_.dungeon_state_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
    "\46\12\15\0\0\0\0\0"
    "dnd5e.api.v1alpha1.DungeonFailureEvent"
    "dungeon_id"
    "final_room_id"
  }},
};
PROTOBUF_NOINLINE void DungeonFailureEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:dnd5e.api.v1alpha1.DungeonFailureEvent)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.dungeon_id_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.final_room_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.dungeon_state_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DungeonFailureEvent::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DungeonFailureEvent& this_ = static_cast<const DungeonFailureEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DungeonFailureEvent::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DungeonFailureEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:dnd5e.api.v1alpha1.DungeonFailureEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string dungeon_id = 1 [json_name = "dungeonId"];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    if (!this_._internal_dungeon_id().empty()) {
      const ::std::string& _s = this_._internal_dungeon_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.DungeonFailureEvent.dungeon_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string final_room_id = 2 [json_name = "finalRoomId"];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_final_room_id().empty()) {
      const ::std::string& _s = this_._internal_final_room_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "dnd5e.api.v1alpha1.DungeonFailureEvent.final_room_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 3 [json_name = "dungeonState"];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_dungeon_state() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          3, this_._internal_dungeon_state(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dnd5e.api.v1alpha1.DungeonFailureEvent)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DungeonFailureEvent::ByteSizeLong(const MessageLite& base) {
  const DungeonFailureEvent& this_ = static_cast<const DungeonFailureEvent&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DungeonFailureEvent::ByteSizeLong() const {
  const DungeonFailureEvent& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:dnd5e.api.v1alpha1.DungeonFailureEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // string dungeon_id = 1 [json_name = "dungeonId"];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!this_._internal_dungeon_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_dungeon_id());
      }
    }
    // string final_room_id = 2 [json_name = "finalRoomId"];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_final_room_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_final_room_id());
      }
    }
    // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 3 [json_name = "dungeonState"];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_dungeon_state() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_dungeon_state());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DungeonFailureEvent::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<DungeonFailureEvent*>(&to_msg);
  auto& from = static_cast<const DungeonFailureEvent&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:dnd5e.api.v1alpha1.DungeonFailureEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      if (!from._internal_dungeon_id().empty()) {
        _this->_internal_set_dungeon_id(from._internal_dungeon_id());
      } else {
        if (_this->_impl_.dungeon_id_.IsDefault()) {
          _this->_internal_set_dungeon_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_final_room_id().empty()) {
        _this->_internal_set_final_room_id(from._internal_final_room_id());
      } else {
        if (_this->_impl_.final_room_id_.IsDefault()) {
          _this->_internal_set_final_room_id("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_dungeon_state() != 0) {
        _this->_impl_.dungeon_state_ = from._impl_.dungeon_state_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void DungeonFailureEvent::CopyFrom(const DungeonFailureEvent& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:dnd5e.api.v1alpha1.DungeonFailureEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DungeonFailureEvent::InternalSwap(DungeonFailureEvent* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dungeon_id_, &other->_impl_.dungeon_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.final_room_id_, &other->_impl_.final_room_id_, arena);
  swap(_impl_.dungeon_state_, other->_impl_.dungeon_state_);
}

::google::protobuf::Metadata DungeonFailureEvent::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ [[maybe_unused]] =
        (::_pbi::AddDescriptors(&descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
