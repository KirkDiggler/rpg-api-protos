// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: dnd5e/api/v1alpha1/character.proto
// Protobuf C++ Version: 6.31.1

#ifndef dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto_2epb_2eh
#define dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "dnd5e/api/v1alpha1/common.pb.h"
#include "dnd5e/api/v1alpha1/enums.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
}  // extern "C"
namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum ChoiceCategory : int;
extern const uint32_t ChoiceCategory_internal_data_[];
enum ChoiceSource : int;
extern const uint32_t ChoiceSource_internal_data_[];
enum CreationStep : int;
extern const uint32_t CreationStep_internal_data_[];
enum EncumbranceLevel : int;
extern const uint32_t EncumbranceLevel_internal_data_[];
enum EquipmentSlot : int;
extern const uint32_t EquipmentSlot_internal_data_[];
enum Size : int;
extern const uint32_t Size_internal_data_[];
enum SpellSelectionType : int;
extern const uint32_t SpellSelectionType_internal_data_[];
enum WarningType : int;
extern const uint32_t WarningType_internal_data_[];
class AbilityModifiers;
struct AbilityModifiersDefaultTypeInternal;
extern AbilityModifiersDefaultTypeInternal _AbilityModifiers_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AbilityModifiers_class_data_;
class AbilityScoreChoice;
struct AbilityScoreChoiceDefaultTypeInternal;
extern AbilityScoreChoiceDefaultTypeInternal _AbilityScoreChoice_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AbilityScoreChoice_class_data_;
class AbilityScoreRoll;
struct AbilityScoreRollDefaultTypeInternal;
extern AbilityScoreRollDefaultTypeInternal _AbilityScoreRoll_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AbilityScoreRoll_class_data_;
class AbilityScores;
struct AbilityScoresDefaultTypeInternal;
extern AbilityScoresDefaultTypeInternal _AbilityScores_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AbilityScores_class_data_;
class AddToInventoryRequest;
struct AddToInventoryRequestDefaultTypeInternal;
extern AddToInventoryRequestDefaultTypeInternal _AddToInventoryRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AddToInventoryRequest_class_data_;
class AddToInventoryResponse;
struct AddToInventoryResponseDefaultTypeInternal;
extern AddToInventoryResponseDefaultTypeInternal _AddToInventoryResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AddToInventoryResponse_class_data_;
class AreaOfEffect;
struct AreaOfEffectDefaultTypeInternal;
extern AreaOfEffectDefaultTypeInternal _AreaOfEffect_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AreaOfEffect_class_data_;
class ArmorData;
struct ArmorDataDefaultTypeInternal;
extern ArmorDataDefaultTypeInternal _ArmorData_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ArmorData_class_data_;
class BackgroundInfo;
struct BackgroundInfoDefaultTypeInternal;
extern BackgroundInfoDefaultTypeInternal _BackgroundInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BackgroundInfo_class_data_;
class BundleItem;
struct BundleItemDefaultTypeInternal;
extern BundleItemDefaultTypeInternal _BundleItem_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BundleItem_class_data_;
class CantripList;
struct CantripListDefaultTypeInternal;
extern CantripListDefaultTypeInternal _CantripList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CantripList_class_data_;
class CategoryReference;
struct CategoryReferenceDefaultTypeInternal;
extern CategoryReferenceDefaultTypeInternal _CategoryReference_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CategoryReference_class_data_;
class Character;
struct CharacterDefaultTypeInternal;
extern CharacterDefaultTypeInternal _Character_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Character_class_data_;
class CharacterDraft;
struct CharacterDraftDefaultTypeInternal;
extern CharacterDraftDefaultTypeInternal _CharacterDraft_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CharacterDraft_class_data_;
class CharacterDraftData;
struct CharacterDraftDataDefaultTypeInternal;
extern CharacterDraftDataDefaultTypeInternal _CharacterDraftData_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CharacterDraftData_class_data_;
class CharacterMetadata;
struct CharacterMetadataDefaultTypeInternal;
extern CharacterMetadataDefaultTypeInternal _CharacterMetadata_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CharacterMetadata_class_data_;
class Choice;
struct ChoiceDefaultTypeInternal;
extern ChoiceDefaultTypeInternal _Choice_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Choice_class_data_;
class ChoiceData;
struct ChoiceDataDefaultTypeInternal;
extern ChoiceDataDefaultTypeInternal _ChoiceData_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ChoiceData_class_data_;
class ChoiceOption;
struct ChoiceOptionDefaultTypeInternal;
extern ChoiceOptionDefaultTypeInternal _ChoiceOption_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ChoiceOption_class_data_;
class ChoiceSelection;
struct ChoiceSelectionDefaultTypeInternal;
extern ChoiceSelectionDefaultTypeInternal _ChoiceSelection_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ChoiceSelection_class_data_;
class ClassChoice;
struct ClassChoiceDefaultTypeInternal;
extern ClassChoiceDefaultTypeInternal _ClassChoice_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ClassChoice_class_data_;
class ClassInfo;
struct ClassInfoDefaultTypeInternal;
extern ClassInfoDefaultTypeInternal _ClassInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ClassInfo_class_data_;
class CombatStats;
struct CombatStatsDefaultTypeInternal;
extern CombatStatsDefaultTypeInternal _CombatStats_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CombatStats_class_data_;
class Cost;
struct CostDefaultTypeInternal;
extern CostDefaultTypeInternal _Cost_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Cost_class_data_;
class CountedItemReference;
struct CountedItemReferenceDefaultTypeInternal;
extern CountedItemReferenceDefaultTypeInternal _CountedItemReference_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CountedItemReference_class_data_;
class CreateDraftRequest;
struct CreateDraftRequestDefaultTypeInternal;
extern CreateDraftRequestDefaultTypeInternal _CreateDraftRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateDraftRequest_class_data_;
class CreateDraftResponse;
struct CreateDraftResponseDefaultTypeInternal;
extern CreateDraftResponseDefaultTypeInternal _CreateDraftResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateDraftResponse_class_data_;
class CreationProgress;
struct CreationProgressDefaultTypeInternal;
extern CreationProgressDefaultTypeInternal _CreationProgress_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreationProgress_class_data_;
class DamageAtSlotLevel;
struct DamageAtSlotLevelDefaultTypeInternal;
extern DamageAtSlotLevelDefaultTypeInternal _DamageAtSlotLevel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DamageAtSlotLevel_class_data_;
class DeleteCharacterRequest;
struct DeleteCharacterRequestDefaultTypeInternal;
extern DeleteCharacterRequestDefaultTypeInternal _DeleteCharacterRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteCharacterRequest_class_data_;
class DeleteCharacterResponse;
struct DeleteCharacterResponseDefaultTypeInternal;
extern DeleteCharacterResponseDefaultTypeInternal _DeleteCharacterResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteCharacterResponse_class_data_;
class DeleteDraftRequest;
struct DeleteDraftRequestDefaultTypeInternal;
extern DeleteDraftRequestDefaultTypeInternal _DeleteDraftRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteDraftRequest_class_data_;
class DeleteDraftResponse;
struct DeleteDraftResponseDefaultTypeInternal;
extern DeleteDraftResponseDefaultTypeInternal _DeleteDraftResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteDraftResponse_class_data_;
class DraftMetadata;
struct DraftMetadataDefaultTypeInternal;
extern DraftMetadataDefaultTypeInternal _DraftMetadata_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DraftMetadata_class_data_;
class EncumbranceInfo;
struct EncumbranceInfoDefaultTypeInternal;
extern EncumbranceInfoDefaultTypeInternal _EncumbranceInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EncumbranceInfo_class_data_;
class EquipItemRequest;
struct EquipItemRequestDefaultTypeInternal;
extern EquipItemRequestDefaultTypeInternal _EquipItemRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EquipItemRequest_class_data_;
class EquipItemResponse;
struct EquipItemResponseDefaultTypeInternal;
extern EquipItemResponseDefaultTypeInternal _EquipItemResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EquipItemResponse_class_data_;
class Equipment;
struct EquipmentDefaultTypeInternal;
extern EquipmentDefaultTypeInternal _Equipment_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Equipment_class_data_;
class EquipmentList;
struct EquipmentListDefaultTypeInternal;
extern EquipmentListDefaultTypeInternal _EquipmentList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EquipmentList_class_data_;
class EquipmentSlots;
struct EquipmentSlotsDefaultTypeInternal;
extern EquipmentSlotsDefaultTypeInternal _EquipmentSlots_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EquipmentSlots_class_data_;
class ExplicitOptions;
struct ExplicitOptionsDefaultTypeInternal;
extern ExplicitOptionsDefaultTypeInternal _ExplicitOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExplicitOptions_class_data_;
class FeatureInfo;
struct FeatureInfoDefaultTypeInternal;
extern FeatureInfoDefaultTypeInternal _FeatureInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FeatureInfo_class_data_;
class FinalizeDraftRequest;
struct FinalizeDraftRequestDefaultTypeInternal;
extern FinalizeDraftRequestDefaultTypeInternal _FinalizeDraftRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FinalizeDraftRequest_class_data_;
class FinalizeDraftResponse;
struct FinalizeDraftResponseDefaultTypeInternal;
extern FinalizeDraftResponseDefaultTypeInternal _FinalizeDraftResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FinalizeDraftResponse_class_data_;
class GearData;
struct GearDataDefaultTypeInternal;
extern GearDataDefaultTypeInternal _GearData_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GearData_class_data_;
class GetBackgroundDetailsRequest;
struct GetBackgroundDetailsRequestDefaultTypeInternal;
extern GetBackgroundDetailsRequestDefaultTypeInternal _GetBackgroundDetailsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetBackgroundDetailsRequest_class_data_;
class GetBackgroundDetailsResponse;
struct GetBackgroundDetailsResponseDefaultTypeInternal;
extern GetBackgroundDetailsResponseDefaultTypeInternal _GetBackgroundDetailsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetBackgroundDetailsResponse_class_data_;
class GetCharacterInventoryRequest;
struct GetCharacterInventoryRequestDefaultTypeInternal;
extern GetCharacterInventoryRequestDefaultTypeInternal _GetCharacterInventoryRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCharacterInventoryRequest_class_data_;
class GetCharacterInventoryResponse;
struct GetCharacterInventoryResponseDefaultTypeInternal;
extern GetCharacterInventoryResponseDefaultTypeInternal _GetCharacterInventoryResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCharacterInventoryResponse_class_data_;
class GetCharacterRequest;
struct GetCharacterRequestDefaultTypeInternal;
extern GetCharacterRequestDefaultTypeInternal _GetCharacterRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCharacterRequest_class_data_;
class GetCharacterResponse;
struct GetCharacterResponseDefaultTypeInternal;
extern GetCharacterResponseDefaultTypeInternal _GetCharacterResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCharacterResponse_class_data_;
class GetClassDetailsRequest;
struct GetClassDetailsRequestDefaultTypeInternal;
extern GetClassDetailsRequestDefaultTypeInternal _GetClassDetailsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetClassDetailsRequest_class_data_;
class GetClassDetailsResponse;
struct GetClassDetailsResponseDefaultTypeInternal;
extern GetClassDetailsResponseDefaultTypeInternal _GetClassDetailsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetClassDetailsResponse_class_data_;
class GetDraftPreviewRequest;
struct GetDraftPreviewRequestDefaultTypeInternal;
extern GetDraftPreviewRequestDefaultTypeInternal _GetDraftPreviewRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetDraftPreviewRequest_class_data_;
class GetDraftPreviewResponse;
struct GetDraftPreviewResponseDefaultTypeInternal;
extern GetDraftPreviewResponseDefaultTypeInternal _GetDraftPreviewResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetDraftPreviewResponse_class_data_;
class GetDraftRequest;
struct GetDraftRequestDefaultTypeInternal;
extern GetDraftRequestDefaultTypeInternal _GetDraftRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetDraftRequest_class_data_;
class GetDraftResponse;
struct GetDraftResponseDefaultTypeInternal;
extern GetDraftResponseDefaultTypeInternal _GetDraftResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetDraftResponse_class_data_;
class GetFeatureRequest;
struct GetFeatureRequestDefaultTypeInternal;
extern GetFeatureRequestDefaultTypeInternal _GetFeatureRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetFeatureRequest_class_data_;
class GetFeatureResponse;
struct GetFeatureResponseDefaultTypeInternal;
extern GetFeatureResponseDefaultTypeInternal _GetFeatureResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetFeatureResponse_class_data_;
class GetRaceDetailsRequest;
struct GetRaceDetailsRequestDefaultTypeInternal;
extern GetRaceDetailsRequestDefaultTypeInternal _GetRaceDetailsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetRaceDetailsRequest_class_data_;
class GetRaceDetailsResponse;
struct GetRaceDetailsResponseDefaultTypeInternal;
extern GetRaceDetailsResponseDefaultTypeInternal _GetRaceDetailsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetRaceDetailsResponse_class_data_;
class InventoryAddition;
struct InventoryAdditionDefaultTypeInternal;
extern InventoryAdditionDefaultTypeInternal _InventoryAddition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InventoryAddition_class_data_;
class InventoryItem;
struct InventoryItemDefaultTypeInternal;
extern InventoryItemDefaultTypeInternal _InventoryItem_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InventoryItem_class_data_;
class ItemBundle;
struct ItemBundleDefaultTypeInternal;
extern ItemBundleDefaultTypeInternal _ItemBundle_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ItemBundle_class_data_;
class ItemReference;
struct ItemReferenceDefaultTypeInternal;
extern ItemReferenceDefaultTypeInternal _ItemReference_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ItemReference_class_data_;
class LanguageList;
struct LanguageListDefaultTypeInternal;
extern LanguageListDefaultTypeInternal _LanguageList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LanguageList_class_data_;
class ListBackgroundsRequest;
struct ListBackgroundsRequestDefaultTypeInternal;
extern ListBackgroundsRequestDefaultTypeInternal _ListBackgroundsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListBackgroundsRequest_class_data_;
class ListBackgroundsResponse;
struct ListBackgroundsResponseDefaultTypeInternal;
extern ListBackgroundsResponseDefaultTypeInternal _ListBackgroundsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListBackgroundsResponse_class_data_;
class ListCharactersRequest;
struct ListCharactersRequestDefaultTypeInternal;
extern ListCharactersRequestDefaultTypeInternal _ListCharactersRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListCharactersRequest_class_data_;
class ListCharactersResponse;
struct ListCharactersResponseDefaultTypeInternal;
extern ListCharactersResponseDefaultTypeInternal _ListCharactersResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListCharactersResponse_class_data_;
class ListClassesRequest;
struct ListClassesRequestDefaultTypeInternal;
extern ListClassesRequestDefaultTypeInternal _ListClassesRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListClassesRequest_class_data_;
class ListClassesResponse;
struct ListClassesResponseDefaultTypeInternal;
extern ListClassesResponseDefaultTypeInternal _ListClassesResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListClassesResponse_class_data_;
class ListDraftsRequest;
struct ListDraftsRequestDefaultTypeInternal;
extern ListDraftsRequestDefaultTypeInternal _ListDraftsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListDraftsRequest_class_data_;
class ListDraftsResponse;
struct ListDraftsResponseDefaultTypeInternal;
extern ListDraftsResponseDefaultTypeInternal _ListDraftsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListDraftsResponse_class_data_;
class ListEquipmentByTypeRequest;
struct ListEquipmentByTypeRequestDefaultTypeInternal;
extern ListEquipmentByTypeRequestDefaultTypeInternal _ListEquipmentByTypeRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListEquipmentByTypeRequest_class_data_;
class ListEquipmentByTypeResponse;
struct ListEquipmentByTypeResponseDefaultTypeInternal;
extern ListEquipmentByTypeResponseDefaultTypeInternal _ListEquipmentByTypeResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListEquipmentByTypeResponse_class_data_;
class ListRacesRequest;
struct ListRacesRequestDefaultTypeInternal;
extern ListRacesRequestDefaultTypeInternal _ListRacesRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListRacesRequest_class_data_;
class ListRacesResponse;
struct ListRacesResponseDefaultTypeInternal;
extern ListRacesResponseDefaultTypeInternal _ListRacesResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListRacesResponse_class_data_;
class ListSpellsByLevelRequest;
struct ListSpellsByLevelRequestDefaultTypeInternal;
extern ListSpellsByLevelRequestDefaultTypeInternal _ListSpellsByLevelRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListSpellsByLevelRequest_class_data_;
class ListSpellsByLevelResponse;
struct ListSpellsByLevelResponseDefaultTypeInternal;
extern ListSpellsByLevelResponseDefaultTypeInternal _ListSpellsByLevelResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListSpellsByLevelResponse_class_data_;
class NestedChoice;
struct NestedChoiceDefaultTypeInternal;
extern NestedChoiceDefaultTypeInternal _NestedChoice_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NestedChoice_class_data_;
class Proficiencies;
struct ProficienciesDefaultTypeInternal;
extern ProficienciesDefaultTypeInternal _Proficiencies_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Proficiencies_class_data_;
class RaceChoice;
struct RaceChoiceDefaultTypeInternal;
extern RaceChoiceDefaultTypeInternal _RaceChoice_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RaceChoice_class_data_;
class RaceInfo;
struct RaceInfoDefaultTypeInternal;
extern RaceInfoDefaultTypeInternal _RaceInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RaceInfo_class_data_;
class RaceInfo_AbilityBonusesEntry_DoNotUse;
struct RaceInfo_AbilityBonusesEntry_DoNotUseDefaultTypeInternal;
extern RaceInfo_AbilityBonusesEntry_DoNotUseDefaultTypeInternal _RaceInfo_AbilityBonusesEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RaceInfo_AbilityBonusesEntry_DoNotUse_class_data_;
class RacialTrait;
struct RacialTraitDefaultTypeInternal;
extern RacialTraitDefaultTypeInternal _RacialTrait_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RacialTrait_class_data_;
class RemoveFromInventoryRequest;
struct RemoveFromInventoryRequestDefaultTypeInternal;
extern RemoveFromInventoryRequestDefaultTypeInternal _RemoveFromInventoryRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RemoveFromInventoryRequest_class_data_;
class RemoveFromInventoryResponse;
struct RemoveFromInventoryResponseDefaultTypeInternal;
extern RemoveFromInventoryResponseDefaultTypeInternal _RemoveFromInventoryResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RemoveFromInventoryResponse_class_data_;
class RollAbilityScoresRequest;
struct RollAbilityScoresRequestDefaultTypeInternal;
extern RollAbilityScoresRequestDefaultTypeInternal _RollAbilityScoresRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RollAbilityScoresRequest_class_data_;
class RollAbilityScoresResponse;
struct RollAbilityScoresResponseDefaultTypeInternal;
extern RollAbilityScoresResponseDefaultTypeInternal _RollAbilityScoresResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RollAbilityScoresResponse_class_data_;
class RollAssignments;
struct RollAssignmentsDefaultTypeInternal;
extern RollAssignmentsDefaultTypeInternal _RollAssignments_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RollAssignments_class_data_;
class SkillList;
struct SkillListDefaultTypeInternal;
extern SkillListDefaultTypeInternal _SkillList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SkillList_class_data_;
class Spell;
struct SpellDefaultTypeInternal;
extern SpellDefaultTypeInternal _Spell_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Spell_class_data_;
class SpellDamage;
struct SpellDamageDefaultTypeInternal;
extern SpellDamageDefaultTypeInternal _SpellDamage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SpellDamage_class_data_;
class SpellList;
struct SpellListDefaultTypeInternal;
extern SpellListDefaultTypeInternal _SpellList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SpellList_class_data_;
class SpellSelectionInfo;
struct SpellSelectionInfoDefaultTypeInternal;
extern SpellSelectionInfoDefaultTypeInternal _SpellSelectionInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SpellSelectionInfo_class_data_;
class SpellcastingInfo;
struct SpellcastingInfoDefaultTypeInternal;
extern SpellcastingInfoDefaultTypeInternal _SpellcastingInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SpellcastingInfo_class_data_;
class SubraceInfo;
struct SubraceInfoDefaultTypeInternal;
extern SubraceInfoDefaultTypeInternal _SubraceInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubraceInfo_class_data_;
class SubraceInfo_AbilityBonusesEntry_DoNotUse;
struct SubraceInfo_AbilityBonusesEntry_DoNotUseDefaultTypeInternal;
extern SubraceInfo_AbilityBonusesEntry_DoNotUseDefaultTypeInternal _SubraceInfo_AbilityBonusesEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubraceInfo_AbilityBonusesEntry_DoNotUse_class_data_;
class UnequipItemRequest;
struct UnequipItemRequestDefaultTypeInternal;
extern UnequipItemRequestDefaultTypeInternal _UnequipItemRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UnequipItemRequest_class_data_;
class UnequipItemResponse;
struct UnequipItemResponseDefaultTypeInternal;
extern UnequipItemResponseDefaultTypeInternal _UnequipItemResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UnequipItemResponse_class_data_;
class UpdateAbilityScoresRequest;
struct UpdateAbilityScoresRequestDefaultTypeInternal;
extern UpdateAbilityScoresRequestDefaultTypeInternal _UpdateAbilityScoresRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateAbilityScoresRequest_class_data_;
class UpdateAbilityScoresResponse;
struct UpdateAbilityScoresResponseDefaultTypeInternal;
extern UpdateAbilityScoresResponseDefaultTypeInternal _UpdateAbilityScoresResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateAbilityScoresResponse_class_data_;
class UpdateBackgroundRequest;
struct UpdateBackgroundRequestDefaultTypeInternal;
extern UpdateBackgroundRequestDefaultTypeInternal _UpdateBackgroundRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateBackgroundRequest_class_data_;
class UpdateBackgroundResponse;
struct UpdateBackgroundResponseDefaultTypeInternal;
extern UpdateBackgroundResponseDefaultTypeInternal _UpdateBackgroundResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateBackgroundResponse_class_data_;
class UpdateCharacterRequest;
struct UpdateCharacterRequestDefaultTypeInternal;
extern UpdateCharacterRequestDefaultTypeInternal _UpdateCharacterRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateCharacterRequest_class_data_;
class UpdateCharacterResponse;
struct UpdateCharacterResponseDefaultTypeInternal;
extern UpdateCharacterResponseDefaultTypeInternal _UpdateCharacterResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateCharacterResponse_class_data_;
class UpdateClassRequest;
struct UpdateClassRequestDefaultTypeInternal;
extern UpdateClassRequestDefaultTypeInternal _UpdateClassRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateClassRequest_class_data_;
class UpdateClassResponse;
struct UpdateClassResponseDefaultTypeInternal;
extern UpdateClassResponseDefaultTypeInternal _UpdateClassResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateClassResponse_class_data_;
class UpdateDraftRequest;
struct UpdateDraftRequestDefaultTypeInternal;
extern UpdateDraftRequestDefaultTypeInternal _UpdateDraftRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateDraftRequest_class_data_;
class UpdateDraftResponse;
struct UpdateDraftResponseDefaultTypeInternal;
extern UpdateDraftResponseDefaultTypeInternal _UpdateDraftResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateDraftResponse_class_data_;
class UpdateNameRequest;
struct UpdateNameRequestDefaultTypeInternal;
extern UpdateNameRequestDefaultTypeInternal _UpdateNameRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateNameRequest_class_data_;
class UpdateNameResponse;
struct UpdateNameResponseDefaultTypeInternal;
extern UpdateNameResponseDefaultTypeInternal _UpdateNameResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateNameResponse_class_data_;
class UpdateRaceRequest;
struct UpdateRaceRequestDefaultTypeInternal;
extern UpdateRaceRequestDefaultTypeInternal _UpdateRaceRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateRaceRequest_class_data_;
class UpdateRaceResponse;
struct UpdateRaceResponseDefaultTypeInternal;
extern UpdateRaceResponseDefaultTypeInternal _UpdateRaceResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateRaceResponse_class_data_;
class UpdateSkillsRequest;
struct UpdateSkillsRequestDefaultTypeInternal;
extern UpdateSkillsRequestDefaultTypeInternal _UpdateSkillsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateSkillsRequest_class_data_;
class UpdateSkillsResponse;
struct UpdateSkillsResponseDefaultTypeInternal;
extern UpdateSkillsResponseDefaultTypeInternal _UpdateSkillsResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateSkillsResponse_class_data_;
class ValidateDraftRequest;
struct ValidateDraftRequestDefaultTypeInternal;
extern ValidateDraftRequestDefaultTypeInternal _ValidateDraftRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ValidateDraftRequest_class_data_;
class ValidateDraftResponse;
struct ValidateDraftResponseDefaultTypeInternal;
extern ValidateDraftResponseDefaultTypeInternal _ValidateDraftResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ValidateDraftResponse_class_data_;
class WeaponData;
struct WeaponDataDefaultTypeInternal;
extern WeaponDataDefaultTypeInternal _WeaponData_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WeaponData_class_data_;
class Weight;
struct WeightDefaultTypeInternal;
extern WeightDefaultTypeInternal _Weight_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Weight_class_data_;
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::ChoiceCategory_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::ChoiceCategory>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::ChoiceSource_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::ChoiceSource>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::CreationStep_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::CreationStep>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::EncumbranceLevel_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::EncumbranceLevel>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::EquipmentSlot_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::EquipmentSlot>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::Size_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::Size>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::SpellSelectionType_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::SpellSelectionType>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::WarningType_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::WarningType>;
}  // namespace protobuf
}  // namespace google

namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum CreationStep : int {
  CREATION_STEP_UNSPECIFIED = 0,
  CREATION_STEP_NAME = 1,
  CREATION_STEP_RACE = 2,
  CREATION_STEP_CLASS = 3,
  CREATION_STEP_BACKGROUND = 4,
  CREATION_STEP_ABILITY_SCORES = 5,
  CREATION_STEP_SKILLS = 6,
  CREATION_STEP_LANGUAGES = 7,
  CREATION_STEP_REVIEW = 8,
  CreationStep_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CreationStep_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CreationStep_internal_data_[];
inline constexpr CreationStep CreationStep_MIN =
    static_cast<CreationStep>(0);
inline constexpr CreationStep CreationStep_MAX =
    static_cast<CreationStep>(8);
inline bool CreationStep_IsValid(int value) {
  return 0 <= value && value <= 8;
}
inline constexpr int CreationStep_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CreationStep_descriptor();
template <typename T>
const ::std::string& CreationStep_Name(T value) {
  static_assert(::std::is_same<T, CreationStep>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CreationStep_Name().");
  return CreationStep_Name(static_cast<CreationStep>(value));
}
template <>
inline const ::std::string& CreationStep_Name(CreationStep value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CreationStep_descriptor, 0, 8>(
      static_cast<int>(value));
}
inline bool CreationStep_Parse(
    ::absl::string_view name, CreationStep* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CreationStep>(CreationStep_descriptor(), name,
                                           value);
}
enum WarningType : int {
  WARNING_TYPE_UNSPECIFIED = 0,
  WARNING_TYPE_MISSING_REQUIRED = 1,
  WARNING_TYPE_INVALID_COMBINATION = 2,
  WARNING_TYPE_SUBOPTIMAL_CHOICE = 3,
  WarningType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  WarningType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t WarningType_internal_data_[];
inline constexpr WarningType WarningType_MIN =
    static_cast<WarningType>(0);
inline constexpr WarningType WarningType_MAX =
    static_cast<WarningType>(3);
inline bool WarningType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int WarningType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL WarningType_descriptor();
template <typename T>
const ::std::string& WarningType_Name(T value) {
  static_assert(::std::is_same<T, WarningType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to WarningType_Name().");
  return WarningType_Name(static_cast<WarningType>(value));
}
template <>
inline const ::std::string& WarningType_Name(WarningType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WarningType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool WarningType_Parse(
    ::absl::string_view name, WarningType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<WarningType>(WarningType_descriptor(), name,
                                           value);
}
enum ChoiceCategory : int {
  CHOICE_CATEGORY_UNSPECIFIED = 0,
  CHOICE_CATEGORY_EQUIPMENT = 1,
  CHOICE_CATEGORY_SKILLS = 2,
  CHOICE_CATEGORY_TOOLS = 3,
  CHOICE_CATEGORY_LANGUAGES = 4,
  CHOICE_CATEGORY_WEAPON_PROFICIENCIES = 5,
  CHOICE_CATEGORY_ARMOR_PROFICIENCIES = 6,
  CHOICE_CATEGORY_SPELLS = 7,
  CHOICE_CATEGORY_FEATS = 8,
  CHOICE_CATEGORY_ABILITY_SCORES = 9,
  CHOICE_CATEGORY_NAME = 10,
  CHOICE_CATEGORY_FIGHTING_STYLE = 11,
  CHOICE_CATEGORY_RACE = 12,
  CHOICE_CATEGORY_CLASS = 13,
  CHOICE_CATEGORY_BACKGROUND = 14,
  CHOICE_CATEGORY_CANTRIPS = 15,
  ChoiceCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ChoiceCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ChoiceCategory_internal_data_[];
inline constexpr ChoiceCategory ChoiceCategory_MIN =
    static_cast<ChoiceCategory>(0);
inline constexpr ChoiceCategory ChoiceCategory_MAX =
    static_cast<ChoiceCategory>(15);
inline bool ChoiceCategory_IsValid(int value) {
  return 0 <= value && value <= 15;
}
inline constexpr int ChoiceCategory_ARRAYSIZE = 15 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ChoiceCategory_descriptor();
template <typename T>
const ::std::string& ChoiceCategory_Name(T value) {
  static_assert(::std::is_same<T, ChoiceCategory>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ChoiceCategory_Name().");
  return ChoiceCategory_Name(static_cast<ChoiceCategory>(value));
}
template <>
inline const ::std::string& ChoiceCategory_Name(ChoiceCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChoiceCategory_descriptor, 0, 15>(
      static_cast<int>(value));
}
inline bool ChoiceCategory_Parse(
    ::absl::string_view name, ChoiceCategory* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChoiceCategory>(ChoiceCategory_descriptor(), name,
                                           value);
}
enum Size : int {
  SIZE_UNSPECIFIED = 0,
  SIZE_TINY = 1,
  SIZE_SMALL = 2,
  SIZE_MEDIUM = 3,
  SIZE_LARGE = 4,
  SIZE_HUGE = 5,
  SIZE_GARGANTUAN = 6,
  Size_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Size_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Size_internal_data_[];
inline constexpr Size Size_MIN =
    static_cast<Size>(0);
inline constexpr Size Size_MAX =
    static_cast<Size>(6);
inline bool Size_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int Size_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Size_descriptor();
template <typename T>
const ::std::string& Size_Name(T value) {
  static_assert(::std::is_same<T, Size>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Size_Name().");
  return Size_Name(static_cast<Size>(value));
}
template <>
inline const ::std::string& Size_Name(Size value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Size_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool Size_Parse(
    ::absl::string_view name, Size* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Size>(Size_descriptor(), name,
                                           value);
}
enum SpellSelectionType : int {
  SPELL_SELECTION_TYPE_UNSPECIFIED = 0,
  SPELL_SELECTION_TYPE_SPELLBOOK = 1,
  SPELL_SELECTION_TYPE_KNOWN = 2,
  SPELL_SELECTION_TYPE_PREPARED = 3,
  SpellSelectionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SpellSelectionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SpellSelectionType_internal_data_[];
inline constexpr SpellSelectionType SpellSelectionType_MIN =
    static_cast<SpellSelectionType>(0);
inline constexpr SpellSelectionType SpellSelectionType_MAX =
    static_cast<SpellSelectionType>(3);
inline bool SpellSelectionType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int SpellSelectionType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SpellSelectionType_descriptor();
template <typename T>
const ::std::string& SpellSelectionType_Name(T value) {
  static_assert(::std::is_same<T, SpellSelectionType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SpellSelectionType_Name().");
  return SpellSelectionType_Name(static_cast<SpellSelectionType>(value));
}
template <>
inline const ::std::string& SpellSelectionType_Name(SpellSelectionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SpellSelectionType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool SpellSelectionType_Parse(
    ::absl::string_view name, SpellSelectionType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpellSelectionType>(SpellSelectionType_descriptor(), name,
                                           value);
}
enum EncumbranceLevel : int {
  ENCUMBRANCE_LEVEL_UNSPECIFIED = 0,
  ENCUMBRANCE_LEVEL_UNENCUMBERED = 1,
  ENCUMBRANCE_LEVEL_ENCUMBERED = 2,
  ENCUMBRANCE_LEVEL_HEAVILY_ENCUMBERED = 3,
  ENCUMBRANCE_LEVEL_IMMOBILIZED = 4,
  EncumbranceLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EncumbranceLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EncumbranceLevel_internal_data_[];
inline constexpr EncumbranceLevel EncumbranceLevel_MIN =
    static_cast<EncumbranceLevel>(0);
inline constexpr EncumbranceLevel EncumbranceLevel_MAX =
    static_cast<EncumbranceLevel>(4);
inline bool EncumbranceLevel_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int EncumbranceLevel_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EncumbranceLevel_descriptor();
template <typename T>
const ::std::string& EncumbranceLevel_Name(T value) {
  static_assert(::std::is_same<T, EncumbranceLevel>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EncumbranceLevel_Name().");
  return EncumbranceLevel_Name(static_cast<EncumbranceLevel>(value));
}
template <>
inline const ::std::string& EncumbranceLevel_Name(EncumbranceLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EncumbranceLevel_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool EncumbranceLevel_Parse(
    ::absl::string_view name, EncumbranceLevel* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncumbranceLevel>(EncumbranceLevel_descriptor(), name,
                                           value);
}
enum ChoiceSource : int {
  CHOICE_SOURCE_UNSPECIFIED = 0,
  CHOICE_SOURCE_PLAYER = 1,
  CHOICE_SOURCE_RACE = 2,
  CHOICE_SOURCE_SUBRACE = 3,
  CHOICE_SOURCE_CLASS = 4,
  CHOICE_SOURCE_BACKGROUND = 5,
  CHOICE_SOURCE_LEVEL_UP = 6,
  ChoiceSource_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ChoiceSource_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ChoiceSource_internal_data_[];
inline constexpr ChoiceSource ChoiceSource_MIN =
    static_cast<ChoiceSource>(0);
inline constexpr ChoiceSource ChoiceSource_MAX =
    static_cast<ChoiceSource>(6);
inline bool ChoiceSource_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int ChoiceSource_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ChoiceSource_descriptor();
template <typename T>
const ::std::string& ChoiceSource_Name(T value) {
  static_assert(::std::is_same<T, ChoiceSource>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ChoiceSource_Name().");
  return ChoiceSource_Name(static_cast<ChoiceSource>(value));
}
template <>
inline const ::std::string& ChoiceSource_Name(ChoiceSource value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChoiceSource_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool ChoiceSource_Parse(
    ::absl::string_view name, ChoiceSource* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChoiceSource>(ChoiceSource_descriptor(), name,
                                           value);
}
enum EquipmentSlot : int {
  EQUIPMENT_SLOT_UNSPECIFIED = 0,
  EQUIPMENT_SLOT_MAIN_HAND = 1,
  EQUIPMENT_SLOT_OFF_HAND = 2,
  EQUIPMENT_SLOT_ARMOR = 3,
  EQUIPMENT_SLOT_HELMET = 4,
  EQUIPMENT_SLOT_BOOTS = 5,
  EQUIPMENT_SLOT_GLOVES = 6,
  EQUIPMENT_SLOT_CLOAK = 7,
  EQUIPMENT_SLOT_AMULET = 8,
  EQUIPMENT_SLOT_RING_1 = 9,
  EQUIPMENT_SLOT_RING_2 = 10,
  EQUIPMENT_SLOT_BELT = 11,
  EquipmentSlot_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EquipmentSlot_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EquipmentSlot_internal_data_[];
inline constexpr EquipmentSlot EquipmentSlot_MIN =
    static_cast<EquipmentSlot>(0);
inline constexpr EquipmentSlot EquipmentSlot_MAX =
    static_cast<EquipmentSlot>(11);
inline bool EquipmentSlot_IsValid(int value) {
  return 0 <= value && value <= 11;
}
inline constexpr int EquipmentSlot_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EquipmentSlot_descriptor();
template <typename T>
const ::std::string& EquipmentSlot_Name(T value) {
  static_assert(::std::is_same<T, EquipmentSlot>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EquipmentSlot_Name().");
  return EquipmentSlot_Name(static_cast<EquipmentSlot>(value));
}
template <>
inline const ::std::string& EquipmentSlot_Name(EquipmentSlot value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EquipmentSlot_descriptor, 0, 11>(
      static_cast<int>(value));
}
inline bool EquipmentSlot_Parse(
    ::absl::string_view name, EquipmentSlot* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EquipmentSlot>(EquipmentSlot_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class Weight final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.Weight) */ {
 public:
  inline Weight() : Weight(nullptr) {}
  ~Weight() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Weight* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Weight));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Weight(::google::protobuf::internal::ConstantInitialized);

  inline Weight(const Weight& from) : Weight(nullptr, from) {}
  inline Weight(Weight&& from) noexcept
      : Weight(nullptr, ::std::move(from)) {}
  inline Weight& operator=(const Weight& from) {
    CopyFrom(from);
    return *this;
  }
  inline Weight& operator=(Weight&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Weight& default_instance() {
    return *reinterpret_cast<const Weight*>(
        &_Weight_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 84;
  friend void swap(Weight& a, Weight& b) { a.Swap(&b); }
  inline void Swap(Weight* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Weight* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Weight* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Weight>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Weight& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Weight& from) { Weight::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Weight* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.Weight"; }

 protected:
  explicit Weight(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Weight(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Weight& from);
  Weight(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Weight&& from) noexcept
      : Weight(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUnitFieldNumber = 2,
    kQuantityFieldNumber = 1,
  };
  // string unit = 2 [json_name = "unit"];
  void clear_unit() ;
  const ::std::string& unit() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_unit(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_unit();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_unit();
  void set_allocated_unit(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_unit() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_unit();

  public:
  // int32 quantity = 1 [json_name = "quantity"];
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.Weight)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 38,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Weight& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr unit_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Weight_class_data_;
// -------------------------------------------------------------------

class WeaponData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.WeaponData) */ {
 public:
  inline WeaponData() : WeaponData(nullptr) {}
  ~WeaponData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WeaponData* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WeaponData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WeaponData(::google::protobuf::internal::ConstantInitialized);

  inline WeaponData(const WeaponData& from) : WeaponData(nullptr, from) {}
  inline WeaponData(WeaponData&& from) noexcept
      : WeaponData(nullptr, ::std::move(from)) {}
  inline WeaponData& operator=(const WeaponData& from) {
    CopyFrom(from);
    return *this;
  }
  inline WeaponData& operator=(WeaponData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WeaponData& default_instance() {
    return *reinterpret_cast<const WeaponData*>(
        &_WeaponData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 86;
  friend void swap(WeaponData& a, WeaponData& b) { a.Swap(&b); }
  inline void Swap(WeaponData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WeaponData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WeaponData* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WeaponData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WeaponData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WeaponData& from) { WeaponData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WeaponData* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.WeaponData"; }

 protected:
  explicit WeaponData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WeaponData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WeaponData& from);
  WeaponData(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WeaponData&& from) noexcept
      : WeaponData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPropertiesFieldNumber = 4,
    kWeaponCategoryFieldNumber = 1,
    kDamageDiceFieldNumber = 2,
    kDamageTypeFieldNumber = 3,
    kRangeFieldNumber = 5,
    kNormalRangeFieldNumber = 6,
    kLongRangeFieldNumber = 7,
  };
  // repeated string properties = 4 [json_name = "properties"];
  int properties_size() const;
  private:
  int _internal_properties_size() const;

  public:
  void clear_properties() ;
  const ::std::string& properties(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_properties(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_properties(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_properties();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_properties(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& properties() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_properties();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_properties() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_properties();

  public:
  // string weapon_category = 1 [json_name = "weaponCategory"];
  void clear_weapon_category() ;
  const ::std::string& weapon_category() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_weapon_category(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_weapon_category();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_weapon_category();
  void set_allocated_weapon_category(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_weapon_category() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_weapon_category(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_weapon_category();

  public:
  // string damage_dice = 2 [json_name = "damageDice"];
  void clear_damage_dice() ;
  const ::std::string& damage_dice() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_damage_dice(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_damage_dice();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_damage_dice();
  void set_allocated_damage_dice(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_damage_dice() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_damage_dice(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_damage_dice();

  public:
  // string damage_type = 3 [json_name = "damageType"];
  void clear_damage_type() ;
  const ::std::string& damage_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_damage_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_damage_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_damage_type();
  void set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_damage_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_damage_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_damage_type();

  public:
  // string range = 5 [json_name = "range"];
  void clear_range() ;
  const ::std::string& range() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_range(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_range();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_range();
  void set_allocated_range(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_range() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_range(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_range();

  public:
  // int32 normal_range = 6 [json_name = "normalRange"];
  void clear_normal_range() ;
  ::int32_t normal_range() const;
  void set_normal_range(::int32_t value);

  private:
  ::int32_t _internal_normal_range() const;
  void _internal_set_normal_range(::int32_t value);

  public:
  // int32 long_range = 7 [json_name = "longRange"];
  void clear_long_range() ;
  ::int32_t long_range() const;
  void set_long_range(::int32_t value);

  private:
  ::int32_t _internal_long_range() const;
  void _internal_set_long_range(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.WeaponData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 90,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WeaponData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> properties_;
    ::google::protobuf::internal::ArenaStringPtr weapon_category_;
    ::google::protobuf::internal::ArenaStringPtr damage_dice_;
    ::google::protobuf::internal::ArenaStringPtr damage_type_;
    ::google::protobuf::internal::ArenaStringPtr range_;
    ::int32_t normal_range_;
    ::int32_t long_range_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WeaponData_class_data_;
// -------------------------------------------------------------------

class ValidateDraftRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ValidateDraftRequest) */ {
 public:
  inline ValidateDraftRequest() : ValidateDraftRequest(nullptr) {}
  ~ValidateDraftRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ValidateDraftRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ValidateDraftRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateDraftRequest(::google::protobuf::internal::ConstantInitialized);

  inline ValidateDraftRequest(const ValidateDraftRequest& from) : ValidateDraftRequest(nullptr, from) {}
  inline ValidateDraftRequest(ValidateDraftRequest&& from) noexcept
      : ValidateDraftRequest(nullptr, ::std::move(from)) {}
  inline ValidateDraftRequest& operator=(const ValidateDraftRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateDraftRequest& operator=(ValidateDraftRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateDraftRequest& default_instance() {
    return *reinterpret_cast<const ValidateDraftRequest*>(
        &_ValidateDraftRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(ValidateDraftRequest& a, ValidateDraftRequest& b) { a.Swap(&b); }
  inline void Swap(ValidateDraftRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateDraftRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateDraftRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ValidateDraftRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValidateDraftRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ValidateDraftRequest& from) { ValidateDraftRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ValidateDraftRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ValidateDraftRequest"; }

 protected:
  explicit ValidateDraftRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ValidateDraftRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ValidateDraftRequest& from);
  ValidateDraftRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ValidateDraftRequest&& from) noexcept
      : ValidateDraftRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDraftIdFieldNumber = 1,
  };
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ValidateDraftRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ValidateDraftRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ValidateDraftRequest_class_data_;
// -------------------------------------------------------------------

class UpdateSkillsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateSkillsRequest) */ {
 public:
  inline UpdateSkillsRequest() : UpdateSkillsRequest(nullptr) {}
  ~UpdateSkillsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateSkillsRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateSkillsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateSkillsRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateSkillsRequest(const UpdateSkillsRequest& from) : UpdateSkillsRequest(nullptr, from) {}
  inline UpdateSkillsRequest(UpdateSkillsRequest&& from) noexcept
      : UpdateSkillsRequest(nullptr, ::std::move(from)) {}
  inline UpdateSkillsRequest& operator=(const UpdateSkillsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSkillsRequest& operator=(UpdateSkillsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSkillsRequest& default_instance() {
    return *reinterpret_cast<const UpdateSkillsRequest*>(
        &_UpdateSkillsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(UpdateSkillsRequest& a, UpdateSkillsRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateSkillsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSkillsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSkillsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateSkillsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateSkillsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateSkillsRequest& from) { UpdateSkillsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateSkillsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateSkillsRequest"; }

 protected:
  explicit UpdateSkillsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateSkillsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateSkillsRequest& from);
  UpdateSkillsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateSkillsRequest&& from) noexcept
      : UpdateSkillsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkillsFieldNumber = 2,
    kDraftIdFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.Skill skills = 2 [json_name = "skills"];
  int skills_size() const;
  private:
  int _internal_skills_size() const;

  public:
  void clear_skills() ;
  public:
  ::dnd5e::api::v1alpha1::Skill skills(int index) const;
  void set_skills(int index, ::dnd5e::api::v1alpha1::Skill value);
  void add_skills(::dnd5e::api::v1alpha1::Skill value);
  const ::google::protobuf::RepeatedField<int>& skills() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_skills();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_skills() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_skills();

  public:
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateSkillsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateSkillsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> skills_;
    ::google::protobuf::internal::CachedSize _skills_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateSkillsRequest_class_data_;
// -------------------------------------------------------------------

class UpdateNameRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateNameRequest) */ {
 public:
  inline UpdateNameRequest() : UpdateNameRequest(nullptr) {}
  ~UpdateNameRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateNameRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateNameRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateNameRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateNameRequest(const UpdateNameRequest& from) : UpdateNameRequest(nullptr, from) {}
  inline UpdateNameRequest(UpdateNameRequest&& from) noexcept
      : UpdateNameRequest(nullptr, ::std::move(from)) {}
  inline UpdateNameRequest& operator=(const UpdateNameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNameRequest& operator=(UpdateNameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNameRequest& default_instance() {
    return *reinterpret_cast<const UpdateNameRequest*>(
        &_UpdateNameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(UpdateNameRequest& a, UpdateNameRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateNameRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNameRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNameRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateNameRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateNameRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateNameRequest& from) { UpdateNameRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateNameRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateNameRequest"; }

 protected:
  explicit UpdateNameRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateNameRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateNameRequest& from);
  UpdateNameRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateNameRequest&& from) noexcept
      : UpdateNameRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDraftIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateNameRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 57,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateNameRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateNameRequest_class_data_;
// -------------------------------------------------------------------

class UnequipItemRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UnequipItemRequest) */ {
 public:
  inline UnequipItemRequest() : UnequipItemRequest(nullptr) {}
  ~UnequipItemRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UnequipItemRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UnequipItemRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnequipItemRequest(::google::protobuf::internal::ConstantInitialized);

  inline UnequipItemRequest(const UnequipItemRequest& from) : UnequipItemRequest(nullptr, from) {}
  inline UnequipItemRequest(UnequipItemRequest&& from) noexcept
      : UnequipItemRequest(nullptr, ::std::move(from)) {}
  inline UnequipItemRequest& operator=(const UnequipItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnequipItemRequest& operator=(UnequipItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnequipItemRequest& default_instance() {
    return *reinterpret_cast<const UnequipItemRequest*>(
        &_UnequipItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 114;
  friend void swap(UnequipItemRequest& a, UnequipItemRequest& b) { a.Swap(&b); }
  inline void Swap(UnequipItemRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnequipItemRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnequipItemRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UnequipItemRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnequipItemRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UnequipItemRequest& from) { UnequipItemRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UnequipItemRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UnequipItemRequest"; }

 protected:
  explicit UnequipItemRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UnequipItemRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UnequipItemRequest& from);
  UnequipItemRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UnequipItemRequest&& from) noexcept
      : UnequipItemRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterIdFieldNumber = 1,
    kSlotFieldNumber = 2,
  };
  // string character_id = 1 [json_name = "characterId"];
  void clear_character_id() ;
  const ::std::string& character_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_character_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_character_id();
  void set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_character_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_character_id();

  public:
  // .dnd5e.api.v1alpha1.EquipmentSlot slot = 2 [json_name = "slot"];
  void clear_slot() ;
  ::dnd5e::api::v1alpha1::EquipmentSlot slot() const;
  void set_slot(::dnd5e::api::v1alpha1::EquipmentSlot value);

  private:
  ::dnd5e::api::v1alpha1::EquipmentSlot _internal_slot() const;
  void _internal_set_slot(::dnd5e::api::v1alpha1::EquipmentSlot value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UnequipItemRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UnequipItemRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    int slot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UnequipItemRequest_class_data_;
// -------------------------------------------------------------------

class SubraceInfo_AbilityBonusesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, ::int32_t,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  SubraceInfo_AbilityBonusesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubraceInfo_AbilityBonusesEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit SubraceInfo_AbilityBonusesEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_SubraceInfo_AbilityBonusesEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 62,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull SubraceInfo_AbilityBonusesEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class SpellcastingInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.SpellcastingInfo) */ {
 public:
  inline SpellcastingInfo() : SpellcastingInfo(nullptr) {}
  ~SpellcastingInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SpellcastingInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SpellcastingInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SpellcastingInfo(::google::protobuf::internal::ConstantInitialized);

  inline SpellcastingInfo(const SpellcastingInfo& from) : SpellcastingInfo(nullptr, from) {}
  inline SpellcastingInfo(SpellcastingInfo&& from) noexcept
      : SpellcastingInfo(nullptr, ::std::move(from)) {}
  inline SpellcastingInfo& operator=(const SpellcastingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpellcastingInfo& operator=(SpellcastingInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpellcastingInfo& default_instance() {
    return *reinterpret_cast<const SpellcastingInfo*>(
        &_SpellcastingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 61;
  friend void swap(SpellcastingInfo& a, SpellcastingInfo& b) { a.Swap(&b); }
  inline void Swap(SpellcastingInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpellcastingInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpellcastingInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SpellcastingInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpellcastingInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SpellcastingInfo& from) { SpellcastingInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SpellcastingInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.SpellcastingInfo"; }

 protected:
  explicit SpellcastingInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SpellcastingInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SpellcastingInfo& from);
  SpellcastingInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SpellcastingInfo&& from) noexcept
      : SpellcastingInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSpellcastingAbilityFieldNumber = 1,
    kSpellcastingFocusFieldNumber = 3,
    kRitualCastingFieldNumber = 2,
    kCantripsKnownFieldNumber = 4,
    kSpellsKnownFieldNumber = 5,
    kSpellSlotsLevel1FieldNumber = 6,
  };
  // string spellcasting_ability = 1 [json_name = "spellcastingAbility"];
  void clear_spellcasting_ability() ;
  const ::std::string& spellcasting_ability() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_spellcasting_ability(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_spellcasting_ability();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_spellcasting_ability();
  void set_allocated_spellcasting_ability(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_spellcasting_ability() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_spellcasting_ability(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_spellcasting_ability();

  public:
  // string spellcasting_focus = 3 [json_name = "spellcastingFocus"];
  void clear_spellcasting_focus() ;
  const ::std::string& spellcasting_focus() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_spellcasting_focus(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_spellcasting_focus();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_spellcasting_focus();
  void set_allocated_spellcasting_focus(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_spellcasting_focus() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_spellcasting_focus(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_spellcasting_focus();

  public:
  // bool ritual_casting = 2 [json_name = "ritualCasting"];
  void clear_ritual_casting() ;
  bool ritual_casting() const;
  void set_ritual_casting(bool value);

  private:
  bool _internal_ritual_casting() const;
  void _internal_set_ritual_casting(bool value);

  public:
  // int32 cantrips_known = 4 [json_name = "cantripsKnown"];
  void clear_cantrips_known() ;
  ::int32_t cantrips_known() const;
  void set_cantrips_known(::int32_t value);

  private:
  ::int32_t _internal_cantrips_known() const;
  void _internal_set_cantrips_known(::int32_t value);

  public:
  // int32 spells_known = 5 [json_name = "spellsKnown"];
  void clear_spells_known() ;
  ::int32_t spells_known() const;
  void set_spells_known(::int32_t value);

  private:
  ::int32_t _internal_spells_known() const;
  void _internal_set_spells_known(::int32_t value);

  public:
  // int32 spell_slots_level_1 = 6 [json_name = "spellSlotsLevel1"];
  void clear_spell_slots_level_1() ;
  ::int32_t spell_slots_level_1() const;
  void set_spell_slots_level_1(::int32_t value);

  private:
  ::int32_t _internal_spell_slots_level_1() const;
  void _internal_set_spell_slots_level_1(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.SpellcastingInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 82,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SpellcastingInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr spellcasting_ability_;
    ::google::protobuf::internal::ArenaStringPtr spellcasting_focus_;
    bool ritual_casting_;
    ::int32_t cantrips_known_;
    ::int32_t spells_known_;
    ::int32_t spell_slots_level_1_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SpellcastingInfo_class_data_;
// -------------------------------------------------------------------

class SpellSelectionInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.SpellSelectionInfo) */ {
 public:
  inline SpellSelectionInfo() : SpellSelectionInfo(nullptr) {}
  ~SpellSelectionInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SpellSelectionInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SpellSelectionInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SpellSelectionInfo(::google::protobuf::internal::ConstantInitialized);

  inline SpellSelectionInfo(const SpellSelectionInfo& from) : SpellSelectionInfo(nullptr, from) {}
  inline SpellSelectionInfo(SpellSelectionInfo&& from) noexcept
      : SpellSelectionInfo(nullptr, ::std::move(from)) {}
  inline SpellSelectionInfo& operator=(const SpellSelectionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpellSelectionInfo& operator=(SpellSelectionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpellSelectionInfo& default_instance() {
    return *reinterpret_cast<const SpellSelectionInfo*>(
        &_SpellSelectionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 64;
  friend void swap(SpellSelectionInfo& a, SpellSelectionInfo& b) { a.Swap(&b); }
  inline void Swap(SpellSelectionInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpellSelectionInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpellSelectionInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SpellSelectionInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpellSelectionInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SpellSelectionInfo& from) { SpellSelectionInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SpellSelectionInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.SpellSelectionInfo"; }

 protected:
  explicit SpellSelectionInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SpellSelectionInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SpellSelectionInfo& from);
  SpellSelectionInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SpellSelectionInfo&& from) noexcept
      : SpellSelectionInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSpellLevelsFieldNumber = 2,
    kSpellListsFieldNumber = 3,
    kSpellsToSelectFieldNumber = 1,
    kSelectionTypeFieldNumber = 4,
    kRequiresReplaceFieldNumber = 5,
  };
  // repeated int32 spell_levels = 2 [json_name = "spellLevels"];
  int spell_levels_size() const;
  private:
  int _internal_spell_levels_size() const;

  public:
  void clear_spell_levels() ;
  ::int32_t spell_levels(int index) const;
  void set_spell_levels(int index, ::int32_t value);
  void add_spell_levels(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& spell_levels() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_spell_levels();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_spell_levels() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_spell_levels();

  public:
  // repeated string spell_lists = 3 [json_name = "spellLists"];
  int spell_lists_size() const;
  private:
  int _internal_spell_lists_size() const;

  public:
  void clear_spell_lists() ;
  const ::std::string& spell_lists(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_spell_lists(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_spell_lists(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_spell_lists();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_spell_lists(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& spell_lists() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_spell_lists();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_spell_lists() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_spell_lists();

  public:
  // int32 spells_to_select = 1 [json_name = "spellsToSelect"];
  void clear_spells_to_select() ;
  ::int32_t spells_to_select() const;
  void set_spells_to_select(::int32_t value);

  private:
  ::int32_t _internal_spells_to_select() const;
  void _internal_set_spells_to_select(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.SpellSelectionType selection_type = 4 [json_name = "selectionType"];
  void clear_selection_type() ;
  ::dnd5e::api::v1alpha1::SpellSelectionType selection_type() const;
  void set_selection_type(::dnd5e::api::v1alpha1::SpellSelectionType value);

  private:
  ::dnd5e::api::v1alpha1::SpellSelectionType _internal_selection_type() const;
  void _internal_set_selection_type(::dnd5e::api::v1alpha1::SpellSelectionType value);

  public:
  // bool requires_replace = 5 [json_name = "requiresReplace"];
  void clear_requires_replace() ;
  bool requires_replace() const;
  void set_requires_replace(bool value);

  private:
  bool _internal_requires_replace() const;
  void _internal_set_requires_replace(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.SpellSelectionInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 57,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SpellSelectionInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> spell_levels_;
    ::google::protobuf::internal::CachedSize _spell_levels_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> spell_lists_;
    ::int32_t spells_to_select_;
    int selection_type_;
    bool requires_replace_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SpellSelectionInfo_class_data_;
// -------------------------------------------------------------------

class SpellList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.SpellList) */ {
 public:
  inline SpellList() : SpellList(nullptr) {}
  ~SpellList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SpellList* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SpellList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SpellList(::google::protobuf::internal::ConstantInitialized);

  inline SpellList(const SpellList& from) : SpellList(nullptr, from) {}
  inline SpellList(SpellList&& from) noexcept
      : SpellList(nullptr, ::std::move(from)) {}
  inline SpellList& operator=(const SpellList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpellList& operator=(SpellList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpellList& default_instance() {
    return *reinterpret_cast<const SpellList*>(
        &_SpellList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 97;
  friend void swap(SpellList& a, SpellList& b) { a.Swap(&b); }
  inline void Swap(SpellList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpellList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpellList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SpellList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpellList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SpellList& from) { SpellList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SpellList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.SpellList"; }

 protected:
  explicit SpellList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SpellList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SpellList& from);
  SpellList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SpellList&& from) noexcept
      : SpellList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSpellsFieldNumber = 1,
  };
  // repeated string spells = 1 [json_name = "spells"];
  int spells_size() const;
  private:
  int _internal_spells_size() const;

  public:
  void clear_spells() ;
  const ::std::string& spells(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_spells(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_spells(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_spells();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_spells(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& spells() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_spells();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_spells() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_spells();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.SpellList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SpellList& from_msg);
    ::google::protobuf::RepeatedPtrField<::std::string> spells_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SpellList_class_data_;
// -------------------------------------------------------------------

class SkillList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.SkillList) */ {
 public:
  inline SkillList() : SkillList(nullptr) {}
  ~SkillList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SkillList* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SkillList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SkillList(::google::protobuf::internal::ConstantInitialized);

  inline SkillList(const SkillList& from) : SkillList(nullptr, from) {}
  inline SkillList(SkillList&& from) noexcept
      : SkillList(nullptr, ::std::move(from)) {}
  inline SkillList& operator=(const SkillList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillList& operator=(SkillList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillList& default_instance() {
    return *reinterpret_cast<const SkillList*>(
        &_SkillList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 94;
  friend void swap(SkillList& a, SkillList& b) { a.Swap(&b); }
  inline void Swap(SkillList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SkillList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SkillList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SkillList& from) { SkillList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SkillList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.SkillList"; }

 protected:
  explicit SkillList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SkillList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SkillList& from);
  SkillList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SkillList&& from) noexcept
      : SkillList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkillsFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
  int skills_size() const;
  private:
  int _internal_skills_size() const;

  public:
  void clear_skills() ;
  public:
  ::dnd5e::api::v1alpha1::Skill skills(int index) const;
  void set_skills(int index, ::dnd5e::api::v1alpha1::Skill value);
  void add_skills(::dnd5e::api::v1alpha1::Skill value);
  const ::google::protobuf::RepeatedField<int>& skills() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_skills();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_skills() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_skills();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.SkillList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SkillList& from_msg);
    ::google::protobuf::RepeatedField<int> skills_;
    ::google::protobuf::internal::CachedSize _skills_cached_byte_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SkillList_class_data_;
// -------------------------------------------------------------------

class RollAssignments final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.RollAssignments) */ {
 public:
  inline RollAssignments() : RollAssignments(nullptr) {}
  ~RollAssignments() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RollAssignments* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RollAssignments));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RollAssignments(::google::protobuf::internal::ConstantInitialized);

  inline RollAssignments(const RollAssignments& from) : RollAssignments(nullptr, from) {}
  inline RollAssignments(RollAssignments&& from) noexcept
      : RollAssignments(nullptr, ::std::move(from)) {}
  inline RollAssignments& operator=(const RollAssignments& from) {
    CopyFrom(from);
    return *this;
  }
  inline RollAssignments& operator=(RollAssignments&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RollAssignments& default_instance() {
    return *reinterpret_cast<const RollAssignments*>(
        &_RollAssignments_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 82;
  friend void swap(RollAssignments& a, RollAssignments& b) { a.Swap(&b); }
  inline void Swap(RollAssignments* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RollAssignments* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RollAssignments* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RollAssignments>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RollAssignments& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RollAssignments& from) { RollAssignments::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RollAssignments* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.RollAssignments"; }

 protected:
  explicit RollAssignments(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RollAssignments(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RollAssignments& from);
  RollAssignments(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RollAssignments&& from) noexcept
      : RollAssignments(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStrengthRollIdFieldNumber = 1,
    kDexterityRollIdFieldNumber = 2,
    kConstitutionRollIdFieldNumber = 3,
    kIntelligenceRollIdFieldNumber = 4,
    kWisdomRollIdFieldNumber = 5,
    kCharismaRollIdFieldNumber = 6,
  };
  // string strength_roll_id = 1 [json_name = "strengthRollId"];
  void clear_strength_roll_id() ;
  const ::std::string& strength_roll_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_strength_roll_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_strength_roll_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_strength_roll_id();
  void set_allocated_strength_roll_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_strength_roll_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_strength_roll_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_strength_roll_id();

  public:
  // string dexterity_roll_id = 2 [json_name = "dexterityRollId"];
  void clear_dexterity_roll_id() ;
  const ::std::string& dexterity_roll_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dexterity_roll_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dexterity_roll_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dexterity_roll_id();
  void set_allocated_dexterity_roll_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dexterity_roll_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dexterity_roll_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dexterity_roll_id();

  public:
  // string constitution_roll_id = 3 [json_name = "constitutionRollId"];
  void clear_constitution_roll_id() ;
  const ::std::string& constitution_roll_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_constitution_roll_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_constitution_roll_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_constitution_roll_id();
  void set_allocated_constitution_roll_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_constitution_roll_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_constitution_roll_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_constitution_roll_id();

  public:
  // string intelligence_roll_id = 4 [json_name = "intelligenceRollId"];
  void clear_intelligence_roll_id() ;
  const ::std::string& intelligence_roll_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_intelligence_roll_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_intelligence_roll_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_intelligence_roll_id();
  void set_allocated_intelligence_roll_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_intelligence_roll_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_intelligence_roll_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_intelligence_roll_id();

  public:
  // string wisdom_roll_id = 5 [json_name = "wisdomRollId"];
  void clear_wisdom_roll_id() ;
  const ::std::string& wisdom_roll_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_wisdom_roll_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_wisdom_roll_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_wisdom_roll_id();
  void set_allocated_wisdom_roll_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_wisdom_roll_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_wisdom_roll_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_wisdom_roll_id();

  public:
  // string charisma_roll_id = 6 [json_name = "charismaRollId"];
  void clear_charisma_roll_id() ;
  const ::std::string& charisma_roll_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_charisma_roll_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_charisma_roll_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_charisma_roll_id();
  void set_allocated_charisma_roll_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_charisma_roll_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_charisma_roll_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_charisma_roll_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.RollAssignments)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 146,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RollAssignments& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr strength_roll_id_;
    ::google::protobuf::internal::ArenaStringPtr dexterity_roll_id_;
    ::google::protobuf::internal::ArenaStringPtr constitution_roll_id_;
    ::google::protobuf::internal::ArenaStringPtr intelligence_roll_id_;
    ::google::protobuf::internal::ArenaStringPtr wisdom_roll_id_;
    ::google::protobuf::internal::ArenaStringPtr charisma_roll_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RollAssignments_class_data_;
// -------------------------------------------------------------------

class RollAbilityScoresRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.RollAbilityScoresRequest) */ {
 public:
  inline RollAbilityScoresRequest() : RollAbilityScoresRequest(nullptr) {}
  ~RollAbilityScoresRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RollAbilityScoresRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RollAbilityScoresRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RollAbilityScoresRequest(::google::protobuf::internal::ConstantInitialized);

  inline RollAbilityScoresRequest(const RollAbilityScoresRequest& from) : RollAbilityScoresRequest(nullptr, from) {}
  inline RollAbilityScoresRequest(RollAbilityScoresRequest&& from) noexcept
      : RollAbilityScoresRequest(nullptr, ::std::move(from)) {}
  inline RollAbilityScoresRequest& operator=(const RollAbilityScoresRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RollAbilityScoresRequest& operator=(RollAbilityScoresRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RollAbilityScoresRequest& default_instance() {
    return *reinterpret_cast<const RollAbilityScoresRequest*>(
        &_RollAbilityScoresRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 79;
  friend void swap(RollAbilityScoresRequest& a, RollAbilityScoresRequest& b) { a.Swap(&b); }
  inline void Swap(RollAbilityScoresRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RollAbilityScoresRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RollAbilityScoresRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RollAbilityScoresRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RollAbilityScoresRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RollAbilityScoresRequest& from) { RollAbilityScoresRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RollAbilityScoresRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.RollAbilityScoresRequest"; }

 protected:
  explicit RollAbilityScoresRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RollAbilityScoresRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RollAbilityScoresRequest& from);
  RollAbilityScoresRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RollAbilityScoresRequest&& from) noexcept
      : RollAbilityScoresRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDraftIdFieldNumber = 1,
  };
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.RollAbilityScoresRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RollAbilityScoresRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RollAbilityScoresRequest_class_data_;
// -------------------------------------------------------------------

class RemoveFromInventoryRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.RemoveFromInventoryRequest) */ {
 public:
  inline RemoveFromInventoryRequest() : RemoveFromInventoryRequest(nullptr) {}
  ~RemoveFromInventoryRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RemoveFromInventoryRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RemoveFromInventoryRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoveFromInventoryRequest(::google::protobuf::internal::ConstantInitialized);

  inline RemoveFromInventoryRequest(const RemoveFromInventoryRequest& from) : RemoveFromInventoryRequest(nullptr, from) {}
  inline RemoveFromInventoryRequest(RemoveFromInventoryRequest&& from) noexcept
      : RemoveFromInventoryRequest(nullptr, ::std::move(from)) {}
  inline RemoveFromInventoryRequest& operator=(const RemoveFromInventoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveFromInventoryRequest& operator=(RemoveFromInventoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveFromInventoryRequest& default_instance() {
    return *reinterpret_cast<const RemoveFromInventoryRequest*>(
        &_RemoveFromInventoryRequest_default_instance_);
  }
  enum RemovalAmountCase {
    kQuantity = 3,
    kRemoveAll = 4,
    REMOVAL_AMOUNT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 119;
  friend void swap(RemoveFromInventoryRequest& a, RemoveFromInventoryRequest& b) { a.Swap(&b); }
  inline void Swap(RemoveFromInventoryRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveFromInventoryRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveFromInventoryRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RemoveFromInventoryRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoveFromInventoryRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoveFromInventoryRequest& from) { RemoveFromInventoryRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RemoveFromInventoryRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.RemoveFromInventoryRequest"; }

 protected:
  explicit RemoveFromInventoryRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RemoveFromInventoryRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RemoveFromInventoryRequest& from);
  RemoveFromInventoryRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RemoveFromInventoryRequest&& from) noexcept
      : RemoveFromInventoryRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterIdFieldNumber = 1,
    kItemIdFieldNumber = 2,
    kQuantityFieldNumber = 3,
    kRemoveAllFieldNumber = 4,
  };
  // string character_id = 1 [json_name = "characterId"];
  void clear_character_id() ;
  const ::std::string& character_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_character_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_character_id();
  void set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_character_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_character_id();

  public:
  // string item_id = 2 [json_name = "itemId"];
  void clear_item_id() ;
  const ::std::string& item_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_item_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_item_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_item_id();
  void set_allocated_item_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_item_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_item_id();

  public:
  // int32 quantity = 3 [json_name = "quantity"];
  bool has_quantity() const;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // bool remove_all = 4 [json_name = "removeAll"];
  bool has_remove_all() const;
  void clear_remove_all() ;
  bool remove_all() const;
  void set_remove_all(bool value);

  private:
  bool _internal_remove_all() const;
  void _internal_set_remove_all(bool value);

  public:
  void clear_removal_amount();
  RemovalAmountCase removal_amount_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.RemoveFromInventoryRequest)
 private:
  class _Internal;
  void set_has_quantity();
  void set_has_remove_all();
  inline bool has_removal_amount() const;
  inline void clear_has_removal_amount();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 4,
                                   0, 73,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RemoveFromInventoryRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    ::google::protobuf::internal::ArenaStringPtr item_id_;
    union RemovalAmountUnion {
      constexpr RemovalAmountUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t quantity_;
      bool remove_all_;
    } removal_amount_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RemoveFromInventoryRequest_class_data_;
// -------------------------------------------------------------------

class RacialTrait final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.RacialTrait) */ {
 public:
  inline RacialTrait() : RacialTrait(nullptr) {}
  ~RacialTrait() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RacialTrait* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RacialTrait));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RacialTrait(::google::protobuf::internal::ConstantInitialized);

  inline RacialTrait(const RacialTrait& from) : RacialTrait(nullptr, from) {}
  inline RacialTrait(RacialTrait&& from) noexcept
      : RacialTrait(nullptr, ::std::move(from)) {}
  inline RacialTrait& operator=(const RacialTrait& from) {
    CopyFrom(from);
    return *this;
  }
  inline RacialTrait& operator=(RacialTrait&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RacialTrait& default_instance() {
    return *reinterpret_cast<const RacialTrait*>(
        &_RacialTrait_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 50;
  friend void swap(RacialTrait& a, RacialTrait& b) { a.Swap(&b); }
  inline void Swap(RacialTrait* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RacialTrait* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RacialTrait* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RacialTrait>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RacialTrait& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RacialTrait& from) { RacialTrait::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RacialTrait* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.RacialTrait"; }

 protected:
  explicit RacialTrait(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RacialTrait(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RacialTrait& from);
  RacialTrait(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RacialTrait&& from) noexcept
      : RacialTrait(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOptionsFieldNumber = 4,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kIsChoiceFieldNumber = 3,
  };
  // repeated string options = 4 [json_name = "options"];
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  const ::std::string& options(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_options(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_options(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_options();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_options(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& options() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_options();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_options() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_options();

  public:
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // bool is_choice = 3 [json_name = "isChoice"];
  void clear_is_choice() ;
  bool is_choice() const;
  void set_is_choice(bool value);

  private:
  bool _internal_is_choice() const;
  void _internal_set_is_choice(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.RacialTrait)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 61,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RacialTrait& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> options_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    bool is_choice_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RacialTrait_class_data_;
// -------------------------------------------------------------------

class RaceInfo_AbilityBonusesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, ::int32_t,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  RaceInfo_AbilityBonusesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RaceInfo_AbilityBonusesEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit RaceInfo_AbilityBonusesEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_RaceInfo_AbilityBonusesEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 59,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull RaceInfo_AbilityBonusesEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class RaceChoice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.RaceChoice) */ {
 public:
  inline RaceChoice() : RaceChoice(nullptr) {}
  ~RaceChoice() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RaceChoice* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RaceChoice));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RaceChoice(::google::protobuf::internal::ConstantInitialized);

  inline RaceChoice(const RaceChoice& from) : RaceChoice(nullptr, from) {}
  inline RaceChoice(RaceChoice&& from) noexcept
      : RaceChoice(nullptr, ::std::move(from)) {}
  inline RaceChoice& operator=(const RaceChoice& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaceChoice& operator=(RaceChoice&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaceChoice& default_instance() {
    return *reinterpret_cast<const RaceChoice*>(
        &_RaceChoice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 99;
  friend void swap(RaceChoice& a, RaceChoice& b) { a.Swap(&b); }
  inline void Swap(RaceChoice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaceChoice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaceChoice* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RaceChoice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RaceChoice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RaceChoice& from) { RaceChoice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RaceChoice* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.RaceChoice"; }

 protected:
  explicit RaceChoice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RaceChoice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RaceChoice& from);
  RaceChoice(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RaceChoice&& from) noexcept
      : RaceChoice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRaceFieldNumber = 1,
    kSubraceFieldNumber = 2,
  };
  // .dnd5e.api.v1alpha1.Race race = 1 [json_name = "race"];
  void clear_race() ;
  ::dnd5e::api::v1alpha1::Race race() const;
  void set_race(::dnd5e::api::v1alpha1::Race value);

  private:
  ::dnd5e::api::v1alpha1::Race _internal_race() const;
  void _internal_set_race(::dnd5e::api::v1alpha1::Race value);

  public:
  // .dnd5e.api.v1alpha1.Subrace subrace = 2 [json_name = "subrace"];
  void clear_subrace() ;
  ::dnd5e::api::v1alpha1::Subrace subrace() const;
  void set_subrace(::dnd5e::api::v1alpha1::Subrace value);

  private:
  ::dnd5e::api::v1alpha1::Subrace _internal_subrace() const;
  void _internal_set_subrace(::dnd5e::api::v1alpha1::Subrace value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.RaceChoice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RaceChoice& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int race_;
    int subrace_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RaceChoice_class_data_;
// -------------------------------------------------------------------

class Proficiencies final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.Proficiencies) */ {
 public:
  inline Proficiencies() : Proficiencies(nullptr) {}
  ~Proficiencies() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Proficiencies* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Proficiencies));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Proficiencies(::google::protobuf::internal::ConstantInitialized);

  inline Proficiencies(const Proficiencies& from) : Proficiencies(nullptr, from) {}
  inline Proficiencies(Proficiencies&& from) noexcept
      : Proficiencies(nullptr, ::std::move(from)) {}
  inline Proficiencies& operator=(const Proficiencies& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proficiencies& operator=(Proficiencies&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proficiencies& default_instance() {
    return *reinterpret_cast<const Proficiencies*>(
        &_Proficiencies_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Proficiencies& a, Proficiencies& b) { a.Swap(&b); }
  inline void Swap(Proficiencies* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proficiencies* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proficiencies* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Proficiencies>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Proficiencies& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Proficiencies& from) { Proficiencies::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Proficiencies* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.Proficiencies"; }

 protected:
  explicit Proficiencies(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Proficiencies(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Proficiencies& from);
  Proficiencies(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Proficiencies&& from) noexcept
      : Proficiencies(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkillsFieldNumber = 1,
    kSavingThrowsFieldNumber = 2,
    kArmorFieldNumber = 3,
    kWeaponsFieldNumber = 4,
    kToolsFieldNumber = 5,
  };
  // repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
  int skills_size() const;
  private:
  int _internal_skills_size() const;

  public:
  void clear_skills() ;
  public:
  ::dnd5e::api::v1alpha1::Skill skills(int index) const;
  void set_skills(int index, ::dnd5e::api::v1alpha1::Skill value);
  void add_skills(::dnd5e::api::v1alpha1::Skill value);
  const ::google::protobuf::RepeatedField<int>& skills() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_skills();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_skills() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_skills();

  public:
  // repeated .dnd5e.api.v1alpha1.Ability saving_throws = 2 [json_name = "savingThrows"];
  int saving_throws_size() const;
  private:
  int _internal_saving_throws_size() const;

  public:
  void clear_saving_throws() ;
  public:
  ::dnd5e::api::v1alpha1::Ability saving_throws(int index) const;
  void set_saving_throws(int index, ::dnd5e::api::v1alpha1::Ability value);
  void add_saving_throws(::dnd5e::api::v1alpha1::Ability value);
  const ::google::protobuf::RepeatedField<int>& saving_throws() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_saving_throws();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_saving_throws() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_saving_throws();

  public:
  // repeated string armor = 3 [json_name = "armor"];
  int armor_size() const;
  private:
  int _internal_armor_size() const;

  public:
  void clear_armor() ;
  const ::std::string& armor(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_armor(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_armor(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_armor();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_armor(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& armor() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_armor();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_armor() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_armor();

  public:
  // repeated string weapons = 4 [json_name = "weapons"];
  int weapons_size() const;
  private:
  int _internal_weapons_size() const;

  public:
  void clear_weapons() ;
  const ::std::string& weapons(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_weapons(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_weapons(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_weapons();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_weapons(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& weapons() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_weapons();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_weapons() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_weapons();

  public:
  // repeated string tools = 5 [json_name = "tools"];
  int tools_size() const;
  private:
  int _internal_tools_size() const;

  public:
  void clear_tools() ;
  const ::std::string& tools(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_tools(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_tools(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_tools();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_tools(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& tools() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_tools();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_tools() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_tools();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.Proficiencies)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Proficiencies& from_msg);
    ::google::protobuf::RepeatedField<int> skills_;
    ::google::protobuf::internal::CachedSize _skills_cached_byte_size_;
    ::google::protobuf::RepeatedField<int> saving_throws_;
    ::google::protobuf::internal::CachedSize _saving_throws_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> armor_;
    ::google::protobuf::RepeatedPtrField<::std::string> weapons_;
    ::google::protobuf::RepeatedPtrField<::std::string> tools_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Proficiencies_class_data_;
// -------------------------------------------------------------------

class ListSpellsByLevelRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListSpellsByLevelRequest) */ {
 public:
  inline ListSpellsByLevelRequest() : ListSpellsByLevelRequest(nullptr) {}
  ~ListSpellsByLevelRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListSpellsByLevelRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListSpellsByLevelRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListSpellsByLevelRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListSpellsByLevelRequest(const ListSpellsByLevelRequest& from) : ListSpellsByLevelRequest(nullptr, from) {}
  inline ListSpellsByLevelRequest(ListSpellsByLevelRequest&& from) noexcept
      : ListSpellsByLevelRequest(nullptr, ::std::move(from)) {}
  inline ListSpellsByLevelRequest& operator=(const ListSpellsByLevelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSpellsByLevelRequest& operator=(ListSpellsByLevelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSpellsByLevelRequest& default_instance() {
    return *reinterpret_cast<const ListSpellsByLevelRequest*>(
        &_ListSpellsByLevelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 108;
  friend void swap(ListSpellsByLevelRequest& a, ListSpellsByLevelRequest& b) { a.Swap(&b); }
  inline void Swap(ListSpellsByLevelRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSpellsByLevelRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSpellsByLevelRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListSpellsByLevelRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListSpellsByLevelRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListSpellsByLevelRequest& from) { ListSpellsByLevelRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListSpellsByLevelRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListSpellsByLevelRequest"; }

 protected:
  explicit ListSpellsByLevelRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListSpellsByLevelRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListSpellsByLevelRequest& from);
  ListSpellsByLevelRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListSpellsByLevelRequest&& from) noexcept
      : ListSpellsByLevelRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPageTokenFieldNumber = 4,
    kLevelFieldNumber = 1,
    kClassFieldNumber = 2,
    kPageSizeFieldNumber = 3,
  };
  // string page_token = 4 [json_name = "pageToken"];
  void clear_page_token() ;
  const ::std::string& page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_page_token();
  void set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_page_token();

  public:
  // int32 level = 1 [json_name = "level"];
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.Class class = 2 [json_name = "class"];
  void clear_class_() ;
  ::dnd5e::api::v1alpha1::Class class_() const;
  void set_class_(::dnd5e::api::v1alpha1::Class value);

  private:
  ::dnd5e::api::v1alpha1::Class _internal_class_() const;
  void _internal_set_class_(::dnd5e::api::v1alpha1::Class value);

  public:
  // int32 page_size = 3 [json_name = "pageSize"];
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListSpellsByLevelRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 62,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListSpellsByLevelRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::int32_t level_;
    int class__;
    ::int32_t page_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListSpellsByLevelRequest_class_data_;
// -------------------------------------------------------------------

class ListRacesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListRacesRequest) */ {
 public:
  inline ListRacesRequest() : ListRacesRequest(nullptr) {}
  ~ListRacesRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListRacesRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListRacesRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListRacesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListRacesRequest(const ListRacesRequest& from) : ListRacesRequest(nullptr, from) {}
  inline ListRacesRequest(ListRacesRequest&& from) noexcept
      : ListRacesRequest(nullptr, ::std::move(from)) {}
  inline ListRacesRequest& operator=(const ListRacesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRacesRequest& operator=(ListRacesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRacesRequest& default_instance() {
    return *reinterpret_cast<const ListRacesRequest*>(
        &_ListRacesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 65;
  friend void swap(ListRacesRequest& a, ListRacesRequest& b) { a.Swap(&b); }
  inline void Swap(ListRacesRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRacesRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRacesRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListRacesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListRacesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListRacesRequest& from) { ListRacesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListRacesRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListRacesRequest"; }

 protected:
  explicit ListRacesRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListRacesRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListRacesRequest& from);
  ListRacesRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListRacesRequest&& from) noexcept
      : ListRacesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 1,
    kIncludeSubracesFieldNumber = 3,
  };
  // string page_token = 2 [json_name = "pageToken"];
  void clear_page_token() ;
  const ::std::string& page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_page_token();
  void set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_page_token();

  public:
  // int32 page_size = 1 [json_name = "pageSize"];
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // bool include_subraces = 3 [json_name = "includeSubraces"];
  void clear_include_subraces() ;
  bool include_subraces() const;
  void set_include_subraces(bool value);

  private:
  bool _internal_include_subraces() const;
  void _internal_set_include_subraces(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListRacesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 54,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListRacesRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::int32_t page_size_;
    bool include_subraces_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListRacesRequest_class_data_;
// -------------------------------------------------------------------

class ListEquipmentByTypeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListEquipmentByTypeRequest) */ {
 public:
  inline ListEquipmentByTypeRequest() : ListEquipmentByTypeRequest(nullptr) {}
  ~ListEquipmentByTypeRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListEquipmentByTypeRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListEquipmentByTypeRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListEquipmentByTypeRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListEquipmentByTypeRequest(const ListEquipmentByTypeRequest& from) : ListEquipmentByTypeRequest(nullptr, from) {}
  inline ListEquipmentByTypeRequest(ListEquipmentByTypeRequest&& from) noexcept
      : ListEquipmentByTypeRequest(nullptr, ::std::move(from)) {}
  inline ListEquipmentByTypeRequest& operator=(const ListEquipmentByTypeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListEquipmentByTypeRequest& operator=(ListEquipmentByTypeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListEquipmentByTypeRequest& default_instance() {
    return *reinterpret_cast<const ListEquipmentByTypeRequest*>(
        &_ListEquipmentByTypeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 106;
  friend void swap(ListEquipmentByTypeRequest& a, ListEquipmentByTypeRequest& b) { a.Swap(&b); }
  inline void Swap(ListEquipmentByTypeRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListEquipmentByTypeRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListEquipmentByTypeRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListEquipmentByTypeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListEquipmentByTypeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListEquipmentByTypeRequest& from) { ListEquipmentByTypeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListEquipmentByTypeRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListEquipmentByTypeRequest"; }

 protected:
  explicit ListEquipmentByTypeRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListEquipmentByTypeRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListEquipmentByTypeRequest& from);
  ListEquipmentByTypeRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListEquipmentByTypeRequest&& from) noexcept
      : ListEquipmentByTypeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPageTokenFieldNumber = 3,
    kEquipmentTypeFieldNumber = 1,
    kPageSizeFieldNumber = 2,
  };
  // string page_token = 3 [json_name = "pageToken"];
  void clear_page_token() ;
  const ::std::string& page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_page_token();
  void set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_page_token();

  public:
  // .dnd5e.api.v1alpha1.EquipmentType equipment_type = 1 [json_name = "equipmentType"];
  void clear_equipment_type() ;
  ::dnd5e::api::v1alpha1::EquipmentType equipment_type() const;
  void set_equipment_type(::dnd5e::api::v1alpha1::EquipmentType value);

  private:
  ::dnd5e::api::v1alpha1::EquipmentType _internal_equipment_type() const;
  void _internal_set_equipment_type(::dnd5e::api::v1alpha1::EquipmentType value);

  public:
  // int32 page_size = 2 [json_name = "pageSize"];
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListEquipmentByTypeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 64,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListEquipmentByTypeRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    int equipment_type_;
    ::int32_t page_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListEquipmentByTypeRequest_class_data_;
// -------------------------------------------------------------------

class ListDraftsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListDraftsRequest) */ {
 public:
  inline ListDraftsRequest() : ListDraftsRequest(nullptr) {}
  ~ListDraftsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListDraftsRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListDraftsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListDraftsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListDraftsRequest(const ListDraftsRequest& from) : ListDraftsRequest(nullptr, from) {}
  inline ListDraftsRequest(ListDraftsRequest&& from) noexcept
      : ListDraftsRequest(nullptr, ::std::move(from)) {}
  inline ListDraftsRequest& operator=(const ListDraftsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDraftsRequest& operator=(ListDraftsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDraftsRequest& default_instance() {
    return *reinterpret_cast<const ListDraftsRequest*>(
        &_ListDraftsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(ListDraftsRequest& a, ListDraftsRequest& b) { a.Swap(&b); }
  inline void Swap(ListDraftsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDraftsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDraftsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListDraftsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListDraftsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListDraftsRequest& from) { ListDraftsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListDraftsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListDraftsRequest"; }

 protected:
  explicit ListDraftsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListDraftsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListDraftsRequest& from);
  ListDraftsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListDraftsRequest&& from) noexcept
      : ListDraftsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerIdFieldNumber = 1,
    kSessionIdFieldNumber = 2,
    kPageTokenFieldNumber = 4,
    kPageSizeFieldNumber = 3,
  };
  // string player_id = 1 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // string session_id = 2 [json_name = "sessionId"];
  void clear_session_id() ;
  const ::std::string& session_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_session_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_session_id();
  void set_allocated_session_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_session_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_session_id();

  public:
  // string page_token = 4 [json_name = "pageToken"];
  void clear_page_token() ;
  const ::std::string& page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_page_token();
  void set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_page_token();

  public:
  // int32 page_size = 3 [json_name = "pageSize"];
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListDraftsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 74,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListDraftsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::int32_t page_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListDraftsRequest_class_data_;
// -------------------------------------------------------------------

class ListClassesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListClassesRequest) */ {
 public:
  inline ListClassesRequest() : ListClassesRequest(nullptr) {}
  ~ListClassesRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListClassesRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListClassesRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListClassesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListClassesRequest(const ListClassesRequest& from) : ListClassesRequest(nullptr, from) {}
  inline ListClassesRequest(ListClassesRequest&& from) noexcept
      : ListClassesRequest(nullptr, ::std::move(from)) {}
  inline ListClassesRequest& operator=(const ListClassesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListClassesRequest& operator=(ListClassesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListClassesRequest& default_instance() {
    return *reinterpret_cast<const ListClassesRequest*>(
        &_ListClassesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 67;
  friend void swap(ListClassesRequest& a, ListClassesRequest& b) { a.Swap(&b); }
  inline void Swap(ListClassesRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListClassesRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListClassesRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListClassesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListClassesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListClassesRequest& from) { ListClassesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListClassesRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListClassesRequest"; }

 protected:
  explicit ListClassesRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListClassesRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListClassesRequest& from);
  ListClassesRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListClassesRequest&& from) noexcept
      : ListClassesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 1,
    kIncludeSpellcastersOnlyFieldNumber = 3,
    kIncludeFeaturesFieldNumber = 4,
  };
  // string page_token = 2 [json_name = "pageToken"];
  void clear_page_token() ;
  const ::std::string& page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_page_token();
  void set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_page_token();

  public:
  // int32 page_size = 1 [json_name = "pageSize"];
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // bool include_spellcasters_only = 3 [json_name = "includeSpellcastersOnly"];
  void clear_include_spellcasters_only() ;
  bool include_spellcasters_only() const;
  void set_include_spellcasters_only(bool value);

  private:
  bool _internal_include_spellcasters_only() const;
  void _internal_set_include_spellcasters_only(bool value);

  public:
  // bool include_features = 4 [json_name = "includeFeatures"];
  void clear_include_features() ;
  bool include_features() const;
  void set_include_features(bool value);

  private:
  bool _internal_include_features() const;
  void _internal_set_include_features(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListClassesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListClassesRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::int32_t page_size_;
    bool include_spellcasters_only_;
    bool include_features_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListClassesRequest_class_data_;
// -------------------------------------------------------------------

class ListCharactersRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListCharactersRequest) */ {
 public:
  inline ListCharactersRequest() : ListCharactersRequest(nullptr) {}
  ~ListCharactersRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListCharactersRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListCharactersRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListCharactersRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListCharactersRequest(const ListCharactersRequest& from) : ListCharactersRequest(nullptr, from) {}
  inline ListCharactersRequest(ListCharactersRequest&& from) noexcept
      : ListCharactersRequest(nullptr, ::std::move(from)) {}
  inline ListCharactersRequest& operator=(const ListCharactersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCharactersRequest& operator=(ListCharactersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListCharactersRequest& default_instance() {
    return *reinterpret_cast<const ListCharactersRequest*>(
        &_ListCharactersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(ListCharactersRequest& a, ListCharactersRequest& b) { a.Swap(&b); }
  inline void Swap(ListCharactersRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCharactersRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListCharactersRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListCharactersRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListCharactersRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListCharactersRequest& from) { ListCharactersRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListCharactersRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListCharactersRequest"; }

 protected:
  explicit ListCharactersRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListCharactersRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListCharactersRequest& from);
  ListCharactersRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListCharactersRequest&& from) noexcept
      : ListCharactersRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPageTokenFieldNumber = 2,
    kSessionIdFieldNumber = 3,
    kPlayerIdFieldNumber = 4,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2 [json_name = "pageToken"];
  void clear_page_token() ;
  const ::std::string& page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_page_token();
  void set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_page_token();

  public:
  // string session_id = 3 [json_name = "sessionId"];
  void clear_session_id() ;
  const ::std::string& session_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_session_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_session_id();
  void set_allocated_session_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_session_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_session_id();

  public:
  // string player_id = 4 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // int32 page_size = 1 [json_name = "pageSize"];
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListCharactersRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 78,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListCharactersRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::int32_t page_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListCharactersRequest_class_data_;
// -------------------------------------------------------------------

class ListBackgroundsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListBackgroundsRequest) */ {
 public:
  inline ListBackgroundsRequest() : ListBackgroundsRequest(nullptr) {}
  ~ListBackgroundsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListBackgroundsRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListBackgroundsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListBackgroundsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListBackgroundsRequest(const ListBackgroundsRequest& from) : ListBackgroundsRequest(nullptr, from) {}
  inline ListBackgroundsRequest(ListBackgroundsRequest&& from) noexcept
      : ListBackgroundsRequest(nullptr, ::std::move(from)) {}
  inline ListBackgroundsRequest& operator=(const ListBackgroundsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListBackgroundsRequest& operator=(ListBackgroundsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListBackgroundsRequest& default_instance() {
    return *reinterpret_cast<const ListBackgroundsRequest*>(
        &_ListBackgroundsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 69;
  friend void swap(ListBackgroundsRequest& a, ListBackgroundsRequest& b) { a.Swap(&b); }
  inline void Swap(ListBackgroundsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListBackgroundsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListBackgroundsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListBackgroundsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListBackgroundsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListBackgroundsRequest& from) { ListBackgroundsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListBackgroundsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListBackgroundsRequest"; }

 protected:
  explicit ListBackgroundsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListBackgroundsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListBackgroundsRequest& from);
  ListBackgroundsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListBackgroundsRequest&& from) noexcept
      : ListBackgroundsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2 [json_name = "pageToken"];
  void clear_page_token() ;
  const ::std::string& page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_page_token();
  void set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_page_token();

  public:
  // int32 page_size = 1 [json_name = "pageSize"];
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListBackgroundsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListBackgroundsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::int32_t page_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListBackgroundsRequest_class_data_;
// -------------------------------------------------------------------

class LanguageList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.LanguageList) */ {
 public:
  inline LanguageList() : LanguageList(nullptr) {}
  ~LanguageList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LanguageList* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LanguageList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LanguageList(::google::protobuf::internal::ConstantInitialized);

  inline LanguageList(const LanguageList& from) : LanguageList(nullptr, from) {}
  inline LanguageList(LanguageList&& from) noexcept
      : LanguageList(nullptr, ::std::move(from)) {}
  inline LanguageList& operator=(const LanguageList& from) {
    CopyFrom(from);
    return *this;
  }
  inline LanguageList& operator=(LanguageList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LanguageList& default_instance() {
    return *reinterpret_cast<const LanguageList*>(
        &_LanguageList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 95;
  friend void swap(LanguageList& a, LanguageList& b) { a.Swap(&b); }
  inline void Swap(LanguageList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LanguageList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LanguageList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LanguageList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LanguageList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LanguageList& from) { LanguageList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LanguageList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.LanguageList"; }

 protected:
  explicit LanguageList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LanguageList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LanguageList& from);
  LanguageList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LanguageList&& from) noexcept
      : LanguageList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLanguagesFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.Language languages = 1 [json_name = "languages"];
  int languages_size() const;
  private:
  int _internal_languages_size() const;

  public:
  void clear_languages() ;
  public:
  ::dnd5e::api::v1alpha1::Language languages(int index) const;
  void set_languages(int index, ::dnd5e::api::v1alpha1::Language value);
  void add_languages(::dnd5e::api::v1alpha1::Language value);
  const ::google::protobuf::RepeatedField<int>& languages() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_languages();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_languages() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_languages();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.LanguageList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LanguageList& from_msg);
    ::google::protobuf::RepeatedField<int> languages_;
    ::google::protobuf::internal::CachedSize _languages_cached_byte_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LanguageList_class_data_;
// -------------------------------------------------------------------

class ItemReference final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ItemReference) */ {
 public:
  inline ItemReference() : ItemReference(nullptr) {}
  ~ItemReference() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ItemReference* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ItemReference));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ItemReference(::google::protobuf::internal::ConstantInitialized);

  inline ItemReference(const ItemReference& from) : ItemReference(nullptr, from) {}
  inline ItemReference(ItemReference&& from) noexcept
      : ItemReference(nullptr, ::std::move(from)) {}
  inline ItemReference& operator=(const ItemReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemReference& operator=(ItemReference&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemReference& default_instance() {
    return *reinterpret_cast<const ItemReference*>(
        &_ItemReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 55;
  friend void swap(ItemReference& a, ItemReference& b) { a.Swap(&b); }
  inline void Swap(ItemReference* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemReference* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemReference* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ItemReference>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ItemReference& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ItemReference& from) { ItemReference::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ItemReference* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ItemReference"; }

 protected:
  explicit ItemReference(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ItemReference(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ItemReference& from);
  ItemReference(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ItemReference&& from) noexcept
      : ItemReference(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id() ;
  const ::std::string& item_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_item_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_item_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_item_id();
  void set_allocated_item_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_item_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_item_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ItemReference)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ItemReference& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr item_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ItemReference_class_data_;
// -------------------------------------------------------------------

class InventoryAddition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.InventoryAddition) */ {
 public:
  inline InventoryAddition() : InventoryAddition(nullptr) {}
  ~InventoryAddition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InventoryAddition* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InventoryAddition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InventoryAddition(::google::protobuf::internal::ConstantInitialized);

  inline InventoryAddition(const InventoryAddition& from) : InventoryAddition(nullptr, from) {}
  inline InventoryAddition(InventoryAddition&& from) noexcept
      : InventoryAddition(nullptr, ::std::move(from)) {}
  inline InventoryAddition& operator=(const InventoryAddition& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryAddition& operator=(InventoryAddition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryAddition& default_instance() {
    return *reinterpret_cast<const InventoryAddition*>(
        &_InventoryAddition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 117;
  friend void swap(InventoryAddition& a, InventoryAddition& b) { a.Swap(&b); }
  inline void Swap(InventoryAddition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryAddition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryAddition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InventoryAddition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InventoryAddition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InventoryAddition& from) { InventoryAddition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InventoryAddition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.InventoryAddition"; }

 protected:
  explicit InventoryAddition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InventoryAddition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InventoryAddition& from);
  InventoryAddition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InventoryAddition&& from) noexcept
      : InventoryAddition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id() ;
  const ::std::string& item_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_item_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_item_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_item_id();
  void set_allocated_item_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_item_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_item_id();

  public:
  // int32 quantity = 2 [json_name = "quantity"];
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.InventoryAddition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InventoryAddition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr item_id_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InventoryAddition_class_data_;
// -------------------------------------------------------------------

class GetRaceDetailsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetRaceDetailsRequest) */ {
 public:
  inline GetRaceDetailsRequest() : GetRaceDetailsRequest(nullptr) {}
  ~GetRaceDetailsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetRaceDetailsRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetRaceDetailsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetRaceDetailsRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetRaceDetailsRequest(const GetRaceDetailsRequest& from) : GetRaceDetailsRequest(nullptr, from) {}
  inline GetRaceDetailsRequest(GetRaceDetailsRequest&& from) noexcept
      : GetRaceDetailsRequest(nullptr, ::std::move(from)) {}
  inline GetRaceDetailsRequest& operator=(const GetRaceDetailsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRaceDetailsRequest& operator=(GetRaceDetailsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRaceDetailsRequest& default_instance() {
    return *reinterpret_cast<const GetRaceDetailsRequest*>(
        &_GetRaceDetailsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 71;
  friend void swap(GetRaceDetailsRequest& a, GetRaceDetailsRequest& b) { a.Swap(&b); }
  inline void Swap(GetRaceDetailsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRaceDetailsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRaceDetailsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetRaceDetailsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetRaceDetailsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetRaceDetailsRequest& from) { GetRaceDetailsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetRaceDetailsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetRaceDetailsRequest"; }

 protected:
  explicit GetRaceDetailsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetRaceDetailsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetRaceDetailsRequest& from);
  GetRaceDetailsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetRaceDetailsRequest&& from) noexcept
      : GetRaceDetailsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRaceIdFieldNumber = 1,
  };
  // string race_id = 1 [json_name = "raceId"];
  void clear_race_id() ;
  const ::std::string& race_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_race_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_race_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_race_id();
  void set_allocated_race_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_race_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_race_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_race_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetRaceDetailsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetRaceDetailsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr race_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetRaceDetailsRequest_class_data_;
// -------------------------------------------------------------------

class GetFeatureRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetFeatureRequest) */ {
 public:
  inline GetFeatureRequest() : GetFeatureRequest(nullptr) {}
  ~GetFeatureRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetFeatureRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetFeatureRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetFeatureRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetFeatureRequest(const GetFeatureRequest& from) : GetFeatureRequest(nullptr, from) {}
  inline GetFeatureRequest(GetFeatureRequest&& from) noexcept
      : GetFeatureRequest(nullptr, ::std::move(from)) {}
  inline GetFeatureRequest& operator=(const GetFeatureRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFeatureRequest& operator=(GetFeatureRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFeatureRequest& default_instance() {
    return *reinterpret_cast<const GetFeatureRequest*>(
        &_GetFeatureRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 77;
  friend void swap(GetFeatureRequest& a, GetFeatureRequest& b) { a.Swap(&b); }
  inline void Swap(GetFeatureRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFeatureRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFeatureRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetFeatureRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetFeatureRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetFeatureRequest& from) { GetFeatureRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetFeatureRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetFeatureRequest"; }

 protected:
  explicit GetFeatureRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetFeatureRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetFeatureRequest& from);
  GetFeatureRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetFeatureRequest&& from) noexcept
      : GetFeatureRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFeatureIdFieldNumber = 1,
  };
  // string feature_id = 1 [json_name = "featureId"];
  void clear_feature_id() ;
  const ::std::string& feature_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_feature_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_feature_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_feature_id();
  void set_allocated_feature_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_feature_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_feature_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_feature_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetFeatureRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetFeatureRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr feature_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetFeatureRequest_class_data_;
// -------------------------------------------------------------------

class GetDraftRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetDraftRequest) */ {
 public:
  inline GetDraftRequest() : GetDraftRequest(nullptr) {}
  ~GetDraftRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetDraftRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetDraftRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetDraftRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetDraftRequest(const GetDraftRequest& from) : GetDraftRequest(nullptr, from) {}
  inline GetDraftRequest(GetDraftRequest&& from) noexcept
      : GetDraftRequest(nullptr, ::std::move(from)) {}
  inline GetDraftRequest& operator=(const GetDraftRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDraftRequest& operator=(GetDraftRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDraftRequest& default_instance() {
    return *reinterpret_cast<const GetDraftRequest*>(
        &_GetDraftRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(GetDraftRequest& a, GetDraftRequest& b) { a.Swap(&b); }
  inline void Swap(GetDraftRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDraftRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDraftRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetDraftRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetDraftRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetDraftRequest& from) { GetDraftRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetDraftRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetDraftRequest"; }

 protected:
  explicit GetDraftRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetDraftRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetDraftRequest& from);
  GetDraftRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetDraftRequest&& from) noexcept
      : GetDraftRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDraftIdFieldNumber = 1,
  };
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetDraftRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetDraftRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetDraftRequest_class_data_;
// -------------------------------------------------------------------

class GetDraftPreviewRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetDraftPreviewRequest) */ {
 public:
  inline GetDraftPreviewRequest() : GetDraftPreviewRequest(nullptr) {}
  ~GetDraftPreviewRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetDraftPreviewRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetDraftPreviewRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetDraftPreviewRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetDraftPreviewRequest(const GetDraftPreviewRequest& from) : GetDraftPreviewRequest(nullptr, from) {}
  inline GetDraftPreviewRequest(GetDraftPreviewRequest&& from) noexcept
      : GetDraftPreviewRequest(nullptr, ::std::move(from)) {}
  inline GetDraftPreviewRequest& operator=(const GetDraftPreviewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDraftPreviewRequest& operator=(GetDraftPreviewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDraftPreviewRequest& default_instance() {
    return *reinterpret_cast<const GetDraftPreviewRequest*>(
        &_GetDraftPreviewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(GetDraftPreviewRequest& a, GetDraftPreviewRequest& b) { a.Swap(&b); }
  inline void Swap(GetDraftPreviewRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDraftPreviewRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDraftPreviewRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetDraftPreviewRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetDraftPreviewRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetDraftPreviewRequest& from) { GetDraftPreviewRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetDraftPreviewRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetDraftPreviewRequest"; }

 protected:
  explicit GetDraftPreviewRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetDraftPreviewRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetDraftPreviewRequest& from);
  GetDraftPreviewRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetDraftPreviewRequest&& from) noexcept
      : GetDraftPreviewRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDraftIdFieldNumber = 1,
  };
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetDraftPreviewRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetDraftPreviewRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetDraftPreviewRequest_class_data_;
// -------------------------------------------------------------------

class GetClassDetailsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetClassDetailsRequest) */ {
 public:
  inline GetClassDetailsRequest() : GetClassDetailsRequest(nullptr) {}
  ~GetClassDetailsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetClassDetailsRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetClassDetailsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetClassDetailsRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetClassDetailsRequest(const GetClassDetailsRequest& from) : GetClassDetailsRequest(nullptr, from) {}
  inline GetClassDetailsRequest(GetClassDetailsRequest&& from) noexcept
      : GetClassDetailsRequest(nullptr, ::std::move(from)) {}
  inline GetClassDetailsRequest& operator=(const GetClassDetailsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetClassDetailsRequest& operator=(GetClassDetailsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetClassDetailsRequest& default_instance() {
    return *reinterpret_cast<const GetClassDetailsRequest*>(
        &_GetClassDetailsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 73;
  friend void swap(GetClassDetailsRequest& a, GetClassDetailsRequest& b) { a.Swap(&b); }
  inline void Swap(GetClassDetailsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetClassDetailsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetClassDetailsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetClassDetailsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetClassDetailsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetClassDetailsRequest& from) { GetClassDetailsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetClassDetailsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetClassDetailsRequest"; }

 protected:
  explicit GetClassDetailsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetClassDetailsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetClassDetailsRequest& from);
  GetClassDetailsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetClassDetailsRequest&& from) noexcept
      : GetClassDetailsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClassIdFieldNumber = 1,
  };
  // string class_id = 1 [json_name = "classId"];
  void clear_class_id() ;
  const ::std::string& class_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_class_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_class_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_class_id();
  void set_allocated_class_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_class_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_class_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_class_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetClassDetailsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetClassDetailsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr class_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetClassDetailsRequest_class_data_;
// -------------------------------------------------------------------

class GetCharacterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetCharacterRequest) */ {
 public:
  inline GetCharacterRequest() : GetCharacterRequest(nullptr) {}
  ~GetCharacterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCharacterRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCharacterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCharacterRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetCharacterRequest(const GetCharacterRequest& from) : GetCharacterRequest(nullptr, from) {}
  inline GetCharacterRequest(GetCharacterRequest&& from) noexcept
      : GetCharacterRequest(nullptr, ::std::move(from)) {}
  inline GetCharacterRequest& operator=(const GetCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCharacterRequest& operator=(GetCharacterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCharacterRequest& default_instance() {
    return *reinterpret_cast<const GetCharacterRequest*>(
        &_GetCharacterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(GetCharacterRequest& a, GetCharacterRequest& b) { a.Swap(&b); }
  inline void Swap(GetCharacterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCharacterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCharacterRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCharacterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCharacterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCharacterRequest& from) { GetCharacterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCharacterRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetCharacterRequest"; }

 protected:
  explicit GetCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCharacterRequest& from);
  GetCharacterRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCharacterRequest&& from) noexcept
      : GetCharacterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterIdFieldNumber = 1,
  };
  // string character_id = 1 [json_name = "characterId"];
  void clear_character_id() ;
  const ::std::string& character_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_character_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_character_id();
  void set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_character_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_character_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetCharacterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCharacterRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCharacterRequest_class_data_;
// -------------------------------------------------------------------

class GetCharacterInventoryRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetCharacterInventoryRequest) */ {
 public:
  inline GetCharacterInventoryRequest() : GetCharacterInventoryRequest(nullptr) {}
  ~GetCharacterInventoryRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCharacterInventoryRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCharacterInventoryRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCharacterInventoryRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetCharacterInventoryRequest(const GetCharacterInventoryRequest& from) : GetCharacterInventoryRequest(nullptr, from) {}
  inline GetCharacterInventoryRequest(GetCharacterInventoryRequest&& from) noexcept
      : GetCharacterInventoryRequest(nullptr, ::std::move(from)) {}
  inline GetCharacterInventoryRequest& operator=(const GetCharacterInventoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCharacterInventoryRequest& operator=(GetCharacterInventoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCharacterInventoryRequest& default_instance() {
    return *reinterpret_cast<const GetCharacterInventoryRequest*>(
        &_GetCharacterInventoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 110;
  friend void swap(GetCharacterInventoryRequest& a, GetCharacterInventoryRequest& b) { a.Swap(&b); }
  inline void Swap(GetCharacterInventoryRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCharacterInventoryRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCharacterInventoryRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCharacterInventoryRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCharacterInventoryRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCharacterInventoryRequest& from) { GetCharacterInventoryRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCharacterInventoryRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetCharacterInventoryRequest"; }

 protected:
  explicit GetCharacterInventoryRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCharacterInventoryRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCharacterInventoryRequest& from);
  GetCharacterInventoryRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCharacterInventoryRequest&& from) noexcept
      : GetCharacterInventoryRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterIdFieldNumber = 1,
  };
  // string character_id = 1 [json_name = "characterId"];
  void clear_character_id() ;
  const ::std::string& character_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_character_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_character_id();
  void set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_character_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_character_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetCharacterInventoryRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 68,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCharacterInventoryRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCharacterInventoryRequest_class_data_;
// -------------------------------------------------------------------

class GetBackgroundDetailsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetBackgroundDetailsRequest) */ {
 public:
  inline GetBackgroundDetailsRequest() : GetBackgroundDetailsRequest(nullptr) {}
  ~GetBackgroundDetailsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetBackgroundDetailsRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetBackgroundDetailsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBackgroundDetailsRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetBackgroundDetailsRequest(const GetBackgroundDetailsRequest& from) : GetBackgroundDetailsRequest(nullptr, from) {}
  inline GetBackgroundDetailsRequest(GetBackgroundDetailsRequest&& from) noexcept
      : GetBackgroundDetailsRequest(nullptr, ::std::move(from)) {}
  inline GetBackgroundDetailsRequest& operator=(const GetBackgroundDetailsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBackgroundDetailsRequest& operator=(GetBackgroundDetailsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBackgroundDetailsRequest& default_instance() {
    return *reinterpret_cast<const GetBackgroundDetailsRequest*>(
        &_GetBackgroundDetailsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 75;
  friend void swap(GetBackgroundDetailsRequest& a, GetBackgroundDetailsRequest& b) { a.Swap(&b); }
  inline void Swap(GetBackgroundDetailsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBackgroundDetailsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBackgroundDetailsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetBackgroundDetailsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBackgroundDetailsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetBackgroundDetailsRequest& from) { GetBackgroundDetailsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetBackgroundDetailsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetBackgroundDetailsRequest"; }

 protected:
  explicit GetBackgroundDetailsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetBackgroundDetailsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetBackgroundDetailsRequest& from);
  GetBackgroundDetailsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetBackgroundDetailsRequest&& from) noexcept
      : GetBackgroundDetailsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBackgroundIdFieldNumber = 1,
  };
  // string background_id = 1 [json_name = "backgroundId"];
  void clear_background_id() ;
  const ::std::string& background_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_background_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_background_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_background_id();
  void set_allocated_background_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_background_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_background_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_background_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetBackgroundDetailsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 68,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetBackgroundDetailsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr background_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetBackgroundDetailsRequest_class_data_;
// -------------------------------------------------------------------

class GearData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GearData) */ {
 public:
  inline GearData() : GearData(nullptr) {}
  ~GearData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GearData* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GearData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GearData(::google::protobuf::internal::ConstantInitialized);

  inline GearData(const GearData& from) : GearData(nullptr, from) {}
  inline GearData(GearData&& from) noexcept
      : GearData(nullptr, ::std::move(from)) {}
  inline GearData& operator=(const GearData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GearData& operator=(GearData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GearData& default_instance() {
    return *reinterpret_cast<const GearData*>(
        &_GearData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 88;
  friend void swap(GearData& a, GearData& b) { a.Swap(&b); }
  inline void Swap(GearData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GearData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GearData* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GearData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GearData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GearData& from) { GearData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GearData* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GearData"; }

 protected:
  explicit GearData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GearData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GearData& from);
  GearData(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GearData&& from) noexcept
      : GearData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPropertiesFieldNumber = 2,
    kGearCategoryFieldNumber = 1,
  };
  // repeated string properties = 2 [json_name = "properties"];
  int properties_size() const;
  private:
  int _internal_properties_size() const;

  public:
  void clear_properties() ;
  const ::std::string& properties(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_properties(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_properties(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_properties();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_properties(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& properties() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_properties();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_properties() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_properties();

  public:
  // string gear_category = 1 [json_name = "gearCategory"];
  void clear_gear_category() ;
  const ::std::string& gear_category() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_gear_category(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_gear_category();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_gear_category();
  void set_allocated_gear_category(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_gear_category() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_gear_category(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_gear_category();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GearData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GearData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> properties_;
    ::google::protobuf::internal::ArenaStringPtr gear_category_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GearData_class_data_;
// -------------------------------------------------------------------

class FinalizeDraftRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.FinalizeDraftRequest) */ {
 public:
  inline FinalizeDraftRequest() : FinalizeDraftRequest(nullptr) {}
  ~FinalizeDraftRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FinalizeDraftRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FinalizeDraftRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FinalizeDraftRequest(::google::protobuf::internal::ConstantInitialized);

  inline FinalizeDraftRequest(const FinalizeDraftRequest& from) : FinalizeDraftRequest(nullptr, from) {}
  inline FinalizeDraftRequest(FinalizeDraftRequest&& from) noexcept
      : FinalizeDraftRequest(nullptr, ::std::move(from)) {}
  inline FinalizeDraftRequest& operator=(const FinalizeDraftRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinalizeDraftRequest& operator=(FinalizeDraftRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FinalizeDraftRequest& default_instance() {
    return *reinterpret_cast<const FinalizeDraftRequest*>(
        &_FinalizeDraftRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(FinalizeDraftRequest& a, FinalizeDraftRequest& b) { a.Swap(&b); }
  inline void Swap(FinalizeDraftRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinalizeDraftRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinalizeDraftRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FinalizeDraftRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FinalizeDraftRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FinalizeDraftRequest& from) { FinalizeDraftRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FinalizeDraftRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.FinalizeDraftRequest"; }

 protected:
  explicit FinalizeDraftRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FinalizeDraftRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FinalizeDraftRequest& from);
  FinalizeDraftRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FinalizeDraftRequest&& from) noexcept
      : FinalizeDraftRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDraftIdFieldNumber = 1,
  };
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.FinalizeDraftRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FinalizeDraftRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FinalizeDraftRequest_class_data_;
// -------------------------------------------------------------------

class EquipmentList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EquipmentList) */ {
 public:
  inline EquipmentList() : EquipmentList(nullptr) {}
  ~EquipmentList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EquipmentList* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EquipmentList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EquipmentList(::google::protobuf::internal::ConstantInitialized);

  inline EquipmentList(const EquipmentList& from) : EquipmentList(nullptr, from) {}
  inline EquipmentList(EquipmentList&& from) noexcept
      : EquipmentList(nullptr, ::std::move(from)) {}
  inline EquipmentList& operator=(const EquipmentList& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentList& operator=(EquipmentList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentList& default_instance() {
    return *reinterpret_cast<const EquipmentList*>(
        &_EquipmentList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 96;
  friend void swap(EquipmentList& a, EquipmentList& b) { a.Swap(&b); }
  inline void Swap(EquipmentList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EquipmentList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EquipmentList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EquipmentList& from) { EquipmentList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EquipmentList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EquipmentList"; }

 protected:
  explicit EquipmentList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EquipmentList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EquipmentList& from);
  EquipmentList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EquipmentList&& from) noexcept
      : EquipmentList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated string items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const ::std::string& items(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_items(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_items(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_items();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_items(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& items() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EquipmentList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EquipmentList& from_msg);
    ::google::protobuf::RepeatedPtrField<::std::string> items_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EquipmentList_class_data_;
// -------------------------------------------------------------------

class EquipItemRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EquipItemRequest) */ {
 public:
  inline EquipItemRequest() : EquipItemRequest(nullptr) {}
  ~EquipItemRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EquipItemRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EquipItemRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EquipItemRequest(::google::protobuf::internal::ConstantInitialized);

  inline EquipItemRequest(const EquipItemRequest& from) : EquipItemRequest(nullptr, from) {}
  inline EquipItemRequest(EquipItemRequest&& from) noexcept
      : EquipItemRequest(nullptr, ::std::move(from)) {}
  inline EquipItemRequest& operator=(const EquipItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipItemRequest& operator=(EquipItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipItemRequest& default_instance() {
    return *reinterpret_cast<const EquipItemRequest*>(
        &_EquipItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 112;
  friend void swap(EquipItemRequest& a, EquipItemRequest& b) { a.Swap(&b); }
  inline void Swap(EquipItemRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipItemRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipItemRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EquipItemRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EquipItemRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EquipItemRequest& from) { EquipItemRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EquipItemRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EquipItemRequest"; }

 protected:
  explicit EquipItemRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EquipItemRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EquipItemRequest& from);
  EquipItemRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EquipItemRequest&& from) noexcept
      : EquipItemRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterIdFieldNumber = 1,
    kItemIdFieldNumber = 2,
    kSlotFieldNumber = 3,
  };
  // string character_id = 1 [json_name = "characterId"];
  void clear_character_id() ;
  const ::std::string& character_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_character_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_character_id();
  void set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_character_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_character_id();

  public:
  // string item_id = 2 [json_name = "itemId"];
  void clear_item_id() ;
  const ::std::string& item_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_item_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_item_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_item_id();
  void set_allocated_item_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_item_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_item_id();

  public:
  // .dnd5e.api.v1alpha1.EquipmentSlot slot = 3 [json_name = "slot"];
  void clear_slot() ;
  ::dnd5e::api::v1alpha1::EquipmentSlot slot() const;
  void set_slot(::dnd5e::api::v1alpha1::EquipmentSlot value);

  private:
  ::dnd5e::api::v1alpha1::EquipmentSlot _internal_slot() const;
  void _internal_set_slot(::dnd5e::api::v1alpha1::EquipmentSlot value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EquipItemRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 63,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EquipItemRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    ::google::protobuf::internal::ArenaStringPtr item_id_;
    int slot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EquipItemRequest_class_data_;
// -------------------------------------------------------------------

class EncumbranceInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EncumbranceInfo) */ {
 public:
  inline EncumbranceInfo() : EncumbranceInfo(nullptr) {}
  ~EncumbranceInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EncumbranceInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EncumbranceInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EncumbranceInfo(::google::protobuf::internal::ConstantInitialized);

  inline EncumbranceInfo(const EncumbranceInfo& from) : EncumbranceInfo(nullptr, from) {}
  inline EncumbranceInfo(EncumbranceInfo&& from) noexcept
      : EncumbranceInfo(nullptr, ::std::move(from)) {}
  inline EncumbranceInfo& operator=(const EncumbranceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncumbranceInfo& operator=(EncumbranceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncumbranceInfo& default_instance() {
    return *reinterpret_cast<const EncumbranceInfo*>(
        &_EncumbranceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 91;
  friend void swap(EncumbranceInfo& a, EncumbranceInfo& b) { a.Swap(&b); }
  inline void Swap(EncumbranceInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncumbranceInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncumbranceInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EncumbranceInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EncumbranceInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EncumbranceInfo& from) { EncumbranceInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EncumbranceInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EncumbranceInfo"; }

 protected:
  explicit EncumbranceInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EncumbranceInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EncumbranceInfo& from);
  EncumbranceInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EncumbranceInfo&& from) noexcept
      : EncumbranceInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCurrentWeightFieldNumber = 1,
    kCarryingCapacityFieldNumber = 2,
    kMaxCapacityFieldNumber = 3,
    kLevelFieldNumber = 4,
  };
  // int32 current_weight = 1 [json_name = "currentWeight"];
  void clear_current_weight() ;
  ::int32_t current_weight() const;
  void set_current_weight(::int32_t value);

  private:
  ::int32_t _internal_current_weight() const;
  void _internal_set_current_weight(::int32_t value);

  public:
  // int32 carrying_capacity = 2 [json_name = "carryingCapacity"];
  void clear_carrying_capacity() ;
  ::int32_t carrying_capacity() const;
  void set_carrying_capacity(::int32_t value);

  private:
  ::int32_t _internal_carrying_capacity() const;
  void _internal_set_carrying_capacity(::int32_t value);

  public:
  // int32 max_capacity = 3 [json_name = "maxCapacity"];
  void clear_max_capacity() ;
  ::int32_t max_capacity() const;
  void set_max_capacity(::int32_t value);

  private:
  ::int32_t _internal_max_capacity() const;
  void _internal_set_max_capacity(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.EncumbranceLevel level = 4 [json_name = "level"];
  void clear_level() ;
  ::dnd5e::api::v1alpha1::EncumbranceLevel level() const;
  void set_level(::dnd5e::api::v1alpha1::EncumbranceLevel value);

  private:
  ::dnd5e::api::v1alpha1::EncumbranceLevel _internal_level() const;
  void _internal_set_level(::dnd5e::api::v1alpha1::EncumbranceLevel value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EncumbranceInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EncumbranceInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t current_weight_;
    ::int32_t carrying_capacity_;
    ::int32_t max_capacity_;
    int level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EncumbranceInfo_class_data_;
// -------------------------------------------------------------------

class DraftMetadata final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DraftMetadata) */ {
 public:
  inline DraftMetadata() : DraftMetadata(nullptr) {}
  ~DraftMetadata() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DraftMetadata* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DraftMetadata));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DraftMetadata(::google::protobuf::internal::ConstantInitialized);

  inline DraftMetadata(const DraftMetadata& from) : DraftMetadata(nullptr, from) {}
  inline DraftMetadata(DraftMetadata&& from) noexcept
      : DraftMetadata(nullptr, ::std::move(from)) {}
  inline DraftMetadata& operator=(const DraftMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DraftMetadata& operator=(DraftMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DraftMetadata& default_instance() {
    return *reinterpret_cast<const DraftMetadata*>(
        &_DraftMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(DraftMetadata& a, DraftMetadata& b) { a.Swap(&b); }
  inline void Swap(DraftMetadata* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DraftMetadata* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DraftMetadata* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DraftMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DraftMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DraftMetadata& from) { DraftMetadata::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DraftMetadata* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DraftMetadata"; }

 protected:
  explicit DraftMetadata(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DraftMetadata(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DraftMetadata& from);
  DraftMetadata(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DraftMetadata&& from) noexcept
      : DraftMetadata(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDiscordChannelIdFieldNumber = 3,
    kDiscordMessageIdFieldNumber = 4,
    kCreatedAtFieldNumber = 1,
    kUpdatedAtFieldNumber = 2,
  };
  // string discord_channel_id = 3 [json_name = "discordChannelId"];
  void clear_discord_channel_id() ;
  const ::std::string& discord_channel_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_discord_channel_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_discord_channel_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_discord_channel_id();
  void set_allocated_discord_channel_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_discord_channel_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_discord_channel_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_discord_channel_id();

  public:
  // string discord_message_id = 4 [json_name = "discordMessageId"];
  void clear_discord_message_id() ;
  const ::std::string& discord_message_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_discord_message_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_discord_message_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_discord_message_id();
  void set_allocated_discord_message_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_discord_message_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_discord_message_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_discord_message_id();

  public:
  // int64 created_at = 1 [json_name = "createdAt"];
  void clear_created_at() ;
  ::int64_t created_at() const;
  void set_created_at(::int64_t value);

  private:
  ::int64_t _internal_created_at() const;
  void _internal_set_created_at(::int64_t value);

  public:
  // int64 updated_at = 2 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DraftMetadata)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 77,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DraftMetadata& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr discord_channel_id_;
    ::google::protobuf::internal::ArenaStringPtr discord_message_id_;
    ::int64_t created_at_;
    ::int64_t updated_at_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DraftMetadata_class_data_;
// -------------------------------------------------------------------

class DeleteDraftResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DeleteDraftResponse) */ {
 public:
  inline DeleteDraftResponse() : DeleteDraftResponse(nullptr) {}
  ~DeleteDraftResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteDraftResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteDraftResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteDraftResponse(::google::protobuf::internal::ConstantInitialized);

  inline DeleteDraftResponse(const DeleteDraftResponse& from) : DeleteDraftResponse(nullptr, from) {}
  inline DeleteDraftResponse(DeleteDraftResponse&& from) noexcept
      : DeleteDraftResponse(nullptr, ::std::move(from)) {}
  inline DeleteDraftResponse& operator=(const DeleteDraftResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteDraftResponse& operator=(DeleteDraftResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteDraftResponse& default_instance() {
    return *reinterpret_cast<const DeleteDraftResponse*>(
        &_DeleteDraftResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(DeleteDraftResponse& a, DeleteDraftResponse& b) { a.Swap(&b); }
  inline void Swap(DeleteDraftResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteDraftResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteDraftResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteDraftResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteDraftResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteDraftResponse& from) { DeleteDraftResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteDraftResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DeleteDraftResponse"; }

 protected:
  explicit DeleteDraftResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteDraftResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteDraftResponse& from);
  DeleteDraftResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteDraftResponse&& from) noexcept
      : DeleteDraftResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1 [json_name = "message"];
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DeleteDraftResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 54,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteDraftResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteDraftResponse_class_data_;
// -------------------------------------------------------------------

class DeleteDraftRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DeleteDraftRequest) */ {
 public:
  inline DeleteDraftRequest() : DeleteDraftRequest(nullptr) {}
  ~DeleteDraftRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteDraftRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteDraftRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteDraftRequest(::google::protobuf::internal::ConstantInitialized);

  inline DeleteDraftRequest(const DeleteDraftRequest& from) : DeleteDraftRequest(nullptr, from) {}
  inline DeleteDraftRequest(DeleteDraftRequest&& from) noexcept
      : DeleteDraftRequest(nullptr, ::std::move(from)) {}
  inline DeleteDraftRequest& operator=(const DeleteDraftRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteDraftRequest& operator=(DeleteDraftRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteDraftRequest& default_instance() {
    return *reinterpret_cast<const DeleteDraftRequest*>(
        &_DeleteDraftRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(DeleteDraftRequest& a, DeleteDraftRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteDraftRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteDraftRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteDraftRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteDraftRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteDraftRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteDraftRequest& from) { DeleteDraftRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteDraftRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DeleteDraftRequest"; }

 protected:
  explicit DeleteDraftRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteDraftRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteDraftRequest& from);
  DeleteDraftRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteDraftRequest&& from) noexcept
      : DeleteDraftRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDraftIdFieldNumber = 1,
  };
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DeleteDraftRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 54,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteDraftRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteDraftRequest_class_data_;
// -------------------------------------------------------------------

class DeleteCharacterResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DeleteCharacterResponse) */ {
 public:
  inline DeleteCharacterResponse() : DeleteCharacterResponse(nullptr) {}
  ~DeleteCharacterResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteCharacterResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteCharacterResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteCharacterResponse(::google::protobuf::internal::ConstantInitialized);

  inline DeleteCharacterResponse(const DeleteCharacterResponse& from) : DeleteCharacterResponse(nullptr, from) {}
  inline DeleteCharacterResponse(DeleteCharacterResponse&& from) noexcept
      : DeleteCharacterResponse(nullptr, ::std::move(from)) {}
  inline DeleteCharacterResponse& operator=(const DeleteCharacterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteCharacterResponse& operator=(DeleteCharacterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteCharacterResponse& default_instance() {
    return *reinterpret_cast<const DeleteCharacterResponse*>(
        &_DeleteCharacterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(DeleteCharacterResponse& a, DeleteCharacterResponse& b) { a.Swap(&b); }
  inline void Swap(DeleteCharacterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteCharacterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteCharacterResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteCharacterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteCharacterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteCharacterResponse& from) { DeleteCharacterResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteCharacterResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DeleteCharacterResponse"; }

 protected:
  explicit DeleteCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteCharacterResponse& from);
  DeleteCharacterResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteCharacterResponse&& from) noexcept
      : DeleteCharacterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1 [json_name = "message"];
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DeleteCharacterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteCharacterResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteCharacterResponse_class_data_;
// -------------------------------------------------------------------

class DeleteCharacterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DeleteCharacterRequest) */ {
 public:
  inline DeleteCharacterRequest() : DeleteCharacterRequest(nullptr) {}
  ~DeleteCharacterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteCharacterRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteCharacterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteCharacterRequest(::google::protobuf::internal::ConstantInitialized);

  inline DeleteCharacterRequest(const DeleteCharacterRequest& from) : DeleteCharacterRequest(nullptr, from) {}
  inline DeleteCharacterRequest(DeleteCharacterRequest&& from) noexcept
      : DeleteCharacterRequest(nullptr, ::std::move(from)) {}
  inline DeleteCharacterRequest& operator=(const DeleteCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteCharacterRequest& operator=(DeleteCharacterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteCharacterRequest& default_instance() {
    return *reinterpret_cast<const DeleteCharacterRequest*>(
        &_DeleteCharacterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(DeleteCharacterRequest& a, DeleteCharacterRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteCharacterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteCharacterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteCharacterRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteCharacterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteCharacterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteCharacterRequest& from) { DeleteCharacterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteCharacterRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DeleteCharacterRequest"; }

 protected:
  explicit DeleteCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteCharacterRequest& from);
  DeleteCharacterRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteCharacterRequest&& from) noexcept
      : DeleteCharacterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterIdFieldNumber = 1,
  };
  // string character_id = 1 [json_name = "characterId"];
  void clear_character_id() ;
  const ::std::string& character_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_character_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_character_id();
  void set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_character_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_character_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DeleteCharacterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 62,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteCharacterRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteCharacterRequest_class_data_;
// -------------------------------------------------------------------

class DamageAtSlotLevel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DamageAtSlotLevel) */ {
 public:
  inline DamageAtSlotLevel() : DamageAtSlotLevel(nullptr) {}
  ~DamageAtSlotLevel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DamageAtSlotLevel* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DamageAtSlotLevel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DamageAtSlotLevel(::google::protobuf::internal::ConstantInitialized);

  inline DamageAtSlotLevel(const DamageAtSlotLevel& from) : DamageAtSlotLevel(nullptr, from) {}
  inline DamageAtSlotLevel(DamageAtSlotLevel&& from) noexcept
      : DamageAtSlotLevel(nullptr, ::std::move(from)) {}
  inline DamageAtSlotLevel& operator=(const DamageAtSlotLevel& from) {
    CopyFrom(from);
    return *this;
  }
  inline DamageAtSlotLevel& operator=(DamageAtSlotLevel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DamageAtSlotLevel& default_instance() {
    return *reinterpret_cast<const DamageAtSlotLevel*>(
        &_DamageAtSlotLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 104;
  friend void swap(DamageAtSlotLevel& a, DamageAtSlotLevel& b) { a.Swap(&b); }
  inline void Swap(DamageAtSlotLevel* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DamageAtSlotLevel* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DamageAtSlotLevel* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DamageAtSlotLevel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DamageAtSlotLevel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DamageAtSlotLevel& from) { DamageAtSlotLevel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DamageAtSlotLevel* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DamageAtSlotLevel"; }

 protected:
  explicit DamageAtSlotLevel(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DamageAtSlotLevel(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DamageAtSlotLevel& from);
  DamageAtSlotLevel(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DamageAtSlotLevel&& from) noexcept
      : DamageAtSlotLevel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDamageDiceFieldNumber = 2,
    kSlotLevelFieldNumber = 1,
  };
  // string damage_dice = 2 [json_name = "damageDice"];
  void clear_damage_dice() ;
  const ::std::string& damage_dice() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_damage_dice(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_damage_dice();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_damage_dice();
  void set_allocated_damage_dice(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_damage_dice() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_damage_dice(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_damage_dice();

  public:
  // int32 slot_level = 1 [json_name = "slotLevel"];
  void clear_slot_level() ;
  ::int32_t slot_level() const;
  void set_slot_level(::int32_t value);

  private:
  ::int32_t _internal_slot_level() const;
  void _internal_set_slot_level(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DamageAtSlotLevel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DamageAtSlotLevel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr damage_dice_;
    ::int32_t slot_level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DamageAtSlotLevel_class_data_;
// -------------------------------------------------------------------

class CreationProgress final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CreationProgress) */ {
 public:
  inline CreationProgress() : CreationProgress(nullptr) {}
  ~CreationProgress() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreationProgress* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreationProgress));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreationProgress(::google::protobuf::internal::ConstantInitialized);

  inline CreationProgress(const CreationProgress& from) : CreationProgress(nullptr, from) {}
  inline CreationProgress(CreationProgress&& from) noexcept
      : CreationProgress(nullptr, ::std::move(from)) {}
  inline CreationProgress& operator=(const CreationProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreationProgress& operator=(CreationProgress&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreationProgress& default_instance() {
    return *reinterpret_cast<const CreationProgress*>(
        &_CreationProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(CreationProgress& a, CreationProgress& b) { a.Swap(&b); }
  inline void Swap(CreationProgress* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreationProgress* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreationProgress* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreationProgress>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreationProgress& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreationProgress& from) { CreationProgress::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreationProgress* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CreationProgress"; }

 protected:
  explicit CreationProgress(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreationProgress(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreationProgress& from);
  CreationProgress(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreationProgress&& from) noexcept
      : CreationProgress(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHasNameFieldNumber = 1,
    kHasRaceFieldNumber = 2,
    kHasClassFieldNumber = 3,
    kHasBackgroundFieldNumber = 4,
    kHasAbilityScoresFieldNumber = 5,
    kHasSkillsFieldNumber = 6,
    kHasLanguagesFieldNumber = 7,
    kCompletionPercentageFieldNumber = 8,
    kCurrentStepFieldNumber = 9,
  };
  // bool has_name = 1 [json_name = "hasName"];
  void clear_has_name() ;
  bool has_name() const;
  void set_has_name(bool value);

  private:
  bool _internal_has_name() const;
  void _internal_set_has_name(bool value);

  public:
  // bool has_race = 2 [json_name = "hasRace"];
  void clear_has_race() ;
  bool has_race() const;
  void set_has_race(bool value);

  private:
  bool _internal_has_race() const;
  void _internal_set_has_race(bool value);

  public:
  // bool has_class = 3 [json_name = "hasClass"];
  void clear_has_class() ;
  bool has_class() const;
  void set_has_class(bool value);

  private:
  bool _internal_has_class() const;
  void _internal_set_has_class(bool value);

  public:
  // bool has_background = 4 [json_name = "hasBackground"];
  void clear_has_background() ;
  bool has_background() const;
  void set_has_background(bool value);

  private:
  bool _internal_has_background() const;
  void _internal_set_has_background(bool value);

  public:
  // bool has_ability_scores = 5 [json_name = "hasAbilityScores"];
  void clear_has_ability_scores() ;
  bool has_ability_scores() const;
  void set_has_ability_scores(bool value);

  private:
  bool _internal_has_ability_scores() const;
  void _internal_set_has_ability_scores(bool value);

  public:
  // bool has_skills = 6 [json_name = "hasSkills"];
  void clear_has_skills() ;
  bool has_skills() const;
  void set_has_skills(bool value);

  private:
  bool _internal_has_skills() const;
  void _internal_set_has_skills(bool value);

  public:
  // bool has_languages = 7 [json_name = "hasLanguages"];
  void clear_has_languages() ;
  bool has_languages() const;
  void set_has_languages(bool value);

  private:
  bool _internal_has_languages() const;
  void _internal_set_has_languages(bool value);

  public:
  // int32 completion_percentage = 8 [json_name = "completionPercentage"];
  void clear_completion_percentage() ;
  ::int32_t completion_percentage() const;
  void set_completion_percentage(::int32_t value);

  private:
  ::int32_t _internal_completion_percentage() const;
  void _internal_set_completion_percentage(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.CreationStep current_step = 9 [json_name = "currentStep"];
  void clear_current_step() ;
  ::dnd5e::api::v1alpha1::CreationStep current_step() const;
  void set_current_step(::dnd5e::api::v1alpha1::CreationStep value);

  private:
  ::dnd5e::api::v1alpha1::CreationStep _internal_current_step() const;
  void _internal_set_current_step(::dnd5e::api::v1alpha1::CreationStep value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CreationProgress)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CreationProgress& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool has_name_;
    bool has_race_;
    bool has_class_;
    bool has_background_;
    bool has_ability_scores_;
    bool has_skills_;
    bool has_languages_;
    ::int32_t completion_percentage_;
    int current_step_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreationProgress_class_data_;
// -------------------------------------------------------------------

class CountedItemReference final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CountedItemReference) */ {
 public:
  inline CountedItemReference() : CountedItemReference(nullptr) {}
  ~CountedItemReference() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CountedItemReference* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CountedItemReference));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CountedItemReference(::google::protobuf::internal::ConstantInitialized);

  inline CountedItemReference(const CountedItemReference& from) : CountedItemReference(nullptr, from) {}
  inline CountedItemReference(CountedItemReference&& from) noexcept
      : CountedItemReference(nullptr, ::std::move(from)) {}
  inline CountedItemReference& operator=(const CountedItemReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline CountedItemReference& operator=(CountedItemReference&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CountedItemReference& default_instance() {
    return *reinterpret_cast<const CountedItemReference*>(
        &_CountedItemReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 56;
  friend void swap(CountedItemReference& a, CountedItemReference& b) { a.Swap(&b); }
  inline void Swap(CountedItemReference* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CountedItemReference* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CountedItemReference* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CountedItemReference>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CountedItemReference& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CountedItemReference& from) { CountedItemReference::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CountedItemReference* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CountedItemReference"; }

 protected:
  explicit CountedItemReference(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CountedItemReference(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CountedItemReference& from);
  CountedItemReference(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CountedItemReference&& from) noexcept
      : CountedItemReference(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kQuantityFieldNumber = 3,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id() ;
  const ::std::string& item_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_item_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_item_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_item_id();
  void set_allocated_item_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_item_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_item_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // int32 quantity = 3 [json_name = "quantity"];
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CountedItemReference)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CountedItemReference& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr item_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CountedItemReference_class_data_;
// -------------------------------------------------------------------

class Cost final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.Cost) */ {
 public:
  inline Cost() : Cost(nullptr) {}
  ~Cost() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Cost* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Cost));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Cost(::google::protobuf::internal::ConstantInitialized);

  inline Cost(const Cost& from) : Cost(nullptr, from) {}
  inline Cost(Cost&& from) noexcept
      : Cost(nullptr, ::std::move(from)) {}
  inline Cost& operator=(const Cost& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cost& operator=(Cost&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cost& default_instance() {
    return *reinterpret_cast<const Cost*>(
        &_Cost_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 83;
  friend void swap(Cost& a, Cost& b) { a.Swap(&b); }
  inline void Swap(Cost* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cost* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cost* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Cost>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Cost& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Cost& from) { Cost::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Cost* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.Cost"; }

 protected:
  explicit Cost(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Cost(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Cost& from);
  Cost(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Cost&& from) noexcept
      : Cost(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUnitFieldNumber = 2,
    kQuantityFieldNumber = 1,
  };
  // string unit = 2 [json_name = "unit"];
  void clear_unit() ;
  const ::std::string& unit() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_unit(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_unit();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_unit();
  void set_allocated_unit(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_unit() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_unit();

  public:
  // int32 quantity = 1 [json_name = "quantity"];
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.Cost)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 36,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Cost& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr unit_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Cost_class_data_;
// -------------------------------------------------------------------

class CombatStats final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CombatStats) */ {
 public:
  inline CombatStats() : CombatStats(nullptr) {}
  ~CombatStats() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CombatStats* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CombatStats));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CombatStats(::google::protobuf::internal::ConstantInitialized);

  inline CombatStats(const CombatStats& from) : CombatStats(nullptr, from) {}
  inline CombatStats(CombatStats&& from) noexcept
      : CombatStats(nullptr, ::std::move(from)) {}
  inline CombatStats& operator=(const CombatStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombatStats& operator=(CombatStats&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombatStats& default_instance() {
    return *reinterpret_cast<const CombatStats*>(
        &_CombatStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(CombatStats& a, CombatStats& b) { a.Swap(&b); }
  inline void Swap(CombatStats* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombatStats* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombatStats* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CombatStats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CombatStats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CombatStats& from) { CombatStats::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CombatStats* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CombatStats"; }

 protected:
  explicit CombatStats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CombatStats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CombatStats& from);
  CombatStats(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CombatStats&& from) noexcept
      : CombatStats(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHitDiceFieldNumber = 6,
    kHitPointMaximumFieldNumber = 1,
    kArmorClassFieldNumber = 2,
    kInitiativeFieldNumber = 3,
    kSpeedFieldNumber = 4,
    kProficiencyBonusFieldNumber = 5,
  };
  // string hit_dice = 6 [json_name = "hitDice"];
  void clear_hit_dice() ;
  const ::std::string& hit_dice() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_hit_dice(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_hit_dice();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_hit_dice();
  void set_allocated_hit_dice(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_hit_dice() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_hit_dice(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_hit_dice();

  public:
  // int32 hit_point_maximum = 1 [json_name = "hitPointMaximum"];
  void clear_hit_point_maximum() ;
  ::int32_t hit_point_maximum() const;
  void set_hit_point_maximum(::int32_t value);

  private:
  ::int32_t _internal_hit_point_maximum() const;
  void _internal_set_hit_point_maximum(::int32_t value);

  public:
  // int32 armor_class = 2 [json_name = "armorClass"];
  void clear_armor_class() ;
  ::int32_t armor_class() const;
  void set_armor_class(::int32_t value);

  private:
  ::int32_t _internal_armor_class() const;
  void _internal_set_armor_class(::int32_t value);

  public:
  // int32 initiative = 3 [json_name = "initiative"];
  void clear_initiative() ;
  ::int32_t initiative() const;
  void set_initiative(::int32_t value);

  private:
  ::int32_t _internal_initiative() const;
  void _internal_set_initiative(::int32_t value);

  public:
  // int32 speed = 4 [json_name = "speed"];
  void clear_speed() ;
  ::int32_t speed() const;
  void set_speed(::int32_t value);

  private:
  ::int32_t _internal_speed() const;
  void _internal_set_speed(::int32_t value);

  public:
  // int32 proficiency_bonus = 5 [json_name = "proficiencyBonus"];
  void clear_proficiency_bonus() ;
  ::int32_t proficiency_bonus() const;
  void set_proficiency_bonus(::int32_t value);

  private:
  ::int32_t _internal_proficiency_bonus() const;
  void _internal_set_proficiency_bonus(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CombatStats)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CombatStats& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr hit_dice_;
    ::int32_t hit_point_maximum_;
    ::int32_t armor_class_;
    ::int32_t initiative_;
    ::int32_t speed_;
    ::int32_t proficiency_bonus_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CombatStats_class_data_;
// -------------------------------------------------------------------

class ClassChoice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ClassChoice) */ {
 public:
  inline ClassChoice() : ClassChoice(nullptr) {}
  ~ClassChoice() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClassChoice* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClassChoice));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClassChoice(::google::protobuf::internal::ConstantInitialized);

  inline ClassChoice(const ClassChoice& from) : ClassChoice(nullptr, from) {}
  inline ClassChoice(ClassChoice&& from) noexcept
      : ClassChoice(nullptr, ::std::move(from)) {}
  inline ClassChoice& operator=(const ClassChoice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassChoice& operator=(ClassChoice&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClassChoice& default_instance() {
    return *reinterpret_cast<const ClassChoice*>(
        &_ClassChoice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 100;
  friend void swap(ClassChoice& a, ClassChoice& b) { a.Swap(&b); }
  inline void Swap(ClassChoice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClassChoice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClassChoice* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ClassChoice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClassChoice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClassChoice& from) { ClassChoice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClassChoice* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ClassChoice"; }

 protected:
  explicit ClassChoice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ClassChoice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ClassChoice& from);
  ClassChoice(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ClassChoice&& from) noexcept
      : ClassChoice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClassFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.Class class = 1 [json_name = "class"];
  void clear_class_() ;
  ::dnd5e::api::v1alpha1::Class class_() const;
  void set_class_(::dnd5e::api::v1alpha1::Class value);

  private:
  ::dnd5e::api::v1alpha1::Class _internal_class_() const;
  void _internal_set_class_(::dnd5e::api::v1alpha1::Class value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ClassChoice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ClassChoice& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int class__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ClassChoice_class_data_;
// -------------------------------------------------------------------

class CharacterMetadata final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CharacterMetadata) */ {
 public:
  inline CharacterMetadata() : CharacterMetadata(nullptr) {}
  ~CharacterMetadata() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CharacterMetadata* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CharacterMetadata));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CharacterMetadata(::google::protobuf::internal::ConstantInitialized);

  inline CharacterMetadata(const CharacterMetadata& from) : CharacterMetadata(nullptr, from) {}
  inline CharacterMetadata(CharacterMetadata&& from) noexcept
      : CharacterMetadata(nullptr, ::std::move(from)) {}
  inline CharacterMetadata& operator=(const CharacterMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterMetadata& operator=(CharacterMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterMetadata& default_instance() {
    return *reinterpret_cast<const CharacterMetadata*>(
        &_CharacterMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(CharacterMetadata& a, CharacterMetadata& b) { a.Swap(&b); }
  inline void Swap(CharacterMetadata* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterMetadata* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterMetadata* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CharacterMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CharacterMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CharacterMetadata& from) { CharacterMetadata::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CharacterMetadata* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CharacterMetadata"; }

 protected:
  explicit CharacterMetadata(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CharacterMetadata(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CharacterMetadata& from);
  CharacterMetadata(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CharacterMetadata&& from) noexcept
      : CharacterMetadata(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerIdFieldNumber = 3,
    kCreatedAtFieldNumber = 1,
    kUpdatedAtFieldNumber = 2,
  };
  // string player_id = 3 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // int64 created_at = 1 [json_name = "createdAt"];
  void clear_created_at() ;
  ::int64_t created_at() const;
  void set_created_at(::int64_t value);

  private:
  ::int64_t _internal_created_at() const;
  void _internal_set_created_at(::int64_t value);

  public:
  // int64 updated_at = 2 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CharacterMetadata)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 54,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CharacterMetadata& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::int64_t created_at_;
    ::int64_t updated_at_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CharacterMetadata_class_data_;
// -------------------------------------------------------------------

class CategoryReference final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CategoryReference) */ {
 public:
  inline CategoryReference() : CategoryReference(nullptr) {}
  ~CategoryReference() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CategoryReference* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CategoryReference));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CategoryReference(::google::protobuf::internal::ConstantInitialized);

  inline CategoryReference(const CategoryReference& from) : CategoryReference(nullptr, from) {}
  inline CategoryReference(CategoryReference&& from) noexcept
      : CategoryReference(nullptr, ::std::move(from)) {}
  inline CategoryReference& operator=(const CategoryReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline CategoryReference& operator=(CategoryReference&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CategoryReference& default_instance() {
    return *reinterpret_cast<const CategoryReference*>(
        &_CategoryReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 53;
  friend void swap(CategoryReference& a, CategoryReference& b) { a.Swap(&b); }
  inline void Swap(CategoryReference* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CategoryReference* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CategoryReference* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CategoryReference>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CategoryReference& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CategoryReference& from) { CategoryReference::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CategoryReference* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CategoryReference"; }

 protected:
  explicit CategoryReference(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CategoryReference(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CategoryReference& from);
  CategoryReference(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CategoryReference&& from) noexcept
      : CategoryReference(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExcludeIdsFieldNumber = 2,
    kCategoryIdFieldNumber = 1,
  };
  // repeated string exclude_ids = 2 [json_name = "excludeIds"];
  int exclude_ids_size() const;
  private:
  int _internal_exclude_ids_size() const;

  public:
  void clear_exclude_ids() ;
  const ::std::string& exclude_ids(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_exclude_ids(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_exclude_ids(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_exclude_ids();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_exclude_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& exclude_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_exclude_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_exclude_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_exclude_ids();

  public:
  // string category_id = 1 [json_name = "categoryId"];
  void clear_category_id() ;
  const ::std::string& category_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_category_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_category_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_category_id();
  void set_allocated_category_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_category_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_category_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_category_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CategoryReference)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 67,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CategoryReference& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> exclude_ids_;
    ::google::protobuf::internal::ArenaStringPtr category_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CategoryReference_class_data_;
// -------------------------------------------------------------------

class CantripList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CantripList) */ {
 public:
  inline CantripList() : CantripList(nullptr) {}
  ~CantripList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CantripList* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CantripList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CantripList(::google::protobuf::internal::ConstantInitialized);

  inline CantripList(const CantripList& from) : CantripList(nullptr, from) {}
  inline CantripList(CantripList&& from) noexcept
      : CantripList(nullptr, ::std::move(from)) {}
  inline CantripList& operator=(const CantripList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CantripList& operator=(CantripList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CantripList& default_instance() {
    return *reinterpret_cast<const CantripList*>(
        &_CantripList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 98;
  friend void swap(CantripList& a, CantripList& b) { a.Swap(&b); }
  inline void Swap(CantripList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CantripList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CantripList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CantripList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CantripList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CantripList& from) { CantripList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CantripList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CantripList"; }

 protected:
  explicit CantripList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CantripList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CantripList& from);
  CantripList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CantripList&& from) noexcept
      : CantripList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCantripsFieldNumber = 1,
  };
  // repeated string cantrips = 1 [json_name = "cantrips"];
  int cantrips_size() const;
  private:
  int _internal_cantrips_size() const;

  public:
  void clear_cantrips() ;
  const ::std::string& cantrips(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_cantrips(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_cantrips(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_cantrips();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_cantrips(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& cantrips() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_cantrips();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_cantrips() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_cantrips();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CantripList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CantripList& from_msg);
    ::google::protobuf::RepeatedPtrField<::std::string> cantrips_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CantripList_class_data_;
// -------------------------------------------------------------------

class BackgroundInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.BackgroundInfo) */ {
 public:
  inline BackgroundInfo() : BackgroundInfo(nullptr) {}
  ~BackgroundInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BackgroundInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BackgroundInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BackgroundInfo(::google::protobuf::internal::ConstantInitialized);

  inline BackgroundInfo(const BackgroundInfo& from) : BackgroundInfo(nullptr, from) {}
  inline BackgroundInfo(BackgroundInfo&& from) noexcept
      : BackgroundInfo(nullptr, ::std::move(from)) {}
  inline BackgroundInfo& operator=(const BackgroundInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackgroundInfo& operator=(BackgroundInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackgroundInfo& default_instance() {
    return *reinterpret_cast<const BackgroundInfo*>(
        &_BackgroundInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 62;
  friend void swap(BackgroundInfo& a, BackgroundInfo& b) { a.Swap(&b); }
  inline void Swap(BackgroundInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackgroundInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BackgroundInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BackgroundInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BackgroundInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BackgroundInfo& from) { BackgroundInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BackgroundInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.BackgroundInfo"; }

 protected:
  explicit BackgroundInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BackgroundInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BackgroundInfo& from);
  BackgroundInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BackgroundInfo&& from) noexcept
      : BackgroundInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkillProficienciesFieldNumber = 4,
    kToolProficienciesFieldNumber = 5,
    kLanguagesFieldNumber = 6,
    kStartingEquipmentFieldNumber = 8,
    kPersonalityTraitsFieldNumber = 12,
    kIdealsFieldNumber = 13,
    kBondsFieldNumber = 14,
    kFlawsFieldNumber = 15,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kFeatureNameFieldNumber = 10,
    kFeatureDescriptionFieldNumber = 11,
    kAdditionalLanguagesFieldNumber = 7,
    kStartingGoldFieldNumber = 9,
  };
  // repeated string skill_proficiencies = 4 [json_name = "skillProficiencies"];
  int skill_proficiencies_size() const;
  private:
  int _internal_skill_proficiencies_size() const;

  public:
  void clear_skill_proficiencies() ;
  const ::std::string& skill_proficiencies(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_skill_proficiencies(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_skill_proficiencies(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_skill_proficiencies();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_skill_proficiencies(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& skill_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_skill_proficiencies();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_skill_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_skill_proficiencies();

  public:
  // repeated string tool_proficiencies = 5 [json_name = "toolProficiencies"];
  int tool_proficiencies_size() const;
  private:
  int _internal_tool_proficiencies_size() const;

  public:
  void clear_tool_proficiencies() ;
  const ::std::string& tool_proficiencies(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_tool_proficiencies(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_tool_proficiencies(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_tool_proficiencies();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_tool_proficiencies(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& tool_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_tool_proficiencies();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_tool_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_tool_proficiencies();

  public:
  // repeated .dnd5e.api.v1alpha1.Language languages = 6 [json_name = "languages"];
  int languages_size() const;
  private:
  int _internal_languages_size() const;

  public:
  void clear_languages() ;
  public:
  ::dnd5e::api::v1alpha1::Language languages(int index) const;
  void set_languages(int index, ::dnd5e::api::v1alpha1::Language value);
  void add_languages(::dnd5e::api::v1alpha1::Language value);
  const ::google::protobuf::RepeatedField<int>& languages() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_languages();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_languages() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_languages();

  public:
  // repeated string starting_equipment = 8 [json_name = "startingEquipment"];
  int starting_equipment_size() const;
  private:
  int _internal_starting_equipment_size() const;

  public:
  void clear_starting_equipment() ;
  const ::std::string& starting_equipment(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_starting_equipment(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_starting_equipment(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_starting_equipment();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_starting_equipment(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& starting_equipment() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_starting_equipment();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_starting_equipment() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_starting_equipment();

  public:
  // repeated string personality_traits = 12 [json_name = "personalityTraits"];
  int personality_traits_size() const;
  private:
  int _internal_personality_traits_size() const;

  public:
  void clear_personality_traits() ;
  const ::std::string& personality_traits(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_personality_traits(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_personality_traits(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_personality_traits();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_personality_traits(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& personality_traits() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_personality_traits();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_personality_traits() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_personality_traits();

  public:
  // repeated string ideals = 13 [json_name = "ideals"];
  int ideals_size() const;
  private:
  int _internal_ideals_size() const;

  public:
  void clear_ideals() ;
  const ::std::string& ideals(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_ideals(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_ideals(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_ideals();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_ideals(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& ideals() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_ideals();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_ideals() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_ideals();

  public:
  // repeated string bonds = 14 [json_name = "bonds"];
  int bonds_size() const;
  private:
  int _internal_bonds_size() const;

  public:
  void clear_bonds() ;
  const ::std::string& bonds(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_bonds(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_bonds(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_bonds();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_bonds(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& bonds() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_bonds();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_bonds() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_bonds();

  public:
  // repeated string flaws = 15 [json_name = "flaws"];
  int flaws_size() const;
  private:
  int _internal_flaws_size() const;

  public:
  void clear_flaws() ;
  const ::std::string& flaws(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_flaws(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_flaws(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_flaws();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_flaws(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& flaws() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_flaws();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_flaws() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_flaws();

  public:
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string description = 3 [json_name = "description"];
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // string feature_name = 10 [json_name = "featureName"];
  void clear_feature_name() ;
  const ::std::string& feature_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_feature_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_feature_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_feature_name();
  void set_allocated_feature_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_feature_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_feature_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_feature_name();

  public:
  // string feature_description = 11 [json_name = "featureDescription"];
  void clear_feature_description() ;
  const ::std::string& feature_description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_feature_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_feature_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_feature_description();
  void set_allocated_feature_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_feature_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_feature_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_feature_description();

  public:
  // int32 additional_languages = 7 [json_name = "additionalLanguages"];
  void clear_additional_languages() ;
  ::int32_t additional_languages() const;
  void set_additional_languages(::int32_t value);

  private:
  ::int32_t _internal_additional_languages() const;
  void _internal_set_additional_languages(::int32_t value);

  public:
  // int32 starting_gold = 9 [json_name = "startingGold"];
  void clear_starting_gold() ;
  ::int32_t starting_gold() const;
  void set_starting_gold(::int32_t value);

  private:
  ::int32_t _internal_starting_gold() const;
  void _internal_set_starting_gold(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.BackgroundInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 15,
                                   0, 187,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BackgroundInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> skill_proficiencies_;
    ::google::protobuf::RepeatedPtrField<::std::string> tool_proficiencies_;
    ::google::protobuf::RepeatedField<int> languages_;
    ::google::protobuf::internal::CachedSize _languages_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> starting_equipment_;
    ::google::protobuf::RepeatedPtrField<::std::string> personality_traits_;
    ::google::protobuf::RepeatedPtrField<::std::string> ideals_;
    ::google::protobuf::RepeatedPtrField<::std::string> bonds_;
    ::google::protobuf::RepeatedPtrField<::std::string> flaws_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr feature_name_;
    ::google::protobuf::internal::ArenaStringPtr feature_description_;
    ::int32_t additional_languages_;
    ::int32_t starting_gold_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BackgroundInfo_class_data_;
// -------------------------------------------------------------------

class ArmorData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ArmorData) */ {
 public:
  inline ArmorData() : ArmorData(nullptr) {}
  ~ArmorData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ArmorData* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ArmorData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ArmorData(::google::protobuf::internal::ConstantInitialized);

  inline ArmorData(const ArmorData& from) : ArmorData(nullptr, from) {}
  inline ArmorData(ArmorData&& from) noexcept
      : ArmorData(nullptr, ::std::move(from)) {}
  inline ArmorData& operator=(const ArmorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmorData& operator=(ArmorData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArmorData& default_instance() {
    return *reinterpret_cast<const ArmorData*>(
        &_ArmorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 87;
  friend void swap(ArmorData& a, ArmorData& b) { a.Swap(&b); }
  inline void Swap(ArmorData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArmorData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArmorData* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ArmorData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ArmorData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ArmorData& from) { ArmorData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ArmorData* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ArmorData"; }

 protected:
  explicit ArmorData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ArmorData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ArmorData& from);
  ArmorData(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ArmorData&& from) noexcept
      : ArmorData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kArmorCategoryFieldNumber = 1,
    kBaseAcFieldNumber = 2,
    kDexBonusFieldNumber = 3,
    kHasDexLimitFieldNumber = 4,
    kStealthDisadvantageFieldNumber = 7,
    kMaxDexBonusFieldNumber = 5,
    kStrMinimumFieldNumber = 6,
  };
  // string armor_category = 1 [json_name = "armorCategory"];
  void clear_armor_category() ;
  const ::std::string& armor_category() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_armor_category(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_armor_category();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_armor_category();
  void set_allocated_armor_category(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_armor_category() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_armor_category(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_armor_category();

  public:
  // int32 base_ac = 2 [json_name = "baseAc"];
  void clear_base_ac() ;
  ::int32_t base_ac() const;
  void set_base_ac(::int32_t value);

  private:
  ::int32_t _internal_base_ac() const;
  void _internal_set_base_ac(::int32_t value);

  public:
  // bool dex_bonus = 3 [json_name = "dexBonus"];
  void clear_dex_bonus() ;
  bool dex_bonus() const;
  void set_dex_bonus(bool value);

  private:
  bool _internal_dex_bonus() const;
  void _internal_set_dex_bonus(bool value);

  public:
  // bool has_dex_limit = 4 [json_name = "hasDexLimit"];
  void clear_has_dex_limit() ;
  bool has_dex_limit() const;
  void set_has_dex_limit(bool value);

  private:
  bool _internal_has_dex_limit() const;
  void _internal_set_has_dex_limit(bool value);

  public:
  // bool stealth_disadvantage = 7 [json_name = "stealthDisadvantage"];
  void clear_stealth_disadvantage() ;
  bool stealth_disadvantage() const;
  void set_stealth_disadvantage(bool value);

  private:
  bool _internal_stealth_disadvantage() const;
  void _internal_set_stealth_disadvantage(bool value);

  public:
  // int32 max_dex_bonus = 5 [json_name = "maxDexBonus"];
  void clear_max_dex_bonus() ;
  ::int32_t max_dex_bonus() const;
  void set_max_dex_bonus(::int32_t value);

  private:
  ::int32_t _internal_max_dex_bonus() const;
  void _internal_set_max_dex_bonus(::int32_t value);

  public:
  // int32 str_minimum = 6 [json_name = "strMinimum"];
  void clear_str_minimum() ;
  ::int32_t str_minimum() const;
  void set_str_minimum(::int32_t value);

  private:
  ::int32_t _internal_str_minimum() const;
  void _internal_set_str_minimum(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ArmorData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ArmorData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr armor_category_;
    ::int32_t base_ac_;
    bool dex_bonus_;
    bool has_dex_limit_;
    bool stealth_disadvantage_;
    ::int32_t max_dex_bonus_;
    ::int32_t str_minimum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ArmorData_class_data_;
// -------------------------------------------------------------------

class AreaOfEffect final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AreaOfEffect) */ {
 public:
  inline AreaOfEffect() : AreaOfEffect(nullptr) {}
  ~AreaOfEffect() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AreaOfEffect* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AreaOfEffect));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AreaOfEffect(::google::protobuf::internal::ConstantInitialized);

  inline AreaOfEffect(const AreaOfEffect& from) : AreaOfEffect(nullptr, from) {}
  inline AreaOfEffect(AreaOfEffect&& from) noexcept
      : AreaOfEffect(nullptr, ::std::move(from)) {}
  inline AreaOfEffect& operator=(const AreaOfEffect& from) {
    CopyFrom(from);
    return *this;
  }
  inline AreaOfEffect& operator=(AreaOfEffect&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AreaOfEffect& default_instance() {
    return *reinterpret_cast<const AreaOfEffect*>(
        &_AreaOfEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 105;
  friend void swap(AreaOfEffect& a, AreaOfEffect& b) { a.Swap(&b); }
  inline void Swap(AreaOfEffect* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AreaOfEffect* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AreaOfEffect* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AreaOfEffect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AreaOfEffect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AreaOfEffect& from) { AreaOfEffect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AreaOfEffect* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AreaOfEffect"; }

 protected:
  explicit AreaOfEffect(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AreaOfEffect(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AreaOfEffect& from);
  AreaOfEffect(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AreaOfEffect&& from) noexcept
      : AreaOfEffect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // string type = 1 [json_name = "type"];
  void clear_type() ;
  const ::std::string& type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_type();
  void set_allocated_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_type();

  public:
  // int32 size = 2 [json_name = "size"];
  void clear_size() ;
  ::int32_t size() const;
  void set_size(::int32_t value);

  private:
  ::int32_t _internal_size() const;
  void _internal_set_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AreaOfEffect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 44,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AreaOfEffect& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::int32_t size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AreaOfEffect_class_data_;
// -------------------------------------------------------------------

class AbilityScores final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AbilityScores) */ {
 public:
  inline AbilityScores() : AbilityScores(nullptr) {}
  ~AbilityScores() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AbilityScores* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AbilityScores));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AbilityScores(::google::protobuf::internal::ConstantInitialized);

  inline AbilityScores(const AbilityScores& from) : AbilityScores(nullptr, from) {}
  inline AbilityScores(AbilityScores&& from) noexcept
      : AbilityScores(nullptr, ::std::move(from)) {}
  inline AbilityScores& operator=(const AbilityScores& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbilityScores& operator=(AbilityScores&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbilityScores& default_instance() {
    return *reinterpret_cast<const AbilityScores*>(
        &_AbilityScores_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(AbilityScores& a, AbilityScores& b) { a.Swap(&b); }
  inline void Swap(AbilityScores* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbilityScores* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbilityScores* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AbilityScores>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AbilityScores& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AbilityScores& from) { AbilityScores::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AbilityScores* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AbilityScores"; }

 protected:
  explicit AbilityScores(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AbilityScores(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AbilityScores& from);
  AbilityScores(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AbilityScores&& from) noexcept
      : AbilityScores(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStrengthFieldNumber = 1,
    kDexterityFieldNumber = 2,
    kConstitutionFieldNumber = 3,
    kIntelligenceFieldNumber = 4,
    kWisdomFieldNumber = 5,
    kCharismaFieldNumber = 6,
  };
  // int32 strength = 1 [json_name = "strength"];
  void clear_strength() ;
  ::int32_t strength() const;
  void set_strength(::int32_t value);

  private:
  ::int32_t _internal_strength() const;
  void _internal_set_strength(::int32_t value);

  public:
  // int32 dexterity = 2 [json_name = "dexterity"];
  void clear_dexterity() ;
  ::int32_t dexterity() const;
  void set_dexterity(::int32_t value);

  private:
  ::int32_t _internal_dexterity() const;
  void _internal_set_dexterity(::int32_t value);

  public:
  // int32 constitution = 3 [json_name = "constitution"];
  void clear_constitution() ;
  ::int32_t constitution() const;
  void set_constitution(::int32_t value);

  private:
  ::int32_t _internal_constitution() const;
  void _internal_set_constitution(::int32_t value);

  public:
  // int32 intelligence = 4 [json_name = "intelligence"];
  void clear_intelligence() ;
  ::int32_t intelligence() const;
  void set_intelligence(::int32_t value);

  private:
  ::int32_t _internal_intelligence() const;
  void _internal_set_intelligence(::int32_t value);

  public:
  // int32 wisdom = 5 [json_name = "wisdom"];
  void clear_wisdom() ;
  ::int32_t wisdom() const;
  void set_wisdom(::int32_t value);

  private:
  ::int32_t _internal_wisdom() const;
  void _internal_set_wisdom(::int32_t value);

  public:
  // int32 charisma = 6 [json_name = "charisma"];
  void clear_charisma() ;
  ::int32_t charisma() const;
  void set_charisma(::int32_t value);

  private:
  ::int32_t _internal_charisma() const;
  void _internal_set_charisma(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AbilityScores)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AbilityScores& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t strength_;
    ::int32_t dexterity_;
    ::int32_t constitution_;
    ::int32_t intelligence_;
    ::int32_t wisdom_;
    ::int32_t charisma_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AbilityScores_class_data_;
// -------------------------------------------------------------------

class AbilityScoreRoll final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AbilityScoreRoll) */ {
 public:
  inline AbilityScoreRoll() : AbilityScoreRoll(nullptr) {}
  ~AbilityScoreRoll() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AbilityScoreRoll* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AbilityScoreRoll));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AbilityScoreRoll(::google::protobuf::internal::ConstantInitialized);

  inline AbilityScoreRoll(const AbilityScoreRoll& from) : AbilityScoreRoll(nullptr, from) {}
  inline AbilityScoreRoll(AbilityScoreRoll&& from) noexcept
      : AbilityScoreRoll(nullptr, ::std::move(from)) {}
  inline AbilityScoreRoll& operator=(const AbilityScoreRoll& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbilityScoreRoll& operator=(AbilityScoreRoll&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbilityScoreRoll& default_instance() {
    return *reinterpret_cast<const AbilityScoreRoll*>(
        &_AbilityScoreRoll_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 80;
  friend void swap(AbilityScoreRoll& a, AbilityScoreRoll& b) { a.Swap(&b); }
  inline void Swap(AbilityScoreRoll* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbilityScoreRoll* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbilityScoreRoll* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AbilityScoreRoll>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AbilityScoreRoll& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AbilityScoreRoll& from) { AbilityScoreRoll::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AbilityScoreRoll* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AbilityScoreRoll"; }

 protected:
  explicit AbilityScoreRoll(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AbilityScoreRoll(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AbilityScoreRoll& from);
  AbilityScoreRoll(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AbilityScoreRoll&& from) noexcept
      : AbilityScoreRoll(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDiceFieldNumber = 2,
    kRollIdFieldNumber = 1,
    kNotationFieldNumber = 5,
    kTotalFieldNumber = 3,
    kDroppedFieldNumber = 4,
  };
  // repeated int32 dice = 2 [json_name = "dice"];
  int dice_size() const;
  private:
  int _internal_dice_size() const;

  public:
  void clear_dice() ;
  ::int32_t dice(int index) const;
  void set_dice(int index, ::int32_t value);
  void add_dice(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& dice() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_dice();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_dice() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_dice();

  public:
  // string roll_id = 1 [json_name = "rollId"];
  void clear_roll_id() ;
  const ::std::string& roll_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_roll_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_roll_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_roll_id();
  void set_allocated_roll_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_roll_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_roll_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_roll_id();

  public:
  // string notation = 5 [json_name = "notation"];
  void clear_notation() ;
  const ::std::string& notation() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_notation(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_notation();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_notation();
  void set_allocated_notation(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_notation() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_notation(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_notation();

  public:
  // int32 total = 3 [json_name = "total"];
  void clear_total() ;
  ::int32_t total() const;
  void set_total(::int32_t value);

  private:
  ::int32_t _internal_total() const;
  void _internal_set_total(::int32_t value);

  public:
  // int32 dropped = 4 [json_name = "dropped"];
  void clear_dropped() ;
  ::int32_t dropped() const;
  void set_dropped(::int32_t value);

  private:
  ::int32_t _internal_dropped() const;
  void _internal_set_dropped(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AbilityScoreRoll)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AbilityScoreRoll& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> dice_;
    ::google::protobuf::internal::CachedSize _dice_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr roll_id_;
    ::google::protobuf::internal::ArenaStringPtr notation_;
    ::int32_t total_;
    ::int32_t dropped_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AbilityScoreRoll_class_data_;
// -------------------------------------------------------------------

class AbilityScoreChoice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AbilityScoreChoice) */ {
 public:
  inline AbilityScoreChoice() : AbilityScoreChoice(nullptr) {}
  ~AbilityScoreChoice() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AbilityScoreChoice* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AbilityScoreChoice));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AbilityScoreChoice(::google::protobuf::internal::ConstantInitialized);

  inline AbilityScoreChoice(const AbilityScoreChoice& from) : AbilityScoreChoice(nullptr, from) {}
  inline AbilityScoreChoice(AbilityScoreChoice&& from) noexcept
      : AbilityScoreChoice(nullptr, ::std::move(from)) {}
  inline AbilityScoreChoice& operator=(const AbilityScoreChoice& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbilityScoreChoice& operator=(AbilityScoreChoice&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbilityScoreChoice& default_instance() {
    return *reinterpret_cast<const AbilityScoreChoice*>(
        &_AbilityScoreChoice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 102;
  friend void swap(AbilityScoreChoice& a, AbilityScoreChoice& b) { a.Swap(&b); }
  inline void Swap(AbilityScoreChoice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbilityScoreChoice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbilityScoreChoice* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AbilityScoreChoice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AbilityScoreChoice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AbilityScoreChoice& from) { AbilityScoreChoice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AbilityScoreChoice* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AbilityScoreChoice"; }

 protected:
  explicit AbilityScoreChoice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AbilityScoreChoice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AbilityScoreChoice& from);
  AbilityScoreChoice(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AbilityScoreChoice&& from) noexcept
      : AbilityScoreChoice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAbilityFieldNumber = 1,
    kBonusFieldNumber = 2,
  };
  // .dnd5e.api.v1alpha1.Ability ability = 1 [json_name = "ability"];
  void clear_ability() ;
  ::dnd5e::api::v1alpha1::Ability ability() const;
  void set_ability(::dnd5e::api::v1alpha1::Ability value);

  private:
  ::dnd5e::api::v1alpha1::Ability _internal_ability() const;
  void _internal_set_ability(::dnd5e::api::v1alpha1::Ability value);

  public:
  // int32 bonus = 2 [json_name = "bonus"];
  void clear_bonus() ;
  ::int32_t bonus() const;
  void set_bonus(::int32_t value);

  private:
  ::int32_t _internal_bonus() const;
  void _internal_set_bonus(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AbilityScoreChoice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AbilityScoreChoice& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int ability_;
    ::int32_t bonus_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AbilityScoreChoice_class_data_;
// -------------------------------------------------------------------

class AbilityModifiers final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AbilityModifiers) */ {
 public:
  inline AbilityModifiers() : AbilityModifiers(nullptr) {}
  ~AbilityModifiers() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AbilityModifiers* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AbilityModifiers));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AbilityModifiers(::google::protobuf::internal::ConstantInitialized);

  inline AbilityModifiers(const AbilityModifiers& from) : AbilityModifiers(nullptr, from) {}
  inline AbilityModifiers(AbilityModifiers&& from) noexcept
      : AbilityModifiers(nullptr, ::std::move(from)) {}
  inline AbilityModifiers& operator=(const AbilityModifiers& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbilityModifiers& operator=(AbilityModifiers&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbilityModifiers& default_instance() {
    return *reinterpret_cast<const AbilityModifiers*>(
        &_AbilityModifiers_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(AbilityModifiers& a, AbilityModifiers& b) { a.Swap(&b); }
  inline void Swap(AbilityModifiers* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbilityModifiers* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbilityModifiers* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AbilityModifiers>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AbilityModifiers& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AbilityModifiers& from) { AbilityModifiers::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AbilityModifiers* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AbilityModifiers"; }

 protected:
  explicit AbilityModifiers(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AbilityModifiers(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AbilityModifiers& from);
  AbilityModifiers(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AbilityModifiers&& from) noexcept
      : AbilityModifiers(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStrengthFieldNumber = 1,
    kDexterityFieldNumber = 2,
    kConstitutionFieldNumber = 3,
    kIntelligenceFieldNumber = 4,
    kWisdomFieldNumber = 5,
    kCharismaFieldNumber = 6,
  };
  // int32 strength = 1 [json_name = "strength"];
  void clear_strength() ;
  ::int32_t strength() const;
  void set_strength(::int32_t value);

  private:
  ::int32_t _internal_strength() const;
  void _internal_set_strength(::int32_t value);

  public:
  // int32 dexterity = 2 [json_name = "dexterity"];
  void clear_dexterity() ;
  ::int32_t dexterity() const;
  void set_dexterity(::int32_t value);

  private:
  ::int32_t _internal_dexterity() const;
  void _internal_set_dexterity(::int32_t value);

  public:
  // int32 constitution = 3 [json_name = "constitution"];
  void clear_constitution() ;
  ::int32_t constitution() const;
  void set_constitution(::int32_t value);

  private:
  ::int32_t _internal_constitution() const;
  void _internal_set_constitution(::int32_t value);

  public:
  // int32 intelligence = 4 [json_name = "intelligence"];
  void clear_intelligence() ;
  ::int32_t intelligence() const;
  void set_intelligence(::int32_t value);

  private:
  ::int32_t _internal_intelligence() const;
  void _internal_set_intelligence(::int32_t value);

  public:
  // int32 wisdom = 5 [json_name = "wisdom"];
  void clear_wisdom() ;
  ::int32_t wisdom() const;
  void set_wisdom(::int32_t value);

  private:
  ::int32_t _internal_wisdom() const;
  void _internal_set_wisdom(::int32_t value);

  public:
  // int32 charisma = 6 [json_name = "charisma"];
  void clear_charisma() ;
  ::int32_t charisma() const;
  void set_charisma(::int32_t value);

  private:
  ::int32_t _internal_charisma() const;
  void _internal_set_charisma(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AbilityModifiers)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AbilityModifiers& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t strength_;
    ::int32_t dexterity_;
    ::int32_t constitution_;
    ::int32_t intelligence_;
    ::int32_t wisdom_;
    ::int32_t charisma_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AbilityModifiers_class_data_;
// -------------------------------------------------------------------

class ValidateDraftResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ValidateDraftResponse) */ {
 public:
  inline ValidateDraftResponse() : ValidateDraftResponse(nullptr) {}
  ~ValidateDraftResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ValidateDraftResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ValidateDraftResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateDraftResponse(::google::protobuf::internal::ConstantInitialized);

  inline ValidateDraftResponse(const ValidateDraftResponse& from) : ValidateDraftResponse(nullptr, from) {}
  inline ValidateDraftResponse(ValidateDraftResponse&& from) noexcept
      : ValidateDraftResponse(nullptr, ::std::move(from)) {}
  inline ValidateDraftResponse& operator=(const ValidateDraftResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateDraftResponse& operator=(ValidateDraftResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateDraftResponse& default_instance() {
    return *reinterpret_cast<const ValidateDraftResponse*>(
        &_ValidateDraftResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(ValidateDraftResponse& a, ValidateDraftResponse& b) { a.Swap(&b); }
  inline void Swap(ValidateDraftResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateDraftResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateDraftResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ValidateDraftResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValidateDraftResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ValidateDraftResponse& from) { ValidateDraftResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ValidateDraftResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ValidateDraftResponse"; }

 protected:
  explicit ValidateDraftResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ValidateDraftResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ValidateDraftResponse& from);
  ValidateDraftResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ValidateDraftResponse&& from) noexcept
      : ValidateDraftResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorsFieldNumber = 3,
    kWarningsFieldNumber = 4,
    kMissingStepsFieldNumber = 5,
    kIsCompleteFieldNumber = 1,
    kIsValidFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.ValidationError errors = 3 [json_name = "errors"];
  int errors_size() const;
  private:
  int _internal_errors_size() const;

  public:
  void clear_errors() ;
  ::dnd5e::api::v1alpha1::ValidationError* PROTOBUF_NONNULL mutable_errors(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>* PROTOBUF_NONNULL mutable_errors();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>& _internal_errors() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>* PROTOBUF_NONNULL _internal_mutable_errors();
  public:
  const ::dnd5e::api::v1alpha1::ValidationError& errors(int index) const;
  ::dnd5e::api::v1alpha1::ValidationError* PROTOBUF_NONNULL add_errors();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>& errors() const;
  // repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 4 [json_name = "warnings"];
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;

  public:
  void clear_warnings() ;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL mutable_warnings(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL mutable_warnings();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& _internal_warnings() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL _internal_mutable_warnings();
  public:
  const ::dnd5e::api::v1alpha1::ValidationWarning& warnings(int index) const;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL add_warnings();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& warnings() const;
  // repeated .dnd5e.api.v1alpha1.CreationStep missing_steps = 5 [json_name = "missingSteps"];
  int missing_steps_size() const;
  private:
  int _internal_missing_steps_size() const;

  public:
  void clear_missing_steps() ;
  public:
  ::dnd5e::api::v1alpha1::CreationStep missing_steps(int index) const;
  void set_missing_steps(int index, ::dnd5e::api::v1alpha1::CreationStep value);
  void add_missing_steps(::dnd5e::api::v1alpha1::CreationStep value);
  const ::google::protobuf::RepeatedField<int>& missing_steps() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_missing_steps();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_missing_steps() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_missing_steps();

  public:
  // bool is_complete = 1 [json_name = "isComplete"];
  void clear_is_complete() ;
  bool is_complete() const;
  void set_is_complete(bool value);

  private:
  bool _internal_is_complete() const;
  void _internal_set_is_complete(bool value);

  public:
  // bool is_valid = 2 [json_name = "isValid"];
  void clear_is_valid() ;
  bool is_valid() const;
  void set_is_valid(bool value);

  private:
  bool _internal_is_valid() const;
  void _internal_set_is_valid(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ValidateDraftResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ValidateDraftResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ValidationError > errors_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ValidationWarning > warnings_;
    ::google::protobuf::RepeatedField<int> missing_steps_;
    ::google::protobuf::internal::CachedSize _missing_steps_cached_byte_size_;
    bool is_complete_;
    bool is_valid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ValidateDraftResponse_class_data_;
// -------------------------------------------------------------------

class UpdateAbilityScoresRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest) */ {
 public:
  inline UpdateAbilityScoresRequest() : UpdateAbilityScoresRequest(nullptr) {}
  ~UpdateAbilityScoresRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateAbilityScoresRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateAbilityScoresRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateAbilityScoresRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateAbilityScoresRequest(const UpdateAbilityScoresRequest& from) : UpdateAbilityScoresRequest(nullptr, from) {}
  inline UpdateAbilityScoresRequest(UpdateAbilityScoresRequest&& from) noexcept
      : UpdateAbilityScoresRequest(nullptr, ::std::move(from)) {}
  inline UpdateAbilityScoresRequest& operator=(const UpdateAbilityScoresRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAbilityScoresRequest& operator=(UpdateAbilityScoresRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAbilityScoresRequest& default_instance() {
    return *reinterpret_cast<const UpdateAbilityScoresRequest*>(
        &_UpdateAbilityScoresRequest_default_instance_);
  }
  enum ScoresInputCase {
    kAbilityScores = 2,
    kRollAssignments = 3,
    SCORES_INPUT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(UpdateAbilityScoresRequest& a, UpdateAbilityScoresRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateAbilityScoresRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAbilityScoresRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateAbilityScoresRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateAbilityScoresRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateAbilityScoresRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateAbilityScoresRequest& from) { UpdateAbilityScoresRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateAbilityScoresRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateAbilityScoresRequest"; }

 protected:
  explicit UpdateAbilityScoresRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateAbilityScoresRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateAbilityScoresRequest& from);
  UpdateAbilityScoresRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateAbilityScoresRequest&& from) noexcept
      : UpdateAbilityScoresRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDraftIdFieldNumber = 1,
    kAbilityScoresFieldNumber = 2,
    kRollAssignmentsFieldNumber = 3,
  };
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // .dnd5e.api.v1alpha1.AbilityScores ability_scores = 2 [json_name = "abilityScores"];
  bool has_ability_scores() const;
  private:
  bool _internal_has_ability_scores() const;

  public:
  void clear_ability_scores() ;
  const ::dnd5e::api::v1alpha1::AbilityScores& ability_scores() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE release_ability_scores();
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL mutable_ability_scores();
  void set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE unsafe_arena_release_ability_scores();

  private:
  const ::dnd5e::api::v1alpha1::AbilityScores& _internal_ability_scores() const;
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL _internal_mutable_ability_scores();

  public:
  // .dnd5e.api.v1alpha1.RollAssignments roll_assignments = 3 [json_name = "rollAssignments"];
  bool has_roll_assignments() const;
  private:
  bool _internal_has_roll_assignments() const;

  public:
  void clear_roll_assignments() ;
  const ::dnd5e::api::v1alpha1::RollAssignments& roll_assignments() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::RollAssignments* PROTOBUF_NULLABLE release_roll_assignments();
  ::dnd5e::api::v1alpha1::RollAssignments* PROTOBUF_NONNULL mutable_roll_assignments();
  void set_allocated_roll_assignments(::dnd5e::api::v1alpha1::RollAssignments* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_roll_assignments(::dnd5e::api::v1alpha1::RollAssignments* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::RollAssignments* PROTOBUF_NULLABLE unsafe_arena_release_roll_assignments();

  private:
  const ::dnd5e::api::v1alpha1::RollAssignments& _internal_roll_assignments() const;
  ::dnd5e::api::v1alpha1::RollAssignments* PROTOBUF_NONNULL _internal_mutable_roll_assignments();

  public:
  void clear_scores_input();
  ScoresInputCase scores_input_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest)
 private:
  class _Internal;
  void set_has_ability_scores();
  void set_has_roll_assignments();
  inline bool has_scores_input() const;
  inline void clear_has_scores_input();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3,
                                   2, 62,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateAbilityScoresRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    union ScoresInputUnion {
      constexpr ScoresInputUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE ability_scores_;
      ::dnd5e::api::v1alpha1::RollAssignments* PROTOBUF_NULLABLE roll_assignments_;
    } scores_input_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateAbilityScoresRequest_class_data_;
// -------------------------------------------------------------------

class SubraceInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.SubraceInfo) */ {
 public:
  inline SubraceInfo() : SubraceInfo(nullptr) {}
  ~SubraceInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubraceInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubraceInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubraceInfo(::google::protobuf::internal::ConstantInitialized);

  inline SubraceInfo(const SubraceInfo& from) : SubraceInfo(nullptr, from) {}
  inline SubraceInfo(SubraceInfo&& from) noexcept
      : SubraceInfo(nullptr, ::std::move(from)) {}
  inline SubraceInfo& operator=(const SubraceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubraceInfo& operator=(SubraceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubraceInfo& default_instance() {
    return *reinterpret_cast<const SubraceInfo*>(
        &_SubraceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 49;
  friend void swap(SubraceInfo& a, SubraceInfo& b) { a.Swap(&b); }
  inline void Swap(SubraceInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubraceInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubraceInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubraceInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubraceInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubraceInfo& from) { SubraceInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubraceInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.SubraceInfo"; }

 protected:
  explicit SubraceInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubraceInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubraceInfo& from);
  SubraceInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubraceInfo&& from) noexcept
      : SubraceInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAbilityBonusesFieldNumber = 4,
    kTraitsFieldNumber = 5,
    kLanguagesFieldNumber = 6,
    kProficienciesFieldNumber = 7,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
  };
  // map<string, int32> ability_bonuses = 4 [json_name = "abilityBonuses"];
  int ability_bonuses_size() const;
  private:
  int _internal_ability_bonuses_size() const;

  public:
  void clear_ability_bonuses() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& ability_bonuses() const;
  ::google::protobuf::Map<std::string, ::int32_t>* PROTOBUF_NONNULL mutable_ability_bonuses();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_ability_bonuses() const;
  ::google::protobuf::Map<std::string, ::int32_t>* PROTOBUF_NONNULL _internal_mutable_ability_bonuses();

  public:
  // repeated .dnd5e.api.v1alpha1.RacialTrait traits = 5 [json_name = "traits"];
  int traits_size() const;
  private:
  int _internal_traits_size() const;

  public:
  void clear_traits() ;
  ::dnd5e::api::v1alpha1::RacialTrait* PROTOBUF_NONNULL mutable_traits(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>* PROTOBUF_NONNULL mutable_traits();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>& _internal_traits() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>* PROTOBUF_NONNULL _internal_mutable_traits();
  public:
  const ::dnd5e::api::v1alpha1::RacialTrait& traits(int index) const;
  ::dnd5e::api::v1alpha1::RacialTrait* PROTOBUF_NONNULL add_traits();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>& traits() const;
  // repeated .dnd5e.api.v1alpha1.Language languages = 6 [json_name = "languages"];
  int languages_size() const;
  private:
  int _internal_languages_size() const;

  public:
  void clear_languages() ;
  public:
  ::dnd5e::api::v1alpha1::Language languages(int index) const;
  void set_languages(int index, ::dnd5e::api::v1alpha1::Language value);
  void add_languages(::dnd5e::api::v1alpha1::Language value);
  const ::google::protobuf::RepeatedField<int>& languages() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_languages();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_languages() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_languages();

  public:
  // repeated string proficiencies = 7 [json_name = "proficiencies"];
  int proficiencies_size() const;
  private:
  int _internal_proficiencies_size() const;

  public:
  void clear_proficiencies() ;
  const ::std::string& proficiencies(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_proficiencies(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_proficiencies(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_proficiencies();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_proficiencies(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_proficiencies();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_proficiencies();

  public:
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string description = 3 [json_name = "description"];
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.SubraceInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   2, 84,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubraceInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<SubraceInfo_AbilityBonusesEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        ability_bonuses_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::RacialTrait > traits_;
    ::google::protobuf::RepeatedField<int> languages_;
    ::google::protobuf::internal::CachedSize _languages_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> proficiencies_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubraceInfo_class_data_;
// -------------------------------------------------------------------

class SpellDamage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.SpellDamage) */ {
 public:
  inline SpellDamage() : SpellDamage(nullptr) {}
  ~SpellDamage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SpellDamage* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SpellDamage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SpellDamage(::google::protobuf::internal::ConstantInitialized);

  inline SpellDamage(const SpellDamage& from) : SpellDamage(nullptr, from) {}
  inline SpellDamage(SpellDamage&& from) noexcept
      : SpellDamage(nullptr, ::std::move(from)) {}
  inline SpellDamage& operator=(const SpellDamage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpellDamage& operator=(SpellDamage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpellDamage& default_instance() {
    return *reinterpret_cast<const SpellDamage*>(
        &_SpellDamage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 103;
  friend void swap(SpellDamage& a, SpellDamage& b) { a.Swap(&b); }
  inline void Swap(SpellDamage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpellDamage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpellDamage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SpellDamage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpellDamage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SpellDamage& from) { SpellDamage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SpellDamage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.SpellDamage"; }

 protected:
  explicit SpellDamage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SpellDamage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SpellDamage& from);
  SpellDamage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SpellDamage&& from) noexcept
      : SpellDamage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDamageAtSlotLevelFieldNumber = 2,
    kDamageTypeFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.DamageAtSlotLevel damage_at_slot_level = 2 [json_name = "damageAtSlotLevel"];
  int damage_at_slot_level_size() const;
  private:
  int _internal_damage_at_slot_level_size() const;

  public:
  void clear_damage_at_slot_level() ;
  ::dnd5e::api::v1alpha1::DamageAtSlotLevel* PROTOBUF_NONNULL mutable_damage_at_slot_level(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageAtSlotLevel>* PROTOBUF_NONNULL mutable_damage_at_slot_level();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageAtSlotLevel>& _internal_damage_at_slot_level() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageAtSlotLevel>* PROTOBUF_NONNULL _internal_mutable_damage_at_slot_level();
  public:
  const ::dnd5e::api::v1alpha1::DamageAtSlotLevel& damage_at_slot_level(int index) const;
  ::dnd5e::api::v1alpha1::DamageAtSlotLevel* PROTOBUF_NONNULL add_damage_at_slot_level();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageAtSlotLevel>& damage_at_slot_level() const;
  // string damage_type = 1 [json_name = "damageType"];
  void clear_damage_type() ;
  const ::std::string& damage_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_damage_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_damage_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_damage_type();
  void set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_damage_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_damage_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_damage_type();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.SpellDamage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 50,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SpellDamage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::DamageAtSlotLevel > damage_at_slot_level_;
    ::google::protobuf::internal::ArenaStringPtr damage_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SpellDamage_class_data_;
// -------------------------------------------------------------------

class RollAbilityScoresResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.RollAbilityScoresResponse) */ {
 public:
  inline RollAbilityScoresResponse() : RollAbilityScoresResponse(nullptr) {}
  ~RollAbilityScoresResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RollAbilityScoresResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RollAbilityScoresResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RollAbilityScoresResponse(::google::protobuf::internal::ConstantInitialized);

  inline RollAbilityScoresResponse(const RollAbilityScoresResponse& from) : RollAbilityScoresResponse(nullptr, from) {}
  inline RollAbilityScoresResponse(RollAbilityScoresResponse&& from) noexcept
      : RollAbilityScoresResponse(nullptr, ::std::move(from)) {}
  inline RollAbilityScoresResponse& operator=(const RollAbilityScoresResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RollAbilityScoresResponse& operator=(RollAbilityScoresResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RollAbilityScoresResponse& default_instance() {
    return *reinterpret_cast<const RollAbilityScoresResponse*>(
        &_RollAbilityScoresResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 81;
  friend void swap(RollAbilityScoresResponse& a, RollAbilityScoresResponse& b) { a.Swap(&b); }
  inline void Swap(RollAbilityScoresResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RollAbilityScoresResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RollAbilityScoresResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RollAbilityScoresResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RollAbilityScoresResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RollAbilityScoresResponse& from) { RollAbilityScoresResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RollAbilityScoresResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.RollAbilityScoresResponse"; }

 protected:
  explicit RollAbilityScoresResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RollAbilityScoresResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RollAbilityScoresResponse& from);
  RollAbilityScoresResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RollAbilityScoresResponse&& from) noexcept
      : RollAbilityScoresResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRollsFieldNumber = 1,
    kExpiresAtFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.AbilityScoreRoll rolls = 1 [json_name = "rolls"];
  int rolls_size() const;
  private:
  int _internal_rolls_size() const;

  public:
  void clear_rolls() ;
  ::dnd5e::api::v1alpha1::AbilityScoreRoll* PROTOBUF_NONNULL mutable_rolls(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreRoll>* PROTOBUF_NONNULL mutable_rolls();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreRoll>& _internal_rolls() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreRoll>* PROTOBUF_NONNULL _internal_mutable_rolls();
  public:
  const ::dnd5e::api::v1alpha1::AbilityScoreRoll& rolls(int index) const;
  ::dnd5e::api::v1alpha1::AbilityScoreRoll* PROTOBUF_NONNULL add_rolls();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreRoll>& rolls() const;
  // int64 expires_at = 2 [json_name = "expiresAt"];
  void clear_expires_at() ;
  ::int64_t expires_at() const;
  void set_expires_at(::int64_t value);

  private:
  ::int64_t _internal_expires_at() const;
  void _internal_set_expires_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.RollAbilityScoresResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RollAbilityScoresResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::AbilityScoreRoll > rolls_;
    ::int64_t expires_at_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RollAbilityScoresResponse_class_data_;
// -------------------------------------------------------------------

class ListBackgroundsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListBackgroundsResponse) */ {
 public:
  inline ListBackgroundsResponse() : ListBackgroundsResponse(nullptr) {}
  ~ListBackgroundsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListBackgroundsResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListBackgroundsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListBackgroundsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListBackgroundsResponse(const ListBackgroundsResponse& from) : ListBackgroundsResponse(nullptr, from) {}
  inline ListBackgroundsResponse(ListBackgroundsResponse&& from) noexcept
      : ListBackgroundsResponse(nullptr, ::std::move(from)) {}
  inline ListBackgroundsResponse& operator=(const ListBackgroundsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListBackgroundsResponse& operator=(ListBackgroundsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListBackgroundsResponse& default_instance() {
    return *reinterpret_cast<const ListBackgroundsResponse*>(
        &_ListBackgroundsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 70;
  friend void swap(ListBackgroundsResponse& a, ListBackgroundsResponse& b) { a.Swap(&b); }
  inline void Swap(ListBackgroundsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListBackgroundsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListBackgroundsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListBackgroundsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListBackgroundsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListBackgroundsResponse& from) { ListBackgroundsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListBackgroundsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListBackgroundsResponse"; }

 protected:
  explicit ListBackgroundsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListBackgroundsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListBackgroundsResponse& from);
  ListBackgroundsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListBackgroundsResponse&& from) noexcept
      : ListBackgroundsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBackgroundsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .dnd5e.api.v1alpha1.BackgroundInfo backgrounds = 1 [json_name = "backgrounds"];
  int backgrounds_size() const;
  private:
  int _internal_backgrounds_size() const;

  public:
  void clear_backgrounds() ;
  ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NONNULL mutable_backgrounds(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BackgroundInfo>* PROTOBUF_NONNULL mutable_backgrounds();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BackgroundInfo>& _internal_backgrounds() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BackgroundInfo>* PROTOBUF_NONNULL _internal_mutable_backgrounds();
  public:
  const ::dnd5e::api::v1alpha1::BackgroundInfo& backgrounds(int index) const;
  ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NONNULL add_backgrounds();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BackgroundInfo>& backgrounds() const;
  // string next_page_token = 2 [json_name = "nextPageToken"];
  void clear_next_page_token() ;
  const ::std::string& next_page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_next_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_next_page_token();
  void set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_next_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_next_page_token();

  public:
  // int32 total_size = 3 [json_name = "totalSize"];
  void clear_total_size() ;
  ::int32_t total_size() const;
  void set_total_size(::int32_t value);

  private:
  ::int32_t _internal_total_size() const;
  void _internal_set_total_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListBackgroundsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 66,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListBackgroundsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::BackgroundInfo > backgrounds_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::int32_t total_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListBackgroundsResponse_class_data_;
// -------------------------------------------------------------------

class GetBackgroundDetailsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetBackgroundDetailsResponse) */ {
 public:
  inline GetBackgroundDetailsResponse() : GetBackgroundDetailsResponse(nullptr) {}
  ~GetBackgroundDetailsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetBackgroundDetailsResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetBackgroundDetailsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetBackgroundDetailsResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetBackgroundDetailsResponse(const GetBackgroundDetailsResponse& from) : GetBackgroundDetailsResponse(nullptr, from) {}
  inline GetBackgroundDetailsResponse(GetBackgroundDetailsResponse&& from) noexcept
      : GetBackgroundDetailsResponse(nullptr, ::std::move(from)) {}
  inline GetBackgroundDetailsResponse& operator=(const GetBackgroundDetailsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBackgroundDetailsResponse& operator=(GetBackgroundDetailsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBackgroundDetailsResponse& default_instance() {
    return *reinterpret_cast<const GetBackgroundDetailsResponse*>(
        &_GetBackgroundDetailsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 76;
  friend void swap(GetBackgroundDetailsResponse& a, GetBackgroundDetailsResponse& b) { a.Swap(&b); }
  inline void Swap(GetBackgroundDetailsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBackgroundDetailsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBackgroundDetailsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetBackgroundDetailsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBackgroundDetailsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetBackgroundDetailsResponse& from) { GetBackgroundDetailsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetBackgroundDetailsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetBackgroundDetailsResponse"; }

 protected:
  explicit GetBackgroundDetailsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetBackgroundDetailsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetBackgroundDetailsResponse& from);
  GetBackgroundDetailsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetBackgroundDetailsResponse&& from) noexcept
      : GetBackgroundDetailsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBackgroundFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.BackgroundInfo background = 1 [json_name = "background"];
  bool has_background() const;
  void clear_background() ;
  const ::dnd5e::api::v1alpha1::BackgroundInfo& background() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE release_background();
  ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NONNULL mutable_background();
  void set_allocated_background(::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_background(::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE unsafe_arena_release_background();

  private:
  const ::dnd5e::api::v1alpha1::BackgroundInfo& _internal_background() const;
  ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NONNULL _internal_mutable_background();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetBackgroundDetailsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetBackgroundDetailsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE background_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetBackgroundDetailsResponse_class_data_;
// -------------------------------------------------------------------

class Equipment final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.Equipment) */ {
 public:
  inline Equipment() : Equipment(nullptr) {}
  ~Equipment() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Equipment* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Equipment));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Equipment(::google::protobuf::internal::ConstantInitialized);

  inline Equipment(const Equipment& from) : Equipment(nullptr, from) {}
  inline Equipment(Equipment&& from) noexcept
      : Equipment(nullptr, ::std::move(from)) {}
  inline Equipment& operator=(const Equipment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Equipment& operator=(Equipment&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Equipment& default_instance() {
    return *reinterpret_cast<const Equipment*>(
        &_Equipment_default_instance_);
  }
  enum EquipmentDataCase {
    kWeaponData = 7,
    kArmorData = 8,
    kGearData = 9,
    EQUIPMENT_DATA_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 85;
  friend void swap(Equipment& a, Equipment& b) { a.Swap(&b); }
  inline void Swap(Equipment* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Equipment* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Equipment* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Equipment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Equipment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Equipment& from) { Equipment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Equipment* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.Equipment"; }

 protected:
  explicit Equipment(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Equipment(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Equipment& from);
  Equipment(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Equipment&& from) noexcept
      : Equipment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCategoryFieldNumber = 3,
    kDescriptionFieldNumber = 6,
    kCostFieldNumber = 4,
    kWeightFieldNumber = 5,
    kWeaponDataFieldNumber = 7,
    kArmorDataFieldNumber = 8,
    kGearDataFieldNumber = 9,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string category = 3 [json_name = "category"];
  void clear_category() ;
  const ::std::string& category() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_category();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_category();
  void set_allocated_category(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_category() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_category(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_category();

  public:
  // string description = 6 [json_name = "description"];
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // .dnd5e.api.v1alpha1.Cost cost = 4 [json_name = "cost"];
  bool has_cost() const;
  void clear_cost() ;
  const ::dnd5e::api::v1alpha1::Cost& cost() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Cost* PROTOBUF_NULLABLE release_cost();
  ::dnd5e::api::v1alpha1::Cost* PROTOBUF_NONNULL mutable_cost();
  void set_allocated_cost(::dnd5e::api::v1alpha1::Cost* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_cost(::dnd5e::api::v1alpha1::Cost* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Cost* PROTOBUF_NULLABLE unsafe_arena_release_cost();

  private:
  const ::dnd5e::api::v1alpha1::Cost& _internal_cost() const;
  ::dnd5e::api::v1alpha1::Cost* PROTOBUF_NONNULL _internal_mutable_cost();

  public:
  // .dnd5e.api.v1alpha1.Weight weight = 5 [json_name = "weight"];
  bool has_weight() const;
  void clear_weight() ;
  const ::dnd5e::api::v1alpha1::Weight& weight() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Weight* PROTOBUF_NULLABLE release_weight();
  ::dnd5e::api::v1alpha1::Weight* PROTOBUF_NONNULL mutable_weight();
  void set_allocated_weight(::dnd5e::api::v1alpha1::Weight* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_weight(::dnd5e::api::v1alpha1::Weight* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Weight* PROTOBUF_NULLABLE unsafe_arena_release_weight();

  private:
  const ::dnd5e::api::v1alpha1::Weight& _internal_weight() const;
  ::dnd5e::api::v1alpha1::Weight* PROTOBUF_NONNULL _internal_mutable_weight();

  public:
  // .dnd5e.api.v1alpha1.WeaponData weapon_data = 7 [json_name = "weaponData"];
  bool has_weapon_data() const;
  private:
  bool _internal_has_weapon_data() const;

  public:
  void clear_weapon_data() ;
  const ::dnd5e::api::v1alpha1::WeaponData& weapon_data() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::WeaponData* PROTOBUF_NULLABLE release_weapon_data();
  ::dnd5e::api::v1alpha1::WeaponData* PROTOBUF_NONNULL mutable_weapon_data();
  void set_allocated_weapon_data(::dnd5e::api::v1alpha1::WeaponData* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_weapon_data(::dnd5e::api::v1alpha1::WeaponData* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::WeaponData* PROTOBUF_NULLABLE unsafe_arena_release_weapon_data();

  private:
  const ::dnd5e::api::v1alpha1::WeaponData& _internal_weapon_data() const;
  ::dnd5e::api::v1alpha1::WeaponData* PROTOBUF_NONNULL _internal_mutable_weapon_data();

  public:
  // .dnd5e.api.v1alpha1.ArmorData armor_data = 8 [json_name = "armorData"];
  bool has_armor_data() const;
  private:
  bool _internal_has_armor_data() const;

  public:
  void clear_armor_data() ;
  const ::dnd5e::api::v1alpha1::ArmorData& armor_data() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ArmorData* PROTOBUF_NULLABLE release_armor_data();
  ::dnd5e::api::v1alpha1::ArmorData* PROTOBUF_NONNULL mutable_armor_data();
  void set_allocated_armor_data(::dnd5e::api::v1alpha1::ArmorData* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_armor_data(::dnd5e::api::v1alpha1::ArmorData* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ArmorData* PROTOBUF_NULLABLE unsafe_arena_release_armor_data();

  private:
  const ::dnd5e::api::v1alpha1::ArmorData& _internal_armor_data() const;
  ::dnd5e::api::v1alpha1::ArmorData* PROTOBUF_NONNULL _internal_mutable_armor_data();

  public:
  // .dnd5e.api.v1alpha1.GearData gear_data = 9 [json_name = "gearData"];
  bool has_gear_data() const;
  private:
  bool _internal_has_gear_data() const;

  public:
  void clear_gear_data() ;
  const ::dnd5e::api::v1alpha1::GearData& gear_data() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::GearData* PROTOBUF_NULLABLE release_gear_data();
  ::dnd5e::api::v1alpha1::GearData* PROTOBUF_NONNULL mutable_gear_data();
  void set_allocated_gear_data(::dnd5e::api::v1alpha1::GearData* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gear_data(::dnd5e::api::v1alpha1::GearData* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::GearData* PROTOBUF_NULLABLE unsafe_arena_release_gear_data();

  private:
  const ::dnd5e::api::v1alpha1::GearData& _internal_gear_data() const;
  ::dnd5e::api::v1alpha1::GearData* PROTOBUF_NONNULL _internal_mutable_gear_data();

  public:
  void clear_equipment_data();
  EquipmentDataCase equipment_data_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.Equipment)
 private:
  class _Internal;
  void set_has_weapon_data();
  void set_has_armor_data();
  void set_has_gear_data();
  inline bool has_equipment_data() const;
  inline void clear_has_equipment_data();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 9,
                                   5, 70,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Equipment& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::dnd5e::api::v1alpha1::Cost* PROTOBUF_NULLABLE cost_;
    ::dnd5e::api::v1alpha1::Weight* PROTOBUF_NULLABLE weight_;
    union EquipmentDataUnion {
      constexpr EquipmentDataUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE weapon_data_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE armor_data_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE gear_data_;
    } equipment_data_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Equipment_class_data_;
// -------------------------------------------------------------------

class ChoiceSelection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ChoiceSelection) */ {
 public:
  inline ChoiceSelection() : ChoiceSelection(nullptr) {}
  ~ChoiceSelection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChoiceSelection* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChoiceSelection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChoiceSelection(::google::protobuf::internal::ConstantInitialized);

  inline ChoiceSelection(const ChoiceSelection& from) : ChoiceSelection(nullptr, from) {}
  inline ChoiceSelection(ChoiceSelection&& from) noexcept
      : ChoiceSelection(nullptr, ::std::move(from)) {}
  inline ChoiceSelection& operator=(const ChoiceSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChoiceSelection& operator=(ChoiceSelection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChoiceSelection& default_instance() {
    return *reinterpret_cast<const ChoiceSelection*>(
        &_ChoiceSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 101;
  friend void swap(ChoiceSelection& a, ChoiceSelection& b) { a.Swap(&b); }
  inline void Swap(ChoiceSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChoiceSelection* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChoiceSelection* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChoiceSelection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChoiceSelection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChoiceSelection& from) { ChoiceSelection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChoiceSelection* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ChoiceSelection"; }

 protected:
  explicit ChoiceSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ChoiceSelection(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChoiceSelection& from);
  ChoiceSelection(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ChoiceSelection&& from) noexcept
      : ChoiceSelection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSelectedKeysFieldNumber = 4,
    kAbilityScoreChoicesFieldNumber = 5,
    kChoiceIdFieldNumber = 1,
    kChoiceTypeFieldNumber = 2,
    kSourceFieldNumber = 3,
  };
  // repeated string selected_keys = 4 [json_name = "selectedKeys"];
  int selected_keys_size() const;
  private:
  int _internal_selected_keys_size() const;

  public:
  void clear_selected_keys() ;
  const ::std::string& selected_keys(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_selected_keys(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_selected_keys(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_selected_keys();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_selected_keys(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& selected_keys() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_selected_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_selected_keys() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_selected_keys();

  public:
  // repeated .dnd5e.api.v1alpha1.AbilityScoreChoice ability_score_choices = 5 [json_name = "abilityScoreChoices"];
  int ability_score_choices_size() const;
  private:
  int _internal_ability_score_choices_size() const;

  public:
  void clear_ability_score_choices() ;
  ::dnd5e::api::v1alpha1::AbilityScoreChoice* PROTOBUF_NONNULL mutable_ability_score_choices(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreChoice>* PROTOBUF_NONNULL mutable_ability_score_choices();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreChoice>& _internal_ability_score_choices() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreChoice>* PROTOBUF_NONNULL _internal_mutable_ability_score_choices();
  public:
  const ::dnd5e::api::v1alpha1::AbilityScoreChoice& ability_score_choices(int index) const;
  ::dnd5e::api::v1alpha1::AbilityScoreChoice* PROTOBUF_NONNULL add_ability_score_choices();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreChoice>& ability_score_choices() const;
  // string choice_id = 1 [json_name = "choiceId"];
  void clear_choice_id() ;
  const ::std::string& choice_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_choice_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_choice_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_choice_id();
  void set_allocated_choice_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_choice_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_choice_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_choice_id();

  public:
  // .dnd5e.api.v1alpha1.ChoiceCategory choice_type = 2 [json_name = "choiceType"];
  void clear_choice_type() ;
  ::dnd5e::api::v1alpha1::ChoiceCategory choice_type() const;
  void set_choice_type(::dnd5e::api::v1alpha1::ChoiceCategory value);

  private:
  ::dnd5e::api::v1alpha1::ChoiceCategory _internal_choice_type() const;
  void _internal_set_choice_type(::dnd5e::api::v1alpha1::ChoiceCategory value);

  public:
  // .dnd5e.api.v1alpha1.ChoiceSource source = 3 [json_name = "source"];
  void clear_source() ;
  ::dnd5e::api::v1alpha1::ChoiceSource source() const;
  void set_source(::dnd5e::api::v1alpha1::ChoiceSource value);

  private:
  ::dnd5e::api::v1alpha1::ChoiceSource _internal_source() const;
  void _internal_set_source(::dnd5e::api::v1alpha1::ChoiceSource value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ChoiceSelection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   1, 65,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ChoiceSelection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> selected_keys_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::AbilityScoreChoice > ability_score_choices_;
    ::google::protobuf::internal::ArenaStringPtr choice_id_;
    int choice_type_;
    int source_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ChoiceSelection_class_data_;
// -------------------------------------------------------------------

class ChoiceData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ChoiceData) */ {
 public:
  inline ChoiceData() : ChoiceData(nullptr) {}
  ~ChoiceData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChoiceData* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChoiceData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChoiceData(::google::protobuf::internal::ConstantInitialized);

  inline ChoiceData(const ChoiceData& from) : ChoiceData(nullptr, from) {}
  inline ChoiceData(ChoiceData&& from) noexcept
      : ChoiceData(nullptr, ::std::move(from)) {}
  inline ChoiceData& operator=(const ChoiceData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChoiceData& operator=(ChoiceData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChoiceData& default_instance() {
    return *reinterpret_cast<const ChoiceData*>(
        &_ChoiceData_default_instance_);
  }
  enum SelectionCase {
    kName = 4,
    kSkills = 5,
    kLanguages = 6,
    kAbilityScores = 7,
    kFightingStyle = 8,
    kEquipment = 9,
    kRace = 10,
    kClass = 11,
    kBackground = 12,
    kSpells = 13,
    kCantrips = 14,
    SELECTION_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 93;
  friend void swap(ChoiceData& a, ChoiceData& b) { a.Swap(&b); }
  inline void Swap(ChoiceData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChoiceData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChoiceData* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChoiceData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChoiceData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChoiceData& from) { ChoiceData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChoiceData* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ChoiceData"; }

 protected:
  explicit ChoiceData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ChoiceData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChoiceData& from);
  ChoiceData(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ChoiceData&& from) noexcept
      : ChoiceData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChoiceIdFieldNumber = 3,
    kCategoryFieldNumber = 1,
    kSourceFieldNumber = 2,
    kNameFieldNumber = 4,
    kSkillsFieldNumber = 5,
    kLanguagesFieldNumber = 6,
    kAbilityScoresFieldNumber = 7,
    kFightingStyleFieldNumber = 8,
    kEquipmentFieldNumber = 9,
    kRaceFieldNumber = 10,
    kClassFieldNumber = 11,
    kBackgroundFieldNumber = 12,
    kSpellsFieldNumber = 13,
    kCantripsFieldNumber = 14,
  };
  // string choice_id = 3 [json_name = "choiceId"];
  void clear_choice_id() ;
  const ::std::string& choice_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_choice_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_choice_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_choice_id();
  void set_allocated_choice_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_choice_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_choice_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_choice_id();

  public:
  // .dnd5e.api.v1alpha1.ChoiceCategory category = 1 [json_name = "category"];
  void clear_category() ;
  ::dnd5e::api::v1alpha1::ChoiceCategory category() const;
  void set_category(::dnd5e::api::v1alpha1::ChoiceCategory value);

  private:
  ::dnd5e::api::v1alpha1::ChoiceCategory _internal_category() const;
  void _internal_set_category(::dnd5e::api::v1alpha1::ChoiceCategory value);

  public:
  // .dnd5e.api.v1alpha1.ChoiceSource source = 2 [json_name = "source"];
  void clear_source() ;
  ::dnd5e::api::v1alpha1::ChoiceSource source() const;
  void set_source(::dnd5e::api::v1alpha1::ChoiceSource value);

  private:
  ::dnd5e::api::v1alpha1::ChoiceSource _internal_source() const;
  void _internal_set_source(::dnd5e::api::v1alpha1::ChoiceSource value);

  public:
  // string name = 4 [json_name = "name"];
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // .dnd5e.api.v1alpha1.SkillList skills = 5 [json_name = "skills"];
  bool has_skills() const;
  private:
  bool _internal_has_skills() const;

  public:
  void clear_skills() ;
  const ::dnd5e::api::v1alpha1::SkillList& skills() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SkillList* PROTOBUF_NULLABLE release_skills();
  ::dnd5e::api::v1alpha1::SkillList* PROTOBUF_NONNULL mutable_skills();
  void set_allocated_skills(::dnd5e::api::v1alpha1::SkillList* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_skills(::dnd5e::api::v1alpha1::SkillList* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SkillList* PROTOBUF_NULLABLE unsafe_arena_release_skills();

  private:
  const ::dnd5e::api::v1alpha1::SkillList& _internal_skills() const;
  ::dnd5e::api::v1alpha1::SkillList* PROTOBUF_NONNULL _internal_mutable_skills();

  public:
  // .dnd5e.api.v1alpha1.LanguageList languages = 6 [json_name = "languages"];
  bool has_languages() const;
  private:
  bool _internal_has_languages() const;

  public:
  void clear_languages() ;
  const ::dnd5e::api::v1alpha1::LanguageList& languages() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::LanguageList* PROTOBUF_NULLABLE release_languages();
  ::dnd5e::api::v1alpha1::LanguageList* PROTOBUF_NONNULL mutable_languages();
  void set_allocated_languages(::dnd5e::api::v1alpha1::LanguageList* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_languages(::dnd5e::api::v1alpha1::LanguageList* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::LanguageList* PROTOBUF_NULLABLE unsafe_arena_release_languages();

  private:
  const ::dnd5e::api::v1alpha1::LanguageList& _internal_languages() const;
  ::dnd5e::api::v1alpha1::LanguageList* PROTOBUF_NONNULL _internal_mutable_languages();

  public:
  // .dnd5e.api.v1alpha1.AbilityScores ability_scores = 7 [json_name = "abilityScores"];
  bool has_ability_scores() const;
  private:
  bool _internal_has_ability_scores() const;

  public:
  void clear_ability_scores() ;
  const ::dnd5e::api::v1alpha1::AbilityScores& ability_scores() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE release_ability_scores();
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL mutable_ability_scores();
  void set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE unsafe_arena_release_ability_scores();

  private:
  const ::dnd5e::api::v1alpha1::AbilityScores& _internal_ability_scores() const;
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL _internal_mutable_ability_scores();

  public:
  // string fighting_style = 8 [json_name = "fightingStyle"];
  bool has_fighting_style() const;
  void clear_fighting_style() ;
  const ::std::string& fighting_style() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_fighting_style(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_fighting_style();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_fighting_style();
  void set_allocated_fighting_style(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_fighting_style() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_fighting_style(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_fighting_style();

  public:
  // .dnd5e.api.v1alpha1.EquipmentList equipment = 9 [json_name = "equipment"];
  bool has_equipment() const;
  private:
  bool _internal_has_equipment() const;

  public:
  void clear_equipment() ;
  const ::dnd5e::api::v1alpha1::EquipmentList& equipment() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::EquipmentList* PROTOBUF_NULLABLE release_equipment();
  ::dnd5e::api::v1alpha1::EquipmentList* PROTOBUF_NONNULL mutable_equipment();
  void set_allocated_equipment(::dnd5e::api::v1alpha1::EquipmentList* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_equipment(::dnd5e::api::v1alpha1::EquipmentList* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::EquipmentList* PROTOBUF_NULLABLE unsafe_arena_release_equipment();

  private:
  const ::dnd5e::api::v1alpha1::EquipmentList& _internal_equipment() const;
  ::dnd5e::api::v1alpha1::EquipmentList* PROTOBUF_NONNULL _internal_mutable_equipment();

  public:
  // .dnd5e.api.v1alpha1.RaceChoice race = 10 [json_name = "race"];
  bool has_race() const;
  private:
  bool _internal_has_race() const;

  public:
  void clear_race() ;
  const ::dnd5e::api::v1alpha1::RaceChoice& race() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::RaceChoice* PROTOBUF_NULLABLE release_race();
  ::dnd5e::api::v1alpha1::RaceChoice* PROTOBUF_NONNULL mutable_race();
  void set_allocated_race(::dnd5e::api::v1alpha1::RaceChoice* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_race(::dnd5e::api::v1alpha1::RaceChoice* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::RaceChoice* PROTOBUF_NULLABLE unsafe_arena_release_race();

  private:
  const ::dnd5e::api::v1alpha1::RaceChoice& _internal_race() const;
  ::dnd5e::api::v1alpha1::RaceChoice* PROTOBUF_NONNULL _internal_mutable_race();

  public:
  // .dnd5e.api.v1alpha1.ClassChoice class = 11 [json_name = "class"];
  bool has_class_() const;
  private:
  bool _internal_has_class_() const;

  public:
  void clear_class_() ;
  const ::dnd5e::api::v1alpha1::ClassChoice& class_() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ClassChoice* PROTOBUF_NULLABLE release_class_();
  ::dnd5e::api::v1alpha1::ClassChoice* PROTOBUF_NONNULL mutable_class_();
  void set_allocated_class_(::dnd5e::api::v1alpha1::ClassChoice* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_class_(::dnd5e::api::v1alpha1::ClassChoice* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ClassChoice* PROTOBUF_NULLABLE unsafe_arena_release_class_();

  private:
  const ::dnd5e::api::v1alpha1::ClassChoice& _internal_class_() const;
  ::dnd5e::api::v1alpha1::ClassChoice* PROTOBUF_NONNULL _internal_mutable_class_();

  public:
  // .dnd5e.api.v1alpha1.Background background = 12 [json_name = "background"];
  bool has_background() const;
  void clear_background() ;
  ::dnd5e::api::v1alpha1::Background background() const;
  void set_background(::dnd5e::api::v1alpha1::Background value);

  private:
  ::dnd5e::api::v1alpha1::Background _internal_background() const;
  void _internal_set_background(::dnd5e::api::v1alpha1::Background value);

  public:
  // .dnd5e.api.v1alpha1.SpellList spells = 13 [json_name = "spells"];
  bool has_spells() const;
  private:
  bool _internal_has_spells() const;

  public:
  void clear_spells() ;
  const ::dnd5e::api::v1alpha1::SpellList& spells() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SpellList* PROTOBUF_NULLABLE release_spells();
  ::dnd5e::api::v1alpha1::SpellList* PROTOBUF_NONNULL mutable_spells();
  void set_allocated_spells(::dnd5e::api::v1alpha1::SpellList* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_spells(::dnd5e::api::v1alpha1::SpellList* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SpellList* PROTOBUF_NULLABLE unsafe_arena_release_spells();

  private:
  const ::dnd5e::api::v1alpha1::SpellList& _internal_spells() const;
  ::dnd5e::api::v1alpha1::SpellList* PROTOBUF_NONNULL _internal_mutable_spells();

  public:
  // .dnd5e.api.v1alpha1.CantripList cantrips = 14 [json_name = "cantrips"];
  bool has_cantrips() const;
  private:
  bool _internal_has_cantrips() const;

  public:
  void clear_cantrips() ;
  const ::dnd5e::api::v1alpha1::CantripList& cantrips() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CantripList* PROTOBUF_NULLABLE release_cantrips();
  ::dnd5e::api::v1alpha1::CantripList* PROTOBUF_NONNULL mutable_cantrips();
  void set_allocated_cantrips(::dnd5e::api::v1alpha1::CantripList* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_cantrips(::dnd5e::api::v1alpha1::CantripList* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CantripList* PROTOBUF_NULLABLE unsafe_arena_release_cantrips();

  private:
  const ::dnd5e::api::v1alpha1::CantripList& _internal_cantrips() const;
  ::dnd5e::api::v1alpha1::CantripList* PROTOBUF_NONNULL _internal_mutable_cantrips();

  public:
  void clear_selection();
  SelectionCase selection_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ChoiceData)
 private:
  class _Internal;
  void set_has_name();
  void set_has_skills();
  void set_has_languages();
  void set_has_ability_scores();
  void set_has_fighting_style();
  void set_has_equipment();
  void set_has_race();
  void set_has_class_();
  void set_has_background();
  void set_has_spells();
  void set_has_cantrips();
  inline bool has_selection() const;
  inline void clear_has_selection();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 14,
                                   8, 73,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ChoiceData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr choice_id_;
    int category_;
    int source_;
    union SelectionUnion {
      constexpr SelectionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr name_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE skills_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE languages_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE ability_scores_;
      ::google::protobuf::internal::ArenaStringPtr fighting_style_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE equipment_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE race_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE class__;
      int background_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE spells_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE cantrips_;
    } selection_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ChoiceData_class_data_;
// -------------------------------------------------------------------

class BundleItem final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.BundleItem) */ {
 public:
  inline BundleItem() : BundleItem(nullptr) {}
  ~BundleItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BundleItem* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BundleItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BundleItem(::google::protobuf::internal::ConstantInitialized);

  inline BundleItem(const BundleItem& from) : BundleItem(nullptr, from) {}
  inline BundleItem(BundleItem&& from) noexcept
      : BundleItem(nullptr, ::std::move(from)) {}
  inline BundleItem& operator=(const BundleItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline BundleItem& operator=(BundleItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BundleItem& default_instance() {
    return *reinterpret_cast<const BundleItem*>(
        &_BundleItem_default_instance_);
  }
  enum ItemTypeCase {
    kConcreteItem = 1,
    kChoiceItem = 2,
    ITEM_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 58;
  friend void swap(BundleItem& a, BundleItem& b) { a.Swap(&b); }
  inline void Swap(BundleItem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BundleItem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BundleItem* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BundleItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BundleItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BundleItem& from) { BundleItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BundleItem* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.BundleItem"; }

 protected:
  explicit BundleItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BundleItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BundleItem& from);
  BundleItem(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BundleItem&& from) noexcept
      : BundleItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConcreteItemFieldNumber = 1,
    kChoiceItemFieldNumber = 2,
  };
  // .dnd5e.api.v1alpha1.CountedItemReference concrete_item = 1 [json_name = "concreteItem"];
  bool has_concrete_item() const;
  private:
  bool _internal_has_concrete_item() const;

  public:
  void clear_concrete_item() ;
  const ::dnd5e::api::v1alpha1::CountedItemReference& concrete_item() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE release_concrete_item();
  ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NONNULL mutable_concrete_item();
  void set_allocated_concrete_item(::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_concrete_item(::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE unsafe_arena_release_concrete_item();

  private:
  const ::dnd5e::api::v1alpha1::CountedItemReference& _internal_concrete_item() const;
  ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NONNULL _internal_mutable_concrete_item();

  public:
  // .dnd5e.api.v1alpha1.NestedChoice choice_item = 2 [json_name = "choiceItem"];
  bool has_choice_item() const;
  private:
  bool _internal_has_choice_item() const;

  public:
  void clear_choice_item() ;
  const ::dnd5e::api::v1alpha1::NestedChoice& choice_item() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE release_choice_item();
  ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NONNULL mutable_choice_item();
  void set_allocated_choice_item(::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_choice_item(::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE unsafe_arena_release_choice_item();

  private:
  const ::dnd5e::api::v1alpha1::NestedChoice& _internal_choice_item() const;
  ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NONNULL _internal_mutable_choice_item();

  public:
  void clear_item_type();
  ItemTypeCase item_type_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.BundleItem)
 private:
  class _Internal;
  void set_has_concrete_item();
  void set_has_choice_item();
  inline bool has_item_type() const;
  inline void clear_has_item_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BundleItem& from_msg);
    union ItemTypeUnion {
      constexpr ItemTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE concrete_item_;
      ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE choice_item_;
    } item_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BundleItem_class_data_;
// -------------------------------------------------------------------

class Choice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.Choice) */ {
 public:
  inline Choice() : Choice(nullptr) {}
  ~Choice() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Choice* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Choice));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Choice(::google::protobuf::internal::ConstantInitialized);

  inline Choice(const Choice& from) : Choice(nullptr, from) {}
  inline Choice(Choice&& from) noexcept
      : Choice(nullptr, ::std::move(from)) {}
  inline Choice& operator=(const Choice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Choice& operator=(Choice&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Choice& default_instance() {
    return *reinterpret_cast<const Choice*>(
        &_Choice_default_instance_);
  }
  enum OptionSetCase {
    kExplicitOptions = 5,
    kCategoryReference = 6,
    OPTION_SET_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 51;
  friend void swap(Choice& a, Choice& b) { a.Swap(&b); }
  inline void Swap(Choice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Choice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Choice* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Choice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Choice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Choice& from) { Choice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Choice* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.Choice"; }

 protected:
  explicit Choice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Choice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Choice& from);
  Choice(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Choice&& from) noexcept
      : Choice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kChooseCountFieldNumber = 3,
    kChoiceTypeFieldNumber = 4,
    kExplicitOptionsFieldNumber = 5,
    kCategoryReferenceFieldNumber = 6,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // int32 choose_count = 3 [json_name = "chooseCount"];
  void clear_choose_count() ;
  ::int32_t choose_count() const;
  void set_choose_count(::int32_t value);

  private:
  ::int32_t _internal_choose_count() const;
  void _internal_set_choose_count(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.ChoiceCategory choice_type = 4 [json_name = "choiceType"];
  void clear_choice_type() ;
  ::dnd5e::api::v1alpha1::ChoiceCategory choice_type() const;
  void set_choice_type(::dnd5e::api::v1alpha1::ChoiceCategory value);

  private:
  ::dnd5e::api::v1alpha1::ChoiceCategory _internal_choice_type() const;
  void _internal_set_choice_type(::dnd5e::api::v1alpha1::ChoiceCategory value);

  public:
  // .dnd5e.api.v1alpha1.ExplicitOptions explicit_options = 5 [json_name = "explicitOptions"];
  bool has_explicit_options() const;
  private:
  bool _internal_has_explicit_options() const;

  public:
  void clear_explicit_options() ;
  const ::dnd5e::api::v1alpha1::ExplicitOptions& explicit_options() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ExplicitOptions* PROTOBUF_NULLABLE release_explicit_options();
  ::dnd5e::api::v1alpha1::ExplicitOptions* PROTOBUF_NONNULL mutable_explicit_options();
  void set_allocated_explicit_options(::dnd5e::api::v1alpha1::ExplicitOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_explicit_options(::dnd5e::api::v1alpha1::ExplicitOptions* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ExplicitOptions* PROTOBUF_NULLABLE unsafe_arena_release_explicit_options();

  private:
  const ::dnd5e::api::v1alpha1::ExplicitOptions& _internal_explicit_options() const;
  ::dnd5e::api::v1alpha1::ExplicitOptions* PROTOBUF_NONNULL _internal_mutable_explicit_options();

  public:
  // .dnd5e.api.v1alpha1.CategoryReference category_reference = 6 [json_name = "categoryReference"];
  bool has_category_reference() const;
  private:
  bool _internal_has_category_reference() const;

  public:
  void clear_category_reference() ;
  const ::dnd5e::api::v1alpha1::CategoryReference& category_reference() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CategoryReference* PROTOBUF_NULLABLE release_category_reference();
  ::dnd5e::api::v1alpha1::CategoryReference* PROTOBUF_NONNULL mutable_category_reference();
  void set_allocated_category_reference(::dnd5e::api::v1alpha1::CategoryReference* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_category_reference(::dnd5e::api::v1alpha1::CategoryReference* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CategoryReference* PROTOBUF_NULLABLE unsafe_arena_release_category_reference();

  private:
  const ::dnd5e::api::v1alpha1::CategoryReference& _internal_category_reference() const;
  ::dnd5e::api::v1alpha1::CategoryReference* PROTOBUF_NONNULL _internal_mutable_category_reference();

  public:
  void clear_option_set();
  OptionSetCase option_set_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.Choice)
 private:
  class _Internal;
  void set_has_explicit_options();
  void set_has_category_reference();
  inline bool has_option_set() const;
  inline void clear_has_option_set();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 6,
                                   2, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Choice& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::int32_t choose_count_;
    int choice_type_;
    union OptionSetUnion {
      constexpr OptionSetUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::dnd5e::api::v1alpha1::ExplicitOptions* PROTOBUF_NULLABLE explicit_options_;
      ::dnd5e::api::v1alpha1::CategoryReference* PROTOBUF_NULLABLE category_reference_;
    } option_set_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Choice_class_data_;
// -------------------------------------------------------------------

class ChoiceOption final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ChoiceOption) */ {
 public:
  inline ChoiceOption() : ChoiceOption(nullptr) {}
  ~ChoiceOption() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChoiceOption* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChoiceOption));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChoiceOption(::google::protobuf::internal::ConstantInitialized);

  inline ChoiceOption(const ChoiceOption& from) : ChoiceOption(nullptr, from) {}
  inline ChoiceOption(ChoiceOption&& from) noexcept
      : ChoiceOption(nullptr, ::std::move(from)) {}
  inline ChoiceOption& operator=(const ChoiceOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChoiceOption& operator=(ChoiceOption&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChoiceOption& default_instance() {
    return *reinterpret_cast<const ChoiceOption*>(
        &_ChoiceOption_default_instance_);
  }
  enum OptionTypeCase {
    kItem = 1,
    kCountedItem = 2,
    kBundle = 3,
    kNestedChoice = 4,
    OPTION_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 54;
  friend void swap(ChoiceOption& a, ChoiceOption& b) { a.Swap(&b); }
  inline void Swap(ChoiceOption* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChoiceOption* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChoiceOption* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChoiceOption>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChoiceOption& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChoiceOption& from) { ChoiceOption::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChoiceOption* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ChoiceOption"; }

 protected:
  explicit ChoiceOption(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ChoiceOption(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChoiceOption& from);
  ChoiceOption(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ChoiceOption&& from) noexcept
      : ChoiceOption(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemFieldNumber = 1,
    kCountedItemFieldNumber = 2,
    kBundleFieldNumber = 3,
    kNestedChoiceFieldNumber = 4,
  };
  // .dnd5e.api.v1alpha1.ItemReference item = 1 [json_name = "item"];
  bool has_item() const;
  private:
  bool _internal_has_item() const;

  public:
  void clear_item() ;
  const ::dnd5e::api::v1alpha1::ItemReference& item() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ItemReference* PROTOBUF_NULLABLE release_item();
  ::dnd5e::api::v1alpha1::ItemReference* PROTOBUF_NONNULL mutable_item();
  void set_allocated_item(::dnd5e::api::v1alpha1::ItemReference* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_item(::dnd5e::api::v1alpha1::ItemReference* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ItemReference* PROTOBUF_NULLABLE unsafe_arena_release_item();

  private:
  const ::dnd5e::api::v1alpha1::ItemReference& _internal_item() const;
  ::dnd5e::api::v1alpha1::ItemReference* PROTOBUF_NONNULL _internal_mutable_item();

  public:
  // .dnd5e.api.v1alpha1.CountedItemReference counted_item = 2 [json_name = "countedItem"];
  bool has_counted_item() const;
  private:
  bool _internal_has_counted_item() const;

  public:
  void clear_counted_item() ;
  const ::dnd5e::api::v1alpha1::CountedItemReference& counted_item() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE release_counted_item();
  ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NONNULL mutable_counted_item();
  void set_allocated_counted_item(::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_counted_item(::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE unsafe_arena_release_counted_item();

  private:
  const ::dnd5e::api::v1alpha1::CountedItemReference& _internal_counted_item() const;
  ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NONNULL _internal_mutable_counted_item();

  public:
  // .dnd5e.api.v1alpha1.ItemBundle bundle = 3 [json_name = "bundle"];
  bool has_bundle() const;
  private:
  bool _internal_has_bundle() const;

  public:
  void clear_bundle() ;
  const ::dnd5e::api::v1alpha1::ItemBundle& bundle() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ItemBundle* PROTOBUF_NULLABLE release_bundle();
  ::dnd5e::api::v1alpha1::ItemBundle* PROTOBUF_NONNULL mutable_bundle();
  void set_allocated_bundle(::dnd5e::api::v1alpha1::ItemBundle* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bundle(::dnd5e::api::v1alpha1::ItemBundle* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ItemBundle* PROTOBUF_NULLABLE unsafe_arena_release_bundle();

  private:
  const ::dnd5e::api::v1alpha1::ItemBundle& _internal_bundle() const;
  ::dnd5e::api::v1alpha1::ItemBundle* PROTOBUF_NONNULL _internal_mutable_bundle();

  public:
  // .dnd5e.api.v1alpha1.NestedChoice nested_choice = 4 [json_name = "nestedChoice"];
  bool has_nested_choice() const;
  private:
  bool _internal_has_nested_choice() const;

  public:
  void clear_nested_choice() ;
  const ::dnd5e::api::v1alpha1::NestedChoice& nested_choice() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE release_nested_choice();
  ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NONNULL mutable_nested_choice();
  void set_allocated_nested_choice(::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_nested_choice(::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE unsafe_arena_release_nested_choice();

  private:
  const ::dnd5e::api::v1alpha1::NestedChoice& _internal_nested_choice() const;
  ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NONNULL _internal_mutable_nested_choice();

  public:
  void clear_option_type();
  OptionTypeCase option_type_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ChoiceOption)
 private:
  class _Internal;
  void set_has_item();
  void set_has_counted_item();
  void set_has_bundle();
  void set_has_nested_choice();
  inline bool has_option_type() const;
  inline void clear_has_option_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ChoiceOption& from_msg);
    union OptionTypeUnion {
      constexpr OptionTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE item_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE counted_item_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE bundle_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE nested_choice_;
    } option_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ChoiceOption_class_data_;
// -------------------------------------------------------------------

class ExplicitOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ExplicitOptions) */ {
 public:
  inline ExplicitOptions() : ExplicitOptions(nullptr) {}
  ~ExplicitOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExplicitOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExplicitOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExplicitOptions(::google::protobuf::internal::ConstantInitialized);

  inline ExplicitOptions(const ExplicitOptions& from) : ExplicitOptions(nullptr, from) {}
  inline ExplicitOptions(ExplicitOptions&& from) noexcept
      : ExplicitOptions(nullptr, ::std::move(from)) {}
  inline ExplicitOptions& operator=(const ExplicitOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExplicitOptions& operator=(ExplicitOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExplicitOptions& default_instance() {
    return *reinterpret_cast<const ExplicitOptions*>(
        &_ExplicitOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 52;
  friend void swap(ExplicitOptions& a, ExplicitOptions& b) { a.Swap(&b); }
  inline void Swap(ExplicitOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExplicitOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExplicitOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExplicitOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExplicitOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExplicitOptions& from) { ExplicitOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExplicitOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ExplicitOptions"; }

 protected:
  explicit ExplicitOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ExplicitOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ExplicitOptions& from);
  ExplicitOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ExplicitOptions&& from) noexcept
      : ExplicitOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOptionsFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.ChoiceOption options = 1 [json_name = "options"];
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  ::dnd5e::api::v1alpha1::ChoiceOption* PROTOBUF_NONNULL mutable_options(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceOption>* PROTOBUF_NONNULL mutable_options();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceOption>& _internal_options() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceOption>* PROTOBUF_NONNULL _internal_mutable_options();
  public:
  const ::dnd5e::api::v1alpha1::ChoiceOption& options(int index) const;
  ::dnd5e::api::v1alpha1::ChoiceOption* PROTOBUF_NONNULL add_options();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceOption>& options() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ExplicitOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ExplicitOptions& from_msg);
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ChoiceOption > options_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExplicitOptions_class_data_;
// -------------------------------------------------------------------

class ItemBundle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ItemBundle) */ {
 public:
  inline ItemBundle() : ItemBundle(nullptr) {}
  ~ItemBundle() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ItemBundle* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ItemBundle));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ItemBundle(::google::protobuf::internal::ConstantInitialized);

  inline ItemBundle(const ItemBundle& from) : ItemBundle(nullptr, from) {}
  inline ItemBundle(ItemBundle&& from) noexcept
      : ItemBundle(nullptr, ::std::move(from)) {}
  inline ItemBundle& operator=(const ItemBundle& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemBundle& operator=(ItemBundle&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemBundle& default_instance() {
    return *reinterpret_cast<const ItemBundle*>(
        &_ItemBundle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 57;
  friend void swap(ItemBundle& a, ItemBundle& b) { a.Swap(&b); }
  inline void Swap(ItemBundle* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemBundle* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemBundle* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ItemBundle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ItemBundle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ItemBundle& from) { ItemBundle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ItemBundle* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ItemBundle"; }

 protected:
  explicit ItemBundle(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ItemBundle(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ItemBundle& from);
  ItemBundle(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ItemBundle&& from) noexcept
      : ItemBundle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.BundleItem items = 1 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::dnd5e::api::v1alpha1::BundleItem* PROTOBUF_NONNULL mutable_items(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BundleItem>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BundleItem>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BundleItem>* PROTOBUF_NONNULL _internal_mutable_items();
  public:
  const ::dnd5e::api::v1alpha1::BundleItem& items(int index) const;
  ::dnd5e::api::v1alpha1::BundleItem* PROTOBUF_NONNULL add_items();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BundleItem>& items() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ItemBundle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ItemBundle& from_msg);
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::BundleItem > items_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ItemBundle_class_data_;
// -------------------------------------------------------------------

class NestedChoice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.NestedChoice) */ {
 public:
  inline NestedChoice() : NestedChoice(nullptr) {}
  ~NestedChoice() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NestedChoice* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NestedChoice));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NestedChoice(::google::protobuf::internal::ConstantInitialized);

  inline NestedChoice(const NestedChoice& from) : NestedChoice(nullptr, from) {}
  inline NestedChoice(NestedChoice&& from) noexcept
      : NestedChoice(nullptr, ::std::move(from)) {}
  inline NestedChoice& operator=(const NestedChoice& from) {
    CopyFrom(from);
    return *this;
  }
  inline NestedChoice& operator=(NestedChoice&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NestedChoice& default_instance() {
    return *reinterpret_cast<const NestedChoice*>(
        &_NestedChoice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 59;
  friend void swap(NestedChoice& a, NestedChoice& b) { a.Swap(&b); }
  inline void Swap(NestedChoice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NestedChoice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NestedChoice* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NestedChoice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NestedChoice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NestedChoice& from) { NestedChoice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NestedChoice* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.NestedChoice"; }

 protected:
  explicit NestedChoice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NestedChoice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NestedChoice& from);
  NestedChoice(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NestedChoice&& from) noexcept
      : NestedChoice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChoiceFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.Choice choice = 1 [json_name = "choice"];
  bool has_choice() const;
  void clear_choice() ;
  const ::dnd5e::api::v1alpha1::Choice& choice() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NULLABLE release_choice();
  ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL mutable_choice();
  void set_allocated_choice(::dnd5e::api::v1alpha1::Choice* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_choice(::dnd5e::api::v1alpha1::Choice* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NULLABLE unsafe_arena_release_choice();

  private:
  const ::dnd5e::api::v1alpha1::Choice& _internal_choice() const;
  ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL _internal_mutable_choice();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.NestedChoice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NestedChoice& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NULLABLE choice_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NestedChoice_class_data_;
// -------------------------------------------------------------------

class AddToInventoryRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AddToInventoryRequest) */ {
 public:
  inline AddToInventoryRequest() : AddToInventoryRequest(nullptr) {}
  ~AddToInventoryRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AddToInventoryRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AddToInventoryRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddToInventoryRequest(::google::protobuf::internal::ConstantInitialized);

  inline AddToInventoryRequest(const AddToInventoryRequest& from) : AddToInventoryRequest(nullptr, from) {}
  inline AddToInventoryRequest(AddToInventoryRequest&& from) noexcept
      : AddToInventoryRequest(nullptr, ::std::move(from)) {}
  inline AddToInventoryRequest& operator=(const AddToInventoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddToInventoryRequest& operator=(AddToInventoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddToInventoryRequest& default_instance() {
    return *reinterpret_cast<const AddToInventoryRequest*>(
        &_AddToInventoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 116;
  friend void swap(AddToInventoryRequest& a, AddToInventoryRequest& b) { a.Swap(&b); }
  inline void Swap(AddToInventoryRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddToInventoryRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddToInventoryRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AddToInventoryRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddToInventoryRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddToInventoryRequest& from) { AddToInventoryRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AddToInventoryRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AddToInventoryRequest"; }

 protected:
  explicit AddToInventoryRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AddToInventoryRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AddToInventoryRequest& from);
  AddToInventoryRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AddToInventoryRequest&& from) noexcept
      : AddToInventoryRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 2,
    kCharacterIdFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.InventoryAddition items = 2 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::dnd5e::api::v1alpha1::InventoryAddition* PROTOBUF_NONNULL mutable_items(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryAddition>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryAddition>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryAddition>* PROTOBUF_NONNULL _internal_mutable_items();
  public:
  const ::dnd5e::api::v1alpha1::InventoryAddition& items(int index) const;
  ::dnd5e::api::v1alpha1::InventoryAddition* PROTOBUF_NONNULL add_items();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryAddition>& items() const;
  // string character_id = 1 [json_name = "characterId"];
  void clear_character_id() ;
  const ::std::string& character_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_character_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_character_id();
  void set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_character_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_character_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AddToInventoryRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 61,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AddToInventoryRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::InventoryAddition > items_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AddToInventoryRequest_class_data_;
// -------------------------------------------------------------------

class UpdateRaceRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateRaceRequest) */ {
 public:
  inline UpdateRaceRequest() : UpdateRaceRequest(nullptr) {}
  ~UpdateRaceRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateRaceRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateRaceRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateRaceRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateRaceRequest(const UpdateRaceRequest& from) : UpdateRaceRequest(nullptr, from) {}
  inline UpdateRaceRequest(UpdateRaceRequest&& from) noexcept
      : UpdateRaceRequest(nullptr, ::std::move(from)) {}
  inline UpdateRaceRequest& operator=(const UpdateRaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRaceRequest& operator=(UpdateRaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRaceRequest& default_instance() {
    return *reinterpret_cast<const UpdateRaceRequest*>(
        &_UpdateRaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(UpdateRaceRequest& a, UpdateRaceRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateRaceRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRaceRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRaceRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateRaceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateRaceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateRaceRequest& from) { UpdateRaceRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateRaceRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateRaceRequest"; }

 protected:
  explicit UpdateRaceRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateRaceRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateRaceRequest& from);
  UpdateRaceRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateRaceRequest&& from) noexcept
      : UpdateRaceRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRaceChoicesFieldNumber = 4,
    kDraftIdFieldNumber = 1,
    kRaceFieldNumber = 2,
    kSubraceFieldNumber = 3,
  };
  // repeated .dnd5e.api.v1alpha1.ChoiceSelection race_choices = 4 [json_name = "raceChoices"];
  int race_choices_size() const;
  private:
  int _internal_race_choices_size() const;

  public:
  void clear_race_choices() ;
  ::dnd5e::api::v1alpha1::ChoiceSelection* PROTOBUF_NONNULL mutable_race_choices(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>* PROTOBUF_NONNULL mutable_race_choices();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>& _internal_race_choices() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>* PROTOBUF_NONNULL _internal_mutable_race_choices();
  public:
  const ::dnd5e::api::v1alpha1::ChoiceSelection& race_choices(int index) const;
  ::dnd5e::api::v1alpha1::ChoiceSelection* PROTOBUF_NONNULL add_race_choices();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>& race_choices() const;
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // .dnd5e.api.v1alpha1.Race race = 2 [json_name = "race"];
  void clear_race() ;
  ::dnd5e::api::v1alpha1::Race race() const;
  void set_race(::dnd5e::api::v1alpha1::Race value);

  private:
  ::dnd5e::api::v1alpha1::Race _internal_race() const;
  void _internal_set_race(::dnd5e::api::v1alpha1::Race value);

  public:
  // .dnd5e.api.v1alpha1.Subrace subrace = 3 [json_name = "subrace"];
  void clear_subrace() ;
  ::dnd5e::api::v1alpha1::Subrace subrace() const;
  void set_subrace(::dnd5e::api::v1alpha1::Subrace value);

  private:
  ::dnd5e::api::v1alpha1::Subrace _internal_subrace() const;
  void _internal_set_subrace(::dnd5e::api::v1alpha1::Subrace value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateRaceRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 53,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateRaceRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ChoiceSelection > race_choices_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    int race_;
    int subrace_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateRaceRequest_class_data_;
// -------------------------------------------------------------------

class UpdateClassRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateClassRequest) */ {
 public:
  inline UpdateClassRequest() : UpdateClassRequest(nullptr) {}
  ~UpdateClassRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateClassRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateClassRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateClassRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateClassRequest(const UpdateClassRequest& from) : UpdateClassRequest(nullptr, from) {}
  inline UpdateClassRequest(UpdateClassRequest&& from) noexcept
      : UpdateClassRequest(nullptr, ::std::move(from)) {}
  inline UpdateClassRequest& operator=(const UpdateClassRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateClassRequest& operator=(UpdateClassRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateClassRequest& default_instance() {
    return *reinterpret_cast<const UpdateClassRequest*>(
        &_UpdateClassRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(UpdateClassRequest& a, UpdateClassRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateClassRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateClassRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateClassRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateClassRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateClassRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateClassRequest& from) { UpdateClassRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateClassRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateClassRequest"; }

 protected:
  explicit UpdateClassRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateClassRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateClassRequest& from);
  UpdateClassRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateClassRequest&& from) noexcept
      : UpdateClassRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClassChoicesFieldNumber = 3,
    kDraftIdFieldNumber = 1,
    kClassFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.ChoiceSelection class_choices = 3 [json_name = "classChoices"];
  int class_choices_size() const;
  private:
  int _internal_class_choices_size() const;

  public:
  void clear_class_choices() ;
  ::dnd5e::api::v1alpha1::ChoiceSelection* PROTOBUF_NONNULL mutable_class_choices(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>* PROTOBUF_NONNULL mutable_class_choices();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>& _internal_class_choices() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>* PROTOBUF_NONNULL _internal_mutable_class_choices();
  public:
  const ::dnd5e::api::v1alpha1::ChoiceSelection& class_choices(int index) const;
  ::dnd5e::api::v1alpha1::ChoiceSelection* PROTOBUF_NONNULL add_class_choices();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>& class_choices() const;
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // .dnd5e.api.v1alpha1.Class class = 2 [json_name = "class"];
  void clear_class_() ;
  ::dnd5e::api::v1alpha1::Class class_() const;
  void set_class_(::dnd5e::api::v1alpha1::Class value);

  private:
  ::dnd5e::api::v1alpha1::Class _internal_class_() const;
  void _internal_set_class_(::dnd5e::api::v1alpha1::Class value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateClassRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 54,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateClassRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ChoiceSelection > class_choices_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    int class__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateClassRequest_class_data_;
// -------------------------------------------------------------------

class UpdateBackgroundRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateBackgroundRequest) */ {
 public:
  inline UpdateBackgroundRequest() : UpdateBackgroundRequest(nullptr) {}
  ~UpdateBackgroundRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateBackgroundRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateBackgroundRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateBackgroundRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateBackgroundRequest(const UpdateBackgroundRequest& from) : UpdateBackgroundRequest(nullptr, from) {}
  inline UpdateBackgroundRequest(UpdateBackgroundRequest&& from) noexcept
      : UpdateBackgroundRequest(nullptr, ::std::move(from)) {}
  inline UpdateBackgroundRequest& operator=(const UpdateBackgroundRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBackgroundRequest& operator=(UpdateBackgroundRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateBackgroundRequest& default_instance() {
    return *reinterpret_cast<const UpdateBackgroundRequest*>(
        &_UpdateBackgroundRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(UpdateBackgroundRequest& a, UpdateBackgroundRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateBackgroundRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateBackgroundRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateBackgroundRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateBackgroundRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateBackgroundRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateBackgroundRequest& from) { UpdateBackgroundRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateBackgroundRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateBackgroundRequest"; }

 protected:
  explicit UpdateBackgroundRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateBackgroundRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateBackgroundRequest& from);
  UpdateBackgroundRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateBackgroundRequest&& from) noexcept
      : UpdateBackgroundRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBackgroundChoicesFieldNumber = 3,
    kDraftIdFieldNumber = 1,
    kBackgroundFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.ChoiceSelection background_choices = 3 [json_name = "backgroundChoices"];
  int background_choices_size() const;
  private:
  int _internal_background_choices_size() const;

  public:
  void clear_background_choices() ;
  ::dnd5e::api::v1alpha1::ChoiceSelection* PROTOBUF_NONNULL mutable_background_choices(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>* PROTOBUF_NONNULL mutable_background_choices();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>& _internal_background_choices() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>* PROTOBUF_NONNULL _internal_mutable_background_choices();
  public:
  const ::dnd5e::api::v1alpha1::ChoiceSelection& background_choices(int index) const;
  ::dnd5e::api::v1alpha1::ChoiceSelection* PROTOBUF_NONNULL add_background_choices();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>& background_choices() const;
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // .dnd5e.api.v1alpha1.Background background = 2 [json_name = "background"];
  void clear_background() ;
  ::dnd5e::api::v1alpha1::Background background() const;
  void set_background(::dnd5e::api::v1alpha1::Background value);

  private:
  ::dnd5e::api::v1alpha1::Background _internal_background() const;
  void _internal_set_background(::dnd5e::api::v1alpha1::Background value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateBackgroundRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateBackgroundRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ChoiceSelection > background_choices_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    int background_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateBackgroundRequest_class_data_;
// -------------------------------------------------------------------

class Spell final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.Spell) */ {
 public:
  inline Spell() : Spell(nullptr) {}
  ~Spell() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Spell* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Spell));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Spell(::google::protobuf::internal::ConstantInitialized);

  inline Spell(const Spell& from) : Spell(nullptr, from) {}
  inline Spell(Spell&& from) noexcept
      : Spell(nullptr, ::std::move(from)) {}
  inline Spell& operator=(const Spell& from) {
    CopyFrom(from);
    return *this;
  }
  inline Spell& operator=(Spell&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Spell& default_instance() {
    return *reinterpret_cast<const Spell*>(
        &_Spell_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 92;
  friend void swap(Spell& a, Spell& b) { a.Swap(&b); }
  inline void Swap(Spell* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Spell* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Spell* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Spell>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Spell& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Spell& from) { Spell::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Spell* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.Spell"; }

 protected:
  explicit Spell(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Spell(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Spell& from);
  Spell(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Spell&& from) noexcept
      : Spell(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClassesFieldNumber = 5,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kSchoolFieldNumber = 4,
    kCastingTimeFieldNumber = 6,
    kRangeFieldNumber = 7,
    kDurationFieldNumber = 8,
    kComponentsFieldNumber = 11,
    kDescriptionFieldNumber = 12,
    kDamageFieldNumber = 13,
    kAreaOfEffectFieldNumber = 14,
    kLevelFieldNumber = 3,
    kRitualFieldNumber = 9,
    kConcentrationFieldNumber = 10,
  };
  // repeated string classes = 5 [json_name = "classes"];
  int classes_size() const;
  private:
  int _internal_classes_size() const;

  public:
  void clear_classes() ;
  const ::std::string& classes(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_classes(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_classes(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_classes();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_classes(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& classes() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_classes();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_classes() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_classes();

  public:
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string school = 4 [json_name = "school"];
  void clear_school() ;
  const ::std::string& school() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_school(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_school();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_school();
  void set_allocated_school(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_school() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_school(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_school();

  public:
  // string casting_time = 6 [json_name = "castingTime"];
  void clear_casting_time() ;
  const ::std::string& casting_time() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_casting_time(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_casting_time();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_casting_time();
  void set_allocated_casting_time(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_casting_time() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_casting_time(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_casting_time();

  public:
  // string range = 7 [json_name = "range"];
  void clear_range() ;
  const ::std::string& range() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_range(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_range();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_range();
  void set_allocated_range(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_range() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_range(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_range();

  public:
  // string duration = 8 [json_name = "duration"];
  void clear_duration() ;
  const ::std::string& duration() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_duration(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_duration();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_duration();
  void set_allocated_duration(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_duration() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_duration(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_duration();

  public:
  // string components = 11 [json_name = "components"];
  void clear_components() ;
  const ::std::string& components() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_components(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_components();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_components();
  void set_allocated_components(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_components() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_components(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_components();

  public:
  // string description = 12 [json_name = "description"];
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // .dnd5e.api.v1alpha1.SpellDamage damage = 13 [json_name = "damage"];
  bool has_damage() const;
  void clear_damage() ;
  const ::dnd5e::api::v1alpha1::SpellDamage& damage() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NULLABLE release_damage();
  ::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NONNULL mutable_damage();
  void set_allocated_damage(::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_damage(::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NULLABLE unsafe_arena_release_damage();

  private:
  const ::dnd5e::api::v1alpha1::SpellDamage& _internal_damage() const;
  ::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NONNULL _internal_mutable_damage();

  public:
  // .dnd5e.api.v1alpha1.AreaOfEffect area_of_effect = 14 [json_name = "areaOfEffect"];
  bool has_area_of_effect() const;
  void clear_area_of_effect() ;
  const ::dnd5e::api::v1alpha1::AreaOfEffect& area_of_effect() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NULLABLE release_area_of_effect();
  ::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NONNULL mutable_area_of_effect();
  void set_allocated_area_of_effect(::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_area_of_effect(::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NULLABLE unsafe_arena_release_area_of_effect();

  private:
  const ::dnd5e::api::v1alpha1::AreaOfEffect& _internal_area_of_effect() const;
  ::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NONNULL _internal_mutable_area_of_effect();

  public:
  // int32 level = 3 [json_name = "level"];
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // bool ritual = 9 [json_name = "ritual"];
  void clear_ritual() ;
  bool ritual() const;
  void set_ritual(bool value);

  private:
  bool _internal_ritual() const;
  void _internal_set_ritual(bool value);

  public:
  // bool concentration = 10 [json_name = "concentration"];
  void clear_concentration() ;
  bool concentration() const;
  void set_concentration(bool value);

  private:
  bool _internal_concentration() const;
  void _internal_set_concentration(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.Spell)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 14,
                                   2, 106,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Spell& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> classes_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr school_;
    ::google::protobuf::internal::ArenaStringPtr casting_time_;
    ::google::protobuf::internal::ArenaStringPtr range_;
    ::google::protobuf::internal::ArenaStringPtr duration_;
    ::google::protobuf::internal::ArenaStringPtr components_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NULLABLE damage_;
    ::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NULLABLE area_of_effect_;
    ::int32_t level_;
    bool ritual_;
    bool concentration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Spell_class_data_;
// -------------------------------------------------------------------

class RaceInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.RaceInfo) */ {
 public:
  inline RaceInfo() : RaceInfo(nullptr) {}
  ~RaceInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RaceInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RaceInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RaceInfo(::google::protobuf::internal::ConstantInitialized);

  inline RaceInfo(const RaceInfo& from) : RaceInfo(nullptr, from) {}
  inline RaceInfo(RaceInfo&& from) noexcept
      : RaceInfo(nullptr, ::std::move(from)) {}
  inline RaceInfo& operator=(const RaceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaceInfo& operator=(RaceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaceInfo& default_instance() {
    return *reinterpret_cast<const RaceInfo*>(
        &_RaceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 47;
  friend void swap(RaceInfo& a, RaceInfo& b) { a.Swap(&b); }
  inline void Swap(RaceInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaceInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaceInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RaceInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RaceInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RaceInfo& from) { RaceInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RaceInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.RaceInfo"; }

 protected:
  explicit RaceInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RaceInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RaceInfo& from);
  RaceInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RaceInfo&& from) noexcept
      : RaceInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAbilityBonusesFieldNumber = 6,
    kTraitsFieldNumber = 7,
    kSubracesFieldNumber = 8,
    kProficienciesFieldNumber = 9,
    kLanguagesFieldNumber = 10,
    kChoicesFieldNumber = 14,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kAgeDescriptionFieldNumber = 11,
    kAlignmentDescriptionFieldNumber = 12,
    kSizeDescriptionFieldNumber = 13,
    kSpeedFieldNumber = 4,
    kSizeFieldNumber = 5,
  };
  // map<string, int32> ability_bonuses = 6 [json_name = "abilityBonuses"];
  int ability_bonuses_size() const;
  private:
  int _internal_ability_bonuses_size() const;

  public:
  void clear_ability_bonuses() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& ability_bonuses() const;
  ::google::protobuf::Map<std::string, ::int32_t>* PROTOBUF_NONNULL mutable_ability_bonuses();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_ability_bonuses() const;
  ::google::protobuf::Map<std::string, ::int32_t>* PROTOBUF_NONNULL _internal_mutable_ability_bonuses();

  public:
  // repeated .dnd5e.api.v1alpha1.RacialTrait traits = 7 [json_name = "traits"];
  int traits_size() const;
  private:
  int _internal_traits_size() const;

  public:
  void clear_traits() ;
  ::dnd5e::api::v1alpha1::RacialTrait* PROTOBUF_NONNULL mutable_traits(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>* PROTOBUF_NONNULL mutable_traits();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>& _internal_traits() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>* PROTOBUF_NONNULL _internal_mutable_traits();
  public:
  const ::dnd5e::api::v1alpha1::RacialTrait& traits(int index) const;
  ::dnd5e::api::v1alpha1::RacialTrait* PROTOBUF_NONNULL add_traits();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>& traits() const;
  // repeated .dnd5e.api.v1alpha1.SubraceInfo subraces = 8 [json_name = "subraces"];
  int subraces_size() const;
  private:
  int _internal_subraces_size() const;

  public:
  void clear_subraces() ;
  ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NONNULL mutable_subraces(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::SubraceInfo>* PROTOBUF_NONNULL mutable_subraces();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::SubraceInfo>& _internal_subraces() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::SubraceInfo>* PROTOBUF_NONNULL _internal_mutable_subraces();
  public:
  const ::dnd5e::api::v1alpha1::SubraceInfo& subraces(int index) const;
  ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NONNULL add_subraces();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::SubraceInfo>& subraces() const;
  // repeated string proficiencies = 9 [json_name = "proficiencies"];
  int proficiencies_size() const;
  private:
  int _internal_proficiencies_size() const;

  public:
  void clear_proficiencies() ;
  const ::std::string& proficiencies(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_proficiencies(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_proficiencies(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_proficiencies();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_proficiencies(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_proficiencies();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_proficiencies();

  public:
  // repeated .dnd5e.api.v1alpha1.Language languages = 10 [json_name = "languages"];
  int languages_size() const;
  private:
  int _internal_languages_size() const;

  public:
  void clear_languages() ;
  public:
  ::dnd5e::api::v1alpha1::Language languages(int index) const;
  void set_languages(int index, ::dnd5e::api::v1alpha1::Language value);
  void add_languages(::dnd5e::api::v1alpha1::Language value);
  const ::google::protobuf::RepeatedField<int>& languages() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_languages();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_languages() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_languages();

  public:
  // repeated .dnd5e.api.v1alpha1.Choice choices = 14 [json_name = "choices"];
  int choices_size() const;
  private:
  int _internal_choices_size() const;

  public:
  void clear_choices() ;
  ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL mutable_choices(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>* PROTOBUF_NONNULL mutable_choices();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>& _internal_choices() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>* PROTOBUF_NONNULL _internal_mutable_choices();
  public:
  const ::dnd5e::api::v1alpha1::Choice& choices(int index) const;
  ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL add_choices();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>& choices() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string description = 3 [json_name = "description"];
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // string age_description = 11 [json_name = "ageDescription"];
  void clear_age_description() ;
  const ::std::string& age_description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_age_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_age_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_age_description();
  void set_allocated_age_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_age_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_age_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_age_description();

  public:
  // string alignment_description = 12 [json_name = "alignmentDescription"];
  void clear_alignment_description() ;
  const ::std::string& alignment_description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_alignment_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_alignment_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_alignment_description();
  void set_allocated_alignment_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_alignment_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_alignment_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_alignment_description();

  public:
  // string size_description = 13 [json_name = "sizeDescription"];
  void clear_size_description() ;
  const ::std::string& size_description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_size_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_size_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_size_description();
  void set_allocated_size_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_size_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_size_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_size_description();

  public:
  // int32 speed = 4 [json_name = "speed"];
  void clear_speed() ;
  ::int32_t speed() const;
  void set_speed(::int32_t value);

  private:
  ::int32_t _internal_speed() const;
  void _internal_set_speed(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.Size size = 5 [json_name = "size"];
  void clear_size() ;
  ::dnd5e::api::v1alpha1::Size size() const;
  void set_size(::dnd5e::api::v1alpha1::Size value);

  private:
  ::dnd5e::api::v1alpha1::Size _internal_size() const;
  void _internal_set_size(::dnd5e::api::v1alpha1::Size value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.RaceInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 14,
                                   4, 141,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RaceInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<RaceInfo_AbilityBonusesEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        ability_bonuses_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::RacialTrait > traits_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::SubraceInfo > subraces_;
    ::google::protobuf::RepeatedPtrField<::std::string> proficiencies_;
    ::google::protobuf::RepeatedField<int> languages_;
    ::google::protobuf::internal::CachedSize _languages_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::Choice > choices_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr age_description_;
    ::google::protobuf::internal::ArenaStringPtr alignment_description_;
    ::google::protobuf::internal::ArenaStringPtr size_description_;
    ::int32_t speed_;
    int size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RaceInfo_class_data_;
// -------------------------------------------------------------------

class ListEquipmentByTypeResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse) */ {
 public:
  inline ListEquipmentByTypeResponse() : ListEquipmentByTypeResponse(nullptr) {}
  ~ListEquipmentByTypeResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListEquipmentByTypeResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListEquipmentByTypeResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListEquipmentByTypeResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListEquipmentByTypeResponse(const ListEquipmentByTypeResponse& from) : ListEquipmentByTypeResponse(nullptr, from) {}
  inline ListEquipmentByTypeResponse(ListEquipmentByTypeResponse&& from) noexcept
      : ListEquipmentByTypeResponse(nullptr, ::std::move(from)) {}
  inline ListEquipmentByTypeResponse& operator=(const ListEquipmentByTypeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListEquipmentByTypeResponse& operator=(ListEquipmentByTypeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListEquipmentByTypeResponse& default_instance() {
    return *reinterpret_cast<const ListEquipmentByTypeResponse*>(
        &_ListEquipmentByTypeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 107;
  friend void swap(ListEquipmentByTypeResponse& a, ListEquipmentByTypeResponse& b) { a.Swap(&b); }
  inline void Swap(ListEquipmentByTypeResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListEquipmentByTypeResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListEquipmentByTypeResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListEquipmentByTypeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListEquipmentByTypeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListEquipmentByTypeResponse& from) { ListEquipmentByTypeResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListEquipmentByTypeResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListEquipmentByTypeResponse"; }

 protected:
  explicit ListEquipmentByTypeResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListEquipmentByTypeResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListEquipmentByTypeResponse& from);
  ListEquipmentByTypeResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListEquipmentByTypeResponse&& from) noexcept
      : ListEquipmentByTypeResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEquipmentFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .dnd5e.api.v1alpha1.Equipment equipment = 1 [json_name = "equipment"];
  int equipment_size() const;
  private:
  int _internal_equipment_size() const;

  public:
  void clear_equipment() ;
  ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NONNULL mutable_equipment(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Equipment>* PROTOBUF_NONNULL mutable_equipment();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Equipment>& _internal_equipment() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Equipment>* PROTOBUF_NONNULL _internal_mutable_equipment();
  public:
  const ::dnd5e::api::v1alpha1::Equipment& equipment(int index) const;
  ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NONNULL add_equipment();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Equipment>& equipment() const;
  // string next_page_token = 2 [json_name = "nextPageToken"];
  void clear_next_page_token() ;
  const ::std::string& next_page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_next_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_next_page_token();
  void set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_next_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_next_page_token();

  public:
  // int32 total_size = 3 [json_name = "totalSize"];
  void clear_total_size() ;
  ::int32_t total_size() const;
  void set_total_size(::int32_t value);

  private:
  ::int32_t _internal_total_size() const;
  void _internal_set_total_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 70,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListEquipmentByTypeResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::Equipment > equipment_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::int32_t total_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListEquipmentByTypeResponse_class_data_;
// -------------------------------------------------------------------

class InventoryItem final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.InventoryItem) */ {
 public:
  inline InventoryItem() : InventoryItem(nullptr) {}
  ~InventoryItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InventoryItem* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InventoryItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InventoryItem(::google::protobuf::internal::ConstantInitialized);

  inline InventoryItem(const InventoryItem& from) : InventoryItem(nullptr, from) {}
  inline InventoryItem(InventoryItem&& from) noexcept
      : InventoryItem(nullptr, ::std::move(from)) {}
  inline InventoryItem& operator=(const InventoryItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryItem& operator=(InventoryItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryItem& default_instance() {
    return *reinterpret_cast<const InventoryItem*>(
        &_InventoryItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 90;
  friend void swap(InventoryItem& a, InventoryItem& b) { a.Swap(&b); }
  inline void Swap(InventoryItem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryItem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryItem* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InventoryItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InventoryItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InventoryItem& from) { InventoryItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InventoryItem* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.InventoryItem"; }

 protected:
  explicit InventoryItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InventoryItem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InventoryItem& from);
  InventoryItem(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InventoryItem&& from) noexcept
      : InventoryItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemIdFieldNumber = 1,
    kCustomNameFieldNumber = 4,
    kEquipmentFieldNumber = 5,
    kQuantityFieldNumber = 2,
    kIsAttunedFieldNumber = 3,
  };
  // string item_id = 1 [json_name = "itemId"];
  void clear_item_id() ;
  const ::std::string& item_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_item_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_item_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_item_id();
  void set_allocated_item_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_item_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_item_id();

  public:
  // string custom_name = 4 [json_name = "customName"];
  void clear_custom_name() ;
  const ::std::string& custom_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_custom_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_custom_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_custom_name();
  void set_allocated_custom_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_custom_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_custom_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_custom_name();

  public:
  // .dnd5e.api.v1alpha1.Equipment equipment = 5 [json_name = "equipment"];
  bool has_equipment() const;
  void clear_equipment() ;
  const ::dnd5e::api::v1alpha1::Equipment& equipment() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NULLABLE release_equipment();
  ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NONNULL mutable_equipment();
  void set_allocated_equipment(::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_equipment(::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NULLABLE unsafe_arena_release_equipment();

  private:
  const ::dnd5e::api::v1alpha1::Equipment& _internal_equipment() const;
  ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NONNULL _internal_mutable_equipment();

  public:
  // int32 quantity = 2 [json_name = "quantity"];
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // bool is_attuned = 3 [json_name = "isAttuned"];
  void clear_is_attuned() ;
  bool is_attuned() const;
  void set_is_attuned(bool value);

  private:
  bool _internal_is_attuned() const;
  void _internal_set_is_attuned(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.InventoryItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   1, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InventoryItem& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr item_id_;
    ::google::protobuf::internal::ArenaStringPtr custom_name_;
    ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NULLABLE equipment_;
    ::int32_t quantity_;
    bool is_attuned_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InventoryItem_class_data_;
// -------------------------------------------------------------------

class FeatureInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.FeatureInfo) */ {
 public:
  inline FeatureInfo() : FeatureInfo(nullptr) {}
  ~FeatureInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FeatureInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FeatureInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FeatureInfo(::google::protobuf::internal::ConstantInitialized);

  inline FeatureInfo(const FeatureInfo& from) : FeatureInfo(nullptr, from) {}
  inline FeatureInfo(FeatureInfo&& from) noexcept
      : FeatureInfo(nullptr, ::std::move(from)) {}
  inline FeatureInfo& operator=(const FeatureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureInfo& operator=(FeatureInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeatureInfo& default_instance() {
    return *reinterpret_cast<const FeatureInfo*>(
        &_FeatureInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 63;
  friend void swap(FeatureInfo& a, FeatureInfo& b) { a.Swap(&b); }
  inline void Swap(FeatureInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeatureInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FeatureInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FeatureInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FeatureInfo& from) { FeatureInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FeatureInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.FeatureInfo"; }

 protected:
  explicit FeatureInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FeatureInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FeatureInfo& from);
  FeatureInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FeatureInfo&& from) noexcept
      : FeatureInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChoicesFieldNumber = 6,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kClassNameFieldNumber = 5,
    kSpellSelectionFieldNumber = 8,
    kLevelFieldNumber = 4,
    kHasChoicesFieldNumber = 7,
  };
  // repeated .dnd5e.api.v1alpha1.Choice choices = 6 [json_name = "choices"];
  int choices_size() const;
  private:
  int _internal_choices_size() const;

  public:
  void clear_choices() ;
  ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL mutable_choices(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>* PROTOBUF_NONNULL mutable_choices();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>& _internal_choices() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>* PROTOBUF_NONNULL _internal_mutable_choices();
  public:
  const ::dnd5e::api::v1alpha1::Choice& choices(int index) const;
  ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL add_choices();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>& choices() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string description = 3 [json_name = "description"];
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // string class_name = 5 [json_name = "className"];
  void clear_class_name() ;
  const ::std::string& class_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_class_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_class_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_class_name();
  void set_allocated_class_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_class_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_class_name();

  public:
  // .dnd5e.api.v1alpha1.SpellSelectionInfo spell_selection = 8 [json_name = "spellSelection"];
  bool has_spell_selection() const;
  void clear_spell_selection() ;
  const ::dnd5e::api::v1alpha1::SpellSelectionInfo& spell_selection() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NULLABLE release_spell_selection();
  ::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NONNULL mutable_spell_selection();
  void set_allocated_spell_selection(::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_spell_selection(::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NULLABLE unsafe_arena_release_spell_selection();

  private:
  const ::dnd5e::api::v1alpha1::SpellSelectionInfo& _internal_spell_selection() const;
  ::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NONNULL _internal_mutable_spell_selection();

  public:
  // int32 level = 4 [json_name = "level"];
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // bool has_choices = 7 [json_name = "hasChoices"];
  void clear_has_choices() ;
  bool has_choices() const;
  void set_has_choices(bool value);

  private:
  bool _internal_has_choices() const;
  void _internal_set_has_choices(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.FeatureInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   2, 74,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FeatureInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::Choice > choices_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr class_name_;
    ::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NULLABLE spell_selection_;
    ::int32_t level_;
    bool has_choices_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FeatureInfo_class_data_;
// -------------------------------------------------------------------

class CharacterDraftData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CharacterDraftData) */ {
 public:
  inline CharacterDraftData() : CharacterDraftData(nullptr) {}
  ~CharacterDraftData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CharacterDraftData* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CharacterDraftData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CharacterDraftData(::google::protobuf::internal::ConstantInitialized);

  inline CharacterDraftData(const CharacterDraftData& from) : CharacterDraftData(nullptr, from) {}
  inline CharacterDraftData(CharacterDraftData&& from) noexcept
      : CharacterDraftData(nullptr, ::std::move(from)) {}
  inline CharacterDraftData& operator=(const CharacterDraftData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterDraftData& operator=(CharacterDraftData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterDraftData& default_instance() {
    return *reinterpret_cast<const CharacterDraftData*>(
        &_CharacterDraftData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(CharacterDraftData& a, CharacterDraftData& b) { a.Swap(&b); }
  inline void Swap(CharacterDraftData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterDraftData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterDraftData* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CharacterDraftData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CharacterDraftData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CharacterDraftData& from) { CharacterDraftData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CharacterDraftData* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CharacterDraftData"; }

 protected:
  explicit CharacterDraftData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CharacterDraftData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CharacterDraftData& from);
  CharacterDraftData(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CharacterDraftData&& from) noexcept
      : CharacterDraftData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChoicesFieldNumber = 11,
    kIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kSessionIdFieldNumber = 3,
    kNameFieldNumber = 4,
    kAbilityScoresFieldNumber = 9,
    kProgressFieldNumber = 12,
    kMetadataFieldNumber = 16,
    kRaceFieldNumber = 5,
    kSubraceFieldNumber = 6,
    kClassFieldNumber = 7,
    kBackgroundFieldNumber = 8,
    kExpiresAtFieldNumber = 13,
    kCreatedAtFieldNumber = 14,
    kUpdatedAtFieldNumber = 15,
    kAlignmentFieldNumber = 10,
  };
  // repeated .dnd5e.api.v1alpha1.ChoiceData choices = 11 [json_name = "choices"];
  int choices_size() const;
  private:
  int _internal_choices_size() const;

  public:
  void clear_choices() ;
  ::dnd5e::api::v1alpha1::ChoiceData* PROTOBUF_NONNULL mutable_choices(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>* PROTOBUF_NONNULL mutable_choices();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>& _internal_choices() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>* PROTOBUF_NONNULL _internal_mutable_choices();
  public:
  const ::dnd5e::api::v1alpha1::ChoiceData& choices(int index) const;
  ::dnd5e::api::v1alpha1::ChoiceData* PROTOBUF_NONNULL add_choices();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>& choices() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string player_id = 2 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // string session_id = 3 [json_name = "sessionId"];
  void clear_session_id() ;
  const ::std::string& session_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_session_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_session_id();
  void set_allocated_session_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_session_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_session_id();

  public:
  // string name = 4 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // .dnd5e.api.v1alpha1.AbilityScores ability_scores = 9 [json_name = "abilityScores"];
  bool has_ability_scores() const;
  void clear_ability_scores() ;
  const ::dnd5e::api::v1alpha1::AbilityScores& ability_scores() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE release_ability_scores();
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL mutable_ability_scores();
  void set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE unsafe_arena_release_ability_scores();

  private:
  const ::dnd5e::api::v1alpha1::AbilityScores& _internal_ability_scores() const;
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL _internal_mutable_ability_scores();

  public:
  // .dnd5e.api.v1alpha1.CreationProgress progress = 12 [json_name = "progress"];
  bool has_progress() const;
  void clear_progress() ;
  const ::dnd5e::api::v1alpha1::CreationProgress& progress() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE release_progress();
  ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NONNULL mutable_progress();
  void set_allocated_progress(::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_progress(::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE unsafe_arena_release_progress();

  private:
  const ::dnd5e::api::v1alpha1::CreationProgress& _internal_progress() const;
  ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NONNULL _internal_mutable_progress();

  public:
  // .dnd5e.api.v1alpha1.DraftMetadata metadata = 16 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::dnd5e::api::v1alpha1::DraftMetadata& metadata() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE release_metadata();
  ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NONNULL mutable_metadata();
  void set_allocated_metadata(::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_metadata(::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE unsafe_arena_release_metadata();

  private:
  const ::dnd5e::api::v1alpha1::DraftMetadata& _internal_metadata() const;
  ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NONNULL _internal_mutable_metadata();

  public:
  // .dnd5e.api.v1alpha1.Race race = 5 [json_name = "race"];
  void clear_race() ;
  ::dnd5e::api::v1alpha1::Race race() const;
  void set_race(::dnd5e::api::v1alpha1::Race value);

  private:
  ::dnd5e::api::v1alpha1::Race _internal_race() const;
  void _internal_set_race(::dnd5e::api::v1alpha1::Race value);

  public:
  // .dnd5e.api.v1alpha1.Subrace subrace = 6 [json_name = "subrace"];
  void clear_subrace() ;
  ::dnd5e::api::v1alpha1::Subrace subrace() const;
  void set_subrace(::dnd5e::api::v1alpha1::Subrace value);

  private:
  ::dnd5e::api::v1alpha1::Subrace _internal_subrace() const;
  void _internal_set_subrace(::dnd5e::api::v1alpha1::Subrace value);

  public:
  // .dnd5e.api.v1alpha1.Class class = 7 [json_name = "class"];
  void clear_class_() ;
  ::dnd5e::api::v1alpha1::Class class_() const;
  void set_class_(::dnd5e::api::v1alpha1::Class value);

  private:
  ::dnd5e::api::v1alpha1::Class _internal_class_() const;
  void _internal_set_class_(::dnd5e::api::v1alpha1::Class value);

  public:
  // .dnd5e.api.v1alpha1.Background background = 8 [json_name = "background"];
  void clear_background() ;
  ::dnd5e::api::v1alpha1::Background background() const;
  void set_background(::dnd5e::api::v1alpha1::Background value);

  private:
  ::dnd5e::api::v1alpha1::Background _internal_background() const;
  void _internal_set_background(::dnd5e::api::v1alpha1::Background value);

  public:
  // int64 expires_at = 13 [json_name = "expiresAt"];
  void clear_expires_at() ;
  ::int64_t expires_at() const;
  void set_expires_at(::int64_t value);

  private:
  ::int64_t _internal_expires_at() const;
  void _internal_set_expires_at(::int64_t value);

  public:
  // int64 created_at = 14 [json_name = "createdAt"];
  void clear_created_at() ;
  ::int64_t created_at() const;
  void set_created_at(::int64_t value);

  private:
  ::int64_t _internal_created_at() const;
  void _internal_set_created_at(::int64_t value);

  public:
  // int64 updated_at = 15 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // .dnd5e.api.v1alpha1.Alignment alignment = 10 [json_name = "alignment"];
  void clear_alignment() ;
  ::dnd5e::api::v1alpha1::Alignment alignment() const;
  void set_alignment(::dnd5e::api::v1alpha1::Alignment value);

  private:
  ::dnd5e::api::v1alpha1::Alignment _internal_alignment() const;
  void _internal_set_alignment(::dnd5e::api::v1alpha1::Alignment value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CharacterDraftData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 16,
                                   4, 87,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CharacterDraftData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ChoiceData > choices_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE ability_scores_;
    ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE progress_;
    ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE metadata_;
    int race_;
    int subrace_;
    int class__;
    int background_;
    ::int64_t expires_at_;
    ::int64_t created_at_;
    ::int64_t updated_at_;
    int alignment_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CharacterDraftData_class_data_;
// -------------------------------------------------------------------

class UpdateDraftRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateDraftRequest) */ {
 public:
  inline UpdateDraftRequest() : UpdateDraftRequest(nullptr) {}
  ~UpdateDraftRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateDraftRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateDraftRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateDraftRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateDraftRequest(const UpdateDraftRequest& from) : UpdateDraftRequest(nullptr, from) {}
  inline UpdateDraftRequest(UpdateDraftRequest&& from) noexcept
      : UpdateDraftRequest(nullptr, ::std::move(from)) {}
  inline UpdateDraftRequest& operator=(const UpdateDraftRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateDraftRequest& operator=(UpdateDraftRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateDraftRequest& default_instance() {
    return *reinterpret_cast<const UpdateDraftRequest*>(
        &_UpdateDraftRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(UpdateDraftRequest& a, UpdateDraftRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateDraftRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateDraftRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateDraftRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateDraftRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateDraftRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateDraftRequest& from) { UpdateDraftRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateDraftRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateDraftRequest"; }

 protected:
  explicit UpdateDraftRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateDraftRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateDraftRequest& from);
  UpdateDraftRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateDraftRequest&& from) noexcept
      : UpdateDraftRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUpdateMaskFieldNumber = 3,
    kDraftIdFieldNumber = 1,
    kUpdatesFieldNumber = 2,
  };
  // repeated string update_mask = 3 [json_name = "updateMask"];
  int update_mask_size() const;
  private:
  int _internal_update_mask_size() const;

  public:
  void clear_update_mask() ;
  const ::std::string& update_mask(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_update_mask(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_update_mask(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_update_mask();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_update_mask(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& update_mask() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_update_mask();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_update_mask() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_update_mask();

  public:
  // string draft_id = 1 [json_name = "draftId"];
  void clear_draft_id() ;
  const ::std::string& draft_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_draft_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_draft_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_draft_id();
  void set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_draft_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_draft_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_draft_id();

  public:
  // .dnd5e.api.v1alpha1.CharacterDraftData updates = 2 [json_name = "updates"];
  bool has_updates() const;
  void clear_updates() ;
  const ::dnd5e::api::v1alpha1::CharacterDraftData& updates() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE release_updates();
  ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NONNULL mutable_updates();
  void set_allocated_updates(::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updates(::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE unsafe_arena_release_updates();

  private:
  const ::dnd5e::api::v1alpha1::CharacterDraftData& _internal_updates() const;
  ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NONNULL _internal_mutable_updates();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateDraftRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 65,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateDraftRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> update_mask_;
    ::google::protobuf::internal::ArenaStringPtr draft_id_;
    ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE updates_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateDraftRequest_class_data_;
// -------------------------------------------------------------------

class ListSpellsByLevelResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListSpellsByLevelResponse) */ {
 public:
  inline ListSpellsByLevelResponse() : ListSpellsByLevelResponse(nullptr) {}
  ~ListSpellsByLevelResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListSpellsByLevelResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListSpellsByLevelResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListSpellsByLevelResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListSpellsByLevelResponse(const ListSpellsByLevelResponse& from) : ListSpellsByLevelResponse(nullptr, from) {}
  inline ListSpellsByLevelResponse(ListSpellsByLevelResponse&& from) noexcept
      : ListSpellsByLevelResponse(nullptr, ::std::move(from)) {}
  inline ListSpellsByLevelResponse& operator=(const ListSpellsByLevelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSpellsByLevelResponse& operator=(ListSpellsByLevelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSpellsByLevelResponse& default_instance() {
    return *reinterpret_cast<const ListSpellsByLevelResponse*>(
        &_ListSpellsByLevelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 109;
  friend void swap(ListSpellsByLevelResponse& a, ListSpellsByLevelResponse& b) { a.Swap(&b); }
  inline void Swap(ListSpellsByLevelResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSpellsByLevelResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSpellsByLevelResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListSpellsByLevelResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListSpellsByLevelResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListSpellsByLevelResponse& from) { ListSpellsByLevelResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListSpellsByLevelResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListSpellsByLevelResponse"; }

 protected:
  explicit ListSpellsByLevelResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListSpellsByLevelResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListSpellsByLevelResponse& from);
  ListSpellsByLevelResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListSpellsByLevelResponse&& from) noexcept
      : ListSpellsByLevelResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSpellsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .dnd5e.api.v1alpha1.Spell spells = 1 [json_name = "spells"];
  int spells_size() const;
  private:
  int _internal_spells_size() const;

  public:
  void clear_spells() ;
  ::dnd5e::api::v1alpha1::Spell* PROTOBUF_NONNULL mutable_spells(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Spell>* PROTOBUF_NONNULL mutable_spells();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Spell>& _internal_spells() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Spell>* PROTOBUF_NONNULL _internal_mutable_spells();
  public:
  const ::dnd5e::api::v1alpha1::Spell& spells(int index) const;
  ::dnd5e::api::v1alpha1::Spell* PROTOBUF_NONNULL add_spells();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Spell>& spells() const;
  // string next_page_token = 2 [json_name = "nextPageToken"];
  void clear_next_page_token() ;
  const ::std::string& next_page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_next_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_next_page_token();
  void set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_next_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_next_page_token();

  public:
  // int32 total_size = 3 [json_name = "totalSize"];
  void clear_total_size() ;
  ::int32_t total_size() const;
  void set_total_size(::int32_t value);

  private:
  ::int32_t _internal_total_size() const;
  void _internal_set_total_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListSpellsByLevelResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 68,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListSpellsByLevelResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::Spell > spells_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::int32_t total_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListSpellsByLevelResponse_class_data_;
// -------------------------------------------------------------------

class ListRacesResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListRacesResponse) */ {
 public:
  inline ListRacesResponse() : ListRacesResponse(nullptr) {}
  ~ListRacesResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListRacesResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListRacesResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListRacesResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListRacesResponse(const ListRacesResponse& from) : ListRacesResponse(nullptr, from) {}
  inline ListRacesResponse(ListRacesResponse&& from) noexcept
      : ListRacesResponse(nullptr, ::std::move(from)) {}
  inline ListRacesResponse& operator=(const ListRacesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRacesResponse& operator=(ListRacesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRacesResponse& default_instance() {
    return *reinterpret_cast<const ListRacesResponse*>(
        &_ListRacesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 66;
  friend void swap(ListRacesResponse& a, ListRacesResponse& b) { a.Swap(&b); }
  inline void Swap(ListRacesResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRacesResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRacesResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListRacesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListRacesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListRacesResponse& from) { ListRacesResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListRacesResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListRacesResponse"; }

 protected:
  explicit ListRacesResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListRacesResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListRacesResponse& from);
  ListRacesResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListRacesResponse&& from) noexcept
      : ListRacesResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRacesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .dnd5e.api.v1alpha1.RaceInfo races = 1 [json_name = "races"];
  int races_size() const;
  private:
  int _internal_races_size() const;

  public:
  void clear_races() ;
  ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NONNULL mutable_races(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RaceInfo>* PROTOBUF_NONNULL mutable_races();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RaceInfo>& _internal_races() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RaceInfo>* PROTOBUF_NONNULL _internal_mutable_races();
  public:
  const ::dnd5e::api::v1alpha1::RaceInfo& races(int index) const;
  ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NONNULL add_races();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RaceInfo>& races() const;
  // string next_page_token = 2 [json_name = "nextPageToken"];
  void clear_next_page_token() ;
  const ::std::string& next_page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_next_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_next_page_token();
  void set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_next_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_next_page_token();

  public:
  // int32 total_size = 3 [json_name = "totalSize"];
  void clear_total_size() ;
  ::int32_t total_size() const;
  void set_total_size(::int32_t value);

  private:
  ::int32_t _internal_total_size() const;
  void _internal_set_total_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListRacesResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListRacesResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::RaceInfo > races_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::int32_t total_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListRacesResponse_class_data_;
// -------------------------------------------------------------------

class GetRaceDetailsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetRaceDetailsResponse) */ {
 public:
  inline GetRaceDetailsResponse() : GetRaceDetailsResponse(nullptr) {}
  ~GetRaceDetailsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetRaceDetailsResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetRaceDetailsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetRaceDetailsResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetRaceDetailsResponse(const GetRaceDetailsResponse& from) : GetRaceDetailsResponse(nullptr, from) {}
  inline GetRaceDetailsResponse(GetRaceDetailsResponse&& from) noexcept
      : GetRaceDetailsResponse(nullptr, ::std::move(from)) {}
  inline GetRaceDetailsResponse& operator=(const GetRaceDetailsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRaceDetailsResponse& operator=(GetRaceDetailsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRaceDetailsResponse& default_instance() {
    return *reinterpret_cast<const GetRaceDetailsResponse*>(
        &_GetRaceDetailsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 72;
  friend void swap(GetRaceDetailsResponse& a, GetRaceDetailsResponse& b) { a.Swap(&b); }
  inline void Swap(GetRaceDetailsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRaceDetailsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRaceDetailsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetRaceDetailsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetRaceDetailsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetRaceDetailsResponse& from) { GetRaceDetailsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetRaceDetailsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetRaceDetailsResponse"; }

 protected:
  explicit GetRaceDetailsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetRaceDetailsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetRaceDetailsResponse& from);
  GetRaceDetailsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetRaceDetailsResponse&& from) noexcept
      : GetRaceDetailsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRaceFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.RaceInfo race = 1 [json_name = "race"];
  bool has_race() const;
  void clear_race() ;
  const ::dnd5e::api::v1alpha1::RaceInfo& race() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE release_race();
  ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NONNULL mutable_race();
  void set_allocated_race(::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_race(::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE unsafe_arena_release_race();

  private:
  const ::dnd5e::api::v1alpha1::RaceInfo& _internal_race() const;
  ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NONNULL _internal_mutable_race();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetRaceDetailsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetRaceDetailsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE race_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetRaceDetailsResponse_class_data_;
// -------------------------------------------------------------------

class GetFeatureResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetFeatureResponse) */ {
 public:
  inline GetFeatureResponse() : GetFeatureResponse(nullptr) {}
  ~GetFeatureResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetFeatureResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetFeatureResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetFeatureResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetFeatureResponse(const GetFeatureResponse& from) : GetFeatureResponse(nullptr, from) {}
  inline GetFeatureResponse(GetFeatureResponse&& from) noexcept
      : GetFeatureResponse(nullptr, ::std::move(from)) {}
  inline GetFeatureResponse& operator=(const GetFeatureResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFeatureResponse& operator=(GetFeatureResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFeatureResponse& default_instance() {
    return *reinterpret_cast<const GetFeatureResponse*>(
        &_GetFeatureResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 78;
  friend void swap(GetFeatureResponse& a, GetFeatureResponse& b) { a.Swap(&b); }
  inline void Swap(GetFeatureResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFeatureResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFeatureResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetFeatureResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetFeatureResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetFeatureResponse& from) { GetFeatureResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetFeatureResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetFeatureResponse"; }

 protected:
  explicit GetFeatureResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetFeatureResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetFeatureResponse& from);
  GetFeatureResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetFeatureResponse&& from) noexcept
      : GetFeatureResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFeatureFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.FeatureInfo feature = 1 [json_name = "feature"];
  bool has_feature() const;
  void clear_feature() ;
  const ::dnd5e::api::v1alpha1::FeatureInfo& feature() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NULLABLE release_feature();
  ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NONNULL mutable_feature();
  void set_allocated_feature(::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_feature(::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NULLABLE unsafe_arena_release_feature();

  private:
  const ::dnd5e::api::v1alpha1::FeatureInfo& _internal_feature() const;
  ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NONNULL _internal_mutable_feature();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetFeatureResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetFeatureResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NULLABLE feature_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetFeatureResponse_class_data_;
// -------------------------------------------------------------------

class EquipmentSlots final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EquipmentSlots) */ {
 public:
  inline EquipmentSlots() : EquipmentSlots(nullptr) {}
  ~EquipmentSlots() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EquipmentSlots* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EquipmentSlots));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EquipmentSlots(::google::protobuf::internal::ConstantInitialized);

  inline EquipmentSlots(const EquipmentSlots& from) : EquipmentSlots(nullptr, from) {}
  inline EquipmentSlots(EquipmentSlots&& from) noexcept
      : EquipmentSlots(nullptr, ::std::move(from)) {}
  inline EquipmentSlots& operator=(const EquipmentSlots& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentSlots& operator=(EquipmentSlots&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentSlots& default_instance() {
    return *reinterpret_cast<const EquipmentSlots*>(
        &_EquipmentSlots_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 89;
  friend void swap(EquipmentSlots& a, EquipmentSlots& b) { a.Swap(&b); }
  inline void Swap(EquipmentSlots* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentSlots* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentSlots* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EquipmentSlots>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EquipmentSlots& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EquipmentSlots& from) { EquipmentSlots::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EquipmentSlots* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EquipmentSlots"; }

 protected:
  explicit EquipmentSlots(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EquipmentSlots(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EquipmentSlots& from);
  EquipmentSlots(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EquipmentSlots&& from) noexcept
      : EquipmentSlots(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMainHandFieldNumber = 1,
    kOffHandFieldNumber = 2,
    kArmorFieldNumber = 3,
    kHelmetFieldNumber = 4,
    kBootsFieldNumber = 5,
    kGlovesFieldNumber = 6,
    kCloakFieldNumber = 7,
    kAmuletFieldNumber = 8,
    kRing1FieldNumber = 9,
    kRing2FieldNumber = 10,
    kBeltFieldNumber = 11,
  };
  // .dnd5e.api.v1alpha1.InventoryItem main_hand = 1 [json_name = "mainHand"];
  bool has_main_hand() const;
  void clear_main_hand() ;
  const ::dnd5e::api::v1alpha1::InventoryItem& main_hand() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE release_main_hand();
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_main_hand();
  void set_allocated_main_hand(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_main_hand(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE unsafe_arena_release_main_hand();

  private:
  const ::dnd5e::api::v1alpha1::InventoryItem& _internal_main_hand() const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL _internal_mutable_main_hand();

  public:
  // .dnd5e.api.v1alpha1.InventoryItem off_hand = 2 [json_name = "offHand"];
  bool has_off_hand() const;
  void clear_off_hand() ;
  const ::dnd5e::api::v1alpha1::InventoryItem& off_hand() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE release_off_hand();
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_off_hand();
  void set_allocated_off_hand(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_off_hand(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE unsafe_arena_release_off_hand();

  private:
  const ::dnd5e::api::v1alpha1::InventoryItem& _internal_off_hand() const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL _internal_mutable_off_hand();

  public:
  // .dnd5e.api.v1alpha1.InventoryItem armor = 3 [json_name = "armor"];
  bool has_armor() const;
  void clear_armor() ;
  const ::dnd5e::api::v1alpha1::InventoryItem& armor() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE release_armor();
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_armor();
  void set_allocated_armor(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_armor(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE unsafe_arena_release_armor();

  private:
  const ::dnd5e::api::v1alpha1::InventoryItem& _internal_armor() const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL _internal_mutable_armor();

  public:
  // .dnd5e.api.v1alpha1.InventoryItem helmet = 4 [json_name = "helmet"];
  bool has_helmet() const;
  void clear_helmet() ;
  const ::dnd5e::api::v1alpha1::InventoryItem& helmet() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE release_helmet();
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_helmet();
  void set_allocated_helmet(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_helmet(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE unsafe_arena_release_helmet();

  private:
  const ::dnd5e::api::v1alpha1::InventoryItem& _internal_helmet() const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL _internal_mutable_helmet();

  public:
  // .dnd5e.api.v1alpha1.InventoryItem boots = 5 [json_name = "boots"];
  bool has_boots() const;
  void clear_boots() ;
  const ::dnd5e::api::v1alpha1::InventoryItem& boots() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE release_boots();
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_boots();
  void set_allocated_boots(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_boots(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE unsafe_arena_release_boots();

  private:
  const ::dnd5e::api::v1alpha1::InventoryItem& _internal_boots() const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL _internal_mutable_boots();

  public:
  // .dnd5e.api.v1alpha1.InventoryItem gloves = 6 [json_name = "gloves"];
  bool has_gloves() const;
  void clear_gloves() ;
  const ::dnd5e::api::v1alpha1::InventoryItem& gloves() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE release_gloves();
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_gloves();
  void set_allocated_gloves(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gloves(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE unsafe_arena_release_gloves();

  private:
  const ::dnd5e::api::v1alpha1::InventoryItem& _internal_gloves() const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL _internal_mutable_gloves();

  public:
  // .dnd5e.api.v1alpha1.InventoryItem cloak = 7 [json_name = "cloak"];
  bool has_cloak() const;
  void clear_cloak() ;
  const ::dnd5e::api::v1alpha1::InventoryItem& cloak() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE release_cloak();
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_cloak();
  void set_allocated_cloak(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_cloak(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE unsafe_arena_release_cloak();

  private:
  const ::dnd5e::api::v1alpha1::InventoryItem& _internal_cloak() const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL _internal_mutable_cloak();

  public:
  // .dnd5e.api.v1alpha1.InventoryItem amulet = 8 [json_name = "amulet"];
  bool has_amulet() const;
  void clear_amulet() ;
  const ::dnd5e::api::v1alpha1::InventoryItem& amulet() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE release_amulet();
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_amulet();
  void set_allocated_amulet(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_amulet(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE unsafe_arena_release_amulet();

  private:
  const ::dnd5e::api::v1alpha1::InventoryItem& _internal_amulet() const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL _internal_mutable_amulet();

  public:
  // .dnd5e.api.v1alpha1.InventoryItem ring_1 = 9 [json_name = "ring1"];
  bool has_ring_1() const;
  void clear_ring_1() ;
  const ::dnd5e::api::v1alpha1::InventoryItem& ring_1() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE release_ring_1();
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_ring_1();
  void set_allocated_ring_1(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ring_1(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE unsafe_arena_release_ring_1();

  private:
  const ::dnd5e::api::v1alpha1::InventoryItem& _internal_ring_1() const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL _internal_mutable_ring_1();

  public:
  // .dnd5e.api.v1alpha1.InventoryItem ring_2 = 10 [json_name = "ring2"];
  bool has_ring_2() const;
  void clear_ring_2() ;
  const ::dnd5e::api::v1alpha1::InventoryItem& ring_2() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE release_ring_2();
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_ring_2();
  void set_allocated_ring_2(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ring_2(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE unsafe_arena_release_ring_2();

  private:
  const ::dnd5e::api::v1alpha1::InventoryItem& _internal_ring_2() const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL _internal_mutable_ring_2();

  public:
  // .dnd5e.api.v1alpha1.InventoryItem belt = 11 [json_name = "belt"];
  bool has_belt() const;
  void clear_belt() ;
  const ::dnd5e::api::v1alpha1::InventoryItem& belt() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE release_belt();
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_belt();
  void set_allocated_belt(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_belt(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE unsafe_arena_release_belt();

  private:
  const ::dnd5e::api::v1alpha1::InventoryItem& _internal_belt() const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL _internal_mutable_belt();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EquipmentSlots)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11,
                                   11, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EquipmentSlots& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE main_hand_;
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE off_hand_;
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE armor_;
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE helmet_;
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE boots_;
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE gloves_;
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE cloak_;
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE amulet_;
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE ring_1_;
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE ring_2_;
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE belt_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EquipmentSlots_class_data_;
// -------------------------------------------------------------------

class CreateDraftRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CreateDraftRequest) */ {
 public:
  inline CreateDraftRequest() : CreateDraftRequest(nullptr) {}
  ~CreateDraftRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateDraftRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateDraftRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateDraftRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateDraftRequest(const CreateDraftRequest& from) : CreateDraftRequest(nullptr, from) {}
  inline CreateDraftRequest(CreateDraftRequest&& from) noexcept
      : CreateDraftRequest(nullptr, ::std::move(from)) {}
  inline CreateDraftRequest& operator=(const CreateDraftRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDraftRequest& operator=(CreateDraftRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDraftRequest& default_instance() {
    return *reinterpret_cast<const CreateDraftRequest*>(
        &_CreateDraftRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(CreateDraftRequest& a, CreateDraftRequest& b) { a.Swap(&b); }
  inline void Swap(CreateDraftRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDraftRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDraftRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateDraftRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateDraftRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateDraftRequest& from) { CreateDraftRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateDraftRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CreateDraftRequest"; }

 protected:
  explicit CreateDraftRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreateDraftRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreateDraftRequest& from);
  CreateDraftRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreateDraftRequest&& from) noexcept
      : CreateDraftRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerIdFieldNumber = 1,
    kSessionIdFieldNumber = 2,
    kInitialDataFieldNumber = 3,
  };
  // string player_id = 1 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // string session_id = 2 [json_name = "sessionId"];
  void clear_session_id() ;
  const ::std::string& session_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_session_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_session_id();
  void set_allocated_session_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_session_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_session_id();

  public:
  // .dnd5e.api.v1alpha1.CharacterDraftData initial_data = 3 [json_name = "initialData"];
  bool has_initial_data() const;
  void clear_initial_data() ;
  const ::dnd5e::api::v1alpha1::CharacterDraftData& initial_data() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE release_initial_data();
  ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NONNULL mutable_initial_data();
  void set_allocated_initial_data(::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_initial_data(::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE unsafe_arena_release_initial_data();

  private:
  const ::dnd5e::api::v1alpha1::CharacterDraftData& _internal_initial_data() const;
  ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NONNULL _internal_mutable_initial_data();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CreateDraftRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 65,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CreateDraftRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE initial_data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreateDraftRequest_class_data_;
// -------------------------------------------------------------------

class ClassInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ClassInfo) */ {
 public:
  inline ClassInfo() : ClassInfo(nullptr) {}
  ~ClassInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClassInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClassInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClassInfo(::google::protobuf::internal::ConstantInitialized);

  inline ClassInfo(const ClassInfo& from) : ClassInfo(nullptr, from) {}
  inline ClassInfo(ClassInfo&& from) noexcept
      : ClassInfo(nullptr, ::std::move(from)) {}
  inline ClassInfo& operator=(const ClassInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassInfo& operator=(ClassInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClassInfo& default_instance() {
    return *reinterpret_cast<const ClassInfo*>(
        &_ClassInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 60;
  friend void swap(ClassInfo& a, ClassInfo& b) { a.Swap(&b); }
  inline void Swap(ClassInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClassInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClassInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ClassInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClassInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClassInfo& from) { ClassInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClassInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ClassInfo"; }

 protected:
  explicit ClassInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ClassInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ClassInfo& from);
  ClassInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ClassInfo&& from) noexcept
      : ClassInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrimaryAbilitiesFieldNumber = 5,
    kArmorProficienciesFieldNumber = 6,
    kWeaponProficienciesFieldNumber = 7,
    kToolProficienciesFieldNumber = 8,
    kSavingThrowProficienciesFieldNumber = 9,
    kAvailableSkillsFieldNumber = 11,
    kStartingEquipmentFieldNumber = 12,
    kLevel1FeaturesFieldNumber = 13,
    kChoicesFieldNumber = 15,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kHitDieFieldNumber = 4,
    kSpellcastingFieldNumber = 14,
    kSkillChoicesCountFieldNumber = 10,
  };
  // repeated string primary_abilities = 5 [json_name = "primaryAbilities"];
  int primary_abilities_size() const;
  private:
  int _internal_primary_abilities_size() const;

  public:
  void clear_primary_abilities() ;
  const ::std::string& primary_abilities(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_primary_abilities(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_primary_abilities(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_primary_abilities();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_primary_abilities(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& primary_abilities() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_primary_abilities();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_primary_abilities() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_primary_abilities();

  public:
  // repeated string armor_proficiencies = 6 [json_name = "armorProficiencies"];
  int armor_proficiencies_size() const;
  private:
  int _internal_armor_proficiencies_size() const;

  public:
  void clear_armor_proficiencies() ;
  const ::std::string& armor_proficiencies(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_armor_proficiencies(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_armor_proficiencies(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_armor_proficiencies();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_armor_proficiencies(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& armor_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_armor_proficiencies();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_armor_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_armor_proficiencies();

  public:
  // repeated string weapon_proficiencies = 7 [json_name = "weaponProficiencies"];
  int weapon_proficiencies_size() const;
  private:
  int _internal_weapon_proficiencies_size() const;

  public:
  void clear_weapon_proficiencies() ;
  const ::std::string& weapon_proficiencies(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_weapon_proficiencies(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_weapon_proficiencies(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_weapon_proficiencies();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_weapon_proficiencies(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& weapon_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_weapon_proficiencies();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_weapon_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_weapon_proficiencies();

  public:
  // repeated string tool_proficiencies = 8 [json_name = "toolProficiencies"];
  int tool_proficiencies_size() const;
  private:
  int _internal_tool_proficiencies_size() const;

  public:
  void clear_tool_proficiencies() ;
  const ::std::string& tool_proficiencies(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_tool_proficiencies(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_tool_proficiencies(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_tool_proficiencies();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_tool_proficiencies(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& tool_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_tool_proficiencies();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_tool_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_tool_proficiencies();

  public:
  // repeated string saving_throw_proficiencies = 9 [json_name = "savingThrowProficiencies"];
  int saving_throw_proficiencies_size() const;
  private:
  int _internal_saving_throw_proficiencies_size() const;

  public:
  void clear_saving_throw_proficiencies() ;
  const ::std::string& saving_throw_proficiencies(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_saving_throw_proficiencies(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_saving_throw_proficiencies(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_saving_throw_proficiencies();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_saving_throw_proficiencies(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& saving_throw_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_saving_throw_proficiencies();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_saving_throw_proficiencies() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_saving_throw_proficiencies();

  public:
  // repeated string available_skills = 11 [json_name = "availableSkills"];
  int available_skills_size() const;
  private:
  int _internal_available_skills_size() const;

  public:
  void clear_available_skills() ;
  const ::std::string& available_skills(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_available_skills(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_available_skills(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_available_skills();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_available_skills(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& available_skills() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_available_skills();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_available_skills() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_available_skills();

  public:
  // repeated string starting_equipment = 12 [json_name = "startingEquipment"];
  int starting_equipment_size() const;
  private:
  int _internal_starting_equipment_size() const;

  public:
  void clear_starting_equipment() ;
  const ::std::string& starting_equipment(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_starting_equipment(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_starting_equipment(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_starting_equipment();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_starting_equipment(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& starting_equipment() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_starting_equipment();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_starting_equipment() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_starting_equipment();

  public:
  // repeated .dnd5e.api.v1alpha1.FeatureInfo level_1_features = 13 [json_name = "level1Features"];
  int level_1_features_size() const;
  private:
  int _internal_level_1_features_size() const;

  public:
  void clear_level_1_features() ;
  ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NONNULL mutable_level_1_features(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::FeatureInfo>* PROTOBUF_NONNULL mutable_level_1_features();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::FeatureInfo>& _internal_level_1_features() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::FeatureInfo>* PROTOBUF_NONNULL _internal_mutable_level_1_features();
  public:
  const ::dnd5e::api::v1alpha1::FeatureInfo& level_1_features(int index) const;
  ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NONNULL add_level_1_features();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::FeatureInfo>& level_1_features() const;
  // repeated .dnd5e.api.v1alpha1.Choice choices = 15 [json_name = "choices"];
  int choices_size() const;
  private:
  int _internal_choices_size() const;

  public:
  void clear_choices() ;
  ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL mutable_choices(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>* PROTOBUF_NONNULL mutable_choices();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>& _internal_choices() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>* PROTOBUF_NONNULL _internal_mutable_choices();
  public:
  const ::dnd5e::api::v1alpha1::Choice& choices(int index) const;
  ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL add_choices();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>& choices() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string description = 3 [json_name = "description"];
  void clear_description() ;
  const ::std::string& description() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_description();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_description();
  void set_allocated_description(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_description();

  public:
  // string hit_die = 4 [json_name = "hitDie"];
  void clear_hit_die() ;
  const ::std::string& hit_die() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_hit_die(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_hit_die();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_hit_die();
  void set_allocated_hit_die(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_hit_die() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_hit_die(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_hit_die();

  public:
  // .dnd5e.api.v1alpha1.SpellcastingInfo spellcasting = 14 [json_name = "spellcasting"];
  bool has_spellcasting() const;
  void clear_spellcasting() ;
  const ::dnd5e::api::v1alpha1::SpellcastingInfo& spellcasting() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NULLABLE release_spellcasting();
  ::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NONNULL mutable_spellcasting();
  void set_allocated_spellcasting(::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_spellcasting(::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NULLABLE unsafe_arena_release_spellcasting();

  private:
  const ::dnd5e::api::v1alpha1::SpellcastingInfo& _internal_spellcasting() const;
  ::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NONNULL _internal_mutable_spellcasting();

  public:
  // int32 skill_choices_count = 10 [json_name = "skillChoicesCount"];
  void clear_skill_choices_count() ;
  ::int32_t skill_choices_count() const;
  void set_skill_choices_count(::int32_t value);

  private:
  ::int32_t _internal_skill_choices_count() const;
  void _internal_set_skill_choices_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ClassInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 15,
                                   3, 203,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ClassInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> primary_abilities_;
    ::google::protobuf::RepeatedPtrField<::std::string> armor_proficiencies_;
    ::google::protobuf::RepeatedPtrField<::std::string> weapon_proficiencies_;
    ::google::protobuf::RepeatedPtrField<::std::string> tool_proficiencies_;
    ::google::protobuf::RepeatedPtrField<::std::string> saving_throw_proficiencies_;
    ::google::protobuf::RepeatedPtrField<::std::string> available_skills_;
    ::google::protobuf::RepeatedPtrField<::std::string> starting_equipment_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::FeatureInfo > level_1_features_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::Choice > choices_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr hit_die_;
    ::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NULLABLE spellcasting_;
    ::int32_t skill_choices_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ClassInfo_class_data_;
// -------------------------------------------------------------------

class ListClassesResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListClassesResponse) */ {
 public:
  inline ListClassesResponse() : ListClassesResponse(nullptr) {}
  ~ListClassesResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListClassesResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListClassesResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListClassesResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListClassesResponse(const ListClassesResponse& from) : ListClassesResponse(nullptr, from) {}
  inline ListClassesResponse(ListClassesResponse&& from) noexcept
      : ListClassesResponse(nullptr, ::std::move(from)) {}
  inline ListClassesResponse& operator=(const ListClassesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListClassesResponse& operator=(ListClassesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListClassesResponse& default_instance() {
    return *reinterpret_cast<const ListClassesResponse*>(
        &_ListClassesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 68;
  friend void swap(ListClassesResponse& a, ListClassesResponse& b) { a.Swap(&b); }
  inline void Swap(ListClassesResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListClassesResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListClassesResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListClassesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListClassesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListClassesResponse& from) { ListClassesResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListClassesResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListClassesResponse"; }

 protected:
  explicit ListClassesResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListClassesResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListClassesResponse& from);
  ListClassesResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListClassesResponse&& from) noexcept
      : ListClassesResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClassesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .dnd5e.api.v1alpha1.ClassInfo classes = 1 [json_name = "classes"];
  int classes_size() const;
  private:
  int _internal_classes_size() const;

  public:
  void clear_classes() ;
  ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NONNULL mutable_classes(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ClassInfo>* PROTOBUF_NONNULL mutable_classes();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ClassInfo>& _internal_classes() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ClassInfo>* PROTOBUF_NONNULL _internal_mutable_classes();
  public:
  const ::dnd5e::api::v1alpha1::ClassInfo& classes(int index) const;
  ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NONNULL add_classes();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ClassInfo>& classes() const;
  // string next_page_token = 2 [json_name = "nextPageToken"];
  void clear_next_page_token() ;
  const ::std::string& next_page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_next_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_next_page_token();
  void set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_next_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_next_page_token();

  public:
  // int32 total_size = 3 [json_name = "totalSize"];
  void clear_total_size() ;
  ::int32_t total_size() const;
  void set_total_size(::int32_t value);

  private:
  ::int32_t _internal_total_size() const;
  void _internal_set_total_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListClassesResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 62,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListClassesResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ClassInfo > classes_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::int32_t total_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListClassesResponse_class_data_;
// -------------------------------------------------------------------

class GetClassDetailsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetClassDetailsResponse) */ {
 public:
  inline GetClassDetailsResponse() : GetClassDetailsResponse(nullptr) {}
  ~GetClassDetailsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetClassDetailsResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetClassDetailsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetClassDetailsResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetClassDetailsResponse(const GetClassDetailsResponse& from) : GetClassDetailsResponse(nullptr, from) {}
  inline GetClassDetailsResponse(GetClassDetailsResponse&& from) noexcept
      : GetClassDetailsResponse(nullptr, ::std::move(from)) {}
  inline GetClassDetailsResponse& operator=(const GetClassDetailsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetClassDetailsResponse& operator=(GetClassDetailsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetClassDetailsResponse& default_instance() {
    return *reinterpret_cast<const GetClassDetailsResponse*>(
        &_GetClassDetailsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 74;
  friend void swap(GetClassDetailsResponse& a, GetClassDetailsResponse& b) { a.Swap(&b); }
  inline void Swap(GetClassDetailsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetClassDetailsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetClassDetailsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetClassDetailsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetClassDetailsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetClassDetailsResponse& from) { GetClassDetailsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetClassDetailsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetClassDetailsResponse"; }

 protected:
  explicit GetClassDetailsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetClassDetailsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetClassDetailsResponse& from);
  GetClassDetailsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetClassDetailsResponse&& from) noexcept
      : GetClassDetailsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClassFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.ClassInfo class = 1 [json_name = "class"];
  bool has_class_() const;
  void clear_class_() ;
  const ::dnd5e::api::v1alpha1::ClassInfo& class_() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE release_class_();
  ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NONNULL mutable_class_();
  void set_allocated_class_(::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_class_(::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE unsafe_arena_release_class_();

  private:
  const ::dnd5e::api::v1alpha1::ClassInfo& _internal_class_() const;
  ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NONNULL _internal_mutable_class_();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetClassDetailsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetClassDetailsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE class__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetClassDetailsResponse_class_data_;
// -------------------------------------------------------------------

class GetCharacterInventoryResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetCharacterInventoryResponse) */ {
 public:
  inline GetCharacterInventoryResponse() : GetCharacterInventoryResponse(nullptr) {}
  ~GetCharacterInventoryResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCharacterInventoryResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCharacterInventoryResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCharacterInventoryResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetCharacterInventoryResponse(const GetCharacterInventoryResponse& from) : GetCharacterInventoryResponse(nullptr, from) {}
  inline GetCharacterInventoryResponse(GetCharacterInventoryResponse&& from) noexcept
      : GetCharacterInventoryResponse(nullptr, ::std::move(from)) {}
  inline GetCharacterInventoryResponse& operator=(const GetCharacterInventoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCharacterInventoryResponse& operator=(GetCharacterInventoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCharacterInventoryResponse& default_instance() {
    return *reinterpret_cast<const GetCharacterInventoryResponse*>(
        &_GetCharacterInventoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 111;
  friend void swap(GetCharacterInventoryResponse& a, GetCharacterInventoryResponse& b) { a.Swap(&b); }
  inline void Swap(GetCharacterInventoryResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCharacterInventoryResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCharacterInventoryResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCharacterInventoryResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCharacterInventoryResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCharacterInventoryResponse& from) { GetCharacterInventoryResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCharacterInventoryResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetCharacterInventoryResponse"; }

 protected:
  explicit GetCharacterInventoryResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCharacterInventoryResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCharacterInventoryResponse& from);
  GetCharacterInventoryResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCharacterInventoryResponse&& from) noexcept
      : GetCharacterInventoryResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInventoryFieldNumber = 2,
    kEquipmentSlotsFieldNumber = 1,
    kEncumbranceFieldNumber = 3,
    kAttunementSlotsUsedFieldNumber = 4,
    kAttunementSlotsMaxFieldNumber = 5,
  };
  // repeated .dnd5e.api.v1alpha1.InventoryItem inventory = 2 [json_name = "inventory"];
  int inventory_size() const;
  private:
  int _internal_inventory_size() const;

  public:
  void clear_inventory() ;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_inventory(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>* PROTOBUF_NONNULL mutable_inventory();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>& _internal_inventory() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>* PROTOBUF_NONNULL _internal_mutable_inventory();
  public:
  const ::dnd5e::api::v1alpha1::InventoryItem& inventory(int index) const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL add_inventory();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>& inventory() const;
  // .dnd5e.api.v1alpha1.EquipmentSlots equipment_slots = 1 [json_name = "equipmentSlots"];
  bool has_equipment_slots() const;
  void clear_equipment_slots() ;
  const ::dnd5e::api::v1alpha1::EquipmentSlots& equipment_slots() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE release_equipment_slots();
  ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NONNULL mutable_equipment_slots();
  void set_allocated_equipment_slots(::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_equipment_slots(::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE unsafe_arena_release_equipment_slots();

  private:
  const ::dnd5e::api::v1alpha1::EquipmentSlots& _internal_equipment_slots() const;
  ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NONNULL _internal_mutable_equipment_slots();

  public:
  // .dnd5e.api.v1alpha1.EncumbranceInfo encumbrance = 3 [json_name = "encumbrance"];
  bool has_encumbrance() const;
  void clear_encumbrance() ;
  const ::dnd5e::api::v1alpha1::EncumbranceInfo& encumbrance() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE release_encumbrance();
  ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NONNULL mutable_encumbrance();
  void set_allocated_encumbrance(::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_encumbrance(::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE unsafe_arena_release_encumbrance();

  private:
  const ::dnd5e::api::v1alpha1::EncumbranceInfo& _internal_encumbrance() const;
  ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NONNULL _internal_mutable_encumbrance();

  public:
  // int32 attunement_slots_used = 4 [json_name = "attunementSlotsUsed"];
  void clear_attunement_slots_used() ;
  ::int32_t attunement_slots_used() const;
  void set_attunement_slots_used(::int32_t value);

  private:
  ::int32_t _internal_attunement_slots_used() const;
  void _internal_set_attunement_slots_used(::int32_t value);

  public:
  // int32 attunement_slots_max = 5 [json_name = "attunementSlotsMax"];
  void clear_attunement_slots_max() ;
  ::int32_t attunement_slots_max() const;
  void set_attunement_slots_max(::int32_t value);

  private:
  ::int32_t _internal_attunement_slots_max() const;
  void _internal_set_attunement_slots_max(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetCharacterInventoryResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCharacterInventoryResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::InventoryItem > inventory_;
    ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE equipment_slots_;
    ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE encumbrance_;
    ::int32_t attunement_slots_used_;
    ::int32_t attunement_slots_max_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCharacterInventoryResponse_class_data_;
// -------------------------------------------------------------------

class CharacterDraft final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CharacterDraft) */ {
 public:
  inline CharacterDraft() : CharacterDraft(nullptr) {}
  ~CharacterDraft() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CharacterDraft* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CharacterDraft));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CharacterDraft(::google::protobuf::internal::ConstantInitialized);

  inline CharacterDraft(const CharacterDraft& from) : CharacterDraft(nullptr, from) {}
  inline CharacterDraft(CharacterDraft&& from) noexcept
      : CharacterDraft(nullptr, ::std::move(from)) {}
  inline CharacterDraft& operator=(const CharacterDraft& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterDraft& operator=(CharacterDraft&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterDraft& default_instance() {
    return *reinterpret_cast<const CharacterDraft*>(
        &_CharacterDraft_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(CharacterDraft& a, CharacterDraft& b) { a.Swap(&b); }
  inline void Swap(CharacterDraft* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterDraft* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterDraft* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CharacterDraft>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CharacterDraft& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CharacterDraft& from) { CharacterDraft::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CharacterDraft* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CharacterDraft"; }

 protected:
  explicit CharacterDraft(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CharacterDraft(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CharacterDraft& from);
  CharacterDraft(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CharacterDraft&& from) noexcept
      : CharacterDraft(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChoicesFieldNumber = 11,
    kIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kSessionIdFieldNumber = 3,
    kNameFieldNumber = 4,
    kRaceFieldNumber = 5,
    kSubraceFieldNumber = 6,
    kClassFieldNumber = 7,
    kBackgroundFieldNumber = 8,
    kAbilityScoresFieldNumber = 9,
    kProgressFieldNumber = 12,
    kMetadataFieldNumber = 16,
    kExpiresAtFieldNumber = 13,
    kAlignmentFieldNumber = 10,
    kRaceIdFieldNumber = 17,
    kCreatedAtFieldNumber = 14,
    kUpdatedAtFieldNumber = 15,
    kSubraceIdFieldNumber = 18,
    kClassIdFieldNumber = 19,
    kBackgroundIdFieldNumber = 20,
  };
  // repeated .dnd5e.api.v1alpha1.ChoiceData choices = 11 [json_name = "choices"];
  int choices_size() const;
  private:
  int _internal_choices_size() const;

  public:
  void clear_choices() ;
  ::dnd5e::api::v1alpha1::ChoiceData* PROTOBUF_NONNULL mutable_choices(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>* PROTOBUF_NONNULL mutable_choices();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>& _internal_choices() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>* PROTOBUF_NONNULL _internal_mutable_choices();
  public:
  const ::dnd5e::api::v1alpha1::ChoiceData& choices(int index) const;
  ::dnd5e::api::v1alpha1::ChoiceData* PROTOBUF_NONNULL add_choices();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>& choices() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string player_id = 2 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // string session_id = 3 [json_name = "sessionId"];
  void clear_session_id() ;
  const ::std::string& session_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_session_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_session_id();
  void set_allocated_session_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_session_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_session_id();

  public:
  // string name = 4 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // .dnd5e.api.v1alpha1.RaceInfo race = 5 [json_name = "race"];
  bool has_race() const;
  void clear_race() ;
  const ::dnd5e::api::v1alpha1::RaceInfo& race() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE release_race();
  ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NONNULL mutable_race();
  void set_allocated_race(::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_race(::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE unsafe_arena_release_race();

  private:
  const ::dnd5e::api::v1alpha1::RaceInfo& _internal_race() const;
  ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NONNULL _internal_mutable_race();

  public:
  // .dnd5e.api.v1alpha1.SubraceInfo subrace = 6 [json_name = "subrace"];
  bool has_subrace() const;
  void clear_subrace() ;
  const ::dnd5e::api::v1alpha1::SubraceInfo& subrace() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NULLABLE release_subrace();
  ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NONNULL mutable_subrace();
  void set_allocated_subrace(::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_subrace(::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NULLABLE unsafe_arena_release_subrace();

  private:
  const ::dnd5e::api::v1alpha1::SubraceInfo& _internal_subrace() const;
  ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NONNULL _internal_mutable_subrace();

  public:
  // .dnd5e.api.v1alpha1.ClassInfo class = 7 [json_name = "class"];
  bool has_class_() const;
  void clear_class_() ;
  const ::dnd5e::api::v1alpha1::ClassInfo& class_() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE release_class_();
  ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NONNULL mutable_class_();
  void set_allocated_class_(::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_class_(::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE unsafe_arena_release_class_();

  private:
  const ::dnd5e::api::v1alpha1::ClassInfo& _internal_class_() const;
  ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NONNULL _internal_mutable_class_();

  public:
  // .dnd5e.api.v1alpha1.BackgroundInfo background = 8 [json_name = "background"];
  bool has_background() const;
  void clear_background() ;
  const ::dnd5e::api::v1alpha1::BackgroundInfo& background() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE release_background();
  ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NONNULL mutable_background();
  void set_allocated_background(::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_background(::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE unsafe_arena_release_background();

  private:
  const ::dnd5e::api::v1alpha1::BackgroundInfo& _internal_background() const;
  ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NONNULL _internal_mutable_background();

  public:
  // .dnd5e.api.v1alpha1.AbilityScores ability_scores = 9 [json_name = "abilityScores"];
  bool has_ability_scores() const;
  void clear_ability_scores() ;
  const ::dnd5e::api::v1alpha1::AbilityScores& ability_scores() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE release_ability_scores();
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL mutable_ability_scores();
  void set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE unsafe_arena_release_ability_scores();

  private:
  const ::dnd5e::api::v1alpha1::AbilityScores& _internal_ability_scores() const;
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL _internal_mutable_ability_scores();

  public:
  // .dnd5e.api.v1alpha1.CreationProgress progress = 12 [json_name = "progress"];
  bool has_progress() const;
  void clear_progress() ;
  const ::dnd5e::api::v1alpha1::CreationProgress& progress() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE release_progress();
  ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NONNULL mutable_progress();
  void set_allocated_progress(::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_progress(::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE unsafe_arena_release_progress();

  private:
  const ::dnd5e::api::v1alpha1::CreationProgress& _internal_progress() const;
  ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NONNULL _internal_mutable_progress();

  public:
  // .dnd5e.api.v1alpha1.DraftMetadata metadata = 16 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::dnd5e::api::v1alpha1::DraftMetadata& metadata() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE release_metadata();
  ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NONNULL mutable_metadata();
  void set_allocated_metadata(::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_metadata(::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE unsafe_arena_release_metadata();

  private:
  const ::dnd5e::api::v1alpha1::DraftMetadata& _internal_metadata() const;
  ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NONNULL _internal_mutable_metadata();

  public:
  // int64 expires_at = 13 [json_name = "expiresAt"];
  void clear_expires_at() ;
  ::int64_t expires_at() const;
  void set_expires_at(::int64_t value);

  private:
  ::int64_t _internal_expires_at() const;
  void _internal_set_expires_at(::int64_t value);

  public:
  // .dnd5e.api.v1alpha1.Alignment alignment = 10 [json_name = "alignment"];
  void clear_alignment() ;
  ::dnd5e::api::v1alpha1::Alignment alignment() const;
  void set_alignment(::dnd5e::api::v1alpha1::Alignment value);

  private:
  ::dnd5e::api::v1alpha1::Alignment _internal_alignment() const;
  void _internal_set_alignment(::dnd5e::api::v1alpha1::Alignment value);

  public:
  // .dnd5e.api.v1alpha1.Race race_id = 17 [json_name = "raceId"];
  void clear_race_id() ;
  ::dnd5e::api::v1alpha1::Race race_id() const;
  void set_race_id(::dnd5e::api::v1alpha1::Race value);

  private:
  ::dnd5e::api::v1alpha1::Race _internal_race_id() const;
  void _internal_set_race_id(::dnd5e::api::v1alpha1::Race value);

  public:
  // int64 created_at = 14 [json_name = "createdAt"];
  void clear_created_at() ;
  ::int64_t created_at() const;
  void set_created_at(::int64_t value);

  private:
  ::int64_t _internal_created_at() const;
  void _internal_set_created_at(::int64_t value);

  public:
  // int64 updated_at = 15 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // .dnd5e.api.v1alpha1.Subrace subrace_id = 18 [json_name = "subraceId"];
  void clear_subrace_id() ;
  ::dnd5e::api::v1alpha1::Subrace subrace_id() const;
  void set_subrace_id(::dnd5e::api::v1alpha1::Subrace value);

  private:
  ::dnd5e::api::v1alpha1::Subrace _internal_subrace_id() const;
  void _internal_set_subrace_id(::dnd5e::api::v1alpha1::Subrace value);

  public:
  // .dnd5e.api.v1alpha1.Class class_id = 19 [json_name = "classId"];
  void clear_class_id() ;
  ::dnd5e::api::v1alpha1::Class class_id() const;
  void set_class_id(::dnd5e::api::v1alpha1::Class value);

  private:
  ::dnd5e::api::v1alpha1::Class _internal_class_id() const;
  void _internal_set_class_id(::dnd5e::api::v1alpha1::Class value);

  public:
  // .dnd5e.api.v1alpha1.Background background_id = 20 [json_name = "backgroundId"];
  void clear_background_id() ;
  ::dnd5e::api::v1alpha1::Background background_id() const;
  void set_background_id(::dnd5e::api::v1alpha1::Background value);

  private:
  ::dnd5e::api::v1alpha1::Background _internal_background_id() const;
  void _internal_set_background_id(::dnd5e::api::v1alpha1::Background value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CharacterDraft)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 20,
                                   8, 83,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CharacterDraft& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ChoiceData > choices_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE race_;
    ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NULLABLE subrace_;
    ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE class__;
    ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE background_;
    ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE ability_scores_;
    ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE progress_;
    ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE metadata_;
    ::int64_t expires_at_;
    int alignment_;
    int race_id_;
    ::int64_t created_at_;
    ::int64_t updated_at_;
    int subrace_id_;
    int class_id_;
    int background_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CharacterDraft_class_data_;
// -------------------------------------------------------------------

class Character final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.Character) */ {
 public:
  inline Character() : Character(nullptr) {}
  ~Character() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Character* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Character));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Character(::google::protobuf::internal::ConstantInitialized);

  inline Character(const Character& from) : Character(nullptr, from) {}
  inline Character(Character&& from) noexcept
      : Character(nullptr, ::std::move(from)) {}
  inline Character& operator=(const Character& from) {
    CopyFrom(from);
    return *this;
  }
  inline Character& operator=(Character&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Character& default_instance() {
    return *reinterpret_cast<const Character*>(
        &_Character_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Character& a, Character& b) { a.Swap(&b); }
  inline void Swap(Character* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Character* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Character* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Character>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Character& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Character& from) { Character::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Character* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.Character"; }

 protected:
  explicit Character(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Character(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Character& from);
  Character(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Character&& from) noexcept
      : Character(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLanguagesFieldNumber = 14,
    kInventoryFieldNumber = 20,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kSessionIdFieldNumber = 17,
    kAbilityScoresFieldNumber = 10,
    kAbilityModifiersFieldNumber = 11,
    kCombatStatsFieldNumber = 12,
    kProficienciesFieldNumber = 13,
    kMetadataFieldNumber = 18,
    kEquipmentSlotsFieldNumber = 19,
    kEncumbranceFieldNumber = 21,
    kLevelFieldNumber = 3,
    kExperiencePointsFieldNumber = 4,
    kRaceFieldNumber = 5,
    kSubraceFieldNumber = 6,
    kClassFieldNumber = 7,
    kBackgroundFieldNumber = 8,
    kAlignmentFieldNumber = 9,
    kCurrentHitPointsFieldNumber = 15,
    kTemporaryHitPointsFieldNumber = 16,
  };
  // repeated .dnd5e.api.v1alpha1.Language languages = 14 [json_name = "languages"];
  int languages_size() const;
  private:
  int _internal_languages_size() const;

  public:
  void clear_languages() ;
  public:
  ::dnd5e::api::v1alpha1::Language languages(int index) const;
  void set_languages(int index, ::dnd5e::api::v1alpha1::Language value);
  void add_languages(::dnd5e::api::v1alpha1::Language value);
  const ::google::protobuf::RepeatedField<int>& languages() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_languages();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_languages() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_languages();

  public:
  // repeated .dnd5e.api.v1alpha1.InventoryItem inventory = 20 [json_name = "inventory"];
  int inventory_size() const;
  private:
  int _internal_inventory_size() const;

  public:
  void clear_inventory() ;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_inventory(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>* PROTOBUF_NONNULL mutable_inventory();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>& _internal_inventory() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>* PROTOBUF_NONNULL _internal_mutable_inventory();
  public:
  const ::dnd5e::api::v1alpha1::InventoryItem& inventory(int index) const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL add_inventory();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>& inventory() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string name = 2 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string session_id = 17 [json_name = "sessionId"];
  void clear_session_id() ;
  const ::std::string& session_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_session_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_session_id();
  void set_allocated_session_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_session_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_session_id();

  public:
  // .dnd5e.api.v1alpha1.AbilityScores ability_scores = 10 [json_name = "abilityScores"];
  bool has_ability_scores() const;
  void clear_ability_scores() ;
  const ::dnd5e::api::v1alpha1::AbilityScores& ability_scores() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE release_ability_scores();
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL mutable_ability_scores();
  void set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE unsafe_arena_release_ability_scores();

  private:
  const ::dnd5e::api::v1alpha1::AbilityScores& _internal_ability_scores() const;
  ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL _internal_mutable_ability_scores();

  public:
  // .dnd5e.api.v1alpha1.AbilityModifiers ability_modifiers = 11 [json_name = "abilityModifiers"];
  bool has_ability_modifiers() const;
  void clear_ability_modifiers() ;
  const ::dnd5e::api::v1alpha1::AbilityModifiers& ability_modifiers() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NULLABLE release_ability_modifiers();
  ::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NONNULL mutable_ability_modifiers();
  void set_allocated_ability_modifiers(::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ability_modifiers(::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NULLABLE unsafe_arena_release_ability_modifiers();

  private:
  const ::dnd5e::api::v1alpha1::AbilityModifiers& _internal_ability_modifiers() const;
  ::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NONNULL _internal_mutable_ability_modifiers();

  public:
  // .dnd5e.api.v1alpha1.CombatStats combat_stats = 12 [json_name = "combatStats"];
  bool has_combat_stats() const;
  void clear_combat_stats() ;
  const ::dnd5e::api::v1alpha1::CombatStats& combat_stats() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NULLABLE release_combat_stats();
  ::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NONNULL mutable_combat_stats();
  void set_allocated_combat_stats(::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_stats(::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NULLABLE unsafe_arena_release_combat_stats();

  private:
  const ::dnd5e::api::v1alpha1::CombatStats& _internal_combat_stats() const;
  ::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NONNULL _internal_mutable_combat_stats();

  public:
  // .dnd5e.api.v1alpha1.Proficiencies proficiencies = 13 [json_name = "proficiencies"];
  bool has_proficiencies() const;
  void clear_proficiencies() ;
  const ::dnd5e::api::v1alpha1::Proficiencies& proficiencies() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NULLABLE release_proficiencies();
  ::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NONNULL mutable_proficiencies();
  void set_allocated_proficiencies(::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_proficiencies(::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NULLABLE unsafe_arena_release_proficiencies();

  private:
  const ::dnd5e::api::v1alpha1::Proficiencies& _internal_proficiencies() const;
  ::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NONNULL _internal_mutable_proficiencies();

  public:
  // .dnd5e.api.v1alpha1.CharacterMetadata metadata = 18 [json_name = "metadata"];
  bool has_metadata() const;
  void clear_metadata() ;
  const ::dnd5e::api::v1alpha1::CharacterMetadata& metadata() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NULLABLE release_metadata();
  ::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NONNULL mutable_metadata();
  void set_allocated_metadata(::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_metadata(::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NULLABLE unsafe_arena_release_metadata();

  private:
  const ::dnd5e::api::v1alpha1::CharacterMetadata& _internal_metadata() const;
  ::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NONNULL _internal_mutable_metadata();

  public:
  // .dnd5e.api.v1alpha1.EquipmentSlots equipment_slots = 19 [json_name = "equipmentSlots"];
  bool has_equipment_slots() const;
  void clear_equipment_slots() ;
  const ::dnd5e::api::v1alpha1::EquipmentSlots& equipment_slots() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE release_equipment_slots();
  ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NONNULL mutable_equipment_slots();
  void set_allocated_equipment_slots(::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_equipment_slots(::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE unsafe_arena_release_equipment_slots();

  private:
  const ::dnd5e::api::v1alpha1::EquipmentSlots& _internal_equipment_slots() const;
  ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NONNULL _internal_mutable_equipment_slots();

  public:
  // .dnd5e.api.v1alpha1.EncumbranceInfo encumbrance = 21 [json_name = "encumbrance"];
  bool has_encumbrance() const;
  void clear_encumbrance() ;
  const ::dnd5e::api::v1alpha1::EncumbranceInfo& encumbrance() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE release_encumbrance();
  ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NONNULL mutable_encumbrance();
  void set_allocated_encumbrance(::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_encumbrance(::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE unsafe_arena_release_encumbrance();

  private:
  const ::dnd5e::api::v1alpha1::EncumbranceInfo& _internal_encumbrance() const;
  ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NONNULL _internal_mutable_encumbrance();

  public:
  // int32 level = 3 [json_name = "level"];
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // int32 experience_points = 4 [json_name = "experiencePoints"];
  void clear_experience_points() ;
  ::int32_t experience_points() const;
  void set_experience_points(::int32_t value);

  private:
  ::int32_t _internal_experience_points() const;
  void _internal_set_experience_points(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.Race race = 5 [json_name = "race"];
  void clear_race() ;
  ::dnd5e::api::v1alpha1::Race race() const;
  void set_race(::dnd5e::api::v1alpha1::Race value);

  private:
  ::dnd5e::api::v1alpha1::Race _internal_race() const;
  void _internal_set_race(::dnd5e::api::v1alpha1::Race value);

  public:
  // .dnd5e.api.v1alpha1.Subrace subrace = 6 [json_name = "subrace"];
  void clear_subrace() ;
  ::dnd5e::api::v1alpha1::Subrace subrace() const;
  void set_subrace(::dnd5e::api::v1alpha1::Subrace value);

  private:
  ::dnd5e::api::v1alpha1::Subrace _internal_subrace() const;
  void _internal_set_subrace(::dnd5e::api::v1alpha1::Subrace value);

  public:
  // .dnd5e.api.v1alpha1.Class class = 7 [json_name = "class"];
  void clear_class_() ;
  ::dnd5e::api::v1alpha1::Class class_() const;
  void set_class_(::dnd5e::api::v1alpha1::Class value);

  private:
  ::dnd5e::api::v1alpha1::Class _internal_class_() const;
  void _internal_set_class_(::dnd5e::api::v1alpha1::Class value);

  public:
  // .dnd5e.api.v1alpha1.Background background = 8 [json_name = "background"];
  void clear_background() ;
  ::dnd5e::api::v1alpha1::Background background() const;
  void set_background(::dnd5e::api::v1alpha1::Background value);

  private:
  ::dnd5e::api::v1alpha1::Background _internal_background() const;
  void _internal_set_background(::dnd5e::api::v1alpha1::Background value);

  public:
  // .dnd5e.api.v1alpha1.Alignment alignment = 9 [json_name = "alignment"];
  void clear_alignment() ;
  ::dnd5e::api::v1alpha1::Alignment alignment() const;
  void set_alignment(::dnd5e::api::v1alpha1::Alignment value);

  private:
  ::dnd5e::api::v1alpha1::Alignment _internal_alignment() const;
  void _internal_set_alignment(::dnd5e::api::v1alpha1::Alignment value);

  public:
  // int32 current_hit_points = 15 [json_name = "currentHitPoints"];
  void clear_current_hit_points() ;
  ::int32_t current_hit_points() const;
  void set_current_hit_points(::int32_t value);

  private:
  ::int32_t _internal_current_hit_points() const;
  void _internal_set_current_hit_points(::int32_t value);

  public:
  // int32 temporary_hit_points = 16 [json_name = "temporaryHitPoints"];
  void clear_temporary_hit_points() ;
  ::int32_t temporary_hit_points() const;
  void set_temporary_hit_points(::int32_t value);

  private:
  ::int32_t _internal_temporary_hit_points() const;
  void _internal_set_temporary_hit_points(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.Character)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 21,
                                   8, 69,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Character& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> languages_;
    ::google::protobuf::internal::CachedSize _languages_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::InventoryItem > inventory_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE ability_scores_;
    ::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NULLABLE ability_modifiers_;
    ::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NULLABLE combat_stats_;
    ::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NULLABLE proficiencies_;
    ::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NULLABLE metadata_;
    ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE equipment_slots_;
    ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE encumbrance_;
    ::int32_t level_;
    ::int32_t experience_points_;
    int race_;
    int subrace_;
    int class__;
    int background_;
    int alignment_;
    ::int32_t current_hit_points_;
    ::int32_t temporary_hit_points_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Character_class_data_;
// -------------------------------------------------------------------

class UpdateSkillsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateSkillsResponse) */ {
 public:
  inline UpdateSkillsResponse() : UpdateSkillsResponse(nullptr) {}
  ~UpdateSkillsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateSkillsResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateSkillsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateSkillsResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateSkillsResponse(const UpdateSkillsResponse& from) : UpdateSkillsResponse(nullptr, from) {}
  inline UpdateSkillsResponse(UpdateSkillsResponse&& from) noexcept
      : UpdateSkillsResponse(nullptr, ::std::move(from)) {}
  inline UpdateSkillsResponse& operator=(const UpdateSkillsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSkillsResponse& operator=(UpdateSkillsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSkillsResponse& default_instance() {
    return *reinterpret_cast<const UpdateSkillsResponse*>(
        &_UpdateSkillsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(UpdateSkillsResponse& a, UpdateSkillsResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateSkillsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSkillsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSkillsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateSkillsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateSkillsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateSkillsResponse& from) { UpdateSkillsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateSkillsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateSkillsResponse"; }

 protected:
  explicit UpdateSkillsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateSkillsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateSkillsResponse& from);
  UpdateSkillsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateSkillsResponse&& from) noexcept
      : UpdateSkillsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWarningsFieldNumber = 2,
    kDraftFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;

  public:
  void clear_warnings() ;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL mutable_warnings(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL mutable_warnings();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& _internal_warnings() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL _internal_mutable_warnings();
  public:
  const ::dnd5e::api::v1alpha1::ValidationWarning& warnings(int index) const;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL add_warnings();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& warnings() const;
  // .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
  bool has_draft() const;
  void clear_draft() ;
  const ::dnd5e::api::v1alpha1::CharacterDraft& draft() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE release_draft();
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL mutable_draft();
  void set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE unsafe_arena_release_draft();

  private:
  const ::dnd5e::api::v1alpha1::CharacterDraft& _internal_draft() const;
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL _internal_mutable_draft();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateSkillsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateSkillsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ValidationWarning > warnings_;
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE draft_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateSkillsResponse_class_data_;
// -------------------------------------------------------------------

class UpdateRaceResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateRaceResponse) */ {
 public:
  inline UpdateRaceResponse() : UpdateRaceResponse(nullptr) {}
  ~UpdateRaceResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateRaceResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateRaceResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateRaceResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateRaceResponse(const UpdateRaceResponse& from) : UpdateRaceResponse(nullptr, from) {}
  inline UpdateRaceResponse(UpdateRaceResponse&& from) noexcept
      : UpdateRaceResponse(nullptr, ::std::move(from)) {}
  inline UpdateRaceResponse& operator=(const UpdateRaceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRaceResponse& operator=(UpdateRaceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRaceResponse& default_instance() {
    return *reinterpret_cast<const UpdateRaceResponse*>(
        &_UpdateRaceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(UpdateRaceResponse& a, UpdateRaceResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateRaceResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRaceResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRaceResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateRaceResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateRaceResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateRaceResponse& from) { UpdateRaceResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateRaceResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateRaceResponse"; }

 protected:
  explicit UpdateRaceResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateRaceResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateRaceResponse& from);
  UpdateRaceResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateRaceResponse&& from) noexcept
      : UpdateRaceResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWarningsFieldNumber = 2,
    kDraftFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;

  public:
  void clear_warnings() ;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL mutable_warnings(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL mutable_warnings();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& _internal_warnings() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL _internal_mutable_warnings();
  public:
  const ::dnd5e::api::v1alpha1::ValidationWarning& warnings(int index) const;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL add_warnings();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& warnings() const;
  // .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
  bool has_draft() const;
  void clear_draft() ;
  const ::dnd5e::api::v1alpha1::CharacterDraft& draft() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE release_draft();
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL mutable_draft();
  void set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE unsafe_arena_release_draft();

  private:
  const ::dnd5e::api::v1alpha1::CharacterDraft& _internal_draft() const;
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL _internal_mutable_draft();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateRaceResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateRaceResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ValidationWarning > warnings_;
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE draft_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateRaceResponse_class_data_;
// -------------------------------------------------------------------

class UpdateNameResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateNameResponse) */ {
 public:
  inline UpdateNameResponse() : UpdateNameResponse(nullptr) {}
  ~UpdateNameResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateNameResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateNameResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateNameResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateNameResponse(const UpdateNameResponse& from) : UpdateNameResponse(nullptr, from) {}
  inline UpdateNameResponse(UpdateNameResponse&& from) noexcept
      : UpdateNameResponse(nullptr, ::std::move(from)) {}
  inline UpdateNameResponse& operator=(const UpdateNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNameResponse& operator=(UpdateNameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNameResponse& default_instance() {
    return *reinterpret_cast<const UpdateNameResponse*>(
        &_UpdateNameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(UpdateNameResponse& a, UpdateNameResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateNameResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNameResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNameResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateNameResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateNameResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateNameResponse& from) { UpdateNameResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateNameResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateNameResponse"; }

 protected:
  explicit UpdateNameResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateNameResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateNameResponse& from);
  UpdateNameResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateNameResponse&& from) noexcept
      : UpdateNameResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWarningsFieldNumber = 2,
    kDraftFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;

  public:
  void clear_warnings() ;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL mutable_warnings(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL mutable_warnings();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& _internal_warnings() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL _internal_mutable_warnings();
  public:
  const ::dnd5e::api::v1alpha1::ValidationWarning& warnings(int index) const;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL add_warnings();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& warnings() const;
  // .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
  bool has_draft() const;
  void clear_draft() ;
  const ::dnd5e::api::v1alpha1::CharacterDraft& draft() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE release_draft();
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL mutable_draft();
  void set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE unsafe_arena_release_draft();

  private:
  const ::dnd5e::api::v1alpha1::CharacterDraft& _internal_draft() const;
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL _internal_mutable_draft();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateNameResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateNameResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ValidationWarning > warnings_;
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE draft_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateNameResponse_class_data_;
// -------------------------------------------------------------------

class UpdateDraftResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateDraftResponse) */ {
 public:
  inline UpdateDraftResponse() : UpdateDraftResponse(nullptr) {}
  ~UpdateDraftResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateDraftResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateDraftResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateDraftResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateDraftResponse(const UpdateDraftResponse& from) : UpdateDraftResponse(nullptr, from) {}
  inline UpdateDraftResponse(UpdateDraftResponse&& from) noexcept
      : UpdateDraftResponse(nullptr, ::std::move(from)) {}
  inline UpdateDraftResponse& operator=(const UpdateDraftResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateDraftResponse& operator=(UpdateDraftResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateDraftResponse& default_instance() {
    return *reinterpret_cast<const UpdateDraftResponse*>(
        &_UpdateDraftResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(UpdateDraftResponse& a, UpdateDraftResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateDraftResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateDraftResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateDraftResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateDraftResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateDraftResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateDraftResponse& from) { UpdateDraftResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateDraftResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateDraftResponse"; }

 protected:
  explicit UpdateDraftResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateDraftResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateDraftResponse& from);
  UpdateDraftResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateDraftResponse&& from) noexcept
      : UpdateDraftResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWarningsFieldNumber = 2,
    kDraftFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;

  public:
  void clear_warnings() ;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL mutable_warnings(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL mutable_warnings();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& _internal_warnings() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL _internal_mutable_warnings();
  public:
  const ::dnd5e::api::v1alpha1::ValidationWarning& warnings(int index) const;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL add_warnings();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& warnings() const;
  // .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
  bool has_draft() const;
  void clear_draft() ;
  const ::dnd5e::api::v1alpha1::CharacterDraft& draft() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE release_draft();
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL mutable_draft();
  void set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE unsafe_arena_release_draft();

  private:
  const ::dnd5e::api::v1alpha1::CharacterDraft& _internal_draft() const;
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL _internal_mutable_draft();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateDraftResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateDraftResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ValidationWarning > warnings_;
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE draft_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateDraftResponse_class_data_;
// -------------------------------------------------------------------

class UpdateClassResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateClassResponse) */ {
 public:
  inline UpdateClassResponse() : UpdateClassResponse(nullptr) {}
  ~UpdateClassResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateClassResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateClassResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateClassResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateClassResponse(const UpdateClassResponse& from) : UpdateClassResponse(nullptr, from) {}
  inline UpdateClassResponse(UpdateClassResponse&& from) noexcept
      : UpdateClassResponse(nullptr, ::std::move(from)) {}
  inline UpdateClassResponse& operator=(const UpdateClassResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateClassResponse& operator=(UpdateClassResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateClassResponse& default_instance() {
    return *reinterpret_cast<const UpdateClassResponse*>(
        &_UpdateClassResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(UpdateClassResponse& a, UpdateClassResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateClassResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateClassResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateClassResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateClassResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateClassResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateClassResponse& from) { UpdateClassResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateClassResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateClassResponse"; }

 protected:
  explicit UpdateClassResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateClassResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateClassResponse& from);
  UpdateClassResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateClassResponse&& from) noexcept
      : UpdateClassResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWarningsFieldNumber = 2,
    kDraftFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;

  public:
  void clear_warnings() ;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL mutable_warnings(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL mutable_warnings();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& _internal_warnings() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL _internal_mutable_warnings();
  public:
  const ::dnd5e::api::v1alpha1::ValidationWarning& warnings(int index) const;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL add_warnings();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& warnings() const;
  // .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
  bool has_draft() const;
  void clear_draft() ;
  const ::dnd5e::api::v1alpha1::CharacterDraft& draft() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE release_draft();
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL mutable_draft();
  void set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE unsafe_arena_release_draft();

  private:
  const ::dnd5e::api::v1alpha1::CharacterDraft& _internal_draft() const;
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL _internal_mutable_draft();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateClassResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateClassResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ValidationWarning > warnings_;
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE draft_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateClassResponse_class_data_;
// -------------------------------------------------------------------

class UpdateCharacterResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateCharacterResponse) */ {
 public:
  inline UpdateCharacterResponse() : UpdateCharacterResponse(nullptr) {}
  ~UpdateCharacterResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateCharacterResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateCharacterResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateCharacterResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateCharacterResponse(const UpdateCharacterResponse& from) : UpdateCharacterResponse(nullptr, from) {}
  inline UpdateCharacterResponse(UpdateCharacterResponse&& from) noexcept
      : UpdateCharacterResponse(nullptr, ::std::move(from)) {}
  inline UpdateCharacterResponse& operator=(const UpdateCharacterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCharacterResponse& operator=(UpdateCharacterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCharacterResponse& default_instance() {
    return *reinterpret_cast<const UpdateCharacterResponse*>(
        &_UpdateCharacterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(UpdateCharacterResponse& a, UpdateCharacterResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateCharacterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCharacterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCharacterResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateCharacterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateCharacterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateCharacterResponse& from) { UpdateCharacterResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateCharacterResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateCharacterResponse"; }

 protected:
  explicit UpdateCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateCharacterResponse& from);
  UpdateCharacterResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateCharacterResponse&& from) noexcept
      : UpdateCharacterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
  bool has_character() const;
  void clear_character() ;
  const ::dnd5e::api::v1alpha1::Character& character() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_character();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_character();
  void set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_character();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_character() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_character();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateCharacterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateCharacterResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE character_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateCharacterResponse_class_data_;
// -------------------------------------------------------------------

class UpdateCharacterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateCharacterRequest) */ {
 public:
  inline UpdateCharacterRequest() : UpdateCharacterRequest(nullptr) {}
  ~UpdateCharacterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateCharacterRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateCharacterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateCharacterRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateCharacterRequest(const UpdateCharacterRequest& from) : UpdateCharacterRequest(nullptr, from) {}
  inline UpdateCharacterRequest(UpdateCharacterRequest&& from) noexcept
      : UpdateCharacterRequest(nullptr, ::std::move(from)) {}
  inline UpdateCharacterRequest& operator=(const UpdateCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCharacterRequest& operator=(UpdateCharacterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCharacterRequest& default_instance() {
    return *reinterpret_cast<const UpdateCharacterRequest*>(
        &_UpdateCharacterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(UpdateCharacterRequest& a, UpdateCharacterRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateCharacterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCharacterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCharacterRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateCharacterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateCharacterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateCharacterRequest& from) { UpdateCharacterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateCharacterRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateCharacterRequest"; }

 protected:
  explicit UpdateCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateCharacterRequest& from);
  UpdateCharacterRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateCharacterRequest&& from) noexcept
      : UpdateCharacterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUpdateMaskFieldNumber = 2,
    kCharacterFieldNumber = 1,
  };
  // repeated string update_mask = 2 [json_name = "updateMask"];
  int update_mask_size() const;
  private:
  int _internal_update_mask_size() const;

  public:
  void clear_update_mask() ;
  const ::std::string& update_mask(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_update_mask(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_update_mask(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_update_mask();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_update_mask(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& update_mask() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_update_mask();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_update_mask() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_update_mask();

  public:
  // .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
  bool has_character() const;
  void clear_character() ;
  const ::dnd5e::api::v1alpha1::Character& character() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_character();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_character();
  void set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_character();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_character() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_character();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateCharacterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 61,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateCharacterRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> update_mask_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE character_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateCharacterRequest_class_data_;
// -------------------------------------------------------------------

class UpdateBackgroundResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateBackgroundResponse) */ {
 public:
  inline UpdateBackgroundResponse() : UpdateBackgroundResponse(nullptr) {}
  ~UpdateBackgroundResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateBackgroundResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateBackgroundResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateBackgroundResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateBackgroundResponse(const UpdateBackgroundResponse& from) : UpdateBackgroundResponse(nullptr, from) {}
  inline UpdateBackgroundResponse(UpdateBackgroundResponse&& from) noexcept
      : UpdateBackgroundResponse(nullptr, ::std::move(from)) {}
  inline UpdateBackgroundResponse& operator=(const UpdateBackgroundResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBackgroundResponse& operator=(UpdateBackgroundResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateBackgroundResponse& default_instance() {
    return *reinterpret_cast<const UpdateBackgroundResponse*>(
        &_UpdateBackgroundResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(UpdateBackgroundResponse& a, UpdateBackgroundResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateBackgroundResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateBackgroundResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateBackgroundResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateBackgroundResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateBackgroundResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateBackgroundResponse& from) { UpdateBackgroundResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateBackgroundResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateBackgroundResponse"; }

 protected:
  explicit UpdateBackgroundResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateBackgroundResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateBackgroundResponse& from);
  UpdateBackgroundResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateBackgroundResponse&& from) noexcept
      : UpdateBackgroundResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWarningsFieldNumber = 2,
    kDraftFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;

  public:
  void clear_warnings() ;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL mutable_warnings(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL mutable_warnings();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& _internal_warnings() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL _internal_mutable_warnings();
  public:
  const ::dnd5e::api::v1alpha1::ValidationWarning& warnings(int index) const;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL add_warnings();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& warnings() const;
  // .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
  bool has_draft() const;
  void clear_draft() ;
  const ::dnd5e::api::v1alpha1::CharacterDraft& draft() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE release_draft();
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL mutable_draft();
  void set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE unsafe_arena_release_draft();

  private:
  const ::dnd5e::api::v1alpha1::CharacterDraft& _internal_draft() const;
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL _internal_mutable_draft();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateBackgroundResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateBackgroundResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ValidationWarning > warnings_;
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE draft_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateBackgroundResponse_class_data_;
// -------------------------------------------------------------------

class UpdateAbilityScoresResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UpdateAbilityScoresResponse) */ {
 public:
  inline UpdateAbilityScoresResponse() : UpdateAbilityScoresResponse(nullptr) {}
  ~UpdateAbilityScoresResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateAbilityScoresResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateAbilityScoresResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateAbilityScoresResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateAbilityScoresResponse(const UpdateAbilityScoresResponse& from) : UpdateAbilityScoresResponse(nullptr, from) {}
  inline UpdateAbilityScoresResponse(UpdateAbilityScoresResponse&& from) noexcept
      : UpdateAbilityScoresResponse(nullptr, ::std::move(from)) {}
  inline UpdateAbilityScoresResponse& operator=(const UpdateAbilityScoresResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAbilityScoresResponse& operator=(UpdateAbilityScoresResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAbilityScoresResponse& default_instance() {
    return *reinterpret_cast<const UpdateAbilityScoresResponse*>(
        &_UpdateAbilityScoresResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(UpdateAbilityScoresResponse& a, UpdateAbilityScoresResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateAbilityScoresResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAbilityScoresResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateAbilityScoresResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateAbilityScoresResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateAbilityScoresResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateAbilityScoresResponse& from) { UpdateAbilityScoresResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateAbilityScoresResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UpdateAbilityScoresResponse"; }

 protected:
  explicit UpdateAbilityScoresResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateAbilityScoresResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateAbilityScoresResponse& from);
  UpdateAbilityScoresResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateAbilityScoresResponse&& from) noexcept
      : UpdateAbilityScoresResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWarningsFieldNumber = 2,
    kDraftFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;

  public:
  void clear_warnings() ;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL mutable_warnings(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL mutable_warnings();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& _internal_warnings() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL _internal_mutable_warnings();
  public:
  const ::dnd5e::api::v1alpha1::ValidationWarning& warnings(int index) const;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL add_warnings();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& warnings() const;
  // .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
  bool has_draft() const;
  void clear_draft() ;
  const ::dnd5e::api::v1alpha1::CharacterDraft& draft() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE release_draft();
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL mutable_draft();
  void set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE unsafe_arena_release_draft();

  private:
  const ::dnd5e::api::v1alpha1::CharacterDraft& _internal_draft() const;
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL _internal_mutable_draft();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UpdateAbilityScoresResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateAbilityScoresResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ValidationWarning > warnings_;
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE draft_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateAbilityScoresResponse_class_data_;
// -------------------------------------------------------------------

class UnequipItemResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.UnequipItemResponse) */ {
 public:
  inline UnequipItemResponse() : UnequipItemResponse(nullptr) {}
  ~UnequipItemResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UnequipItemResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UnequipItemResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnequipItemResponse(::google::protobuf::internal::ConstantInitialized);

  inline UnequipItemResponse(const UnequipItemResponse& from) : UnequipItemResponse(nullptr, from) {}
  inline UnequipItemResponse(UnequipItemResponse&& from) noexcept
      : UnequipItemResponse(nullptr, ::std::move(from)) {}
  inline UnequipItemResponse& operator=(const UnequipItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnequipItemResponse& operator=(UnequipItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnequipItemResponse& default_instance() {
    return *reinterpret_cast<const UnequipItemResponse*>(
        &_UnequipItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 115;
  friend void swap(UnequipItemResponse& a, UnequipItemResponse& b) { a.Swap(&b); }
  inline void Swap(UnequipItemResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnequipItemResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnequipItemResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UnequipItemResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnequipItemResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UnequipItemResponse& from) { UnequipItemResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UnequipItemResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.UnequipItemResponse"; }

 protected:
  explicit UnequipItemResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UnequipItemResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UnequipItemResponse& from);
  UnequipItemResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UnequipItemResponse&& from) noexcept
      : UnequipItemResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
  bool has_character() const;
  void clear_character() ;
  const ::dnd5e::api::v1alpha1::Character& character() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_character();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_character();
  void set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_character();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_character() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_character();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.UnequipItemResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UnequipItemResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE character_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UnequipItemResponse_class_data_;
// -------------------------------------------------------------------

class RemoveFromInventoryResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.RemoveFromInventoryResponse) */ {
 public:
  inline RemoveFromInventoryResponse() : RemoveFromInventoryResponse(nullptr) {}
  ~RemoveFromInventoryResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RemoveFromInventoryResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RemoveFromInventoryResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoveFromInventoryResponse(::google::protobuf::internal::ConstantInitialized);

  inline RemoveFromInventoryResponse(const RemoveFromInventoryResponse& from) : RemoveFromInventoryResponse(nullptr, from) {}
  inline RemoveFromInventoryResponse(RemoveFromInventoryResponse&& from) noexcept
      : RemoveFromInventoryResponse(nullptr, ::std::move(from)) {}
  inline RemoveFromInventoryResponse& operator=(const RemoveFromInventoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveFromInventoryResponse& operator=(RemoveFromInventoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveFromInventoryResponse& default_instance() {
    return *reinterpret_cast<const RemoveFromInventoryResponse*>(
        &_RemoveFromInventoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 120;
  friend void swap(RemoveFromInventoryResponse& a, RemoveFromInventoryResponse& b) { a.Swap(&b); }
  inline void Swap(RemoveFromInventoryResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveFromInventoryResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveFromInventoryResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RemoveFromInventoryResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoveFromInventoryResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoveFromInventoryResponse& from) { RemoveFromInventoryResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RemoveFromInventoryResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.RemoveFromInventoryResponse"; }

 protected:
  explicit RemoveFromInventoryResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RemoveFromInventoryResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RemoveFromInventoryResponse& from);
  RemoveFromInventoryResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RemoveFromInventoryResponse&& from) noexcept
      : RemoveFromInventoryResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterFieldNumber = 1,
    kQuantityRemovedFieldNumber = 2,
  };
  // .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
  bool has_character() const;
  void clear_character() ;
  const ::dnd5e::api::v1alpha1::Character& character() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_character();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_character();
  void set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_character();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_character() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_character();

  public:
  // int32 quantity_removed = 2 [json_name = "quantityRemoved"];
  void clear_quantity_removed() ;
  ::int32_t quantity_removed() const;
  void set_quantity_removed(::int32_t value);

  private:
  ::int32_t _internal_quantity_removed() const;
  void _internal_set_quantity_removed(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.RemoveFromInventoryResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RemoveFromInventoryResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE character_;
    ::int32_t quantity_removed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RemoveFromInventoryResponse_class_data_;
// -------------------------------------------------------------------

class ListDraftsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListDraftsResponse) */ {
 public:
  inline ListDraftsResponse() : ListDraftsResponse(nullptr) {}
  ~ListDraftsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListDraftsResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListDraftsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListDraftsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListDraftsResponse(const ListDraftsResponse& from) : ListDraftsResponse(nullptr, from) {}
  inline ListDraftsResponse(ListDraftsResponse&& from) noexcept
      : ListDraftsResponse(nullptr, ::std::move(from)) {}
  inline ListDraftsResponse& operator=(const ListDraftsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDraftsResponse& operator=(ListDraftsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDraftsResponse& default_instance() {
    return *reinterpret_cast<const ListDraftsResponse*>(
        &_ListDraftsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(ListDraftsResponse& a, ListDraftsResponse& b) { a.Swap(&b); }
  inline void Swap(ListDraftsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDraftsResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDraftsResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListDraftsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListDraftsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListDraftsResponse& from) { ListDraftsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListDraftsResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListDraftsResponse"; }

 protected:
  explicit ListDraftsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListDraftsResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListDraftsResponse& from);
  ListDraftsResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListDraftsResponse&& from) noexcept
      : ListDraftsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDraftsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.CharacterDraft drafts = 1 [json_name = "drafts"];
  int drafts_size() const;
  private:
  int _internal_drafts_size() const;

  public:
  void clear_drafts() ;
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL mutable_drafts(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::CharacterDraft>* PROTOBUF_NONNULL mutable_drafts();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::CharacterDraft>& _internal_drafts() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::CharacterDraft>* PROTOBUF_NONNULL _internal_mutable_drafts();
  public:
  const ::dnd5e::api::v1alpha1::CharacterDraft& drafts(int index) const;
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL add_drafts();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::CharacterDraft>& drafts() const;
  // string next_page_token = 2 [json_name = "nextPageToken"];
  void clear_next_page_token() ;
  const ::std::string& next_page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_next_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_next_page_token();
  void set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_next_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_next_page_token();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListDraftsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 61,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListDraftsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::CharacterDraft > drafts_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListDraftsResponse_class_data_;
// -------------------------------------------------------------------

class ListCharactersResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ListCharactersResponse) */ {
 public:
  inline ListCharactersResponse() : ListCharactersResponse(nullptr) {}
  ~ListCharactersResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListCharactersResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListCharactersResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListCharactersResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListCharactersResponse(const ListCharactersResponse& from) : ListCharactersResponse(nullptr, from) {}
  inline ListCharactersResponse(ListCharactersResponse&& from) noexcept
      : ListCharactersResponse(nullptr, ::std::move(from)) {}
  inline ListCharactersResponse& operator=(const ListCharactersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCharactersResponse& operator=(ListCharactersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListCharactersResponse& default_instance() {
    return *reinterpret_cast<const ListCharactersResponse*>(
        &_ListCharactersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ListCharactersResponse& a, ListCharactersResponse& b) { a.Swap(&b); }
  inline void Swap(ListCharactersResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCharactersResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListCharactersResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListCharactersResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListCharactersResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListCharactersResponse& from) { ListCharactersResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListCharactersResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ListCharactersResponse"; }

 protected:
  explicit ListCharactersResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListCharactersResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListCharactersResponse& from);
  ListCharactersResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListCharactersResponse&& from) noexcept
      : ListCharactersResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharactersFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .dnd5e.api.v1alpha1.Character characters = 1 [json_name = "characters"];
  int characters_size() const;
  private:
  int _internal_characters_size() const;

  public:
  void clear_characters() ;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_characters(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>* PROTOBUF_NONNULL mutable_characters();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>& _internal_characters() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>* PROTOBUF_NONNULL _internal_mutable_characters();
  public:
  const ::dnd5e::api::v1alpha1::Character& characters(int index) const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL add_characters();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>& characters() const;
  // string next_page_token = 2 [json_name = "nextPageToken"];
  void clear_next_page_token() ;
  const ::std::string& next_page_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_next_page_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_next_page_token();
  void set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_next_page_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_next_page_token();

  public:
  // int32 total_size = 3 [json_name = "totalSize"];
  void clear_total_size() ;
  ::int32_t total_size() const;
  void set_total_size(::int32_t value);

  private:
  ::int32_t _internal_total_size() const;
  void _internal_set_total_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ListCharactersResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 65,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListCharactersResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::Character > characters_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::int32_t total_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListCharactersResponse_class_data_;
// -------------------------------------------------------------------

class GetDraftResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetDraftResponse) */ {
 public:
  inline GetDraftResponse() : GetDraftResponse(nullptr) {}
  ~GetDraftResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetDraftResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetDraftResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetDraftResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetDraftResponse(const GetDraftResponse& from) : GetDraftResponse(nullptr, from) {}
  inline GetDraftResponse(GetDraftResponse&& from) noexcept
      : GetDraftResponse(nullptr, ::std::move(from)) {}
  inline GetDraftResponse& operator=(const GetDraftResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDraftResponse& operator=(GetDraftResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDraftResponse& default_instance() {
    return *reinterpret_cast<const GetDraftResponse*>(
        &_GetDraftResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(GetDraftResponse& a, GetDraftResponse& b) { a.Swap(&b); }
  inline void Swap(GetDraftResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDraftResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDraftResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetDraftResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetDraftResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetDraftResponse& from) { GetDraftResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetDraftResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetDraftResponse"; }

 protected:
  explicit GetDraftResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetDraftResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetDraftResponse& from);
  GetDraftResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetDraftResponse&& from) noexcept
      : GetDraftResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDraftFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
  bool has_draft() const;
  void clear_draft() ;
  const ::dnd5e::api::v1alpha1::CharacterDraft& draft() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE release_draft();
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL mutable_draft();
  void set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE unsafe_arena_release_draft();

  private:
  const ::dnd5e::api::v1alpha1::CharacterDraft& _internal_draft() const;
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL _internal_mutable_draft();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetDraftResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetDraftResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE draft_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetDraftResponse_class_data_;
// -------------------------------------------------------------------

class GetDraftPreviewResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetDraftPreviewResponse) */ {
 public:
  inline GetDraftPreviewResponse() : GetDraftPreviewResponse(nullptr) {}
  ~GetDraftPreviewResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetDraftPreviewResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetDraftPreviewResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetDraftPreviewResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetDraftPreviewResponse(const GetDraftPreviewResponse& from) : GetDraftPreviewResponse(nullptr, from) {}
  inline GetDraftPreviewResponse(GetDraftPreviewResponse&& from) noexcept
      : GetDraftPreviewResponse(nullptr, ::std::move(from)) {}
  inline GetDraftPreviewResponse& operator=(const GetDraftPreviewResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDraftPreviewResponse& operator=(GetDraftPreviewResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDraftPreviewResponse& default_instance() {
    return *reinterpret_cast<const GetDraftPreviewResponse*>(
        &_GetDraftPreviewResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(GetDraftPreviewResponse& a, GetDraftPreviewResponse& b) { a.Swap(&b); }
  inline void Swap(GetDraftPreviewResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDraftPreviewResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDraftPreviewResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetDraftPreviewResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetDraftPreviewResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetDraftPreviewResponse& from) { GetDraftPreviewResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetDraftPreviewResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetDraftPreviewResponse"; }

 protected:
  explicit GetDraftPreviewResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetDraftPreviewResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetDraftPreviewResponse& from);
  GetDraftPreviewResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetDraftPreviewResponse&& from) noexcept
      : GetDraftPreviewResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWarningsFieldNumber = 3,
    kErrorsFieldNumber = 4,
    kDraftFieldNumber = 1,
    kPreviewFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 3 [json_name = "warnings"];
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;

  public:
  void clear_warnings() ;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL mutable_warnings(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL mutable_warnings();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& _internal_warnings() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL _internal_mutable_warnings();
  public:
  const ::dnd5e::api::v1alpha1::ValidationWarning& warnings(int index) const;
  ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL add_warnings();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& warnings() const;
  // repeated .dnd5e.api.v1alpha1.ValidationError errors = 4 [json_name = "errors"];
  int errors_size() const;
  private:
  int _internal_errors_size() const;

  public:
  void clear_errors() ;
  ::dnd5e::api::v1alpha1::ValidationError* PROTOBUF_NONNULL mutable_errors(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>* PROTOBUF_NONNULL mutable_errors();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>& _internal_errors() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>* PROTOBUF_NONNULL _internal_mutable_errors();
  public:
  const ::dnd5e::api::v1alpha1::ValidationError& errors(int index) const;
  ::dnd5e::api::v1alpha1::ValidationError* PROTOBUF_NONNULL add_errors();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>& errors() const;
  // .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
  bool has_draft() const;
  void clear_draft() ;
  const ::dnd5e::api::v1alpha1::CharacterDraft& draft() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE release_draft();
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL mutable_draft();
  void set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE unsafe_arena_release_draft();

  private:
  const ::dnd5e::api::v1alpha1::CharacterDraft& _internal_draft() const;
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL _internal_mutable_draft();

  public:
  // .dnd5e.api.v1alpha1.Character preview = 2 [json_name = "preview"];
  bool has_preview() const;
  void clear_preview() ;
  const ::dnd5e::api::v1alpha1::Character& preview() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_preview();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_preview();
  void set_allocated_preview(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_preview(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_preview();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_preview() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_preview();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetDraftPreviewResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetDraftPreviewResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ValidationWarning > warnings_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::ValidationError > errors_;
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE draft_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE preview_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetDraftPreviewResponse_class_data_;
// -------------------------------------------------------------------

class GetCharacterResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetCharacterResponse) */ {
 public:
  inline GetCharacterResponse() : GetCharacterResponse(nullptr) {}
  ~GetCharacterResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCharacterResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCharacterResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCharacterResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetCharacterResponse(const GetCharacterResponse& from) : GetCharacterResponse(nullptr, from) {}
  inline GetCharacterResponse(GetCharacterResponse&& from) noexcept
      : GetCharacterResponse(nullptr, ::std::move(from)) {}
  inline GetCharacterResponse& operator=(const GetCharacterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCharacterResponse& operator=(GetCharacterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCharacterResponse& default_instance() {
    return *reinterpret_cast<const GetCharacterResponse*>(
        &_GetCharacterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(GetCharacterResponse& a, GetCharacterResponse& b) { a.Swap(&b); }
  inline void Swap(GetCharacterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCharacterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCharacterResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCharacterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCharacterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCharacterResponse& from) { GetCharacterResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCharacterResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetCharacterResponse"; }

 protected:
  explicit GetCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCharacterResponse& from);
  GetCharacterResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCharacterResponse&& from) noexcept
      : GetCharacterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
  bool has_character() const;
  void clear_character() ;
  const ::dnd5e::api::v1alpha1::Character& character() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_character();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_character();
  void set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_character();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_character() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_character();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetCharacterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCharacterResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE character_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCharacterResponse_class_data_;
// -------------------------------------------------------------------

class FinalizeDraftResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.FinalizeDraftResponse) */ {
 public:
  inline FinalizeDraftResponse() : FinalizeDraftResponse(nullptr) {}
  ~FinalizeDraftResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FinalizeDraftResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FinalizeDraftResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FinalizeDraftResponse(::google::protobuf::internal::ConstantInitialized);

  inline FinalizeDraftResponse(const FinalizeDraftResponse& from) : FinalizeDraftResponse(nullptr, from) {}
  inline FinalizeDraftResponse(FinalizeDraftResponse&& from) noexcept
      : FinalizeDraftResponse(nullptr, ::std::move(from)) {}
  inline FinalizeDraftResponse& operator=(const FinalizeDraftResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinalizeDraftResponse& operator=(FinalizeDraftResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FinalizeDraftResponse& default_instance() {
    return *reinterpret_cast<const FinalizeDraftResponse*>(
        &_FinalizeDraftResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(FinalizeDraftResponse& a, FinalizeDraftResponse& b) { a.Swap(&b); }
  inline void Swap(FinalizeDraftResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinalizeDraftResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinalizeDraftResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FinalizeDraftResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FinalizeDraftResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FinalizeDraftResponse& from) { FinalizeDraftResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FinalizeDraftResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.FinalizeDraftResponse"; }

 protected:
  explicit FinalizeDraftResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FinalizeDraftResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FinalizeDraftResponse& from);
  FinalizeDraftResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FinalizeDraftResponse&& from) noexcept
      : FinalizeDraftResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterFieldNumber = 1,
    kDraftDeletedFieldNumber = 2,
  };
  // .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
  bool has_character() const;
  void clear_character() ;
  const ::dnd5e::api::v1alpha1::Character& character() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_character();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_character();
  void set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_character();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_character() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_character();

  public:
  // bool draft_deleted = 2 [json_name = "draftDeleted"];
  void clear_draft_deleted() ;
  bool draft_deleted() const;
  void set_draft_deleted(bool value);

  private:
  bool _internal_draft_deleted() const;
  void _internal_set_draft_deleted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.FinalizeDraftResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FinalizeDraftResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE character_;
    bool draft_deleted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FinalizeDraftResponse_class_data_;
// -------------------------------------------------------------------

class EquipItemResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EquipItemResponse) */ {
 public:
  inline EquipItemResponse() : EquipItemResponse(nullptr) {}
  ~EquipItemResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EquipItemResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EquipItemResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EquipItemResponse(::google::protobuf::internal::ConstantInitialized);

  inline EquipItemResponse(const EquipItemResponse& from) : EquipItemResponse(nullptr, from) {}
  inline EquipItemResponse(EquipItemResponse&& from) noexcept
      : EquipItemResponse(nullptr, ::std::move(from)) {}
  inline EquipItemResponse& operator=(const EquipItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipItemResponse& operator=(EquipItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipItemResponse& default_instance() {
    return *reinterpret_cast<const EquipItemResponse*>(
        &_EquipItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 113;
  friend void swap(EquipItemResponse& a, EquipItemResponse& b) { a.Swap(&b); }
  inline void Swap(EquipItemResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipItemResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipItemResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EquipItemResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EquipItemResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EquipItemResponse& from) { EquipItemResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EquipItemResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EquipItemResponse"; }

 protected:
  explicit EquipItemResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EquipItemResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EquipItemResponse& from);
  EquipItemResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EquipItemResponse&& from) noexcept
      : EquipItemResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterFieldNumber = 1,
    kPreviouslyEquippedItemFieldNumber = 2,
  };
  // .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
  bool has_character() const;
  void clear_character() ;
  const ::dnd5e::api::v1alpha1::Character& character() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_character();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_character();
  void set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_character();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_character() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_character();

  public:
  // .dnd5e.api.v1alpha1.InventoryItem previously_equipped_item = 2 [json_name = "previouslyEquippedItem"];
  bool has_previously_equipped_item() const;
  void clear_previously_equipped_item() ;
  const ::dnd5e::api::v1alpha1::InventoryItem& previously_equipped_item() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE release_previously_equipped_item();
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL mutable_previously_equipped_item();
  void set_allocated_previously_equipped_item(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_previously_equipped_item(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE unsafe_arena_release_previously_equipped_item();

  private:
  const ::dnd5e::api::v1alpha1::InventoryItem& _internal_previously_equipped_item() const;
  ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL _internal_mutable_previously_equipped_item();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EquipItemResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EquipItemResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE character_;
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE previously_equipped_item_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EquipItemResponse_class_data_;
// -------------------------------------------------------------------

class CreateDraftResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CreateDraftResponse) */ {
 public:
  inline CreateDraftResponse() : CreateDraftResponse(nullptr) {}
  ~CreateDraftResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateDraftResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateDraftResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateDraftResponse(::google::protobuf::internal::ConstantInitialized);

  inline CreateDraftResponse(const CreateDraftResponse& from) : CreateDraftResponse(nullptr, from) {}
  inline CreateDraftResponse(CreateDraftResponse&& from) noexcept
      : CreateDraftResponse(nullptr, ::std::move(from)) {}
  inline CreateDraftResponse& operator=(const CreateDraftResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDraftResponse& operator=(CreateDraftResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDraftResponse& default_instance() {
    return *reinterpret_cast<const CreateDraftResponse*>(
        &_CreateDraftResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(CreateDraftResponse& a, CreateDraftResponse& b) { a.Swap(&b); }
  inline void Swap(CreateDraftResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDraftResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDraftResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateDraftResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateDraftResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateDraftResponse& from) { CreateDraftResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateDraftResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CreateDraftResponse"; }

 protected:
  explicit CreateDraftResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreateDraftResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreateDraftResponse& from);
  CreateDraftResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreateDraftResponse&& from) noexcept
      : CreateDraftResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDraftFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
  bool has_draft() const;
  void clear_draft() ;
  const ::dnd5e::api::v1alpha1::CharacterDraft& draft() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE release_draft();
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL mutable_draft();
  void set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE unsafe_arena_release_draft();

  private:
  const ::dnd5e::api::v1alpha1::CharacterDraft& _internal_draft() const;
  ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL _internal_mutable_draft();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CreateDraftResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CreateDraftResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE draft_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreateDraftResponse_class_data_;
// -------------------------------------------------------------------

class AddToInventoryResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AddToInventoryResponse) */ {
 public:
  inline AddToInventoryResponse() : AddToInventoryResponse(nullptr) {}
  ~AddToInventoryResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AddToInventoryResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AddToInventoryResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddToInventoryResponse(::google::protobuf::internal::ConstantInitialized);

  inline AddToInventoryResponse(const AddToInventoryResponse& from) : AddToInventoryResponse(nullptr, from) {}
  inline AddToInventoryResponse(AddToInventoryResponse&& from) noexcept
      : AddToInventoryResponse(nullptr, ::std::move(from)) {}
  inline AddToInventoryResponse& operator=(const AddToInventoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddToInventoryResponse& operator=(AddToInventoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddToInventoryResponse& default_instance() {
    return *reinterpret_cast<const AddToInventoryResponse*>(
        &_AddToInventoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 118;
  friend void swap(AddToInventoryResponse& a, AddToInventoryResponse& b) { a.Swap(&b); }
  inline void Swap(AddToInventoryResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddToInventoryResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddToInventoryResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AddToInventoryResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddToInventoryResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddToInventoryResponse& from) { AddToInventoryResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AddToInventoryResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AddToInventoryResponse"; }

 protected:
  explicit AddToInventoryResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AddToInventoryResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AddToInventoryResponse& from);
  AddToInventoryResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AddToInventoryResponse&& from) noexcept
      : AddToInventoryResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorsFieldNumber = 2,
    kCharacterFieldNumber = 1,
  };
  // repeated string errors = 2 [json_name = "errors"];
  int errors_size() const;
  private:
  int _internal_errors_size() const;

  public:
  void clear_errors() ;
  const ::std::string& errors(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_errors(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_errors(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_errors();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_errors(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& errors() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_errors();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_errors() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_errors();

  public:
  // .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
  bool has_character() const;
  void clear_character() ;
  const ::dnd5e::api::v1alpha1::Character& character() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_character();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_character();
  void set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_character();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_character() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_character();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AddToInventoryResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AddToInventoryResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> errors_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE character_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AddToInventoryResponse_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AbilityScores

// int32 strength = 1 [json_name = "strength"];
inline void AbilityScores::clear_strength() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strength_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AbilityScores::strength() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScores.strength)
  return _internal_strength();
}
inline void AbilityScores::set_strength(::int32_t value) {
  _internal_set_strength(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScores.strength)
}
inline ::int32_t AbilityScores::_internal_strength() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strength_;
}
inline void AbilityScores::_internal_set_strength(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strength_ = value;
}

// int32 dexterity = 2 [json_name = "dexterity"];
inline void AbilityScores::clear_dexterity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dexterity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AbilityScores::dexterity() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScores.dexterity)
  return _internal_dexterity();
}
inline void AbilityScores::set_dexterity(::int32_t value) {
  _internal_set_dexterity(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScores.dexterity)
}
inline ::int32_t AbilityScores::_internal_dexterity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dexterity_;
}
inline void AbilityScores::_internal_set_dexterity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dexterity_ = value;
}

// int32 constitution = 3 [json_name = "constitution"];
inline void AbilityScores::clear_constitution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constitution_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t AbilityScores::constitution() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScores.constitution)
  return _internal_constitution();
}
inline void AbilityScores::set_constitution(::int32_t value) {
  _internal_set_constitution(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScores.constitution)
}
inline ::int32_t AbilityScores::_internal_constitution() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.constitution_;
}
inline void AbilityScores::_internal_set_constitution(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constitution_ = value;
}

// int32 intelligence = 4 [json_name = "intelligence"];
inline void AbilityScores::clear_intelligence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.intelligence_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t AbilityScores::intelligence() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScores.intelligence)
  return _internal_intelligence();
}
inline void AbilityScores::set_intelligence(::int32_t value) {
  _internal_set_intelligence(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScores.intelligence)
}
inline ::int32_t AbilityScores::_internal_intelligence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.intelligence_;
}
inline void AbilityScores::_internal_set_intelligence(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.intelligence_ = value;
}

// int32 wisdom = 5 [json_name = "wisdom"];
inline void AbilityScores::clear_wisdom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wisdom_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t AbilityScores::wisdom() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScores.wisdom)
  return _internal_wisdom();
}
inline void AbilityScores::set_wisdom(::int32_t value) {
  _internal_set_wisdom(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScores.wisdom)
}
inline ::int32_t AbilityScores::_internal_wisdom() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wisdom_;
}
inline void AbilityScores::_internal_set_wisdom(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wisdom_ = value;
}

// int32 charisma = 6 [json_name = "charisma"];
inline void AbilityScores::clear_charisma() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.charisma_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t AbilityScores::charisma() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScores.charisma)
  return _internal_charisma();
}
inline void AbilityScores::set_charisma(::int32_t value) {
  _internal_set_charisma(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScores.charisma)
}
inline ::int32_t AbilityScores::_internal_charisma() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.charisma_;
}
inline void AbilityScores::_internal_set_charisma(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.charisma_ = value;
}

// -------------------------------------------------------------------

// Character

// string id = 1 [json_name = "id"];
inline void Character::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Character::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Character::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.id)
}
inline ::std::string* PROTOBUF_NONNULL Character::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Character.id)
  return _s;
}
inline const ::std::string& Character::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Character::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Character::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Character::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Character.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void Character::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Character.id)
}

// string name = 2 [json_name = "name"];
inline void Character::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Character::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Character::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.name)
}
inline ::std::string* PROTOBUF_NONNULL Character::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Character.name)
  return _s;
}
inline const ::std::string& Character::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Character::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Character::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Character::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Character.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void Character::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Character.name)
}

// int32 level = 3 [json_name = "level"];
inline void Character::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int32_t Character::level() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.level)
  return _internal_level();
}
inline void Character::set_level(::int32_t value) {
  _internal_set_level(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.level)
}
inline ::int32_t Character::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_;
}
inline void Character::_internal_set_level(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = value;
}

// int32 experience_points = 4 [json_name = "experiencePoints"];
inline void Character::clear_experience_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.experience_points_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t Character::experience_points() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.experience_points)
  return _internal_experience_points();
}
inline void Character::set_experience_points(::int32_t value) {
  _internal_set_experience_points(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.experience_points)
}
inline ::int32_t Character::_internal_experience_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.experience_points_;
}
inline void Character::_internal_set_experience_points(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.experience_points_ = value;
}

// .dnd5e.api.v1alpha1.Race race = 5 [json_name = "race"];
inline void Character::clear_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.race_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::dnd5e::api::v1alpha1::Race Character::race() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.race)
  return _internal_race();
}
inline void Character::set_race(::dnd5e::api::v1alpha1::Race value) {
  _internal_set_race(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.race)
}
inline ::dnd5e::api::v1alpha1::Race Character::_internal_race() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Race>(_impl_.race_);
}
inline void Character::_internal_set_race(::dnd5e::api::v1alpha1::Race value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.race_ = value;
}

// .dnd5e.api.v1alpha1.Subrace subrace = 6 [json_name = "subrace"];
inline void Character::clear_subrace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subrace_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::dnd5e::api::v1alpha1::Subrace Character::subrace() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.subrace)
  return _internal_subrace();
}
inline void Character::set_subrace(::dnd5e::api::v1alpha1::Subrace value) {
  _internal_set_subrace(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.subrace)
}
inline ::dnd5e::api::v1alpha1::Subrace Character::_internal_subrace() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Subrace>(_impl_.subrace_);
}
inline void Character::_internal_set_subrace(::dnd5e::api::v1alpha1::Subrace value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subrace_ = value;
}

// .dnd5e.api.v1alpha1.Class class = 7 [json_name = "class"];
inline void Character::clear_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class__ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::dnd5e::api::v1alpha1::Class Character::class_() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.class)
  return _internal_class_();
}
inline void Character::set_class_(::dnd5e::api::v1alpha1::Class value) {
  _internal_set_class_(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.class)
}
inline ::dnd5e::api::v1alpha1::Class Character::_internal_class_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Class>(_impl_.class__);
}
inline void Character::_internal_set_class_(::dnd5e::api::v1alpha1::Class value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class__ = value;
}

// .dnd5e.api.v1alpha1.Background background = 8 [json_name = "background"];
inline void Character::clear_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.background_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::dnd5e::api::v1alpha1::Background Character::background() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.background)
  return _internal_background();
}
inline void Character::set_background(::dnd5e::api::v1alpha1::Background value) {
  _internal_set_background(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.background)
}
inline ::dnd5e::api::v1alpha1::Background Character::_internal_background() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Background>(_impl_.background_);
}
inline void Character::_internal_set_background(::dnd5e::api::v1alpha1::Background value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.background_ = value;
}

// .dnd5e.api.v1alpha1.Alignment alignment = 9 [json_name = "alignment"];
inline void Character::clear_alignment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alignment_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::dnd5e::api::v1alpha1::Alignment Character::alignment() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.alignment)
  return _internal_alignment();
}
inline void Character::set_alignment(::dnd5e::api::v1alpha1::Alignment value) {
  _internal_set_alignment(value);
  _impl_._has_bits_[0] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.alignment)
}
inline ::dnd5e::api::v1alpha1::Alignment Character::_internal_alignment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Alignment>(_impl_.alignment_);
}
inline void Character::_internal_set_alignment(::dnd5e::api::v1alpha1::Alignment value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alignment_ = value;
}

// .dnd5e.api.v1alpha1.AbilityScores ability_scores = 10 [json_name = "abilityScores"];
inline bool Character::has_ability_scores() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ability_scores_ != nullptr);
  return value;
}
inline void Character::clear_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ability_scores_ != nullptr) _impl_.ability_scores_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::dnd5e::api::v1alpha1::AbilityScores& Character::_internal_ability_scores() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::AbilityScores* p = _impl_.ability_scores_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::AbilityScores&>(::dnd5e::api::v1alpha1::_AbilityScores_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AbilityScores& Character::ability_scores() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.ability_scores)
  return _internal_ability_scores();
}
inline void Character::unsafe_arena_set_allocated_ability_scores(
    ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ability_scores_);
  }
  _impl_.ability_scores_ = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Character.ability_scores)
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE Character::release_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::dnd5e::api::v1alpha1::AbilityScores* released = _impl_.ability_scores_;
  _impl_.ability_scores_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE Character::unsafe_arena_release_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Character.ability_scores)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::dnd5e::api::v1alpha1::AbilityScores* temp = _impl_.ability_scores_;
  _impl_.ability_scores_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL Character::_internal_mutable_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ability_scores_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AbilityScores>(GetArena());
    _impl_.ability_scores_ = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(p);
  }
  return _impl_.ability_scores_;
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL Character::mutable_ability_scores()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::dnd5e::api::v1alpha1::AbilityScores* _msg = _internal_mutable_ability_scores();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Character.ability_scores)
  return _msg;
}
inline void Character::set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ability_scores_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.ability_scores_ = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Character.ability_scores)
}

// .dnd5e.api.v1alpha1.AbilityModifiers ability_modifiers = 11 [json_name = "abilityModifiers"];
inline bool Character::has_ability_modifiers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ability_modifiers_ != nullptr);
  return value;
}
inline void Character::clear_ability_modifiers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ability_modifiers_ != nullptr) _impl_.ability_modifiers_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::dnd5e::api::v1alpha1::AbilityModifiers& Character::_internal_ability_modifiers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::AbilityModifiers* p = _impl_.ability_modifiers_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::AbilityModifiers&>(::dnd5e::api::v1alpha1::_AbilityModifiers_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AbilityModifiers& Character::ability_modifiers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.ability_modifiers)
  return _internal_ability_modifiers();
}
inline void Character::unsafe_arena_set_allocated_ability_modifiers(
    ::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ability_modifiers_);
  }
  _impl_.ability_modifiers_ = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityModifiers*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Character.ability_modifiers)
}
inline ::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NULLABLE Character::release_ability_modifiers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::AbilityModifiers* released = _impl_.ability_modifiers_;
  _impl_.ability_modifiers_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NULLABLE Character::unsafe_arena_release_ability_modifiers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Character.ability_modifiers)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::AbilityModifiers* temp = _impl_.ability_modifiers_;
  _impl_.ability_modifiers_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NONNULL Character::_internal_mutable_ability_modifiers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ability_modifiers_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AbilityModifiers>(GetArena());
    _impl_.ability_modifiers_ = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityModifiers*>(p);
  }
  return _impl_.ability_modifiers_;
}
inline ::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NONNULL Character::mutable_ability_modifiers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::dnd5e::api::v1alpha1::AbilityModifiers* _msg = _internal_mutable_ability_modifiers();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Character.ability_modifiers)
  return _msg;
}
inline void Character::set_allocated_ability_modifiers(::dnd5e::api::v1alpha1::AbilityModifiers* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ability_modifiers_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.ability_modifiers_ = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityModifiers*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Character.ability_modifiers)
}

// .dnd5e.api.v1alpha1.CombatStats combat_stats = 12 [json_name = "combatStats"];
inline bool Character::has_combat_stats() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.combat_stats_ != nullptr);
  return value;
}
inline void Character::clear_combat_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_stats_ != nullptr) _impl_.combat_stats_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::dnd5e::api::v1alpha1::CombatStats& Character::_internal_combat_stats() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatStats* p = _impl_.combat_stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatStats&>(::dnd5e::api::v1alpha1::_CombatStats_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatStats& Character::combat_stats() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.combat_stats)
  return _internal_combat_stats();
}
inline void Character::unsafe_arena_set_allocated_combat_stats(
    ::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_stats_);
  }
  _impl_.combat_stats_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatStats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Character.combat_stats)
}
inline ::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NULLABLE Character::release_combat_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::dnd5e::api::v1alpha1::CombatStats* released = _impl_.combat_stats_;
  _impl_.combat_stats_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NULLABLE Character::unsafe_arena_release_combat_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Character.combat_stats)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::dnd5e::api::v1alpha1::CombatStats* temp = _impl_.combat_stats_;
  _impl_.combat_stats_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NONNULL Character::_internal_mutable_combat_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_stats_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatStats>(GetArena());
    _impl_.combat_stats_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatStats*>(p);
  }
  return _impl_.combat_stats_;
}
inline ::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NONNULL Character::mutable_combat_stats()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::dnd5e::api::v1alpha1::CombatStats* _msg = _internal_mutable_combat_stats();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Character.combat_stats)
  return _msg;
}
inline void Character::set_allocated_combat_stats(::dnd5e::api::v1alpha1::CombatStats* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_stats_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.combat_stats_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatStats*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Character.combat_stats)
}

// .dnd5e.api.v1alpha1.Proficiencies proficiencies = 13 [json_name = "proficiencies"];
inline bool Character::has_proficiencies() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proficiencies_ != nullptr);
  return value;
}
inline void Character::clear_proficiencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.proficiencies_ != nullptr) _impl_.proficiencies_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::dnd5e::api::v1alpha1::Proficiencies& Character::_internal_proficiencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Proficiencies* p = _impl_.proficiencies_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Proficiencies&>(::dnd5e::api::v1alpha1::_Proficiencies_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Proficiencies& Character::proficiencies() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.proficiencies)
  return _internal_proficiencies();
}
inline void Character::unsafe_arena_set_allocated_proficiencies(
    ::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proficiencies_);
  }
  _impl_.proficiencies_ = reinterpret_cast<::dnd5e::api::v1alpha1::Proficiencies*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Character.proficiencies)
}
inline ::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NULLABLE Character::release_proficiencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::dnd5e::api::v1alpha1::Proficiencies* released = _impl_.proficiencies_;
  _impl_.proficiencies_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NULLABLE Character::unsafe_arena_release_proficiencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Character.proficiencies)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::dnd5e::api::v1alpha1::Proficiencies* temp = _impl_.proficiencies_;
  _impl_.proficiencies_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NONNULL Character::_internal_mutable_proficiencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.proficiencies_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Proficiencies>(GetArena());
    _impl_.proficiencies_ = reinterpret_cast<::dnd5e::api::v1alpha1::Proficiencies*>(p);
  }
  return _impl_.proficiencies_;
}
inline ::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NONNULL Character::mutable_proficiencies()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::dnd5e::api::v1alpha1::Proficiencies* _msg = _internal_mutable_proficiencies();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Character.proficiencies)
  return _msg;
}
inline void Character::set_allocated_proficiencies(::dnd5e::api::v1alpha1::Proficiencies* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proficiencies_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.proficiencies_ = reinterpret_cast<::dnd5e::api::v1alpha1::Proficiencies*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Character.proficiencies)
}

// repeated .dnd5e.api.v1alpha1.Language languages = 14 [json_name = "languages"];
inline int Character::_internal_languages_size() const {
  return _internal_languages().size();
}
inline int Character::languages_size() const {
  return _internal_languages_size();
}
inline void Character::clear_languages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.languages_.Clear();
}
inline ::dnd5e::api::v1alpha1::Language Character::languages(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.languages)
  return static_cast<::dnd5e::api::v1alpha1::Language>(_internal_languages().Get(index));
}
inline void Character::set_languages(int index, ::dnd5e::api::v1alpha1::Language value) {
  _internal_mutable_languages()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.languages)
}
inline void Character::add_languages(::dnd5e::api::v1alpha1::Language value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_languages()->Add(value);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.Character.languages)
}
inline const ::google::protobuf::RepeatedField<int>& Character::languages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.Character.languages)
  return _internal_languages();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL Character::mutable_languages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.Character.languages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_languages();
}
inline const ::google::protobuf::RepeatedField<int>& Character::_internal_languages()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.languages_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
Character::_internal_mutable_languages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.languages_;
}

// int32 current_hit_points = 15 [json_name = "currentHitPoints"];
inline void Character::clear_current_hit_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_hit_points_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::int32_t Character::current_hit_points() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.current_hit_points)
  return _internal_current_hit_points();
}
inline void Character::set_current_hit_points(::int32_t value) {
  _internal_set_current_hit_points(value);
  _impl_._has_bits_[0] |= 0x00020000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.current_hit_points)
}
inline ::int32_t Character::_internal_current_hit_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_hit_points_;
}
inline void Character::_internal_set_current_hit_points(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_hit_points_ = value;
}

// int32 temporary_hit_points = 16 [json_name = "temporaryHitPoints"];
inline void Character::clear_temporary_hit_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.temporary_hit_points_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::int32_t Character::temporary_hit_points() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.temporary_hit_points)
  return _internal_temporary_hit_points();
}
inline void Character::set_temporary_hit_points(::int32_t value) {
  _internal_set_temporary_hit_points(value);
  _impl_._has_bits_[0] |= 0x00040000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.temporary_hit_points)
}
inline ::int32_t Character::_internal_temporary_hit_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.temporary_hit_points_;
}
inline void Character::_internal_set_temporary_hit_points(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.temporary_hit_points_ = value;
}

// string session_id = 17 [json_name = "sessionId"];
inline void Character::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& Character::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Character::set_session_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Character.session_id)
}
inline ::std::string* PROTOBUF_NONNULL Character::mutable_session_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Character.session_id)
  return _s;
}
inline const ::std::string& Character::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void Character::_internal_set_session_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Character::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.session_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Character::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Character.session_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.session_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.session_id_.Set("", GetArena());
  }
  return released;
}
inline void Character::set_allocated_session_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.session_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Character.session_id)
}

// .dnd5e.api.v1alpha1.CharacterMetadata metadata = 18 [json_name = "metadata"];
inline bool Character::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline void Character::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::dnd5e::api::v1alpha1::CharacterMetadata& Character::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterMetadata&>(::dnd5e::api::v1alpha1::_CharacterMetadata_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterMetadata& Character::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.metadata)
  return _internal_metadata();
}
inline void Character::unsafe_arena_set_allocated_metadata(
    ::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Character.metadata)
}
inline ::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NULLABLE Character::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::dnd5e::api::v1alpha1::CharacterMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NULLABLE Character::unsafe_arena_release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Character.metadata)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::dnd5e::api::v1alpha1::CharacterMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NONNULL Character::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NONNULL Character::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::dnd5e::api::v1alpha1::CharacterMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Character.metadata)
  return _msg;
}
inline void Character::set_allocated_metadata(::dnd5e::api::v1alpha1::CharacterMetadata* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.metadata_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Character.metadata)
}

// .dnd5e.api.v1alpha1.EquipmentSlots equipment_slots = 19 [json_name = "equipmentSlots"];
inline bool Character::has_equipment_slots() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.equipment_slots_ != nullptr);
  return value;
}
inline void Character::clear_equipment_slots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.equipment_slots_ != nullptr) _impl_.equipment_slots_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::dnd5e::api::v1alpha1::EquipmentSlots& Character::_internal_equipment_slots() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::EquipmentSlots* p = _impl_.equipment_slots_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::EquipmentSlots&>(::dnd5e::api::v1alpha1::_EquipmentSlots_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::EquipmentSlots& Character::equipment_slots() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.equipment_slots)
  return _internal_equipment_slots();
}
inline void Character::unsafe_arena_set_allocated_equipment_slots(
    ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.equipment_slots_);
  }
  _impl_.equipment_slots_ = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSlots*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Character.equipment_slots)
}
inline ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE Character::release_equipment_slots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::dnd5e::api::v1alpha1::EquipmentSlots* released = _impl_.equipment_slots_;
  _impl_.equipment_slots_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE Character::unsafe_arena_release_equipment_slots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Character.equipment_slots)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::dnd5e::api::v1alpha1::EquipmentSlots* temp = _impl_.equipment_slots_;
  _impl_.equipment_slots_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NONNULL Character::_internal_mutable_equipment_slots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.equipment_slots_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::EquipmentSlots>(GetArena());
    _impl_.equipment_slots_ = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSlots*>(p);
  }
  return _impl_.equipment_slots_;
}
inline ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NONNULL Character::mutable_equipment_slots()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::dnd5e::api::v1alpha1::EquipmentSlots* _msg = _internal_mutable_equipment_slots();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Character.equipment_slots)
  return _msg;
}
inline void Character::set_allocated_equipment_slots(::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.equipment_slots_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.equipment_slots_ = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSlots*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Character.equipment_slots)
}

// repeated .dnd5e.api.v1alpha1.InventoryItem inventory = 20 [json_name = "inventory"];
inline int Character::_internal_inventory_size() const {
  return _internal_inventory().size();
}
inline int Character::inventory_size() const {
  return _internal_inventory_size();
}
inline void Character::clear_inventory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inventory_.Clear();
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL Character::mutable_inventory(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Character.inventory)
  return _internal_mutable_inventory()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>* PROTOBUF_NONNULL Character::mutable_inventory()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.Character.inventory)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inventory();
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& Character::inventory(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.inventory)
  return _internal_inventory().Get(index);
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL Character::add_inventory()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::InventoryItem* _add = _internal_mutable_inventory()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.Character.inventory)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>& Character::inventory() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.Character.inventory)
  return _internal_inventory();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>&
Character::_internal_inventory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inventory_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>* PROTOBUF_NONNULL
Character::_internal_mutable_inventory() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inventory_;
}

// .dnd5e.api.v1alpha1.EncumbranceInfo encumbrance = 21 [json_name = "encumbrance"];
inline bool Character::has_encumbrance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.encumbrance_ != nullptr);
  return value;
}
inline void Character::clear_encumbrance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.encumbrance_ != nullptr) _impl_.encumbrance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::dnd5e::api::v1alpha1::EncumbranceInfo& Character::_internal_encumbrance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::EncumbranceInfo* p = _impl_.encumbrance_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::EncumbranceInfo&>(::dnd5e::api::v1alpha1::_EncumbranceInfo_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::EncumbranceInfo& Character::encumbrance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Character.encumbrance)
  return _internal_encumbrance();
}
inline void Character::unsafe_arena_set_allocated_encumbrance(
    ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.encumbrance_);
  }
  _impl_.encumbrance_ = reinterpret_cast<::dnd5e::api::v1alpha1::EncumbranceInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Character.encumbrance)
}
inline ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE Character::release_encumbrance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::dnd5e::api::v1alpha1::EncumbranceInfo* released = _impl_.encumbrance_;
  _impl_.encumbrance_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE Character::unsafe_arena_release_encumbrance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Character.encumbrance)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::dnd5e::api::v1alpha1::EncumbranceInfo* temp = _impl_.encumbrance_;
  _impl_.encumbrance_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NONNULL Character::_internal_mutable_encumbrance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.encumbrance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::EncumbranceInfo>(GetArena());
    _impl_.encumbrance_ = reinterpret_cast<::dnd5e::api::v1alpha1::EncumbranceInfo*>(p);
  }
  return _impl_.encumbrance_;
}
inline ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NONNULL Character::mutable_encumbrance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::dnd5e::api::v1alpha1::EncumbranceInfo* _msg = _internal_mutable_encumbrance();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Character.encumbrance)
  return _msg;
}
inline void Character::set_allocated_encumbrance(::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.encumbrance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.encumbrance_ = reinterpret_cast<::dnd5e::api::v1alpha1::EncumbranceInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Character.encumbrance)
}

// -------------------------------------------------------------------

// AbilityModifiers

// int32 strength = 1 [json_name = "strength"];
inline void AbilityModifiers::clear_strength() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strength_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AbilityModifiers::strength() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityModifiers.strength)
  return _internal_strength();
}
inline void AbilityModifiers::set_strength(::int32_t value) {
  _internal_set_strength(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityModifiers.strength)
}
inline ::int32_t AbilityModifiers::_internal_strength() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strength_;
}
inline void AbilityModifiers::_internal_set_strength(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strength_ = value;
}

// int32 dexterity = 2 [json_name = "dexterity"];
inline void AbilityModifiers::clear_dexterity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dexterity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AbilityModifiers::dexterity() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityModifiers.dexterity)
  return _internal_dexterity();
}
inline void AbilityModifiers::set_dexterity(::int32_t value) {
  _internal_set_dexterity(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityModifiers.dexterity)
}
inline ::int32_t AbilityModifiers::_internal_dexterity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dexterity_;
}
inline void AbilityModifiers::_internal_set_dexterity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dexterity_ = value;
}

// int32 constitution = 3 [json_name = "constitution"];
inline void AbilityModifiers::clear_constitution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constitution_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t AbilityModifiers::constitution() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityModifiers.constitution)
  return _internal_constitution();
}
inline void AbilityModifiers::set_constitution(::int32_t value) {
  _internal_set_constitution(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityModifiers.constitution)
}
inline ::int32_t AbilityModifiers::_internal_constitution() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.constitution_;
}
inline void AbilityModifiers::_internal_set_constitution(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constitution_ = value;
}

// int32 intelligence = 4 [json_name = "intelligence"];
inline void AbilityModifiers::clear_intelligence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.intelligence_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t AbilityModifiers::intelligence() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityModifiers.intelligence)
  return _internal_intelligence();
}
inline void AbilityModifiers::set_intelligence(::int32_t value) {
  _internal_set_intelligence(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityModifiers.intelligence)
}
inline ::int32_t AbilityModifiers::_internal_intelligence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.intelligence_;
}
inline void AbilityModifiers::_internal_set_intelligence(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.intelligence_ = value;
}

// int32 wisdom = 5 [json_name = "wisdom"];
inline void AbilityModifiers::clear_wisdom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wisdom_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t AbilityModifiers::wisdom() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityModifiers.wisdom)
  return _internal_wisdom();
}
inline void AbilityModifiers::set_wisdom(::int32_t value) {
  _internal_set_wisdom(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityModifiers.wisdom)
}
inline ::int32_t AbilityModifiers::_internal_wisdom() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wisdom_;
}
inline void AbilityModifiers::_internal_set_wisdom(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wisdom_ = value;
}

// int32 charisma = 6 [json_name = "charisma"];
inline void AbilityModifiers::clear_charisma() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.charisma_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t AbilityModifiers::charisma() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityModifiers.charisma)
  return _internal_charisma();
}
inline void AbilityModifiers::set_charisma(::int32_t value) {
  _internal_set_charisma(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityModifiers.charisma)
}
inline ::int32_t AbilityModifiers::_internal_charisma() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.charisma_;
}
inline void AbilityModifiers::_internal_set_charisma(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.charisma_ = value;
}

// -------------------------------------------------------------------

// CombatStats

// int32 hit_point_maximum = 1 [json_name = "hitPointMaximum"];
inline void CombatStats::clear_hit_point_maximum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hit_point_maximum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t CombatStats::hit_point_maximum() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStats.hit_point_maximum)
  return _internal_hit_point_maximum();
}
inline void CombatStats::set_hit_point_maximum(::int32_t value) {
  _internal_set_hit_point_maximum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatStats.hit_point_maximum)
}
inline ::int32_t CombatStats::_internal_hit_point_maximum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hit_point_maximum_;
}
inline void CombatStats::_internal_set_hit_point_maximum(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hit_point_maximum_ = value;
}

// int32 armor_class = 2 [json_name = "armorClass"];
inline void CombatStats::clear_armor_class() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.armor_class_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CombatStats::armor_class() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStats.armor_class)
  return _internal_armor_class();
}
inline void CombatStats::set_armor_class(::int32_t value) {
  _internal_set_armor_class(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatStats.armor_class)
}
inline ::int32_t CombatStats::_internal_armor_class() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.armor_class_;
}
inline void CombatStats::_internal_set_armor_class(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.armor_class_ = value;
}

// int32 initiative = 3 [json_name = "initiative"];
inline void CombatStats::clear_initiative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiative_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t CombatStats::initiative() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStats.initiative)
  return _internal_initiative();
}
inline void CombatStats::set_initiative(::int32_t value) {
  _internal_set_initiative(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatStats.initiative)
}
inline ::int32_t CombatStats::_internal_initiative() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initiative_;
}
inline void CombatStats::_internal_set_initiative(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiative_ = value;
}

// int32 speed = 4 [json_name = "speed"];
inline void CombatStats::clear_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t CombatStats::speed() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStats.speed)
  return _internal_speed();
}
inline void CombatStats::set_speed(::int32_t value) {
  _internal_set_speed(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatStats.speed)
}
inline ::int32_t CombatStats::_internal_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_;
}
inline void CombatStats::_internal_set_speed(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = value;
}

// int32 proficiency_bonus = 5 [json_name = "proficiencyBonus"];
inline void CombatStats::clear_proficiency_bonus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proficiency_bonus_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t CombatStats::proficiency_bonus() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStats.proficiency_bonus)
  return _internal_proficiency_bonus();
}
inline void CombatStats::set_proficiency_bonus(::int32_t value) {
  _internal_set_proficiency_bonus(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatStats.proficiency_bonus)
}
inline ::int32_t CombatStats::_internal_proficiency_bonus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.proficiency_bonus_;
}
inline void CombatStats::_internal_set_proficiency_bonus(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proficiency_bonus_ = value;
}

// string hit_dice = 6 [json_name = "hitDice"];
inline void CombatStats::clear_hit_dice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hit_dice_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CombatStats::hit_dice() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStats.hit_dice)
  return _internal_hit_dice();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CombatStats::set_hit_dice(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hit_dice_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatStats.hit_dice)
}
inline ::std::string* PROTOBUF_NONNULL CombatStats::mutable_hit_dice()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_hit_dice();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatStats.hit_dice)
  return _s;
}
inline const ::std::string& CombatStats::_internal_hit_dice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hit_dice_.Get();
}
inline void CombatStats::_internal_set_hit_dice(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hit_dice_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CombatStats::_internal_mutable_hit_dice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hit_dice_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CombatStats::release_hit_dice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatStats.hit_dice)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.hit_dice_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.hit_dice_.Set("", GetArena());
  }
  return released;
}
inline void CombatStats::set_allocated_hit_dice(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hit_dice_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hit_dice_.IsDefault()) {
    _impl_.hit_dice_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatStats.hit_dice)
}

// -------------------------------------------------------------------

// Proficiencies

// repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
inline int Proficiencies::_internal_skills_size() const {
  return _internal_skills().size();
}
inline int Proficiencies::skills_size() const {
  return _internal_skills_size();
}
inline void Proficiencies::clear_skills() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skills_.Clear();
}
inline ::dnd5e::api::v1alpha1::Skill Proficiencies::skills(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Proficiencies.skills)
  return static_cast<::dnd5e::api::v1alpha1::Skill>(_internal_skills().Get(index));
}
inline void Proficiencies::set_skills(int index, ::dnd5e::api::v1alpha1::Skill value) {
  _internal_mutable_skills()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Proficiencies.skills)
}
inline void Proficiencies::add_skills(::dnd5e::api::v1alpha1::Skill value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_skills()->Add(value);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.Proficiencies.skills)
}
inline const ::google::protobuf::RepeatedField<int>& Proficiencies::skills() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.Proficiencies.skills)
  return _internal_skills();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL Proficiencies::mutable_skills()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.Proficiencies.skills)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_skills();
}
inline const ::google::protobuf::RepeatedField<int>& Proficiencies::_internal_skills()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skills_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
Proficiencies::_internal_mutable_skills() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.skills_;
}

// repeated .dnd5e.api.v1alpha1.Ability saving_throws = 2 [json_name = "savingThrows"];
inline int Proficiencies::_internal_saving_throws_size() const {
  return _internal_saving_throws().size();
}
inline int Proficiencies::saving_throws_size() const {
  return _internal_saving_throws_size();
}
inline void Proficiencies::clear_saving_throws() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.saving_throws_.Clear();
}
inline ::dnd5e::api::v1alpha1::Ability Proficiencies::saving_throws(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Proficiencies.saving_throws)
  return static_cast<::dnd5e::api::v1alpha1::Ability>(_internal_saving_throws().Get(index));
}
inline void Proficiencies::set_saving_throws(int index, ::dnd5e::api::v1alpha1::Ability value) {
  _internal_mutable_saving_throws()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Proficiencies.saving_throws)
}
inline void Proficiencies::add_saving_throws(::dnd5e::api::v1alpha1::Ability value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_saving_throws()->Add(value);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.Proficiencies.saving_throws)
}
inline const ::google::protobuf::RepeatedField<int>& Proficiencies::saving_throws() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.Proficiencies.saving_throws)
  return _internal_saving_throws();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL Proficiencies::mutable_saving_throws()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.Proficiencies.saving_throws)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_saving_throws();
}
inline const ::google::protobuf::RepeatedField<int>& Proficiencies::_internal_saving_throws()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.saving_throws_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
Proficiencies::_internal_mutable_saving_throws() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.saving_throws_;
}

// repeated string armor = 3 [json_name = "armor"];
inline int Proficiencies::_internal_armor_size() const {
  return _internal_armor().size();
}
inline int Proficiencies::armor_size() const {
  return _internal_armor_size();
}
inline void Proficiencies::clear_armor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.armor_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL Proficiencies::add_armor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_armor()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.Proficiencies.armor)
  return _s;
}
inline const ::std::string& Proficiencies::armor(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Proficiencies.armor)
  return _internal_armor().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL Proficiencies::mutable_armor(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Proficiencies.armor)
  return _internal_mutable_armor()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Proficiencies::set_armor(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_armor()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Proficiencies.armor)
}
template <typename Arg_, typename... Args_>
inline void Proficiencies::add_armor(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_armor(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.Proficiencies.armor)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& Proficiencies::armor()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.Proficiencies.armor)
  return _internal_armor();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
Proficiencies::mutable_armor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.Proficiencies.armor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_armor();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Proficiencies::_internal_armor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.armor_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
Proficiencies::_internal_mutable_armor() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.armor_;
}

// repeated string weapons = 4 [json_name = "weapons"];
inline int Proficiencies::_internal_weapons_size() const {
  return _internal_weapons().size();
}
inline int Proficiencies::weapons_size() const {
  return _internal_weapons_size();
}
inline void Proficiencies::clear_weapons() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapons_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL Proficiencies::add_weapons()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_weapons()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.Proficiencies.weapons)
  return _s;
}
inline const ::std::string& Proficiencies::weapons(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Proficiencies.weapons)
  return _internal_weapons().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL Proficiencies::mutable_weapons(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Proficiencies.weapons)
  return _internal_mutable_weapons()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Proficiencies::set_weapons(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_weapons()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Proficiencies.weapons)
}
template <typename Arg_, typename... Args_>
inline void Proficiencies::add_weapons(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_weapons(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.Proficiencies.weapons)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& Proficiencies::weapons()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.Proficiencies.weapons)
  return _internal_weapons();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
Proficiencies::mutable_weapons() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.Proficiencies.weapons)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_weapons();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Proficiencies::_internal_weapons() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.weapons_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
Proficiencies::_internal_mutable_weapons() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.weapons_;
}

// repeated string tools = 5 [json_name = "tools"];
inline int Proficiencies::_internal_tools_size() const {
  return _internal_tools().size();
}
inline int Proficiencies::tools_size() const {
  return _internal_tools_size();
}
inline void Proficiencies::clear_tools() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tools_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL Proficiencies::add_tools()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_tools()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.Proficiencies.tools)
  return _s;
}
inline const ::std::string& Proficiencies::tools(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Proficiencies.tools)
  return _internal_tools().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL Proficiencies::mutable_tools(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Proficiencies.tools)
  return _internal_mutable_tools()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Proficiencies::set_tools(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_tools()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Proficiencies.tools)
}
template <typename Arg_, typename... Args_>
inline void Proficiencies::add_tools(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_tools(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.Proficiencies.tools)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& Proficiencies::tools()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.Proficiencies.tools)
  return _internal_tools();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
Proficiencies::mutable_tools() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.Proficiencies.tools)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tools();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Proficiencies::_internal_tools() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tools_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
Proficiencies::_internal_mutable_tools() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tools_;
}

// -------------------------------------------------------------------

// CharacterMetadata

// int64 created_at = 1 [json_name = "createdAt"];
inline void CharacterMetadata::clear_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t CharacterMetadata::created_at() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterMetadata.created_at)
  return _internal_created_at();
}
inline void CharacterMetadata::set_created_at(::int64_t value) {
  _internal_set_created_at(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterMetadata.created_at)
}
inline ::int64_t CharacterMetadata::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_at_;
}
inline void CharacterMetadata::_internal_set_created_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_ = value;
}

// int64 updated_at = 2 [json_name = "updatedAt"];
inline void CharacterMetadata::clear_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t CharacterMetadata::updated_at() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterMetadata.updated_at)
  return _internal_updated_at();
}
inline void CharacterMetadata::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterMetadata.updated_at)
}
inline ::int64_t CharacterMetadata::_internal_updated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_at_;
}
inline void CharacterMetadata::_internal_set_updated_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = value;
}

// string player_id = 3 [json_name = "playerId"];
inline void CharacterMetadata::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CharacterMetadata::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterMetadata.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CharacterMetadata::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterMetadata.player_id)
}
inline ::std::string* PROTOBUF_NONNULL CharacterMetadata::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterMetadata.player_id)
  return _s;
}
inline const ::std::string& CharacterMetadata::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void CharacterMetadata::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CharacterMetadata::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CharacterMetadata::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterMetadata.player_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void CharacterMetadata::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterMetadata.player_id)
}

// -------------------------------------------------------------------

// GetCharacterRequest

// string character_id = 1 [json_name = "characterId"];
inline void GetCharacterRequest::clear_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetCharacterRequest::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCharacterRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetCharacterRequest::set_character_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetCharacterRequest.character_id)
}
inline ::std::string* PROTOBUF_NONNULL GetCharacterRequest::mutable_character_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCharacterRequest.character_id)
  return _s;
}
inline const ::std::string& GetCharacterRequest::_internal_character_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_id_.Get();
}
inline void GetCharacterRequest::_internal_set_character_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetCharacterRequest::_internal_mutable_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.character_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetCharacterRequest::release_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCharacterRequest.character_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.character_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.character_id_.Set("", GetArena());
  }
  return released;
}
inline void GetCharacterRequest::set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.character_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCharacterRequest.character_id)
}

// -------------------------------------------------------------------

// GetCharacterResponse

// .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
inline bool GetCharacterResponse::has_character() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.character_ != nullptr);
  return value;
}
inline void GetCharacterResponse::clear_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ != nullptr) _impl_.character_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::Character& GetCharacterResponse::_internal_character() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.character_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& GetCharacterResponse::character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCharacterResponse.character)
  return _internal_character();
}
inline void GetCharacterResponse::unsafe_arena_set_allocated_character(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }
  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetCharacterResponse.character)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE GetCharacterResponse::release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* released = _impl_.character_;
  _impl_.character_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE GetCharacterResponse::unsafe_arena_release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCharacterResponse.character)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.character_;
  _impl_.character_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL GetCharacterResponse::_internal_mutable_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.character_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL GetCharacterResponse::mutable_character()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCharacterResponse.character)
  return _msg;
}
inline void GetCharacterResponse::set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCharacterResponse.character)
}

// -------------------------------------------------------------------

// ListCharactersRequest

// int32 page_size = 1 [json_name = "pageSize"];
inline void ListCharactersRequest::clear_page_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t ListCharactersRequest::page_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListCharactersRequest.page_size)
  return _internal_page_size();
}
inline void ListCharactersRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListCharactersRequest.page_size)
}
inline ::int32_t ListCharactersRequest::_internal_page_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_size_;
}
inline void ListCharactersRequest::_internal_set_page_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = value;
}

// string page_token = 2 [json_name = "pageToken"];
inline void ListCharactersRequest::clear_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListCharactersRequest::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListCharactersRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListCharactersRequest::set_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListCharactersRequest.page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListCharactersRequest::mutable_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListCharactersRequest.page_token)
  return _s;
}
inline const ::std::string& ListCharactersRequest::_internal_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_token_.Get();
}
inline void ListCharactersRequest::_internal_set_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListCharactersRequest::_internal_mutable_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListCharactersRequest::release_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListCharactersRequest.page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListCharactersRequest::set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListCharactersRequest.page_token)
}

// string session_id = 3 [json_name = "sessionId"];
inline void ListCharactersRequest::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& ListCharactersRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListCharactersRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListCharactersRequest::set_session_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListCharactersRequest.session_id)
}
inline ::std::string* PROTOBUF_NONNULL ListCharactersRequest::mutable_session_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListCharactersRequest.session_id)
  return _s;
}
inline const ::std::string& ListCharactersRequest::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void ListCharactersRequest::_internal_set_session_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListCharactersRequest::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.session_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListCharactersRequest::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListCharactersRequest.session_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.session_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.session_id_.Set("", GetArena());
  }
  return released;
}
inline void ListCharactersRequest::set_allocated_session_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.session_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListCharactersRequest.session_id)
}

// string player_id = 4 [json_name = "playerId"];
inline void ListCharactersRequest::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& ListCharactersRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListCharactersRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListCharactersRequest::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListCharactersRequest.player_id)
}
inline ::std::string* PROTOBUF_NONNULL ListCharactersRequest::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListCharactersRequest.player_id)
  return _s;
}
inline const ::std::string& ListCharactersRequest::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void ListCharactersRequest::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListCharactersRequest::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListCharactersRequest::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListCharactersRequest.player_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void ListCharactersRequest::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListCharactersRequest.player_id)
}

// -------------------------------------------------------------------

// ListCharactersResponse

// repeated .dnd5e.api.v1alpha1.Character characters = 1 [json_name = "characters"];
inline int ListCharactersResponse::_internal_characters_size() const {
  return _internal_characters().size();
}
inline int ListCharactersResponse::characters_size() const {
  return _internal_characters_size();
}
inline void ListCharactersResponse::clear_characters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.characters_.Clear();
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL ListCharactersResponse::mutable_characters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListCharactersResponse.characters)
  return _internal_mutable_characters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>* PROTOBUF_NONNULL ListCharactersResponse::mutable_characters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ListCharactersResponse.characters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_characters();
}
inline const ::dnd5e::api::v1alpha1::Character& ListCharactersResponse::characters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListCharactersResponse.characters)
  return _internal_characters().Get(index);
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL ListCharactersResponse::add_characters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::Character* _add = _internal_mutable_characters()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ListCharactersResponse.characters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>& ListCharactersResponse::characters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ListCharactersResponse.characters)
  return _internal_characters();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>&
ListCharactersResponse::_internal_characters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.characters_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>* PROTOBUF_NONNULL
ListCharactersResponse::_internal_mutable_characters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.characters_;
}

// string next_page_token = 2 [json_name = "nextPageToken"];
inline void ListCharactersResponse::clear_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListCharactersResponse::next_page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListCharactersResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListCharactersResponse::set_next_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListCharactersResponse.next_page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListCharactersResponse::mutable_next_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListCharactersResponse.next_page_token)
  return _s;
}
inline const ::std::string& ListCharactersResponse::_internal_next_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_page_token_.Get();
}
inline void ListCharactersResponse::_internal_set_next_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListCharactersResponse::_internal_mutable_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.next_page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListCharactersResponse::release_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListCharactersResponse.next_page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.next_page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListCharactersResponse::set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.next_page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListCharactersResponse.next_page_token)
}

// int32 total_size = 3 [json_name = "totalSize"];
inline void ListCharactersResponse::clear_total_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ListCharactersResponse::total_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListCharactersResponse.total_size)
  return _internal_total_size();
}
inline void ListCharactersResponse::set_total_size(::int32_t value) {
  _internal_set_total_size(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListCharactersResponse.total_size)
}
inline ::int32_t ListCharactersResponse::_internal_total_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_size_;
}
inline void ListCharactersResponse::_internal_set_total_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = value;
}

// -------------------------------------------------------------------

// UpdateCharacterRequest

// .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
inline bool UpdateCharacterRequest::has_character() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.character_ != nullptr);
  return value;
}
inline void UpdateCharacterRequest::clear_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ != nullptr) _impl_.character_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::Character& UpdateCharacterRequest::_internal_character() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.character_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& UpdateCharacterRequest::character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateCharacterRequest.character)
  return _internal_character();
}
inline void UpdateCharacterRequest::unsafe_arena_set_allocated_character(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }
  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UpdateCharacterRequest.character)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE UpdateCharacterRequest::release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* released = _impl_.character_;
  _impl_.character_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE UpdateCharacterRequest::unsafe_arena_release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateCharacterRequest.character)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.character_;
  _impl_.character_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL UpdateCharacterRequest::_internal_mutable_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.character_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL UpdateCharacterRequest::mutable_character()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateCharacterRequest.character)
  return _msg;
}
inline void UpdateCharacterRequest::set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateCharacterRequest.character)
}

// repeated string update_mask = 2 [json_name = "updateMask"];
inline int UpdateCharacterRequest::_internal_update_mask_size() const {
  return _internal_update_mask().size();
}
inline int UpdateCharacterRequest::update_mask_size() const {
  return _internal_update_mask_size();
}
inline void UpdateCharacterRequest::clear_update_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.update_mask_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL UpdateCharacterRequest::add_update_mask()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_update_mask()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.UpdateCharacterRequest.update_mask)
  return _s;
}
inline const ::std::string& UpdateCharacterRequest::update_mask(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateCharacterRequest.update_mask)
  return _internal_update_mask().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL UpdateCharacterRequest::mutable_update_mask(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateCharacterRequest.update_mask)
  return _internal_mutable_update_mask()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void UpdateCharacterRequest::set_update_mask(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_update_mask()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateCharacterRequest.update_mask)
}
template <typename Arg_, typename... Args_>
inline void UpdateCharacterRequest::add_update_mask(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_update_mask(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateCharacterRequest.update_mask)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& UpdateCharacterRequest::update_mask()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateCharacterRequest.update_mask)
  return _internal_update_mask();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
UpdateCharacterRequest::mutable_update_mask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateCharacterRequest.update_mask)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_update_mask();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
UpdateCharacterRequest::_internal_update_mask() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.update_mask_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
UpdateCharacterRequest::_internal_mutable_update_mask() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.update_mask_;
}

// -------------------------------------------------------------------

// UpdateCharacterResponse

// .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
inline bool UpdateCharacterResponse::has_character() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.character_ != nullptr);
  return value;
}
inline void UpdateCharacterResponse::clear_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ != nullptr) _impl_.character_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::Character& UpdateCharacterResponse::_internal_character() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.character_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& UpdateCharacterResponse::character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateCharacterResponse.character)
  return _internal_character();
}
inline void UpdateCharacterResponse::unsafe_arena_set_allocated_character(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }
  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UpdateCharacterResponse.character)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE UpdateCharacterResponse::release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* released = _impl_.character_;
  _impl_.character_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE UpdateCharacterResponse::unsafe_arena_release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateCharacterResponse.character)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.character_;
  _impl_.character_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL UpdateCharacterResponse::_internal_mutable_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.character_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL UpdateCharacterResponse::mutable_character()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateCharacterResponse.character)
  return _msg;
}
inline void UpdateCharacterResponse::set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateCharacterResponse.character)
}

// -------------------------------------------------------------------

// DeleteCharacterRequest

// string character_id = 1 [json_name = "characterId"];
inline void DeleteCharacterRequest::clear_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DeleteCharacterRequest::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DeleteCharacterRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeleteCharacterRequest::set_character_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DeleteCharacterRequest.character_id)
}
inline ::std::string* PROTOBUF_NONNULL DeleteCharacterRequest::mutable_character_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DeleteCharacterRequest.character_id)
  return _s;
}
inline const ::std::string& DeleteCharacterRequest::_internal_character_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_id_.Get();
}
inline void DeleteCharacterRequest::_internal_set_character_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DeleteCharacterRequest::_internal_mutable_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.character_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DeleteCharacterRequest::release_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DeleteCharacterRequest.character_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.character_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.character_id_.Set("", GetArena());
  }
  return released;
}
inline void DeleteCharacterRequest::set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.character_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DeleteCharacterRequest.character_id)
}

// -------------------------------------------------------------------

// DeleteCharacterResponse

// string message = 1 [json_name = "message"];
inline void DeleteCharacterResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DeleteCharacterResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DeleteCharacterResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeleteCharacterResponse::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DeleteCharacterResponse.message)
}
inline ::std::string* PROTOBUF_NONNULL DeleteCharacterResponse::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DeleteCharacterResponse.message)
  return _s;
}
inline const ::std::string& DeleteCharacterResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void DeleteCharacterResponse::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DeleteCharacterResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DeleteCharacterResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DeleteCharacterResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void DeleteCharacterResponse::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DeleteCharacterResponse.message)
}

// -------------------------------------------------------------------

// CharacterDraftData

// string id = 1 [json_name = "id"];
inline void CharacterDraftData::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CharacterDraftData::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CharacterDraftData::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraftData.id)
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraftData::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraftData.id)
  return _s;
}
inline const ::std::string& CharacterDraftData::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void CharacterDraftData::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraftData::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CharacterDraftData::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraftData.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void CharacterDraftData::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraftData.id)
}

// string player_id = 2 [json_name = "playerId"];
inline void CharacterDraftData::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CharacterDraftData::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CharacterDraftData::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraftData.player_id)
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraftData::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraftData.player_id)
  return _s;
}
inline const ::std::string& CharacterDraftData::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void CharacterDraftData::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraftData::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CharacterDraftData::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraftData.player_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void CharacterDraftData::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraftData.player_id)
}

// string session_id = 3 [json_name = "sessionId"];
inline void CharacterDraftData::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CharacterDraftData::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CharacterDraftData::set_session_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraftData.session_id)
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraftData::mutable_session_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraftData.session_id)
  return _s;
}
inline const ::std::string& CharacterDraftData::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void CharacterDraftData::_internal_set_session_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraftData::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.session_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CharacterDraftData::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraftData.session_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.session_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.session_id_.Set("", GetArena());
  }
  return released;
}
inline void CharacterDraftData::set_allocated_session_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.session_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraftData.session_id)
}

// string name = 4 [json_name = "name"];
inline void CharacterDraftData::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& CharacterDraftData::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CharacterDraftData::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraftData.name)
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraftData::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraftData.name)
  return _s;
}
inline const ::std::string& CharacterDraftData::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void CharacterDraftData::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraftData::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CharacterDraftData::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraftData.name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void CharacterDraftData::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraftData.name)
}

// .dnd5e.api.v1alpha1.Race race = 5 [json_name = "race"];
inline void CharacterDraftData::clear_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.race_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::dnd5e::api::v1alpha1::Race CharacterDraftData::race() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.race)
  return _internal_race();
}
inline void CharacterDraftData::set_race(::dnd5e::api::v1alpha1::Race value) {
  _internal_set_race(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraftData.race)
}
inline ::dnd5e::api::v1alpha1::Race CharacterDraftData::_internal_race() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Race>(_impl_.race_);
}
inline void CharacterDraftData::_internal_set_race(::dnd5e::api::v1alpha1::Race value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.race_ = value;
}

// .dnd5e.api.v1alpha1.Subrace subrace = 6 [json_name = "subrace"];
inline void CharacterDraftData::clear_subrace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subrace_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::dnd5e::api::v1alpha1::Subrace CharacterDraftData::subrace() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.subrace)
  return _internal_subrace();
}
inline void CharacterDraftData::set_subrace(::dnd5e::api::v1alpha1::Subrace value) {
  _internal_set_subrace(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraftData.subrace)
}
inline ::dnd5e::api::v1alpha1::Subrace CharacterDraftData::_internal_subrace() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Subrace>(_impl_.subrace_);
}
inline void CharacterDraftData::_internal_set_subrace(::dnd5e::api::v1alpha1::Subrace value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subrace_ = value;
}

// .dnd5e.api.v1alpha1.Class class = 7 [json_name = "class"];
inline void CharacterDraftData::clear_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class__ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::dnd5e::api::v1alpha1::Class CharacterDraftData::class_() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.class)
  return _internal_class_();
}
inline void CharacterDraftData::set_class_(::dnd5e::api::v1alpha1::Class value) {
  _internal_set_class_(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraftData.class)
}
inline ::dnd5e::api::v1alpha1::Class CharacterDraftData::_internal_class_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Class>(_impl_.class__);
}
inline void CharacterDraftData::_internal_set_class_(::dnd5e::api::v1alpha1::Class value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class__ = value;
}

// .dnd5e.api.v1alpha1.Background background = 8 [json_name = "background"];
inline void CharacterDraftData::clear_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.background_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::dnd5e::api::v1alpha1::Background CharacterDraftData::background() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.background)
  return _internal_background();
}
inline void CharacterDraftData::set_background(::dnd5e::api::v1alpha1::Background value) {
  _internal_set_background(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraftData.background)
}
inline ::dnd5e::api::v1alpha1::Background CharacterDraftData::_internal_background() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Background>(_impl_.background_);
}
inline void CharacterDraftData::_internal_set_background(::dnd5e::api::v1alpha1::Background value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.background_ = value;
}

// .dnd5e.api.v1alpha1.AbilityScores ability_scores = 9 [json_name = "abilityScores"];
inline bool CharacterDraftData::has_ability_scores() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ability_scores_ != nullptr);
  return value;
}
inline void CharacterDraftData::clear_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ability_scores_ != nullptr) _impl_.ability_scores_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::dnd5e::api::v1alpha1::AbilityScores& CharacterDraftData::_internal_ability_scores() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::AbilityScores* p = _impl_.ability_scores_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::AbilityScores&>(::dnd5e::api::v1alpha1::_AbilityScores_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AbilityScores& CharacterDraftData::ability_scores() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.ability_scores)
  return _internal_ability_scores();
}
inline void CharacterDraftData::unsafe_arena_set_allocated_ability_scores(
    ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ability_scores_);
  }
  _impl_.ability_scores_ = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CharacterDraftData.ability_scores)
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE CharacterDraftData::release_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::AbilityScores* released = _impl_.ability_scores_;
  _impl_.ability_scores_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE CharacterDraftData::unsafe_arena_release_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraftData.ability_scores)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::AbilityScores* temp = _impl_.ability_scores_;
  _impl_.ability_scores_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL CharacterDraftData::_internal_mutable_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ability_scores_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AbilityScores>(GetArena());
    _impl_.ability_scores_ = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(p);
  }
  return _impl_.ability_scores_;
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL CharacterDraftData::mutable_ability_scores()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::dnd5e::api::v1alpha1::AbilityScores* _msg = _internal_mutable_ability_scores();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraftData.ability_scores)
  return _msg;
}
inline void CharacterDraftData::set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ability_scores_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.ability_scores_ = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraftData.ability_scores)
}

// .dnd5e.api.v1alpha1.Alignment alignment = 10 [json_name = "alignment"];
inline void CharacterDraftData::clear_alignment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alignment_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::dnd5e::api::v1alpha1::Alignment CharacterDraftData::alignment() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.alignment)
  return _internal_alignment();
}
inline void CharacterDraftData::set_alignment(::dnd5e::api::v1alpha1::Alignment value) {
  _internal_set_alignment(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraftData.alignment)
}
inline ::dnd5e::api::v1alpha1::Alignment CharacterDraftData::_internal_alignment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Alignment>(_impl_.alignment_);
}
inline void CharacterDraftData::_internal_set_alignment(::dnd5e::api::v1alpha1::Alignment value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alignment_ = value;
}

// repeated .dnd5e.api.v1alpha1.ChoiceData choices = 11 [json_name = "choices"];
inline int CharacterDraftData::_internal_choices_size() const {
  return _internal_choices().size();
}
inline int CharacterDraftData::choices_size() const {
  return _internal_choices_size();
}
inline void CharacterDraftData::clear_choices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choices_.Clear();
}
inline ::dnd5e::api::v1alpha1::ChoiceData* PROTOBUF_NONNULL CharacterDraftData::mutable_choices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraftData.choices)
  return _internal_mutable_choices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>* PROTOBUF_NONNULL CharacterDraftData::mutable_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.CharacterDraftData.choices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_choices();
}
inline const ::dnd5e::api::v1alpha1::ChoiceData& CharacterDraftData::choices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.choices)
  return _internal_choices().Get(index);
}
inline ::dnd5e::api::v1alpha1::ChoiceData* PROTOBUF_NONNULL CharacterDraftData::add_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ChoiceData* _add = _internal_mutable_choices()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.CharacterDraftData.choices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>& CharacterDraftData::choices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.CharacterDraftData.choices)
  return _internal_choices();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>&
CharacterDraftData::_internal_choices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.choices_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>* PROTOBUF_NONNULL
CharacterDraftData::_internal_mutable_choices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.choices_;
}

// .dnd5e.api.v1alpha1.CreationProgress progress = 12 [json_name = "progress"];
inline bool CharacterDraftData::has_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.progress_ != nullptr);
  return value;
}
inline void CharacterDraftData::clear_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.progress_ != nullptr) _impl_.progress_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::dnd5e::api::v1alpha1::CreationProgress& CharacterDraftData::_internal_progress() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CreationProgress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CreationProgress&>(::dnd5e::api::v1alpha1::_CreationProgress_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CreationProgress& CharacterDraftData::progress() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.progress)
  return _internal_progress();
}
inline void CharacterDraftData::unsafe_arena_set_allocated_progress(
    ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = reinterpret_cast<::dnd5e::api::v1alpha1::CreationProgress*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CharacterDraftData.progress)
}
inline ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE CharacterDraftData::release_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::dnd5e::api::v1alpha1::CreationProgress* released = _impl_.progress_;
  _impl_.progress_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE CharacterDraftData::unsafe_arena_release_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraftData.progress)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::dnd5e::api::v1alpha1::CreationProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NONNULL CharacterDraftData::_internal_mutable_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.progress_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CreationProgress>(GetArena());
    _impl_.progress_ = reinterpret_cast<::dnd5e::api::v1alpha1::CreationProgress*>(p);
  }
  return _impl_.progress_;
}
inline ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NONNULL CharacterDraftData::mutable_progress()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::dnd5e::api::v1alpha1::CreationProgress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraftData.progress)
  return _msg;
}
inline void CharacterDraftData::set_allocated_progress(::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.progress_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.progress_ = reinterpret_cast<::dnd5e::api::v1alpha1::CreationProgress*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraftData.progress)
}

// int64 expires_at = 13 [json_name = "expiresAt"];
inline void CharacterDraftData::clear_expires_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int64_t CharacterDraftData::expires_at() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.expires_at)
  return _internal_expires_at();
}
inline void CharacterDraftData::set_expires_at(::int64_t value) {
  _internal_set_expires_at(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraftData.expires_at)
}
inline ::int64_t CharacterDraftData::_internal_expires_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expires_at_;
}
inline void CharacterDraftData::_internal_set_expires_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_at_ = value;
}

// int64 created_at = 14 [json_name = "createdAt"];
inline void CharacterDraftData::clear_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int64_t CharacterDraftData::created_at() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.created_at)
  return _internal_created_at();
}
inline void CharacterDraftData::set_created_at(::int64_t value) {
  _internal_set_created_at(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraftData.created_at)
}
inline ::int64_t CharacterDraftData::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_at_;
}
inline void CharacterDraftData::_internal_set_created_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_ = value;
}

// int64 updated_at = 15 [json_name = "updatedAt"];
inline void CharacterDraftData::clear_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::int64_t CharacterDraftData::updated_at() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.updated_at)
  return _internal_updated_at();
}
inline void CharacterDraftData::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraftData.updated_at)
}
inline ::int64_t CharacterDraftData::_internal_updated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_at_;
}
inline void CharacterDraftData::_internal_set_updated_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = value;
}

// .dnd5e.api.v1alpha1.DraftMetadata metadata = 16 [json_name = "metadata"];
inline bool CharacterDraftData::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline void CharacterDraftData::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::dnd5e::api::v1alpha1::DraftMetadata& CharacterDraftData::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::DraftMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::DraftMetadata&>(::dnd5e::api::v1alpha1::_DraftMetadata_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::DraftMetadata& CharacterDraftData::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraftData.metadata)
  return _internal_metadata();
}
inline void CharacterDraftData::unsafe_arena_set_allocated_metadata(
    ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::dnd5e::api::v1alpha1::DraftMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CharacterDraftData.metadata)
}
inline ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE CharacterDraftData::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::dnd5e::api::v1alpha1::DraftMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE CharacterDraftData::unsafe_arena_release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraftData.metadata)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::dnd5e::api::v1alpha1::DraftMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NONNULL CharacterDraftData::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::DraftMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::dnd5e::api::v1alpha1::DraftMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NONNULL CharacterDraftData::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::dnd5e::api::v1alpha1::DraftMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraftData.metadata)
  return _msg;
}
inline void CharacterDraftData::set_allocated_metadata(::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.metadata_ = reinterpret_cast<::dnd5e::api::v1alpha1::DraftMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraftData.metadata)
}

// -------------------------------------------------------------------

// CreationProgress

// bool has_name = 1 [json_name = "hasName"];
inline void CreationProgress::clear_has_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_name_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool CreationProgress::has_name() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreationProgress.has_name)
  return _internal_has_name();
}
inline void CreationProgress::set_has_name(bool value) {
  _internal_set_has_name(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreationProgress.has_name)
}
inline bool CreationProgress::_internal_has_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_name_;
}
inline void CreationProgress::_internal_set_has_name(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_name_ = value;
}

// bool has_race = 2 [json_name = "hasRace"];
inline void CreationProgress::clear_has_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_race_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CreationProgress::has_race() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreationProgress.has_race)
  return _internal_has_race();
}
inline void CreationProgress::set_has_race(bool value) {
  _internal_set_has_race(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreationProgress.has_race)
}
inline bool CreationProgress::_internal_has_race() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_race_;
}
inline void CreationProgress::_internal_set_has_race(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_race_ = value;
}

// bool has_class = 3 [json_name = "hasClass"];
inline void CreationProgress::clear_has_class() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_class_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CreationProgress::has_class() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreationProgress.has_class)
  return _internal_has_class();
}
inline void CreationProgress::set_has_class(bool value) {
  _internal_set_has_class(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreationProgress.has_class)
}
inline bool CreationProgress::_internal_has_class() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_class_;
}
inline void CreationProgress::_internal_set_has_class(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_class_ = value;
}

// bool has_background = 4 [json_name = "hasBackground"];
inline void CreationProgress::clear_has_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_background_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool CreationProgress::has_background() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreationProgress.has_background)
  return _internal_has_background();
}
inline void CreationProgress::set_has_background(bool value) {
  _internal_set_has_background(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreationProgress.has_background)
}
inline bool CreationProgress::_internal_has_background() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_background_;
}
inline void CreationProgress::_internal_set_has_background(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_background_ = value;
}

// bool has_ability_scores = 5 [json_name = "hasAbilityScores"];
inline void CreationProgress::clear_has_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_ability_scores_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool CreationProgress::has_ability_scores() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreationProgress.has_ability_scores)
  return _internal_has_ability_scores();
}
inline void CreationProgress::set_has_ability_scores(bool value) {
  _internal_set_has_ability_scores(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreationProgress.has_ability_scores)
}
inline bool CreationProgress::_internal_has_ability_scores() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_ability_scores_;
}
inline void CreationProgress::_internal_set_has_ability_scores(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_ability_scores_ = value;
}

// bool has_skills = 6 [json_name = "hasSkills"];
inline void CreationProgress::clear_has_skills() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_skills_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool CreationProgress::has_skills() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreationProgress.has_skills)
  return _internal_has_skills();
}
inline void CreationProgress::set_has_skills(bool value) {
  _internal_set_has_skills(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreationProgress.has_skills)
}
inline bool CreationProgress::_internal_has_skills() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_skills_;
}
inline void CreationProgress::_internal_set_has_skills(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_skills_ = value;
}

// bool has_languages = 7 [json_name = "hasLanguages"];
inline void CreationProgress::clear_has_languages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_languages_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool CreationProgress::has_languages() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreationProgress.has_languages)
  return _internal_has_languages();
}
inline void CreationProgress::set_has_languages(bool value) {
  _internal_set_has_languages(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreationProgress.has_languages)
}
inline bool CreationProgress::_internal_has_languages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_languages_;
}
inline void CreationProgress::_internal_set_has_languages(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_languages_ = value;
}

// int32 completion_percentage = 8 [json_name = "completionPercentage"];
inline void CreationProgress::clear_completion_percentage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completion_percentage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t CreationProgress::completion_percentage() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreationProgress.completion_percentage)
  return _internal_completion_percentage();
}
inline void CreationProgress::set_completion_percentage(::int32_t value) {
  _internal_set_completion_percentage(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreationProgress.completion_percentage)
}
inline ::int32_t CreationProgress::_internal_completion_percentage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.completion_percentage_;
}
inline void CreationProgress::_internal_set_completion_percentage(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completion_percentage_ = value;
}

// .dnd5e.api.v1alpha1.CreationStep current_step = 9 [json_name = "currentStep"];
inline void CreationProgress::clear_current_step() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_step_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::dnd5e::api::v1alpha1::CreationStep CreationProgress::current_step() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreationProgress.current_step)
  return _internal_current_step();
}
inline void CreationProgress::set_current_step(::dnd5e::api::v1alpha1::CreationStep value) {
  _internal_set_current_step(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreationProgress.current_step)
}
inline ::dnd5e::api::v1alpha1::CreationStep CreationProgress::_internal_current_step() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::CreationStep>(_impl_.current_step_);
}
inline void CreationProgress::_internal_set_current_step(::dnd5e::api::v1alpha1::CreationStep value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_step_ = value;
}

// -------------------------------------------------------------------

// DraftMetadata

// int64 created_at = 1 [json_name = "createdAt"];
inline void DraftMetadata::clear_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t DraftMetadata::created_at() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DraftMetadata.created_at)
  return _internal_created_at();
}
inline void DraftMetadata::set_created_at(::int64_t value) {
  _internal_set_created_at(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DraftMetadata.created_at)
}
inline ::int64_t DraftMetadata::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_at_;
}
inline void DraftMetadata::_internal_set_created_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_ = value;
}

// int64 updated_at = 2 [json_name = "updatedAt"];
inline void DraftMetadata::clear_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t DraftMetadata::updated_at() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DraftMetadata.updated_at)
  return _internal_updated_at();
}
inline void DraftMetadata::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DraftMetadata.updated_at)
}
inline ::int64_t DraftMetadata::_internal_updated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_at_;
}
inline void DraftMetadata::_internal_set_updated_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = value;
}

// string discord_channel_id = 3 [json_name = "discordChannelId"];
inline void DraftMetadata::clear_discord_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.discord_channel_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DraftMetadata::discord_channel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DraftMetadata.discord_channel_id)
  return _internal_discord_channel_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DraftMetadata::set_discord_channel_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.discord_channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DraftMetadata.discord_channel_id)
}
inline ::std::string* PROTOBUF_NONNULL DraftMetadata::mutable_discord_channel_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_discord_channel_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DraftMetadata.discord_channel_id)
  return _s;
}
inline const ::std::string& DraftMetadata::_internal_discord_channel_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.discord_channel_id_.Get();
}
inline void DraftMetadata::_internal_set_discord_channel_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.discord_channel_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DraftMetadata::_internal_mutable_discord_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.discord_channel_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DraftMetadata::release_discord_channel_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DraftMetadata.discord_channel_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.discord_channel_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.discord_channel_id_.Set("", GetArena());
  }
  return released;
}
inline void DraftMetadata::set_allocated_discord_channel_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.discord_channel_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.discord_channel_id_.IsDefault()) {
    _impl_.discord_channel_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DraftMetadata.discord_channel_id)
}

// string discord_message_id = 4 [json_name = "discordMessageId"];
inline void DraftMetadata::clear_discord_message_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.discord_message_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& DraftMetadata::discord_message_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DraftMetadata.discord_message_id)
  return _internal_discord_message_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DraftMetadata::set_discord_message_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.discord_message_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DraftMetadata.discord_message_id)
}
inline ::std::string* PROTOBUF_NONNULL DraftMetadata::mutable_discord_message_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_discord_message_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DraftMetadata.discord_message_id)
  return _s;
}
inline const ::std::string& DraftMetadata::_internal_discord_message_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.discord_message_id_.Get();
}
inline void DraftMetadata::_internal_set_discord_message_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.discord_message_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DraftMetadata::_internal_mutable_discord_message_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.discord_message_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DraftMetadata::release_discord_message_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DraftMetadata.discord_message_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.discord_message_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.discord_message_id_.Set("", GetArena());
  }
  return released;
}
inline void DraftMetadata::set_allocated_discord_message_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.discord_message_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.discord_message_id_.IsDefault()) {
    _impl_.discord_message_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DraftMetadata.discord_message_id)
}

// -------------------------------------------------------------------

// CharacterDraft

// string id = 1 [json_name = "id"];
inline void CharacterDraft::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CharacterDraft::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CharacterDraft::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraft.id)
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraft::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraft.id)
  return _s;
}
inline const ::std::string& CharacterDraft::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void CharacterDraft::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraft::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CharacterDraft::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraft.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void CharacterDraft::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.id)
}

// string player_id = 2 [json_name = "playerId"];
inline void CharacterDraft::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CharacterDraft::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CharacterDraft::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraft.player_id)
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraft::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraft.player_id)
  return _s;
}
inline const ::std::string& CharacterDraft::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void CharacterDraft::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraft::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CharacterDraft::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraft.player_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void CharacterDraft::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.player_id)
}

// string session_id = 3 [json_name = "sessionId"];
inline void CharacterDraft::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CharacterDraft::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CharacterDraft::set_session_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraft.session_id)
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraft::mutable_session_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraft.session_id)
  return _s;
}
inline const ::std::string& CharacterDraft::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void CharacterDraft::_internal_set_session_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraft::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.session_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CharacterDraft::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraft.session_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.session_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.session_id_.Set("", GetArena());
  }
  return released;
}
inline void CharacterDraft::set_allocated_session_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.session_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.session_id)
}

// string name = 4 [json_name = "name"];
inline void CharacterDraft::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& CharacterDraft::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CharacterDraft::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraft.name)
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraft::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraft.name)
  return _s;
}
inline const ::std::string& CharacterDraft::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void CharacterDraft::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CharacterDraft::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CharacterDraft::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraft.name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void CharacterDraft::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.name)
}

// .dnd5e.api.v1alpha1.RaceInfo race = 5 [json_name = "race"];
inline bool CharacterDraft::has_race() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.race_ != nullptr);
  return value;
}
inline void CharacterDraft::clear_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.race_ != nullptr) _impl_.race_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::dnd5e::api::v1alpha1::RaceInfo& CharacterDraft::_internal_race() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::RaceInfo* p = _impl_.race_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::RaceInfo&>(::dnd5e::api::v1alpha1::_RaceInfo_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::RaceInfo& CharacterDraft::race() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.race)
  return _internal_race();
}
inline void CharacterDraft::unsafe_arena_set_allocated_race(
    ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.race_);
  }
  _impl_.race_ = reinterpret_cast<::dnd5e::api::v1alpha1::RaceInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.race)
}
inline ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE CharacterDraft::release_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::RaceInfo* released = _impl_.race_;
  _impl_.race_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE CharacterDraft::unsafe_arena_release_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraft.race)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::RaceInfo* temp = _impl_.race_;
  _impl_.race_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NONNULL CharacterDraft::_internal_mutable_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.race_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::RaceInfo>(GetArena());
    _impl_.race_ = reinterpret_cast<::dnd5e::api::v1alpha1::RaceInfo*>(p);
  }
  return _impl_.race_;
}
inline ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NONNULL CharacterDraft::mutable_race()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::dnd5e::api::v1alpha1::RaceInfo* _msg = _internal_mutable_race();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraft.race)
  return _msg;
}
inline void CharacterDraft::set_allocated_race(::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.race_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.race_ = reinterpret_cast<::dnd5e::api::v1alpha1::RaceInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.race)
}

// .dnd5e.api.v1alpha1.SubraceInfo subrace = 6 [json_name = "subrace"];
inline bool CharacterDraft::has_subrace() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subrace_ != nullptr);
  return value;
}
inline void CharacterDraft::clear_subrace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.subrace_ != nullptr) _impl_.subrace_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::dnd5e::api::v1alpha1::SubraceInfo& CharacterDraft::_internal_subrace() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::SubraceInfo* p = _impl_.subrace_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::SubraceInfo&>(::dnd5e::api::v1alpha1::_SubraceInfo_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SubraceInfo& CharacterDraft::subrace() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.subrace)
  return _internal_subrace();
}
inline void CharacterDraft::unsafe_arena_set_allocated_subrace(
    ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.subrace_);
  }
  _impl_.subrace_ = reinterpret_cast<::dnd5e::api::v1alpha1::SubraceInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.subrace)
}
inline ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NULLABLE CharacterDraft::release_subrace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::dnd5e::api::v1alpha1::SubraceInfo* released = _impl_.subrace_;
  _impl_.subrace_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NULLABLE CharacterDraft::unsafe_arena_release_subrace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraft.subrace)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::dnd5e::api::v1alpha1::SubraceInfo* temp = _impl_.subrace_;
  _impl_.subrace_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NONNULL CharacterDraft::_internal_mutable_subrace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.subrace_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SubraceInfo>(GetArena());
    _impl_.subrace_ = reinterpret_cast<::dnd5e::api::v1alpha1::SubraceInfo*>(p);
  }
  return _impl_.subrace_;
}
inline ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NONNULL CharacterDraft::mutable_subrace()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::dnd5e::api::v1alpha1::SubraceInfo* _msg = _internal_mutable_subrace();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraft.subrace)
  return _msg;
}
inline void CharacterDraft::set_allocated_subrace(::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.subrace_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.subrace_ = reinterpret_cast<::dnd5e::api::v1alpha1::SubraceInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.subrace)
}

// .dnd5e.api.v1alpha1.ClassInfo class = 7 [json_name = "class"];
inline bool CharacterDraft::has_class_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.class__ != nullptr);
  return value;
}
inline void CharacterDraft::clear_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.class__ != nullptr) _impl_.class__->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::dnd5e::api::v1alpha1::ClassInfo& CharacterDraft::_internal_class_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::ClassInfo* p = _impl_.class__;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::ClassInfo&>(::dnd5e::api::v1alpha1::_ClassInfo_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ClassInfo& CharacterDraft::class_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.class)
  return _internal_class_();
}
inline void CharacterDraft::unsafe_arena_set_allocated_class_(
    ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.class__);
  }
  _impl_.class__ = reinterpret_cast<::dnd5e::api::v1alpha1::ClassInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.class)
}
inline ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE CharacterDraft::release_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::dnd5e::api::v1alpha1::ClassInfo* released = _impl_.class__;
  _impl_.class__ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE CharacterDraft::unsafe_arena_release_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraft.class)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::dnd5e::api::v1alpha1::ClassInfo* temp = _impl_.class__;
  _impl_.class__ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NONNULL CharacterDraft::_internal_mutable_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.class__ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ClassInfo>(GetArena());
    _impl_.class__ = reinterpret_cast<::dnd5e::api::v1alpha1::ClassInfo*>(p);
  }
  return _impl_.class__;
}
inline ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NONNULL CharacterDraft::mutable_class_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::dnd5e::api::v1alpha1::ClassInfo* _msg = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraft.class)
  return _msg;
}
inline void CharacterDraft::set_allocated_class_(::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.class__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.class__ = reinterpret_cast<::dnd5e::api::v1alpha1::ClassInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.class)
}

// .dnd5e.api.v1alpha1.BackgroundInfo background = 8 [json_name = "background"];
inline bool CharacterDraft::has_background() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.background_ != nullptr);
  return value;
}
inline void CharacterDraft::clear_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.background_ != nullptr) _impl_.background_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::dnd5e::api::v1alpha1::BackgroundInfo& CharacterDraft::_internal_background() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::BackgroundInfo* p = _impl_.background_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::BackgroundInfo&>(::dnd5e::api::v1alpha1::_BackgroundInfo_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::BackgroundInfo& CharacterDraft::background() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.background)
  return _internal_background();
}
inline void CharacterDraft::unsafe_arena_set_allocated_background(
    ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.background_);
  }
  _impl_.background_ = reinterpret_cast<::dnd5e::api::v1alpha1::BackgroundInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.background)
}
inline ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE CharacterDraft::release_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::dnd5e::api::v1alpha1::BackgroundInfo* released = _impl_.background_;
  _impl_.background_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE CharacterDraft::unsafe_arena_release_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraft.background)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::dnd5e::api::v1alpha1::BackgroundInfo* temp = _impl_.background_;
  _impl_.background_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NONNULL CharacterDraft::_internal_mutable_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.background_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::BackgroundInfo>(GetArena());
    _impl_.background_ = reinterpret_cast<::dnd5e::api::v1alpha1::BackgroundInfo*>(p);
  }
  return _impl_.background_;
}
inline ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NONNULL CharacterDraft::mutable_background()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::dnd5e::api::v1alpha1::BackgroundInfo* _msg = _internal_mutable_background();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraft.background)
  return _msg;
}
inline void CharacterDraft::set_allocated_background(::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.background_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.background_ = reinterpret_cast<::dnd5e::api::v1alpha1::BackgroundInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.background)
}

// .dnd5e.api.v1alpha1.AbilityScores ability_scores = 9 [json_name = "abilityScores"];
inline bool CharacterDraft::has_ability_scores() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ability_scores_ != nullptr);
  return value;
}
inline void CharacterDraft::clear_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ability_scores_ != nullptr) _impl_.ability_scores_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::dnd5e::api::v1alpha1::AbilityScores& CharacterDraft::_internal_ability_scores() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::AbilityScores* p = _impl_.ability_scores_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::AbilityScores&>(::dnd5e::api::v1alpha1::_AbilityScores_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AbilityScores& CharacterDraft::ability_scores() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.ability_scores)
  return _internal_ability_scores();
}
inline void CharacterDraft::unsafe_arena_set_allocated_ability_scores(
    ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ability_scores_);
  }
  _impl_.ability_scores_ = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.ability_scores)
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE CharacterDraft::release_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::dnd5e::api::v1alpha1::AbilityScores* released = _impl_.ability_scores_;
  _impl_.ability_scores_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE CharacterDraft::unsafe_arena_release_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraft.ability_scores)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::dnd5e::api::v1alpha1::AbilityScores* temp = _impl_.ability_scores_;
  _impl_.ability_scores_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL CharacterDraft::_internal_mutable_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ability_scores_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AbilityScores>(GetArena());
    _impl_.ability_scores_ = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(p);
  }
  return _impl_.ability_scores_;
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL CharacterDraft::mutable_ability_scores()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::dnd5e::api::v1alpha1::AbilityScores* _msg = _internal_mutable_ability_scores();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraft.ability_scores)
  return _msg;
}
inline void CharacterDraft::set_allocated_ability_scores(::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ability_scores_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.ability_scores_ = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.ability_scores)
}

// .dnd5e.api.v1alpha1.Alignment alignment = 10 [json_name = "alignment"];
inline void CharacterDraft::clear_alignment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alignment_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::dnd5e::api::v1alpha1::Alignment CharacterDraft::alignment() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.alignment)
  return _internal_alignment();
}
inline void CharacterDraft::set_alignment(::dnd5e::api::v1alpha1::Alignment value) {
  _internal_set_alignment(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraft.alignment)
}
inline ::dnd5e::api::v1alpha1::Alignment CharacterDraft::_internal_alignment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Alignment>(_impl_.alignment_);
}
inline void CharacterDraft::_internal_set_alignment(::dnd5e::api::v1alpha1::Alignment value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alignment_ = value;
}

// repeated .dnd5e.api.v1alpha1.ChoiceData choices = 11 [json_name = "choices"];
inline int CharacterDraft::_internal_choices_size() const {
  return _internal_choices().size();
}
inline int CharacterDraft::choices_size() const {
  return _internal_choices_size();
}
inline void CharacterDraft::clear_choices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choices_.Clear();
}
inline ::dnd5e::api::v1alpha1::ChoiceData* PROTOBUF_NONNULL CharacterDraft::mutable_choices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraft.choices)
  return _internal_mutable_choices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>* PROTOBUF_NONNULL CharacterDraft::mutable_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.CharacterDraft.choices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_choices();
}
inline const ::dnd5e::api::v1alpha1::ChoiceData& CharacterDraft::choices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.choices)
  return _internal_choices().Get(index);
}
inline ::dnd5e::api::v1alpha1::ChoiceData* PROTOBUF_NONNULL CharacterDraft::add_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ChoiceData* _add = _internal_mutable_choices()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.CharacterDraft.choices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>& CharacterDraft::choices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.CharacterDraft.choices)
  return _internal_choices();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>&
CharacterDraft::_internal_choices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.choices_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceData>* PROTOBUF_NONNULL
CharacterDraft::_internal_mutable_choices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.choices_;
}

// .dnd5e.api.v1alpha1.CreationProgress progress = 12 [json_name = "progress"];
inline bool CharacterDraft::has_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.progress_ != nullptr);
  return value;
}
inline void CharacterDraft::clear_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.progress_ != nullptr) _impl_.progress_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::dnd5e::api::v1alpha1::CreationProgress& CharacterDraft::_internal_progress() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CreationProgress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CreationProgress&>(::dnd5e::api::v1alpha1::_CreationProgress_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CreationProgress& CharacterDraft::progress() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.progress)
  return _internal_progress();
}
inline void CharacterDraft::unsafe_arena_set_allocated_progress(
    ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = reinterpret_cast<::dnd5e::api::v1alpha1::CreationProgress*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.progress)
}
inline ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE CharacterDraft::release_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::dnd5e::api::v1alpha1::CreationProgress* released = _impl_.progress_;
  _impl_.progress_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE CharacterDraft::unsafe_arena_release_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraft.progress)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::dnd5e::api::v1alpha1::CreationProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NONNULL CharacterDraft::_internal_mutable_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.progress_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CreationProgress>(GetArena());
    _impl_.progress_ = reinterpret_cast<::dnd5e::api::v1alpha1::CreationProgress*>(p);
  }
  return _impl_.progress_;
}
inline ::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NONNULL CharacterDraft::mutable_progress()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::dnd5e::api::v1alpha1::CreationProgress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraft.progress)
  return _msg;
}
inline void CharacterDraft::set_allocated_progress(::dnd5e::api::v1alpha1::CreationProgress* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.progress_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.progress_ = reinterpret_cast<::dnd5e::api::v1alpha1::CreationProgress*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.progress)
}

// int64 expires_at = 13 [json_name = "expiresAt"];
inline void CharacterDraft::clear_expires_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int64_t CharacterDraft::expires_at() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.expires_at)
  return _internal_expires_at();
}
inline void CharacterDraft::set_expires_at(::int64_t value) {
  _internal_set_expires_at(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraft.expires_at)
}
inline ::int64_t CharacterDraft::_internal_expires_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expires_at_;
}
inline void CharacterDraft::_internal_set_expires_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_at_ = value;
}

// int64 created_at = 14 [json_name = "createdAt"];
inline void CharacterDraft::clear_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::int64_t CharacterDraft::created_at() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.created_at)
  return _internal_created_at();
}
inline void CharacterDraft::set_created_at(::int64_t value) {
  _internal_set_created_at(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraft.created_at)
}
inline ::int64_t CharacterDraft::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_at_;
}
inline void CharacterDraft::_internal_set_created_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_ = value;
}

// int64 updated_at = 15 [json_name = "updatedAt"];
inline void CharacterDraft::clear_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::int64_t CharacterDraft::updated_at() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.updated_at)
  return _internal_updated_at();
}
inline void CharacterDraft::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraft.updated_at)
}
inline ::int64_t CharacterDraft::_internal_updated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_at_;
}
inline void CharacterDraft::_internal_set_updated_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = value;
}

// .dnd5e.api.v1alpha1.DraftMetadata metadata = 16 [json_name = "metadata"];
inline bool CharacterDraft::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline void CharacterDraft::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::dnd5e::api::v1alpha1::DraftMetadata& CharacterDraft::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::DraftMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::DraftMetadata&>(::dnd5e::api::v1alpha1::_DraftMetadata_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::DraftMetadata& CharacterDraft::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.metadata)
  return _internal_metadata();
}
inline void CharacterDraft::unsafe_arena_set_allocated_metadata(
    ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::dnd5e::api::v1alpha1::DraftMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.metadata)
}
inline ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE CharacterDraft::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::dnd5e::api::v1alpha1::DraftMetadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE CharacterDraft::unsafe_arena_release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CharacterDraft.metadata)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::dnd5e::api::v1alpha1::DraftMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NONNULL CharacterDraft::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.metadata_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::DraftMetadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::dnd5e::api::v1alpha1::DraftMetadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NONNULL CharacterDraft::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::dnd5e::api::v1alpha1::DraftMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CharacterDraft.metadata)
  return _msg;
}
inline void CharacterDraft::set_allocated_metadata(::dnd5e::api::v1alpha1::DraftMetadata* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.metadata_ = reinterpret_cast<::dnd5e::api::v1alpha1::DraftMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CharacterDraft.metadata)
}

// .dnd5e.api.v1alpha1.Race race_id = 17 [json_name = "raceId"];
inline void CharacterDraft::clear_race_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.race_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::dnd5e::api::v1alpha1::Race CharacterDraft::race_id() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.race_id)
  return _internal_race_id();
}
inline void CharacterDraft::set_race_id(::dnd5e::api::v1alpha1::Race value) {
  _internal_set_race_id(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraft.race_id)
}
inline ::dnd5e::api::v1alpha1::Race CharacterDraft::_internal_race_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Race>(_impl_.race_id_);
}
inline void CharacterDraft::_internal_set_race_id(::dnd5e::api::v1alpha1::Race value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.race_id_ = value;
}

// .dnd5e.api.v1alpha1.Subrace subrace_id = 18 [json_name = "subraceId"];
inline void CharacterDraft::clear_subrace_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subrace_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::dnd5e::api::v1alpha1::Subrace CharacterDraft::subrace_id() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.subrace_id)
  return _internal_subrace_id();
}
inline void CharacterDraft::set_subrace_id(::dnd5e::api::v1alpha1::Subrace value) {
  _internal_set_subrace_id(value);
  _impl_._has_bits_[0] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraft.subrace_id)
}
inline ::dnd5e::api::v1alpha1::Subrace CharacterDraft::_internal_subrace_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Subrace>(_impl_.subrace_id_);
}
inline void CharacterDraft::_internal_set_subrace_id(::dnd5e::api::v1alpha1::Subrace value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subrace_id_ = value;
}

// .dnd5e.api.v1alpha1.Class class_id = 19 [json_name = "classId"];
inline void CharacterDraft::clear_class_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::dnd5e::api::v1alpha1::Class CharacterDraft::class_id() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.class_id)
  return _internal_class_id();
}
inline void CharacterDraft::set_class_id(::dnd5e::api::v1alpha1::Class value) {
  _internal_set_class_id(value);
  _impl_._has_bits_[0] |= 0x00020000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraft.class_id)
}
inline ::dnd5e::api::v1alpha1::Class CharacterDraft::_internal_class_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Class>(_impl_.class_id_);
}
inline void CharacterDraft::_internal_set_class_id(::dnd5e::api::v1alpha1::Class value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class_id_ = value;
}

// .dnd5e.api.v1alpha1.Background background_id = 20 [json_name = "backgroundId"];
inline void CharacterDraft::clear_background_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.background_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::dnd5e::api::v1alpha1::Background CharacterDraft::background_id() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CharacterDraft.background_id)
  return _internal_background_id();
}
inline void CharacterDraft::set_background_id(::dnd5e::api::v1alpha1::Background value) {
  _internal_set_background_id(value);
  _impl_._has_bits_[0] |= 0x00040000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CharacterDraft.background_id)
}
inline ::dnd5e::api::v1alpha1::Background CharacterDraft::_internal_background_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Background>(_impl_.background_id_);
}
inline void CharacterDraft::_internal_set_background_id(::dnd5e::api::v1alpha1::Background value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.background_id_ = value;
}

// -------------------------------------------------------------------

// CreateDraftRequest

// string player_id = 1 [json_name = "playerId"];
inline void CreateDraftRequest::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CreateDraftRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreateDraftRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateDraftRequest::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreateDraftRequest.player_id)
}
inline ::std::string* PROTOBUF_NONNULL CreateDraftRequest::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CreateDraftRequest.player_id)
  return _s;
}
inline const ::std::string& CreateDraftRequest::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void CreateDraftRequest::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CreateDraftRequest::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CreateDraftRequest::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CreateDraftRequest.player_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void CreateDraftRequest::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CreateDraftRequest.player_id)
}

// string session_id = 2 [json_name = "sessionId"];
inline void CreateDraftRequest::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CreateDraftRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreateDraftRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateDraftRequest::set_session_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreateDraftRequest.session_id)
}
inline ::std::string* PROTOBUF_NONNULL CreateDraftRequest::mutable_session_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CreateDraftRequest.session_id)
  return _s;
}
inline const ::std::string& CreateDraftRequest::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void CreateDraftRequest::_internal_set_session_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CreateDraftRequest::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.session_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CreateDraftRequest::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CreateDraftRequest.session_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.session_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.session_id_.Set("", GetArena());
  }
  return released;
}
inline void CreateDraftRequest::set_allocated_session_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.session_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CreateDraftRequest.session_id)
}

// .dnd5e.api.v1alpha1.CharacterDraftData initial_data = 3 [json_name = "initialData"];
inline bool CreateDraftRequest::has_initial_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.initial_data_ != nullptr);
  return value;
}
inline void CreateDraftRequest::clear_initial_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.initial_data_ != nullptr) _impl_.initial_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::dnd5e::api::v1alpha1::CharacterDraftData& CreateDraftRequest::_internal_initial_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterDraftData* p = _impl_.initial_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterDraftData&>(::dnd5e::api::v1alpha1::_CharacterDraftData_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterDraftData& CreateDraftRequest::initial_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreateDraftRequest.initial_data)
  return _internal_initial_data();
}
inline void CreateDraftRequest::unsafe_arena_set_allocated_initial_data(
    ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.initial_data_);
  }
  _impl_.initial_data_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraftData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CreateDraftRequest.initial_data)
}
inline ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE CreateDraftRequest::release_initial_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dnd5e::api::v1alpha1::CharacterDraftData* released = _impl_.initial_data_;
  _impl_.initial_data_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE CreateDraftRequest::unsafe_arena_release_initial_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CreateDraftRequest.initial_data)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dnd5e::api::v1alpha1::CharacterDraftData* temp = _impl_.initial_data_;
  _impl_.initial_data_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NONNULL CreateDraftRequest::_internal_mutable_initial_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.initial_data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterDraftData>(GetArena());
    _impl_.initial_data_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraftData*>(p);
  }
  return _impl_.initial_data_;
}
inline ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NONNULL CreateDraftRequest::mutable_initial_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::dnd5e::api::v1alpha1::CharacterDraftData* _msg = _internal_mutable_initial_data();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CreateDraftRequest.initial_data)
  return _msg;
}
inline void CreateDraftRequest::set_allocated_initial_data(::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.initial_data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.initial_data_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraftData*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CreateDraftRequest.initial_data)
}

// -------------------------------------------------------------------

// CreateDraftResponse

// .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
inline bool CreateDraftResponse::has_draft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.draft_ != nullptr);
  return value;
}
inline void CreateDraftResponse::clear_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ != nullptr) _impl_.draft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& CreateDraftResponse::_internal_draft() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterDraft* p = _impl_.draft_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterDraft&>(::dnd5e::api::v1alpha1::_CharacterDraft_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& CreateDraftResponse::draft() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreateDraftResponse.draft)
  return _internal_draft();
}
inline void CreateDraftResponse::unsafe_arena_set_allocated_draft(
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }
  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CreateDraftResponse.draft)
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE CreateDraftResponse::release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* released = _impl_.draft_;
  _impl_.draft_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE CreateDraftResponse::unsafe_arena_release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CreateDraftResponse.draft)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* temp = _impl_.draft_;
  _impl_.draft_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL CreateDraftResponse::_internal_mutable_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterDraft>(GetArena());
    _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(p);
  }
  return _impl_.draft_;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL CreateDraftResponse::mutable_draft()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* _msg = _internal_mutable_draft();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CreateDraftResponse.draft)
  return _msg;
}
inline void CreateDraftResponse::set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CreateDraftResponse.draft)
}

// -------------------------------------------------------------------

// GetDraftRequest

// string draft_id = 1 [json_name = "draftId"];
inline void GetDraftRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetDraftRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetDraftRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetDraftRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetDraftRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL GetDraftRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetDraftRequest.draft_id)
  return _s;
}
inline const ::std::string& GetDraftRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void GetDraftRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetDraftRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetDraftRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetDraftRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void GetDraftRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetDraftRequest.draft_id)
}

// -------------------------------------------------------------------

// GetDraftResponse

// .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
inline bool GetDraftResponse::has_draft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.draft_ != nullptr);
  return value;
}
inline void GetDraftResponse::clear_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ != nullptr) _impl_.draft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& GetDraftResponse::_internal_draft() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterDraft* p = _impl_.draft_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterDraft&>(::dnd5e::api::v1alpha1::_CharacterDraft_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& GetDraftResponse::draft() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetDraftResponse.draft)
  return _internal_draft();
}
inline void GetDraftResponse::unsafe_arena_set_allocated_draft(
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }
  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetDraftResponse.draft)
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE GetDraftResponse::release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* released = _impl_.draft_;
  _impl_.draft_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE GetDraftResponse::unsafe_arena_release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetDraftResponse.draft)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* temp = _impl_.draft_;
  _impl_.draft_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL GetDraftResponse::_internal_mutable_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterDraft>(GetArena());
    _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(p);
  }
  return _impl_.draft_;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL GetDraftResponse::mutable_draft()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* _msg = _internal_mutable_draft();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetDraftResponse.draft)
  return _msg;
}
inline void GetDraftResponse::set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetDraftResponse.draft)
}

// -------------------------------------------------------------------

// UpdateDraftRequest

// string draft_id = 1 [json_name = "draftId"];
inline void UpdateDraftRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UpdateDraftRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateDraftRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateDraftRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateDraftRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL UpdateDraftRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateDraftRequest.draft_id)
  return _s;
}
inline const ::std::string& UpdateDraftRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void UpdateDraftRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpdateDraftRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpdateDraftRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateDraftRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void UpdateDraftRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateDraftRequest.draft_id)
}

// .dnd5e.api.v1alpha1.CharacterDraftData updates = 2 [json_name = "updates"];
inline bool UpdateDraftRequest::has_updates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updates_ != nullptr);
  return value;
}
inline void UpdateDraftRequest::clear_updates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updates_ != nullptr) _impl_.updates_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dnd5e::api::v1alpha1::CharacterDraftData& UpdateDraftRequest::_internal_updates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterDraftData* p = _impl_.updates_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterDraftData&>(::dnd5e::api::v1alpha1::_CharacterDraftData_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterDraftData& UpdateDraftRequest::updates() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateDraftRequest.updates)
  return _internal_updates();
}
inline void UpdateDraftRequest::unsafe_arena_set_allocated_updates(
    ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updates_);
  }
  _impl_.updates_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraftData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UpdateDraftRequest.updates)
}
inline ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE UpdateDraftRequest::release_updates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::CharacterDraftData* released = _impl_.updates_;
  _impl_.updates_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE UpdateDraftRequest::unsafe_arena_release_updates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateDraftRequest.updates)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::CharacterDraftData* temp = _impl_.updates_;
  _impl_.updates_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NONNULL UpdateDraftRequest::_internal_mutable_updates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updates_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterDraftData>(GetArena());
    _impl_.updates_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraftData*>(p);
  }
  return _impl_.updates_;
}
inline ::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NONNULL UpdateDraftRequest::mutable_updates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::dnd5e::api::v1alpha1::CharacterDraftData* _msg = _internal_mutable_updates();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateDraftRequest.updates)
  return _msg;
}
inline void UpdateDraftRequest::set_allocated_updates(::dnd5e::api::v1alpha1::CharacterDraftData* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updates_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updates_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraftData*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateDraftRequest.updates)
}

// repeated string update_mask = 3 [json_name = "updateMask"];
inline int UpdateDraftRequest::_internal_update_mask_size() const {
  return _internal_update_mask().size();
}
inline int UpdateDraftRequest::update_mask_size() const {
  return _internal_update_mask_size();
}
inline void UpdateDraftRequest::clear_update_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.update_mask_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL UpdateDraftRequest::add_update_mask()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_update_mask()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.UpdateDraftRequest.update_mask)
  return _s;
}
inline const ::std::string& UpdateDraftRequest::update_mask(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateDraftRequest.update_mask)
  return _internal_update_mask().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL UpdateDraftRequest::mutable_update_mask(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateDraftRequest.update_mask)
  return _internal_mutable_update_mask()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void UpdateDraftRequest::set_update_mask(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_update_mask()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateDraftRequest.update_mask)
}
template <typename Arg_, typename... Args_>
inline void UpdateDraftRequest::add_update_mask(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_update_mask(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateDraftRequest.update_mask)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& UpdateDraftRequest::update_mask()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateDraftRequest.update_mask)
  return _internal_update_mask();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
UpdateDraftRequest::mutable_update_mask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateDraftRequest.update_mask)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_update_mask();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
UpdateDraftRequest::_internal_update_mask() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.update_mask_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
UpdateDraftRequest::_internal_mutable_update_mask() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.update_mask_;
}

// -------------------------------------------------------------------

// UpdateDraftResponse

// .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
inline bool UpdateDraftResponse::has_draft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.draft_ != nullptr);
  return value;
}
inline void UpdateDraftResponse::clear_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ != nullptr) _impl_.draft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateDraftResponse::_internal_draft() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterDraft* p = _impl_.draft_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterDraft&>(::dnd5e::api::v1alpha1::_CharacterDraft_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateDraftResponse::draft() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateDraftResponse.draft)
  return _internal_draft();
}
inline void UpdateDraftResponse::unsafe_arena_set_allocated_draft(
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }
  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UpdateDraftResponse.draft)
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateDraftResponse::release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* released = _impl_.draft_;
  _impl_.draft_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateDraftResponse::unsafe_arena_release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateDraftResponse.draft)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* temp = _impl_.draft_;
  _impl_.draft_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateDraftResponse::_internal_mutable_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterDraft>(GetArena());
    _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(p);
  }
  return _impl_.draft_;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateDraftResponse::mutable_draft()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* _msg = _internal_mutable_draft();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateDraftResponse.draft)
  return _msg;
}
inline void UpdateDraftResponse::set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateDraftResponse.draft)
}

// repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
inline int UpdateDraftResponse::_internal_warnings_size() const {
  return _internal_warnings().size();
}
inline int UpdateDraftResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateDraftResponse::mutable_warnings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateDraftResponse.warnings)
  return _internal_mutable_warnings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL UpdateDraftResponse::mutable_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateDraftResponse.warnings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_warnings();
}
inline const ::dnd5e::api::v1alpha1::ValidationWarning& UpdateDraftResponse::warnings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateDraftResponse.warnings)
  return _internal_warnings().Get(index);
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateDraftResponse::add_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ValidationWarning* _add = _internal_mutable_warnings()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateDraftResponse.warnings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& UpdateDraftResponse::warnings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateDraftResponse.warnings)
  return _internal_warnings();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>&
UpdateDraftResponse::_internal_warnings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.warnings_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL
UpdateDraftResponse::_internal_mutable_warnings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.warnings_;
}

// -------------------------------------------------------------------

// UpdateNameRequest

// string draft_id = 1 [json_name = "draftId"];
inline void UpdateNameRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UpdateNameRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateNameRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateNameRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateNameRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL UpdateNameRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateNameRequest.draft_id)
  return _s;
}
inline const ::std::string& UpdateNameRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void UpdateNameRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpdateNameRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpdateNameRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateNameRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void UpdateNameRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateNameRequest.draft_id)
}

// string name = 2 [json_name = "name"];
inline void UpdateNameRequest::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& UpdateNameRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateNameRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateNameRequest::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateNameRequest.name)
}
inline ::std::string* PROTOBUF_NONNULL UpdateNameRequest::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateNameRequest.name)
  return _s;
}
inline const ::std::string& UpdateNameRequest::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void UpdateNameRequest::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpdateNameRequest::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpdateNameRequest::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateNameRequest.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void UpdateNameRequest::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateNameRequest.name)
}

// -------------------------------------------------------------------

// UpdateRaceRequest

// string draft_id = 1 [json_name = "draftId"];
inline void UpdateRaceRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UpdateRaceRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateRaceRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateRaceRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateRaceRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL UpdateRaceRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateRaceRequest.draft_id)
  return _s;
}
inline const ::std::string& UpdateRaceRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void UpdateRaceRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpdateRaceRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpdateRaceRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateRaceRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void UpdateRaceRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateRaceRequest.draft_id)
}

// .dnd5e.api.v1alpha1.Race race = 2 [json_name = "race"];
inline void UpdateRaceRequest::clear_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.race_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::dnd5e::api::v1alpha1::Race UpdateRaceRequest::race() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateRaceRequest.race)
  return _internal_race();
}
inline void UpdateRaceRequest::set_race(::dnd5e::api::v1alpha1::Race value) {
  _internal_set_race(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateRaceRequest.race)
}
inline ::dnd5e::api::v1alpha1::Race UpdateRaceRequest::_internal_race() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Race>(_impl_.race_);
}
inline void UpdateRaceRequest::_internal_set_race(::dnd5e::api::v1alpha1::Race value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.race_ = value;
}

// .dnd5e.api.v1alpha1.Subrace subrace = 3 [json_name = "subrace"];
inline void UpdateRaceRequest::clear_subrace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subrace_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::dnd5e::api::v1alpha1::Subrace UpdateRaceRequest::subrace() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateRaceRequest.subrace)
  return _internal_subrace();
}
inline void UpdateRaceRequest::set_subrace(::dnd5e::api::v1alpha1::Subrace value) {
  _internal_set_subrace(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateRaceRequest.subrace)
}
inline ::dnd5e::api::v1alpha1::Subrace UpdateRaceRequest::_internal_subrace() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Subrace>(_impl_.subrace_);
}
inline void UpdateRaceRequest::_internal_set_subrace(::dnd5e::api::v1alpha1::Subrace value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subrace_ = value;
}

// repeated .dnd5e.api.v1alpha1.ChoiceSelection race_choices = 4 [json_name = "raceChoices"];
inline int UpdateRaceRequest::_internal_race_choices_size() const {
  return _internal_race_choices().size();
}
inline int UpdateRaceRequest::race_choices_size() const {
  return _internal_race_choices_size();
}
inline void UpdateRaceRequest::clear_race_choices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.race_choices_.Clear();
}
inline ::dnd5e::api::v1alpha1::ChoiceSelection* PROTOBUF_NONNULL UpdateRaceRequest::mutable_race_choices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateRaceRequest.race_choices)
  return _internal_mutable_race_choices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>* PROTOBUF_NONNULL UpdateRaceRequest::mutable_race_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateRaceRequest.race_choices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_race_choices();
}
inline const ::dnd5e::api::v1alpha1::ChoiceSelection& UpdateRaceRequest::race_choices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateRaceRequest.race_choices)
  return _internal_race_choices().Get(index);
}
inline ::dnd5e::api::v1alpha1::ChoiceSelection* PROTOBUF_NONNULL UpdateRaceRequest::add_race_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ChoiceSelection* _add = _internal_mutable_race_choices()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateRaceRequest.race_choices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>& UpdateRaceRequest::race_choices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateRaceRequest.race_choices)
  return _internal_race_choices();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>&
UpdateRaceRequest::_internal_race_choices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.race_choices_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>* PROTOBUF_NONNULL
UpdateRaceRequest::_internal_mutable_race_choices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.race_choices_;
}

// -------------------------------------------------------------------

// UpdateClassRequest

// string draft_id = 1 [json_name = "draftId"];
inline void UpdateClassRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UpdateClassRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateClassRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateClassRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateClassRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL UpdateClassRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateClassRequest.draft_id)
  return _s;
}
inline const ::std::string& UpdateClassRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void UpdateClassRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpdateClassRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpdateClassRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateClassRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void UpdateClassRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateClassRequest.draft_id)
}

// .dnd5e.api.v1alpha1.Class class = 2 [json_name = "class"];
inline void UpdateClassRequest::clear_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class__ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::dnd5e::api::v1alpha1::Class UpdateClassRequest::class_() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateClassRequest.class)
  return _internal_class_();
}
inline void UpdateClassRequest::set_class_(::dnd5e::api::v1alpha1::Class value) {
  _internal_set_class_(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateClassRequest.class)
}
inline ::dnd5e::api::v1alpha1::Class UpdateClassRequest::_internal_class_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Class>(_impl_.class__);
}
inline void UpdateClassRequest::_internal_set_class_(::dnd5e::api::v1alpha1::Class value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class__ = value;
}

// repeated .dnd5e.api.v1alpha1.ChoiceSelection class_choices = 3 [json_name = "classChoices"];
inline int UpdateClassRequest::_internal_class_choices_size() const {
  return _internal_class_choices().size();
}
inline int UpdateClassRequest::class_choices_size() const {
  return _internal_class_choices_size();
}
inline void UpdateClassRequest::clear_class_choices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class_choices_.Clear();
}
inline ::dnd5e::api::v1alpha1::ChoiceSelection* PROTOBUF_NONNULL UpdateClassRequest::mutable_class_choices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateClassRequest.class_choices)
  return _internal_mutable_class_choices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>* PROTOBUF_NONNULL UpdateClassRequest::mutable_class_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateClassRequest.class_choices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_class_choices();
}
inline const ::dnd5e::api::v1alpha1::ChoiceSelection& UpdateClassRequest::class_choices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateClassRequest.class_choices)
  return _internal_class_choices().Get(index);
}
inline ::dnd5e::api::v1alpha1::ChoiceSelection* PROTOBUF_NONNULL UpdateClassRequest::add_class_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ChoiceSelection* _add = _internal_mutable_class_choices()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateClassRequest.class_choices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>& UpdateClassRequest::class_choices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateClassRequest.class_choices)
  return _internal_class_choices();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>&
UpdateClassRequest::_internal_class_choices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.class_choices_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>* PROTOBUF_NONNULL
UpdateClassRequest::_internal_mutable_class_choices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.class_choices_;
}

// -------------------------------------------------------------------

// UpdateBackgroundRequest

// string draft_id = 1 [json_name = "draftId"];
inline void UpdateBackgroundRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UpdateBackgroundRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateBackgroundRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateBackgroundRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateBackgroundRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL UpdateBackgroundRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateBackgroundRequest.draft_id)
  return _s;
}
inline const ::std::string& UpdateBackgroundRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void UpdateBackgroundRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpdateBackgroundRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpdateBackgroundRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateBackgroundRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void UpdateBackgroundRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateBackgroundRequest.draft_id)
}

// .dnd5e.api.v1alpha1.Background background = 2 [json_name = "background"];
inline void UpdateBackgroundRequest::clear_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.background_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::dnd5e::api::v1alpha1::Background UpdateBackgroundRequest::background() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateBackgroundRequest.background)
  return _internal_background();
}
inline void UpdateBackgroundRequest::set_background(::dnd5e::api::v1alpha1::Background value) {
  _internal_set_background(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateBackgroundRequest.background)
}
inline ::dnd5e::api::v1alpha1::Background UpdateBackgroundRequest::_internal_background() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Background>(_impl_.background_);
}
inline void UpdateBackgroundRequest::_internal_set_background(::dnd5e::api::v1alpha1::Background value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.background_ = value;
}

// repeated .dnd5e.api.v1alpha1.ChoiceSelection background_choices = 3 [json_name = "backgroundChoices"];
inline int UpdateBackgroundRequest::_internal_background_choices_size() const {
  return _internal_background_choices().size();
}
inline int UpdateBackgroundRequest::background_choices_size() const {
  return _internal_background_choices_size();
}
inline void UpdateBackgroundRequest::clear_background_choices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.background_choices_.Clear();
}
inline ::dnd5e::api::v1alpha1::ChoiceSelection* PROTOBUF_NONNULL UpdateBackgroundRequest::mutable_background_choices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateBackgroundRequest.background_choices)
  return _internal_mutable_background_choices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>* PROTOBUF_NONNULL UpdateBackgroundRequest::mutable_background_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateBackgroundRequest.background_choices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_background_choices();
}
inline const ::dnd5e::api::v1alpha1::ChoiceSelection& UpdateBackgroundRequest::background_choices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateBackgroundRequest.background_choices)
  return _internal_background_choices().Get(index);
}
inline ::dnd5e::api::v1alpha1::ChoiceSelection* PROTOBUF_NONNULL UpdateBackgroundRequest::add_background_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ChoiceSelection* _add = _internal_mutable_background_choices()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateBackgroundRequest.background_choices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>& UpdateBackgroundRequest::background_choices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateBackgroundRequest.background_choices)
  return _internal_background_choices();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>&
UpdateBackgroundRequest::_internal_background_choices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.background_choices_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceSelection>* PROTOBUF_NONNULL
UpdateBackgroundRequest::_internal_mutable_background_choices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.background_choices_;
}

// -------------------------------------------------------------------

// UpdateAbilityScoresRequest

// string draft_id = 1 [json_name = "draftId"];
inline void UpdateAbilityScoresRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UpdateAbilityScoresRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateAbilityScoresRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL UpdateAbilityScoresRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.draft_id)
  return _s;
}
inline const ::std::string& UpdateAbilityScoresRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void UpdateAbilityScoresRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpdateAbilityScoresRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpdateAbilityScoresRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void UpdateAbilityScoresRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.draft_id)
}

// .dnd5e.api.v1alpha1.AbilityScores ability_scores = 2 [json_name = "abilityScores"];
inline bool UpdateAbilityScoresRequest::has_ability_scores() const {
  return scores_input_case() == kAbilityScores;
}
inline bool UpdateAbilityScoresRequest::_internal_has_ability_scores() const {
  return scores_input_case() == kAbilityScores;
}
inline void UpdateAbilityScoresRequest::set_has_ability_scores() {
  _impl_._oneof_case_[0] = kAbilityScores;
}
inline void UpdateAbilityScoresRequest::clear_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (scores_input_case() == kAbilityScores) {
    if (GetArena() == nullptr) {
      delete _impl_.scores_input_.ability_scores_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.scores_input_.ability_scores_);
    }
    clear_has_scores_input();
  }
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE UpdateAbilityScoresRequest::release_ability_scores() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.ability_scores)
  if (scores_input_case() == kAbilityScores) {
    clear_has_scores_input();
    auto* temp = _impl_.scores_input_.ability_scores_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scores_input_.ability_scores_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::AbilityScores& UpdateAbilityScoresRequest::_internal_ability_scores() const {
  return scores_input_case() == kAbilityScores ? *_impl_.scores_input_.ability_scores_ : reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores&>(::dnd5e::api::v1alpha1::_AbilityScores_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AbilityScores& UpdateAbilityScoresRequest::ability_scores() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.ability_scores)
  return _internal_ability_scores();
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE UpdateAbilityScoresRequest::unsafe_arena_release_ability_scores() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.ability_scores)
  if (scores_input_case() == kAbilityScores) {
    clear_has_scores_input();
    auto* temp = _impl_.scores_input_.ability_scores_;
    _impl_.scores_input_.ability_scores_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateAbilityScoresRequest::unsafe_arena_set_allocated_ability_scores(
    ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_scores_input();
  if (value) {
    set_has_ability_scores();
    _impl_.scores_input_.ability_scores_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.ability_scores)
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL UpdateAbilityScoresRequest::_internal_mutable_ability_scores() {
  if (scores_input_case() != kAbilityScores) {
    clear_scores_input();
    set_has_ability_scores();
    _impl_.scores_input_.ability_scores_ = 
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AbilityScores>(GetArena());
  }
  return _impl_.scores_input_.ability_scores_;
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL UpdateAbilityScoresRequest::mutable_ability_scores()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::AbilityScores* _msg = _internal_mutable_ability_scores();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.ability_scores)
  return _msg;
}

// .dnd5e.api.v1alpha1.RollAssignments roll_assignments = 3 [json_name = "rollAssignments"];
inline bool UpdateAbilityScoresRequest::has_roll_assignments() const {
  return scores_input_case() == kRollAssignments;
}
inline bool UpdateAbilityScoresRequest::_internal_has_roll_assignments() const {
  return scores_input_case() == kRollAssignments;
}
inline void UpdateAbilityScoresRequest::set_has_roll_assignments() {
  _impl_._oneof_case_[0] = kRollAssignments;
}
inline void UpdateAbilityScoresRequest::clear_roll_assignments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (scores_input_case() == kRollAssignments) {
    if (GetArena() == nullptr) {
      delete _impl_.scores_input_.roll_assignments_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.scores_input_.roll_assignments_);
    }
    clear_has_scores_input();
  }
}
inline ::dnd5e::api::v1alpha1::RollAssignments* PROTOBUF_NULLABLE UpdateAbilityScoresRequest::release_roll_assignments() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.roll_assignments)
  if (scores_input_case() == kRollAssignments) {
    clear_has_scores_input();
    auto* temp = _impl_.scores_input_.roll_assignments_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.scores_input_.roll_assignments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::RollAssignments& UpdateAbilityScoresRequest::_internal_roll_assignments() const {
  return scores_input_case() == kRollAssignments ? *_impl_.scores_input_.roll_assignments_ : reinterpret_cast<::dnd5e::api::v1alpha1::RollAssignments&>(::dnd5e::api::v1alpha1::_RollAssignments_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::RollAssignments& UpdateAbilityScoresRequest::roll_assignments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.roll_assignments)
  return _internal_roll_assignments();
}
inline ::dnd5e::api::v1alpha1::RollAssignments* PROTOBUF_NULLABLE UpdateAbilityScoresRequest::unsafe_arena_release_roll_assignments() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.roll_assignments)
  if (scores_input_case() == kRollAssignments) {
    clear_has_scores_input();
    auto* temp = _impl_.scores_input_.roll_assignments_;
    _impl_.scores_input_.roll_assignments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateAbilityScoresRequest::unsafe_arena_set_allocated_roll_assignments(
    ::dnd5e::api::v1alpha1::RollAssignments* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_scores_input();
  if (value) {
    set_has_roll_assignments();
    _impl_.scores_input_.roll_assignments_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.roll_assignments)
}
inline ::dnd5e::api::v1alpha1::RollAssignments* PROTOBUF_NONNULL UpdateAbilityScoresRequest::_internal_mutable_roll_assignments() {
  if (scores_input_case() != kRollAssignments) {
    clear_scores_input();
    set_has_roll_assignments();
    _impl_.scores_input_.roll_assignments_ = 
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::RollAssignments>(GetArena());
  }
  return _impl_.scores_input_.roll_assignments_;
}
inline ::dnd5e::api::v1alpha1::RollAssignments* PROTOBUF_NONNULL UpdateAbilityScoresRequest::mutable_roll_assignments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::RollAssignments* _msg = _internal_mutable_roll_assignments();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateAbilityScoresRequest.roll_assignments)
  return _msg;
}

inline bool UpdateAbilityScoresRequest::has_scores_input() const {
  return scores_input_case() != SCORES_INPUT_NOT_SET;
}
inline void UpdateAbilityScoresRequest::clear_has_scores_input() {
  _impl_._oneof_case_[0] = SCORES_INPUT_NOT_SET;
}
inline UpdateAbilityScoresRequest::ScoresInputCase UpdateAbilityScoresRequest::scores_input_case() const {
  return UpdateAbilityScoresRequest::ScoresInputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateSkillsRequest

// string draft_id = 1 [json_name = "draftId"];
inline void UpdateSkillsRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UpdateSkillsRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateSkillsRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateSkillsRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateSkillsRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL UpdateSkillsRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateSkillsRequest.draft_id)
  return _s;
}
inline const ::std::string& UpdateSkillsRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void UpdateSkillsRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UpdateSkillsRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UpdateSkillsRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateSkillsRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void UpdateSkillsRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateSkillsRequest.draft_id)
}

// repeated .dnd5e.api.v1alpha1.Skill skills = 2 [json_name = "skills"];
inline int UpdateSkillsRequest::_internal_skills_size() const {
  return _internal_skills().size();
}
inline int UpdateSkillsRequest::skills_size() const {
  return _internal_skills_size();
}
inline void UpdateSkillsRequest::clear_skills() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skills_.Clear();
}
inline ::dnd5e::api::v1alpha1::Skill UpdateSkillsRequest::skills(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateSkillsRequest.skills)
  return static_cast<::dnd5e::api::v1alpha1::Skill>(_internal_skills().Get(index));
}
inline void UpdateSkillsRequest::set_skills(int index, ::dnd5e::api::v1alpha1::Skill value) {
  _internal_mutable_skills()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UpdateSkillsRequest.skills)
}
inline void UpdateSkillsRequest::add_skills(::dnd5e::api::v1alpha1::Skill value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_skills()->Add(value);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateSkillsRequest.skills)
}
inline const ::google::protobuf::RepeatedField<int>& UpdateSkillsRequest::skills() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateSkillsRequest.skills)
  return _internal_skills();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL UpdateSkillsRequest::mutable_skills()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateSkillsRequest.skills)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_skills();
}
inline const ::google::protobuf::RepeatedField<int>& UpdateSkillsRequest::_internal_skills()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skills_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
UpdateSkillsRequest::_internal_mutable_skills() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.skills_;
}

// -------------------------------------------------------------------

// UpdateNameResponse

// .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
inline bool UpdateNameResponse::has_draft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.draft_ != nullptr);
  return value;
}
inline void UpdateNameResponse::clear_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ != nullptr) _impl_.draft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateNameResponse::_internal_draft() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterDraft* p = _impl_.draft_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterDraft&>(::dnd5e::api::v1alpha1::_CharacterDraft_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateNameResponse::draft() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateNameResponse.draft)
  return _internal_draft();
}
inline void UpdateNameResponse::unsafe_arena_set_allocated_draft(
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }
  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UpdateNameResponse.draft)
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateNameResponse::release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* released = _impl_.draft_;
  _impl_.draft_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateNameResponse::unsafe_arena_release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateNameResponse.draft)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* temp = _impl_.draft_;
  _impl_.draft_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateNameResponse::_internal_mutable_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterDraft>(GetArena());
    _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(p);
  }
  return _impl_.draft_;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateNameResponse::mutable_draft()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* _msg = _internal_mutable_draft();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateNameResponse.draft)
  return _msg;
}
inline void UpdateNameResponse::set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateNameResponse.draft)
}

// repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
inline int UpdateNameResponse::_internal_warnings_size() const {
  return _internal_warnings().size();
}
inline int UpdateNameResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateNameResponse::mutable_warnings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateNameResponse.warnings)
  return _internal_mutable_warnings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL UpdateNameResponse::mutable_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateNameResponse.warnings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_warnings();
}
inline const ::dnd5e::api::v1alpha1::ValidationWarning& UpdateNameResponse::warnings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateNameResponse.warnings)
  return _internal_warnings().Get(index);
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateNameResponse::add_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ValidationWarning* _add = _internal_mutable_warnings()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateNameResponse.warnings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& UpdateNameResponse::warnings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateNameResponse.warnings)
  return _internal_warnings();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>&
UpdateNameResponse::_internal_warnings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.warnings_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL
UpdateNameResponse::_internal_mutable_warnings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.warnings_;
}

// -------------------------------------------------------------------

// UpdateRaceResponse

// .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
inline bool UpdateRaceResponse::has_draft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.draft_ != nullptr);
  return value;
}
inline void UpdateRaceResponse::clear_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ != nullptr) _impl_.draft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateRaceResponse::_internal_draft() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterDraft* p = _impl_.draft_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterDraft&>(::dnd5e::api::v1alpha1::_CharacterDraft_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateRaceResponse::draft() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateRaceResponse.draft)
  return _internal_draft();
}
inline void UpdateRaceResponse::unsafe_arena_set_allocated_draft(
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }
  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UpdateRaceResponse.draft)
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateRaceResponse::release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* released = _impl_.draft_;
  _impl_.draft_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateRaceResponse::unsafe_arena_release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateRaceResponse.draft)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* temp = _impl_.draft_;
  _impl_.draft_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateRaceResponse::_internal_mutable_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterDraft>(GetArena());
    _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(p);
  }
  return _impl_.draft_;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateRaceResponse::mutable_draft()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* _msg = _internal_mutable_draft();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateRaceResponse.draft)
  return _msg;
}
inline void UpdateRaceResponse::set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateRaceResponse.draft)
}

// repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
inline int UpdateRaceResponse::_internal_warnings_size() const {
  return _internal_warnings().size();
}
inline int UpdateRaceResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateRaceResponse::mutable_warnings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateRaceResponse.warnings)
  return _internal_mutable_warnings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL UpdateRaceResponse::mutable_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateRaceResponse.warnings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_warnings();
}
inline const ::dnd5e::api::v1alpha1::ValidationWarning& UpdateRaceResponse::warnings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateRaceResponse.warnings)
  return _internal_warnings().Get(index);
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateRaceResponse::add_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ValidationWarning* _add = _internal_mutable_warnings()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateRaceResponse.warnings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& UpdateRaceResponse::warnings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateRaceResponse.warnings)
  return _internal_warnings();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>&
UpdateRaceResponse::_internal_warnings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.warnings_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL
UpdateRaceResponse::_internal_mutable_warnings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.warnings_;
}

// -------------------------------------------------------------------

// UpdateClassResponse

// .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
inline bool UpdateClassResponse::has_draft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.draft_ != nullptr);
  return value;
}
inline void UpdateClassResponse::clear_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ != nullptr) _impl_.draft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateClassResponse::_internal_draft() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterDraft* p = _impl_.draft_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterDraft&>(::dnd5e::api::v1alpha1::_CharacterDraft_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateClassResponse::draft() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateClassResponse.draft)
  return _internal_draft();
}
inline void UpdateClassResponse::unsafe_arena_set_allocated_draft(
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }
  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UpdateClassResponse.draft)
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateClassResponse::release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* released = _impl_.draft_;
  _impl_.draft_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateClassResponse::unsafe_arena_release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateClassResponse.draft)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* temp = _impl_.draft_;
  _impl_.draft_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateClassResponse::_internal_mutable_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterDraft>(GetArena());
    _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(p);
  }
  return _impl_.draft_;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateClassResponse::mutable_draft()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* _msg = _internal_mutable_draft();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateClassResponse.draft)
  return _msg;
}
inline void UpdateClassResponse::set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateClassResponse.draft)
}

// repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
inline int UpdateClassResponse::_internal_warnings_size() const {
  return _internal_warnings().size();
}
inline int UpdateClassResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateClassResponse::mutable_warnings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateClassResponse.warnings)
  return _internal_mutable_warnings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL UpdateClassResponse::mutable_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateClassResponse.warnings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_warnings();
}
inline const ::dnd5e::api::v1alpha1::ValidationWarning& UpdateClassResponse::warnings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateClassResponse.warnings)
  return _internal_warnings().Get(index);
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateClassResponse::add_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ValidationWarning* _add = _internal_mutable_warnings()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateClassResponse.warnings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& UpdateClassResponse::warnings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateClassResponse.warnings)
  return _internal_warnings();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>&
UpdateClassResponse::_internal_warnings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.warnings_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL
UpdateClassResponse::_internal_mutable_warnings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.warnings_;
}

// -------------------------------------------------------------------

// UpdateBackgroundResponse

// .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
inline bool UpdateBackgroundResponse::has_draft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.draft_ != nullptr);
  return value;
}
inline void UpdateBackgroundResponse::clear_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ != nullptr) _impl_.draft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateBackgroundResponse::_internal_draft() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterDraft* p = _impl_.draft_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterDraft&>(::dnd5e::api::v1alpha1::_CharacterDraft_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateBackgroundResponse::draft() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateBackgroundResponse.draft)
  return _internal_draft();
}
inline void UpdateBackgroundResponse::unsafe_arena_set_allocated_draft(
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }
  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UpdateBackgroundResponse.draft)
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateBackgroundResponse::release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* released = _impl_.draft_;
  _impl_.draft_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateBackgroundResponse::unsafe_arena_release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateBackgroundResponse.draft)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* temp = _impl_.draft_;
  _impl_.draft_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateBackgroundResponse::_internal_mutable_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterDraft>(GetArena());
    _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(p);
  }
  return _impl_.draft_;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateBackgroundResponse::mutable_draft()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* _msg = _internal_mutable_draft();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateBackgroundResponse.draft)
  return _msg;
}
inline void UpdateBackgroundResponse::set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateBackgroundResponse.draft)
}

// repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
inline int UpdateBackgroundResponse::_internal_warnings_size() const {
  return _internal_warnings().size();
}
inline int UpdateBackgroundResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateBackgroundResponse::mutable_warnings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateBackgroundResponse.warnings)
  return _internal_mutable_warnings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL UpdateBackgroundResponse::mutable_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateBackgroundResponse.warnings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_warnings();
}
inline const ::dnd5e::api::v1alpha1::ValidationWarning& UpdateBackgroundResponse::warnings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateBackgroundResponse.warnings)
  return _internal_warnings().Get(index);
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateBackgroundResponse::add_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ValidationWarning* _add = _internal_mutable_warnings()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateBackgroundResponse.warnings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& UpdateBackgroundResponse::warnings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateBackgroundResponse.warnings)
  return _internal_warnings();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>&
UpdateBackgroundResponse::_internal_warnings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.warnings_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL
UpdateBackgroundResponse::_internal_mutable_warnings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.warnings_;
}

// -------------------------------------------------------------------

// UpdateAbilityScoresResponse

// .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
inline bool UpdateAbilityScoresResponse::has_draft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.draft_ != nullptr);
  return value;
}
inline void UpdateAbilityScoresResponse::clear_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ != nullptr) _impl_.draft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateAbilityScoresResponse::_internal_draft() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterDraft* p = _impl_.draft_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterDraft&>(::dnd5e::api::v1alpha1::_CharacterDraft_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateAbilityScoresResponse::draft() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateAbilityScoresResponse.draft)
  return _internal_draft();
}
inline void UpdateAbilityScoresResponse::unsafe_arena_set_allocated_draft(
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }
  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UpdateAbilityScoresResponse.draft)
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateAbilityScoresResponse::release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* released = _impl_.draft_;
  _impl_.draft_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateAbilityScoresResponse::unsafe_arena_release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateAbilityScoresResponse.draft)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* temp = _impl_.draft_;
  _impl_.draft_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateAbilityScoresResponse::_internal_mutable_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterDraft>(GetArena());
    _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(p);
  }
  return _impl_.draft_;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateAbilityScoresResponse::mutable_draft()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* _msg = _internal_mutable_draft();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateAbilityScoresResponse.draft)
  return _msg;
}
inline void UpdateAbilityScoresResponse::set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateAbilityScoresResponse.draft)
}

// repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
inline int UpdateAbilityScoresResponse::_internal_warnings_size() const {
  return _internal_warnings().size();
}
inline int UpdateAbilityScoresResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateAbilityScoresResponse::mutable_warnings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateAbilityScoresResponse.warnings)
  return _internal_mutable_warnings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL UpdateAbilityScoresResponse::mutable_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateAbilityScoresResponse.warnings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_warnings();
}
inline const ::dnd5e::api::v1alpha1::ValidationWarning& UpdateAbilityScoresResponse::warnings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateAbilityScoresResponse.warnings)
  return _internal_warnings().Get(index);
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateAbilityScoresResponse::add_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ValidationWarning* _add = _internal_mutable_warnings()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateAbilityScoresResponse.warnings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& UpdateAbilityScoresResponse::warnings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateAbilityScoresResponse.warnings)
  return _internal_warnings();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>&
UpdateAbilityScoresResponse::_internal_warnings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.warnings_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL
UpdateAbilityScoresResponse::_internal_mutable_warnings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.warnings_;
}

// -------------------------------------------------------------------

// UpdateSkillsResponse

// .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
inline bool UpdateSkillsResponse::has_draft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.draft_ != nullptr);
  return value;
}
inline void UpdateSkillsResponse::clear_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ != nullptr) _impl_.draft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateSkillsResponse::_internal_draft() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterDraft* p = _impl_.draft_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterDraft&>(::dnd5e::api::v1alpha1::_CharacterDraft_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& UpdateSkillsResponse::draft() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateSkillsResponse.draft)
  return _internal_draft();
}
inline void UpdateSkillsResponse::unsafe_arena_set_allocated_draft(
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }
  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UpdateSkillsResponse.draft)
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateSkillsResponse::release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* released = _impl_.draft_;
  _impl_.draft_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE UpdateSkillsResponse::unsafe_arena_release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UpdateSkillsResponse.draft)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* temp = _impl_.draft_;
  _impl_.draft_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateSkillsResponse::_internal_mutable_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterDraft>(GetArena());
    _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(p);
  }
  return _impl_.draft_;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL UpdateSkillsResponse::mutable_draft()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* _msg = _internal_mutable_draft();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateSkillsResponse.draft)
  return _msg;
}
inline void UpdateSkillsResponse::set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UpdateSkillsResponse.draft)
}

// repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 2 [json_name = "warnings"];
inline int UpdateSkillsResponse::_internal_warnings_size() const {
  return _internal_warnings().size();
}
inline int UpdateSkillsResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateSkillsResponse::mutable_warnings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UpdateSkillsResponse.warnings)
  return _internal_mutable_warnings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL UpdateSkillsResponse::mutable_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.UpdateSkillsResponse.warnings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_warnings();
}
inline const ::dnd5e::api::v1alpha1::ValidationWarning& UpdateSkillsResponse::warnings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UpdateSkillsResponse.warnings)
  return _internal_warnings().Get(index);
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL UpdateSkillsResponse::add_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ValidationWarning* _add = _internal_mutable_warnings()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.UpdateSkillsResponse.warnings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& UpdateSkillsResponse::warnings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.UpdateSkillsResponse.warnings)
  return _internal_warnings();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>&
UpdateSkillsResponse::_internal_warnings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.warnings_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL
UpdateSkillsResponse::_internal_mutable_warnings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.warnings_;
}

// -------------------------------------------------------------------

// ListDraftsRequest

// string player_id = 1 [json_name = "playerId"];
inline void ListDraftsRequest::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListDraftsRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListDraftsRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListDraftsRequest::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListDraftsRequest.player_id)
}
inline ::std::string* PROTOBUF_NONNULL ListDraftsRequest::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListDraftsRequest.player_id)
  return _s;
}
inline const ::std::string& ListDraftsRequest::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void ListDraftsRequest::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListDraftsRequest::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListDraftsRequest::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListDraftsRequest.player_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void ListDraftsRequest::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListDraftsRequest.player_id)
}

// string session_id = 2 [json_name = "sessionId"];
inline void ListDraftsRequest::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& ListDraftsRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListDraftsRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListDraftsRequest::set_session_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListDraftsRequest.session_id)
}
inline ::std::string* PROTOBUF_NONNULL ListDraftsRequest::mutable_session_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListDraftsRequest.session_id)
  return _s;
}
inline const ::std::string& ListDraftsRequest::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void ListDraftsRequest::_internal_set_session_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListDraftsRequest::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.session_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListDraftsRequest::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListDraftsRequest.session_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.session_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.session_id_.Set("", GetArena());
  }
  return released;
}
inline void ListDraftsRequest::set_allocated_session_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.session_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListDraftsRequest.session_id)
}

// int32 page_size = 3 [json_name = "pageSize"];
inline void ListDraftsRequest::clear_page_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t ListDraftsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListDraftsRequest.page_size)
  return _internal_page_size();
}
inline void ListDraftsRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListDraftsRequest.page_size)
}
inline ::int32_t ListDraftsRequest::_internal_page_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_size_;
}
inline void ListDraftsRequest::_internal_set_page_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = value;
}

// string page_token = 4 [json_name = "pageToken"];
inline void ListDraftsRequest::clear_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& ListDraftsRequest::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListDraftsRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListDraftsRequest::set_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListDraftsRequest.page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListDraftsRequest::mutable_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListDraftsRequest.page_token)
  return _s;
}
inline const ::std::string& ListDraftsRequest::_internal_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_token_.Get();
}
inline void ListDraftsRequest::_internal_set_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListDraftsRequest::_internal_mutable_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListDraftsRequest::release_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListDraftsRequest.page_token)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListDraftsRequest::set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListDraftsRequest.page_token)
}

// -------------------------------------------------------------------

// ListDraftsResponse

// repeated .dnd5e.api.v1alpha1.CharacterDraft drafts = 1 [json_name = "drafts"];
inline int ListDraftsResponse::_internal_drafts_size() const {
  return _internal_drafts().size();
}
inline int ListDraftsResponse::drafts_size() const {
  return _internal_drafts_size();
}
inline void ListDraftsResponse::clear_drafts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.drafts_.Clear();
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL ListDraftsResponse::mutable_drafts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListDraftsResponse.drafts)
  return _internal_mutable_drafts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::CharacterDraft>* PROTOBUF_NONNULL ListDraftsResponse::mutable_drafts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ListDraftsResponse.drafts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_drafts();
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& ListDraftsResponse::drafts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListDraftsResponse.drafts)
  return _internal_drafts().Get(index);
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL ListDraftsResponse::add_drafts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::CharacterDraft* _add = _internal_mutable_drafts()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ListDraftsResponse.drafts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::CharacterDraft>& ListDraftsResponse::drafts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ListDraftsResponse.drafts)
  return _internal_drafts();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::CharacterDraft>&
ListDraftsResponse::_internal_drafts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.drafts_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::CharacterDraft>* PROTOBUF_NONNULL
ListDraftsResponse::_internal_mutable_drafts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.drafts_;
}

// string next_page_token = 2 [json_name = "nextPageToken"];
inline void ListDraftsResponse::clear_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListDraftsResponse::next_page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListDraftsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListDraftsResponse::set_next_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListDraftsResponse.next_page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListDraftsResponse::mutable_next_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListDraftsResponse.next_page_token)
  return _s;
}
inline const ::std::string& ListDraftsResponse::_internal_next_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_page_token_.Get();
}
inline void ListDraftsResponse::_internal_set_next_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListDraftsResponse::_internal_mutable_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.next_page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListDraftsResponse::release_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListDraftsResponse.next_page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.next_page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListDraftsResponse::set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.next_page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListDraftsResponse.next_page_token)
}

// -------------------------------------------------------------------

// ValidateDraftRequest

// string draft_id = 1 [json_name = "draftId"];
inline void ValidateDraftRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ValidateDraftRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ValidateDraftRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ValidateDraftRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ValidateDraftRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL ValidateDraftRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ValidateDraftRequest.draft_id)
  return _s;
}
inline const ::std::string& ValidateDraftRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void ValidateDraftRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ValidateDraftRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ValidateDraftRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ValidateDraftRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void ValidateDraftRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ValidateDraftRequest.draft_id)
}

// -------------------------------------------------------------------

// ValidateDraftResponse

// bool is_complete = 1 [json_name = "isComplete"];
inline void ValidateDraftResponse::clear_is_complete() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_complete_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ValidateDraftResponse::is_complete() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ValidateDraftResponse.is_complete)
  return _internal_is_complete();
}
inline void ValidateDraftResponse::set_is_complete(bool value) {
  _internal_set_is_complete(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ValidateDraftResponse.is_complete)
}
inline bool ValidateDraftResponse::_internal_is_complete() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_complete_;
}
inline void ValidateDraftResponse::_internal_set_is_complete(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_complete_ = value;
}

// bool is_valid = 2 [json_name = "isValid"];
inline void ValidateDraftResponse::clear_is_valid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_valid_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ValidateDraftResponse::is_valid() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ValidateDraftResponse.is_valid)
  return _internal_is_valid();
}
inline void ValidateDraftResponse::set_is_valid(bool value) {
  _internal_set_is_valid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ValidateDraftResponse.is_valid)
}
inline bool ValidateDraftResponse::_internal_is_valid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_valid_;
}
inline void ValidateDraftResponse::_internal_set_is_valid(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_valid_ = value;
}

// repeated .dnd5e.api.v1alpha1.ValidationError errors = 3 [json_name = "errors"];
inline int ValidateDraftResponse::_internal_errors_size() const {
  return _internal_errors().size();
}
inline int ValidateDraftResponse::errors_size() const {
  return _internal_errors_size();
}
inline ::dnd5e::api::v1alpha1::ValidationError* PROTOBUF_NONNULL ValidateDraftResponse::mutable_errors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ValidateDraftResponse.errors)
  return _internal_mutable_errors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>* PROTOBUF_NONNULL ValidateDraftResponse::mutable_errors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ValidateDraftResponse.errors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_errors();
}
inline const ::dnd5e::api::v1alpha1::ValidationError& ValidateDraftResponse::errors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ValidateDraftResponse.errors)
  return _internal_errors().Get(index);
}
inline ::dnd5e::api::v1alpha1::ValidationError* PROTOBUF_NONNULL ValidateDraftResponse::add_errors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ValidationError* _add = _internal_mutable_errors()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ValidateDraftResponse.errors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>& ValidateDraftResponse::errors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ValidateDraftResponse.errors)
  return _internal_errors();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>&
ValidateDraftResponse::_internal_errors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.errors_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>* PROTOBUF_NONNULL
ValidateDraftResponse::_internal_mutable_errors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.errors_;
}

// repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 4 [json_name = "warnings"];
inline int ValidateDraftResponse::_internal_warnings_size() const {
  return _internal_warnings().size();
}
inline int ValidateDraftResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL ValidateDraftResponse::mutable_warnings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ValidateDraftResponse.warnings)
  return _internal_mutable_warnings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL ValidateDraftResponse::mutable_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ValidateDraftResponse.warnings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_warnings();
}
inline const ::dnd5e::api::v1alpha1::ValidationWarning& ValidateDraftResponse::warnings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ValidateDraftResponse.warnings)
  return _internal_warnings().Get(index);
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL ValidateDraftResponse::add_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ValidationWarning* _add = _internal_mutable_warnings()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ValidateDraftResponse.warnings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& ValidateDraftResponse::warnings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ValidateDraftResponse.warnings)
  return _internal_warnings();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>&
ValidateDraftResponse::_internal_warnings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.warnings_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL
ValidateDraftResponse::_internal_mutable_warnings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.warnings_;
}

// repeated .dnd5e.api.v1alpha1.CreationStep missing_steps = 5 [json_name = "missingSteps"];
inline int ValidateDraftResponse::_internal_missing_steps_size() const {
  return _internal_missing_steps().size();
}
inline int ValidateDraftResponse::missing_steps_size() const {
  return _internal_missing_steps_size();
}
inline void ValidateDraftResponse::clear_missing_steps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.missing_steps_.Clear();
}
inline ::dnd5e::api::v1alpha1::CreationStep ValidateDraftResponse::missing_steps(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ValidateDraftResponse.missing_steps)
  return static_cast<::dnd5e::api::v1alpha1::CreationStep>(_internal_missing_steps().Get(index));
}
inline void ValidateDraftResponse::set_missing_steps(int index, ::dnd5e::api::v1alpha1::CreationStep value) {
  _internal_mutable_missing_steps()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ValidateDraftResponse.missing_steps)
}
inline void ValidateDraftResponse::add_missing_steps(::dnd5e::api::v1alpha1::CreationStep value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_missing_steps()->Add(value);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ValidateDraftResponse.missing_steps)
}
inline const ::google::protobuf::RepeatedField<int>& ValidateDraftResponse::missing_steps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ValidateDraftResponse.missing_steps)
  return _internal_missing_steps();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL ValidateDraftResponse::mutable_missing_steps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ValidateDraftResponse.missing_steps)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_missing_steps();
}
inline const ::google::protobuf::RepeatedField<int>& ValidateDraftResponse::_internal_missing_steps()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.missing_steps_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
ValidateDraftResponse::_internal_mutable_missing_steps() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.missing_steps_;
}

// -------------------------------------------------------------------

// GetDraftPreviewRequest

// string draft_id = 1 [json_name = "draftId"];
inline void GetDraftPreviewRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetDraftPreviewRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetDraftPreviewRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetDraftPreviewRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetDraftPreviewRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL GetDraftPreviewRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetDraftPreviewRequest.draft_id)
  return _s;
}
inline const ::std::string& GetDraftPreviewRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void GetDraftPreviewRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetDraftPreviewRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetDraftPreviewRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetDraftPreviewRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void GetDraftPreviewRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetDraftPreviewRequest.draft_id)
}

// -------------------------------------------------------------------

// GetDraftPreviewResponse

// .dnd5e.api.v1alpha1.CharacterDraft draft = 1 [json_name = "draft"];
inline bool GetDraftPreviewResponse::has_draft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.draft_ != nullptr);
  return value;
}
inline void GetDraftPreviewResponse::clear_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ != nullptr) _impl_.draft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& GetDraftPreviewResponse::_internal_draft() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CharacterDraft* p = _impl_.draft_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CharacterDraft&>(::dnd5e::api::v1alpha1::_CharacterDraft_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CharacterDraft& GetDraftPreviewResponse::draft() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetDraftPreviewResponse.draft)
  return _internal_draft();
}
inline void GetDraftPreviewResponse::unsafe_arena_set_allocated_draft(
    ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }
  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetDraftPreviewResponse.draft)
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE GetDraftPreviewResponse::release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* released = _impl_.draft_;
  _impl_.draft_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE GetDraftPreviewResponse::unsafe_arena_release_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetDraftPreviewResponse.draft)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* temp = _impl_.draft_;
  _impl_.draft_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL GetDraftPreviewResponse::_internal_mutable_draft() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.draft_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CharacterDraft>(GetArena());
    _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(p);
  }
  return _impl_.draft_;
}
inline ::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NONNULL GetDraftPreviewResponse::mutable_draft()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::CharacterDraft* _msg = _internal_mutable_draft();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetDraftPreviewResponse.draft)
  return _msg;
}
inline void GetDraftPreviewResponse::set_allocated_draft(::dnd5e::api::v1alpha1::CharacterDraft* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.draft_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.draft_ = reinterpret_cast<::dnd5e::api::v1alpha1::CharacterDraft*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetDraftPreviewResponse.draft)
}

// .dnd5e.api.v1alpha1.Character preview = 2 [json_name = "preview"];
inline bool GetDraftPreviewResponse::has_preview() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.preview_ != nullptr);
  return value;
}
inline void GetDraftPreviewResponse::clear_preview() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.preview_ != nullptr) _impl_.preview_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dnd5e::api::v1alpha1::Character& GetDraftPreviewResponse::_internal_preview() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.preview_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& GetDraftPreviewResponse::preview() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetDraftPreviewResponse.preview)
  return _internal_preview();
}
inline void GetDraftPreviewResponse::unsafe_arena_set_allocated_preview(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.preview_);
  }
  _impl_.preview_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetDraftPreviewResponse.preview)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE GetDraftPreviewResponse::release_preview() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::Character* released = _impl_.preview_;
  _impl_.preview_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE GetDraftPreviewResponse::unsafe_arena_release_preview() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetDraftPreviewResponse.preview)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.preview_;
  _impl_.preview_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL GetDraftPreviewResponse::_internal_mutable_preview() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.preview_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.preview_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.preview_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL GetDraftPreviewResponse::mutable_preview()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_preview();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetDraftPreviewResponse.preview)
  return _msg;
}
inline void GetDraftPreviewResponse::set_allocated_preview(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.preview_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.preview_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetDraftPreviewResponse.preview)
}

// repeated .dnd5e.api.v1alpha1.ValidationWarning warnings = 3 [json_name = "warnings"];
inline int GetDraftPreviewResponse::_internal_warnings_size() const {
  return _internal_warnings().size();
}
inline int GetDraftPreviewResponse::warnings_size() const {
  return _internal_warnings_size();
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL GetDraftPreviewResponse::mutable_warnings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetDraftPreviewResponse.warnings)
  return _internal_mutable_warnings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL GetDraftPreviewResponse::mutable_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.GetDraftPreviewResponse.warnings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_warnings();
}
inline const ::dnd5e::api::v1alpha1::ValidationWarning& GetDraftPreviewResponse::warnings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetDraftPreviewResponse.warnings)
  return _internal_warnings().Get(index);
}
inline ::dnd5e::api::v1alpha1::ValidationWarning* PROTOBUF_NONNULL GetDraftPreviewResponse::add_warnings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ValidationWarning* _add = _internal_mutable_warnings()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.GetDraftPreviewResponse.warnings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>& GetDraftPreviewResponse::warnings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.GetDraftPreviewResponse.warnings)
  return _internal_warnings();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>&
GetDraftPreviewResponse::_internal_warnings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.warnings_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationWarning>* PROTOBUF_NONNULL
GetDraftPreviewResponse::_internal_mutable_warnings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.warnings_;
}

// repeated .dnd5e.api.v1alpha1.ValidationError errors = 4 [json_name = "errors"];
inline int GetDraftPreviewResponse::_internal_errors_size() const {
  return _internal_errors().size();
}
inline int GetDraftPreviewResponse::errors_size() const {
  return _internal_errors_size();
}
inline ::dnd5e::api::v1alpha1::ValidationError* PROTOBUF_NONNULL GetDraftPreviewResponse::mutable_errors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetDraftPreviewResponse.errors)
  return _internal_mutable_errors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>* PROTOBUF_NONNULL GetDraftPreviewResponse::mutable_errors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.GetDraftPreviewResponse.errors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_errors();
}
inline const ::dnd5e::api::v1alpha1::ValidationError& GetDraftPreviewResponse::errors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetDraftPreviewResponse.errors)
  return _internal_errors().Get(index);
}
inline ::dnd5e::api::v1alpha1::ValidationError* PROTOBUF_NONNULL GetDraftPreviewResponse::add_errors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ValidationError* _add = _internal_mutable_errors()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.GetDraftPreviewResponse.errors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>& GetDraftPreviewResponse::errors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.GetDraftPreviewResponse.errors)
  return _internal_errors();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>&
GetDraftPreviewResponse::_internal_errors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.errors_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ValidationError>* PROTOBUF_NONNULL
GetDraftPreviewResponse::_internal_mutable_errors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.errors_;
}

// -------------------------------------------------------------------

// FinalizeDraftRequest

// string draft_id = 1 [json_name = "draftId"];
inline void FinalizeDraftRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& FinalizeDraftRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FinalizeDraftRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FinalizeDraftRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FinalizeDraftRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL FinalizeDraftRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.FinalizeDraftRequest.draft_id)
  return _s;
}
inline const ::std::string& FinalizeDraftRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void FinalizeDraftRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FinalizeDraftRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FinalizeDraftRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.FinalizeDraftRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void FinalizeDraftRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.FinalizeDraftRequest.draft_id)
}

// -------------------------------------------------------------------

// FinalizeDraftResponse

// .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
inline bool FinalizeDraftResponse::has_character() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.character_ != nullptr);
  return value;
}
inline void FinalizeDraftResponse::clear_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ != nullptr) _impl_.character_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::Character& FinalizeDraftResponse::_internal_character() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.character_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& FinalizeDraftResponse::character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FinalizeDraftResponse.character)
  return _internal_character();
}
inline void FinalizeDraftResponse::unsafe_arena_set_allocated_character(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }
  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.FinalizeDraftResponse.character)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE FinalizeDraftResponse::release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* released = _impl_.character_;
  _impl_.character_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE FinalizeDraftResponse::unsafe_arena_release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.FinalizeDraftResponse.character)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.character_;
  _impl_.character_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL FinalizeDraftResponse::_internal_mutable_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.character_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL FinalizeDraftResponse::mutable_character()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.FinalizeDraftResponse.character)
  return _msg;
}
inline void FinalizeDraftResponse::set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.FinalizeDraftResponse.character)
}

// bool draft_deleted = 2 [json_name = "draftDeleted"];
inline void FinalizeDraftResponse::clear_draft_deleted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_deleted_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool FinalizeDraftResponse::draft_deleted() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FinalizeDraftResponse.draft_deleted)
  return _internal_draft_deleted();
}
inline void FinalizeDraftResponse::set_draft_deleted(bool value) {
  _internal_set_draft_deleted(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FinalizeDraftResponse.draft_deleted)
}
inline bool FinalizeDraftResponse::_internal_draft_deleted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_deleted_;
}
inline void FinalizeDraftResponse::_internal_set_draft_deleted(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_deleted_ = value;
}

// -------------------------------------------------------------------

// DeleteDraftRequest

// string draft_id = 1 [json_name = "draftId"];
inline void DeleteDraftRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DeleteDraftRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DeleteDraftRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeleteDraftRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DeleteDraftRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL DeleteDraftRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DeleteDraftRequest.draft_id)
  return _s;
}
inline const ::std::string& DeleteDraftRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void DeleteDraftRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DeleteDraftRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DeleteDraftRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DeleteDraftRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void DeleteDraftRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DeleteDraftRequest.draft_id)
}

// -------------------------------------------------------------------

// DeleteDraftResponse

// string message = 1 [json_name = "message"];
inline void DeleteDraftResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DeleteDraftResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DeleteDraftResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeleteDraftResponse::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DeleteDraftResponse.message)
}
inline ::std::string* PROTOBUF_NONNULL DeleteDraftResponse::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DeleteDraftResponse.message)
  return _s;
}
inline const ::std::string& DeleteDraftResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void DeleteDraftResponse::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DeleteDraftResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DeleteDraftResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DeleteDraftResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void DeleteDraftResponse::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DeleteDraftResponse.message)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RaceInfo

// string id = 1 [json_name = "id"];
inline void RaceInfo::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& RaceInfo::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RaceInfo::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RaceInfo.id)
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RaceInfo.id)
  return _s;
}
inline const ::std::string& RaceInfo::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void RaceInfo::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RaceInfo::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RaceInfo.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void RaceInfo::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RaceInfo.id)
}

// string name = 2 [json_name = "name"];
inline void RaceInfo::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& RaceInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RaceInfo::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RaceInfo.name)
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RaceInfo.name)
  return _s;
}
inline const ::std::string& RaceInfo::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void RaceInfo::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RaceInfo::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RaceInfo.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void RaceInfo::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RaceInfo.name)
}

// string description = 3 [json_name = "description"];
inline void RaceInfo::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& RaceInfo::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RaceInfo::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RaceInfo.description)
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RaceInfo.description)
  return _s;
}
inline const ::std::string& RaceInfo::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void RaceInfo::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RaceInfo::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RaceInfo.description)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void RaceInfo::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RaceInfo.description)
}

// int32 speed = 4 [json_name = "speed"];
inline void RaceInfo::clear_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t RaceInfo::speed() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.speed)
  return _internal_speed();
}
inline void RaceInfo::set_speed(::int32_t value) {
  _internal_set_speed(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RaceInfo.speed)
}
inline ::int32_t RaceInfo::_internal_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_;
}
inline void RaceInfo::_internal_set_speed(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = value;
}

// .dnd5e.api.v1alpha1.Size size = 5 [json_name = "size"];
inline void RaceInfo::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::dnd5e::api::v1alpha1::Size RaceInfo::size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.size)
  return _internal_size();
}
inline void RaceInfo::set_size(::dnd5e::api::v1alpha1::Size value) {
  _internal_set_size(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RaceInfo.size)
}
inline ::dnd5e::api::v1alpha1::Size RaceInfo::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Size>(_impl_.size_);
}
inline void RaceInfo::_internal_set_size(::dnd5e::api::v1alpha1::Size value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// map<string, int32> ability_bonuses = 6 [json_name = "abilityBonuses"];
inline int RaceInfo::_internal_ability_bonuses_size() const {
  return _internal_ability_bonuses().size();
}
inline int RaceInfo::ability_bonuses_size() const {
  return _internal_ability_bonuses_size();
}
inline void RaceInfo::clear_ability_bonuses() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ability_bonuses_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& RaceInfo::_internal_ability_bonuses() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ability_bonuses_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& RaceInfo::ability_bonuses() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:dnd5e.api.v1alpha1.RaceInfo.ability_bonuses)
  return _internal_ability_bonuses();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* PROTOBUF_NONNULL RaceInfo::_internal_mutable_ability_bonuses() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ability_bonuses_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* PROTOBUF_NONNULL RaceInfo::mutable_ability_bonuses()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:dnd5e.api.v1alpha1.RaceInfo.ability_bonuses)
  return _internal_mutable_ability_bonuses();
}

// repeated .dnd5e.api.v1alpha1.RacialTrait traits = 7 [json_name = "traits"];
inline int RaceInfo::_internal_traits_size() const {
  return _internal_traits().size();
}
inline int RaceInfo::traits_size() const {
  return _internal_traits_size();
}
inline void RaceInfo::clear_traits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.traits_.Clear();
}
inline ::dnd5e::api::v1alpha1::RacialTrait* PROTOBUF_NONNULL RaceInfo::mutable_traits(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RaceInfo.traits)
  return _internal_mutable_traits()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>* PROTOBUF_NONNULL RaceInfo::mutable_traits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.RaceInfo.traits)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_traits();
}
inline const ::dnd5e::api::v1alpha1::RacialTrait& RaceInfo::traits(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.traits)
  return _internal_traits().Get(index);
}
inline ::dnd5e::api::v1alpha1::RacialTrait* PROTOBUF_NONNULL RaceInfo::add_traits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::RacialTrait* _add = _internal_mutable_traits()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.RaceInfo.traits)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>& RaceInfo::traits() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.RaceInfo.traits)
  return _internal_traits();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>&
RaceInfo::_internal_traits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.traits_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>* PROTOBUF_NONNULL
RaceInfo::_internal_mutable_traits() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.traits_;
}

// repeated .dnd5e.api.v1alpha1.SubraceInfo subraces = 8 [json_name = "subraces"];
inline int RaceInfo::_internal_subraces_size() const {
  return _internal_subraces().size();
}
inline int RaceInfo::subraces_size() const {
  return _internal_subraces_size();
}
inline void RaceInfo::clear_subraces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subraces_.Clear();
}
inline ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NONNULL RaceInfo::mutable_subraces(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RaceInfo.subraces)
  return _internal_mutable_subraces()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::SubraceInfo>* PROTOBUF_NONNULL RaceInfo::mutable_subraces()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.RaceInfo.subraces)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_subraces();
}
inline const ::dnd5e::api::v1alpha1::SubraceInfo& RaceInfo::subraces(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.subraces)
  return _internal_subraces().Get(index);
}
inline ::dnd5e::api::v1alpha1::SubraceInfo* PROTOBUF_NONNULL RaceInfo::add_subraces()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::SubraceInfo* _add = _internal_mutable_subraces()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.RaceInfo.subraces)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::SubraceInfo>& RaceInfo::subraces() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.RaceInfo.subraces)
  return _internal_subraces();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::SubraceInfo>&
RaceInfo::_internal_subraces() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subraces_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::SubraceInfo>* PROTOBUF_NONNULL
RaceInfo::_internal_mutable_subraces() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.subraces_;
}

// repeated string proficiencies = 9 [json_name = "proficiencies"];
inline int RaceInfo::_internal_proficiencies_size() const {
  return _internal_proficiencies().size();
}
inline int RaceInfo::proficiencies_size() const {
  return _internal_proficiencies_size();
}
inline void RaceInfo::clear_proficiencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proficiencies_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::add_proficiencies()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_proficiencies()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.RaceInfo.proficiencies)
  return _s;
}
inline const ::std::string& RaceInfo::proficiencies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.proficiencies)
  return _internal_proficiencies().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::mutable_proficiencies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RaceInfo.proficiencies)
  return _internal_mutable_proficiencies()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void RaceInfo::set_proficiencies(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_proficiencies()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RaceInfo.proficiencies)
}
template <typename Arg_, typename... Args_>
inline void RaceInfo::add_proficiencies(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_proficiencies(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.RaceInfo.proficiencies)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& RaceInfo::proficiencies()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.RaceInfo.proficiencies)
  return _internal_proficiencies();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
RaceInfo::mutable_proficiencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.RaceInfo.proficiencies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_proficiencies();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
RaceInfo::_internal_proficiencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.proficiencies_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
RaceInfo::_internal_mutable_proficiencies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.proficiencies_;
}

// repeated .dnd5e.api.v1alpha1.Language languages = 10 [json_name = "languages"];
inline int RaceInfo::_internal_languages_size() const {
  return _internal_languages().size();
}
inline int RaceInfo::languages_size() const {
  return _internal_languages_size();
}
inline void RaceInfo::clear_languages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.languages_.Clear();
}
inline ::dnd5e::api::v1alpha1::Language RaceInfo::languages(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.languages)
  return static_cast<::dnd5e::api::v1alpha1::Language>(_internal_languages().Get(index));
}
inline void RaceInfo::set_languages(int index, ::dnd5e::api::v1alpha1::Language value) {
  _internal_mutable_languages()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RaceInfo.languages)
}
inline void RaceInfo::add_languages(::dnd5e::api::v1alpha1::Language value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_languages()->Add(value);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.RaceInfo.languages)
}
inline const ::google::protobuf::RepeatedField<int>& RaceInfo::languages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.RaceInfo.languages)
  return _internal_languages();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL RaceInfo::mutable_languages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.RaceInfo.languages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_languages();
}
inline const ::google::protobuf::RepeatedField<int>& RaceInfo::_internal_languages()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.languages_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
RaceInfo::_internal_mutable_languages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.languages_;
}

// string age_description = 11 [json_name = "ageDescription"];
inline void RaceInfo::clear_age_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.age_description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& RaceInfo::age_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.age_description)
  return _internal_age_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RaceInfo::set_age_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.age_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RaceInfo.age_description)
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::mutable_age_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_age_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RaceInfo.age_description)
  return _s;
}
inline const ::std::string& RaceInfo::_internal_age_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.age_description_.Get();
}
inline void RaceInfo::_internal_set_age_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.age_description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::_internal_mutable_age_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.age_description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RaceInfo::release_age_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RaceInfo.age_description)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.age_description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.age_description_.Set("", GetArena());
  }
  return released;
}
inline void RaceInfo::set_allocated_age_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.age_description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.age_description_.IsDefault()) {
    _impl_.age_description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RaceInfo.age_description)
}

// string alignment_description = 12 [json_name = "alignmentDescription"];
inline void RaceInfo::clear_alignment_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alignment_description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& RaceInfo::alignment_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.alignment_description)
  return _internal_alignment_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RaceInfo::set_alignment_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.alignment_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RaceInfo.alignment_description)
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::mutable_alignment_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_alignment_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RaceInfo.alignment_description)
  return _s;
}
inline const ::std::string& RaceInfo::_internal_alignment_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alignment_description_.Get();
}
inline void RaceInfo::_internal_set_alignment_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.alignment_description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::_internal_mutable_alignment_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.alignment_description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RaceInfo::release_alignment_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RaceInfo.alignment_description)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.alignment_description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.alignment_description_.Set("", GetArena());
  }
  return released;
}
inline void RaceInfo::set_allocated_alignment_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.alignment_description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alignment_description_.IsDefault()) {
    _impl_.alignment_description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RaceInfo.alignment_description)
}

// string size_description = 13 [json_name = "sizeDescription"];
inline void RaceInfo::clear_size_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& RaceInfo::size_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.size_description)
  return _internal_size_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RaceInfo::set_size_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.size_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RaceInfo.size_description)
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::mutable_size_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_size_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RaceInfo.size_description)
  return _s;
}
inline const ::std::string& RaceInfo::_internal_size_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_description_.Get();
}
inline void RaceInfo::_internal_set_size_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.size_description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RaceInfo::_internal_mutable_size_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.size_description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RaceInfo::release_size_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RaceInfo.size_description)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.size_description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.size_description_.Set("", GetArena());
  }
  return released;
}
inline void RaceInfo::set_allocated_size_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.size_description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.size_description_.IsDefault()) {
    _impl_.size_description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RaceInfo.size_description)
}

// repeated .dnd5e.api.v1alpha1.Choice choices = 14 [json_name = "choices"];
inline int RaceInfo::_internal_choices_size() const {
  return _internal_choices().size();
}
inline int RaceInfo::choices_size() const {
  return _internal_choices_size();
}
inline void RaceInfo::clear_choices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choices_.Clear();
}
inline ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL RaceInfo::mutable_choices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RaceInfo.choices)
  return _internal_mutable_choices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>* PROTOBUF_NONNULL RaceInfo::mutable_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.RaceInfo.choices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_choices();
}
inline const ::dnd5e::api::v1alpha1::Choice& RaceInfo::choices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceInfo.choices)
  return _internal_choices().Get(index);
}
inline ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL RaceInfo::add_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::Choice* _add = _internal_mutable_choices()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.RaceInfo.choices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>& RaceInfo::choices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.RaceInfo.choices)
  return _internal_choices();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>&
RaceInfo::_internal_choices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.choices_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>* PROTOBUF_NONNULL
RaceInfo::_internal_mutable_choices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.choices_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SubraceInfo

// string id = 1 [json_name = "id"];
inline void SubraceInfo::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SubraceInfo::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SubraceInfo.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubraceInfo::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SubraceInfo.id)
}
inline ::std::string* PROTOBUF_NONNULL SubraceInfo::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SubraceInfo.id)
  return _s;
}
inline const ::std::string& SubraceInfo::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void SubraceInfo::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubraceInfo::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubraceInfo::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.SubraceInfo.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void SubraceInfo::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.SubraceInfo.id)
}

// string name = 2 [json_name = "name"];
inline void SubraceInfo::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& SubraceInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SubraceInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubraceInfo::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SubraceInfo.name)
}
inline ::std::string* PROTOBUF_NONNULL SubraceInfo::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SubraceInfo.name)
  return _s;
}
inline const ::std::string& SubraceInfo::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void SubraceInfo::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubraceInfo::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubraceInfo::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.SubraceInfo.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void SubraceInfo::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.SubraceInfo.name)
}

// string description = 3 [json_name = "description"];
inline void SubraceInfo::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& SubraceInfo::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SubraceInfo.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubraceInfo::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SubraceInfo.description)
}
inline ::std::string* PROTOBUF_NONNULL SubraceInfo::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SubraceInfo.description)
  return _s;
}
inline const ::std::string& SubraceInfo::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void SubraceInfo::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubraceInfo::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubraceInfo::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.SubraceInfo.description)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void SubraceInfo::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.SubraceInfo.description)
}

// map<string, int32> ability_bonuses = 4 [json_name = "abilityBonuses"];
inline int SubraceInfo::_internal_ability_bonuses_size() const {
  return _internal_ability_bonuses().size();
}
inline int SubraceInfo::ability_bonuses_size() const {
  return _internal_ability_bonuses_size();
}
inline void SubraceInfo::clear_ability_bonuses() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ability_bonuses_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& SubraceInfo::_internal_ability_bonuses() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ability_bonuses_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& SubraceInfo::ability_bonuses() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:dnd5e.api.v1alpha1.SubraceInfo.ability_bonuses)
  return _internal_ability_bonuses();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* PROTOBUF_NONNULL SubraceInfo::_internal_mutable_ability_bonuses() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ability_bonuses_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* PROTOBUF_NONNULL SubraceInfo::mutable_ability_bonuses()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:dnd5e.api.v1alpha1.SubraceInfo.ability_bonuses)
  return _internal_mutable_ability_bonuses();
}

// repeated .dnd5e.api.v1alpha1.RacialTrait traits = 5 [json_name = "traits"];
inline int SubraceInfo::_internal_traits_size() const {
  return _internal_traits().size();
}
inline int SubraceInfo::traits_size() const {
  return _internal_traits_size();
}
inline void SubraceInfo::clear_traits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.traits_.Clear();
}
inline ::dnd5e::api::v1alpha1::RacialTrait* PROTOBUF_NONNULL SubraceInfo::mutable_traits(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SubraceInfo.traits)
  return _internal_mutable_traits()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>* PROTOBUF_NONNULL SubraceInfo::mutable_traits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.SubraceInfo.traits)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_traits();
}
inline const ::dnd5e::api::v1alpha1::RacialTrait& SubraceInfo::traits(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SubraceInfo.traits)
  return _internal_traits().Get(index);
}
inline ::dnd5e::api::v1alpha1::RacialTrait* PROTOBUF_NONNULL SubraceInfo::add_traits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::RacialTrait* _add = _internal_mutable_traits()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.SubraceInfo.traits)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>& SubraceInfo::traits() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.SubraceInfo.traits)
  return _internal_traits();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>&
SubraceInfo::_internal_traits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.traits_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RacialTrait>* PROTOBUF_NONNULL
SubraceInfo::_internal_mutable_traits() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.traits_;
}

// repeated .dnd5e.api.v1alpha1.Language languages = 6 [json_name = "languages"];
inline int SubraceInfo::_internal_languages_size() const {
  return _internal_languages().size();
}
inline int SubraceInfo::languages_size() const {
  return _internal_languages_size();
}
inline void SubraceInfo::clear_languages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.languages_.Clear();
}
inline ::dnd5e::api::v1alpha1::Language SubraceInfo::languages(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SubraceInfo.languages)
  return static_cast<::dnd5e::api::v1alpha1::Language>(_internal_languages().Get(index));
}
inline void SubraceInfo::set_languages(int index, ::dnd5e::api::v1alpha1::Language value) {
  _internal_mutable_languages()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SubraceInfo.languages)
}
inline void SubraceInfo::add_languages(::dnd5e::api::v1alpha1::Language value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_languages()->Add(value);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.SubraceInfo.languages)
}
inline const ::google::protobuf::RepeatedField<int>& SubraceInfo::languages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.SubraceInfo.languages)
  return _internal_languages();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL SubraceInfo::mutable_languages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.SubraceInfo.languages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_languages();
}
inline const ::google::protobuf::RepeatedField<int>& SubraceInfo::_internal_languages()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.languages_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
SubraceInfo::_internal_mutable_languages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.languages_;
}

// repeated string proficiencies = 7 [json_name = "proficiencies"];
inline int SubraceInfo::_internal_proficiencies_size() const {
  return _internal_proficiencies().size();
}
inline int SubraceInfo::proficiencies_size() const {
  return _internal_proficiencies_size();
}
inline void SubraceInfo::clear_proficiencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proficiencies_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL SubraceInfo::add_proficiencies()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_proficiencies()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.SubraceInfo.proficiencies)
  return _s;
}
inline const ::std::string& SubraceInfo::proficiencies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SubraceInfo.proficiencies)
  return _internal_proficiencies().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL SubraceInfo::mutable_proficiencies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SubraceInfo.proficiencies)
  return _internal_mutable_proficiencies()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SubraceInfo::set_proficiencies(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_proficiencies()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SubraceInfo.proficiencies)
}
template <typename Arg_, typename... Args_>
inline void SubraceInfo::add_proficiencies(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_proficiencies(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.SubraceInfo.proficiencies)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& SubraceInfo::proficiencies()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.SubraceInfo.proficiencies)
  return _internal_proficiencies();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubraceInfo::mutable_proficiencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.SubraceInfo.proficiencies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_proficiencies();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SubraceInfo::_internal_proficiencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.proficiencies_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SubraceInfo::_internal_mutable_proficiencies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.proficiencies_;
}

// -------------------------------------------------------------------

// RacialTrait

// string name = 1 [json_name = "name"];
inline void RacialTrait::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& RacialTrait::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RacialTrait.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RacialTrait::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RacialTrait.name)
}
inline ::std::string* PROTOBUF_NONNULL RacialTrait::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RacialTrait.name)
  return _s;
}
inline const ::std::string& RacialTrait::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void RacialTrait::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RacialTrait::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RacialTrait::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RacialTrait.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void RacialTrait::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RacialTrait.name)
}

// string description = 2 [json_name = "description"];
inline void RacialTrait::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& RacialTrait::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RacialTrait.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RacialTrait::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RacialTrait.description)
}
inline ::std::string* PROTOBUF_NONNULL RacialTrait::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RacialTrait.description)
  return _s;
}
inline const ::std::string& RacialTrait::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void RacialTrait::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RacialTrait::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RacialTrait::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RacialTrait.description)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void RacialTrait::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RacialTrait.description)
}

// bool is_choice = 3 [json_name = "isChoice"];
inline void RacialTrait::clear_is_choice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_choice_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool RacialTrait::is_choice() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RacialTrait.is_choice)
  return _internal_is_choice();
}
inline void RacialTrait::set_is_choice(bool value) {
  _internal_set_is_choice(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RacialTrait.is_choice)
}
inline bool RacialTrait::_internal_is_choice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_choice_;
}
inline void RacialTrait::_internal_set_is_choice(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_choice_ = value;
}

// repeated string options = 4 [json_name = "options"];
inline int RacialTrait::_internal_options_size() const {
  return _internal_options().size();
}
inline int RacialTrait::options_size() const {
  return _internal_options_size();
}
inline void RacialTrait::clear_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.options_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL RacialTrait::add_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_options()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.RacialTrait.options)
  return _s;
}
inline const ::std::string& RacialTrait::options(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RacialTrait.options)
  return _internal_options().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL RacialTrait::mutable_options(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RacialTrait.options)
  return _internal_mutable_options()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void RacialTrait::set_options(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_options()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RacialTrait.options)
}
template <typename Arg_, typename... Args_>
inline void RacialTrait::add_options(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_options(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.RacialTrait.options)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& RacialTrait::options()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.RacialTrait.options)
  return _internal_options();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
RacialTrait::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.RacialTrait.options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_options();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
RacialTrait::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.options_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
RacialTrait::_internal_mutable_options() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.options_;
}

// -------------------------------------------------------------------

// Choice

// string id = 1 [json_name = "id"];
inline void Choice::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Choice::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Choice::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Choice.id)
}
inline ::std::string* PROTOBUF_NONNULL Choice::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.id)
  return _s;
}
inline const ::std::string& Choice::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Choice::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Choice::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Choice::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void Choice::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Choice.id)
}

// string description = 2 [json_name = "description"];
inline void Choice::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Choice::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Choice::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Choice.description)
}
inline ::std::string* PROTOBUF_NONNULL Choice::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.description)
  return _s;
}
inline const ::std::string& Choice::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void Choice::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Choice::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Choice::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.description)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void Choice::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Choice.description)
}

// int32 choose_count = 3 [json_name = "chooseCount"];
inline void Choice::clear_choose_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choose_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t Choice::choose_count() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.choose_count)
  return _internal_choose_count();
}
inline void Choice::set_choose_count(::int32_t value) {
  _internal_set_choose_count(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Choice.choose_count)
}
inline ::int32_t Choice::_internal_choose_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.choose_count_;
}
inline void Choice::_internal_set_choose_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choose_count_ = value;
}

// .dnd5e.api.v1alpha1.ChoiceCategory choice_type = 4 [json_name = "choiceType"];
inline void Choice::clear_choice_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choice_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::dnd5e::api::v1alpha1::ChoiceCategory Choice::choice_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.choice_type)
  return _internal_choice_type();
}
inline void Choice::set_choice_type(::dnd5e::api::v1alpha1::ChoiceCategory value) {
  _internal_set_choice_type(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Choice.choice_type)
}
inline ::dnd5e::api::v1alpha1::ChoiceCategory Choice::_internal_choice_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::ChoiceCategory>(_impl_.choice_type_);
}
inline void Choice::_internal_set_choice_type(::dnd5e::api::v1alpha1::ChoiceCategory value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choice_type_ = value;
}

// .dnd5e.api.v1alpha1.ExplicitOptions explicit_options = 5 [json_name = "explicitOptions"];
inline bool Choice::has_explicit_options() const {
  return option_set_case() == kExplicitOptions;
}
inline bool Choice::_internal_has_explicit_options() const {
  return option_set_case() == kExplicitOptions;
}
inline void Choice::set_has_explicit_options() {
  _impl_._oneof_case_[0] = kExplicitOptions;
}
inline void Choice::clear_explicit_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_set_case() == kExplicitOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.option_set_.explicit_options_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.option_set_.explicit_options_);
    }
    clear_has_option_set();
  }
}
inline ::dnd5e::api::v1alpha1::ExplicitOptions* PROTOBUF_NULLABLE Choice::release_explicit_options() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.explicit_options)
  if (option_set_case() == kExplicitOptions) {
    clear_has_option_set();
    auto* temp = _impl_.option_set_.explicit_options_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.option_set_.explicit_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::ExplicitOptions& Choice::_internal_explicit_options() const {
  return option_set_case() == kExplicitOptions ? *_impl_.option_set_.explicit_options_ : reinterpret_cast<::dnd5e::api::v1alpha1::ExplicitOptions&>(::dnd5e::api::v1alpha1::_ExplicitOptions_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ExplicitOptions& Choice::explicit_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.explicit_options)
  return _internal_explicit_options();
}
inline ::dnd5e::api::v1alpha1::ExplicitOptions* PROTOBUF_NULLABLE Choice::unsafe_arena_release_explicit_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.Choice.explicit_options)
  if (option_set_case() == kExplicitOptions) {
    clear_has_option_set();
    auto* temp = _impl_.option_set_.explicit_options_;
    _impl_.option_set_.explicit_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Choice::unsafe_arena_set_allocated_explicit_options(
    ::dnd5e::api::v1alpha1::ExplicitOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_option_set();
  if (value) {
    set_has_explicit_options();
    _impl_.option_set_.explicit_options_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Choice.explicit_options)
}
inline ::dnd5e::api::v1alpha1::ExplicitOptions* PROTOBUF_NONNULL Choice::_internal_mutable_explicit_options() {
  if (option_set_case() != kExplicitOptions) {
    clear_option_set();
    set_has_explicit_options();
    _impl_.option_set_.explicit_options_ = 
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ExplicitOptions>(GetArena());
  }
  return _impl_.option_set_.explicit_options_;
}
inline ::dnd5e::api::v1alpha1::ExplicitOptions* PROTOBUF_NONNULL Choice::mutable_explicit_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::ExplicitOptions* _msg = _internal_mutable_explicit_options();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.explicit_options)
  return _msg;
}

// .dnd5e.api.v1alpha1.CategoryReference category_reference = 6 [json_name = "categoryReference"];
inline bool Choice::has_category_reference() const {
  return option_set_case() == kCategoryReference;
}
inline bool Choice::_internal_has_category_reference() const {
  return option_set_case() == kCategoryReference;
}
inline void Choice::set_has_category_reference() {
  _impl_._oneof_case_[0] = kCategoryReference;
}
inline void Choice::clear_category_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_set_case() == kCategoryReference) {
    if (GetArena() == nullptr) {
      delete _impl_.option_set_.category_reference_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.option_set_.category_reference_);
    }
    clear_has_option_set();
  }
}
inline ::dnd5e::api::v1alpha1::CategoryReference* PROTOBUF_NULLABLE Choice::release_category_reference() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Choice.category_reference)
  if (option_set_case() == kCategoryReference) {
    clear_has_option_set();
    auto* temp = _impl_.option_set_.category_reference_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.option_set_.category_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::CategoryReference& Choice::_internal_category_reference() const {
  return option_set_case() == kCategoryReference ? *_impl_.option_set_.category_reference_ : reinterpret_cast<::dnd5e::api::v1alpha1::CategoryReference&>(::dnd5e::api::v1alpha1::_CategoryReference_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CategoryReference& Choice::category_reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Choice.category_reference)
  return _internal_category_reference();
}
inline ::dnd5e::api::v1alpha1::CategoryReference* PROTOBUF_NULLABLE Choice::unsafe_arena_release_category_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.Choice.category_reference)
  if (option_set_case() == kCategoryReference) {
    clear_has_option_set();
    auto* temp = _impl_.option_set_.category_reference_;
    _impl_.option_set_.category_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Choice::unsafe_arena_set_allocated_category_reference(
    ::dnd5e::api::v1alpha1::CategoryReference* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_option_set();
  if (value) {
    set_has_category_reference();
    _impl_.option_set_.category_reference_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Choice.category_reference)
}
inline ::dnd5e::api::v1alpha1::CategoryReference* PROTOBUF_NONNULL Choice::_internal_mutable_category_reference() {
  if (option_set_case() != kCategoryReference) {
    clear_option_set();
    set_has_category_reference();
    _impl_.option_set_.category_reference_ = 
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CategoryReference>(GetArena());
  }
  return _impl_.option_set_.category_reference_;
}
inline ::dnd5e::api::v1alpha1::CategoryReference* PROTOBUF_NONNULL Choice::mutable_category_reference()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::CategoryReference* _msg = _internal_mutable_category_reference();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Choice.category_reference)
  return _msg;
}

inline bool Choice::has_option_set() const {
  return option_set_case() != OPTION_SET_NOT_SET;
}
inline void Choice::clear_has_option_set() {
  _impl_._oneof_case_[0] = OPTION_SET_NOT_SET;
}
inline Choice::OptionSetCase Choice::option_set_case() const {
  return Choice::OptionSetCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExplicitOptions

// repeated .dnd5e.api.v1alpha1.ChoiceOption options = 1 [json_name = "options"];
inline int ExplicitOptions::_internal_options_size() const {
  return _internal_options().size();
}
inline int ExplicitOptions::options_size() const {
  return _internal_options_size();
}
inline void ExplicitOptions::clear_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.options_.Clear();
}
inline ::dnd5e::api::v1alpha1::ChoiceOption* PROTOBUF_NONNULL ExplicitOptions::mutable_options(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ExplicitOptions.options)
  return _internal_mutable_options()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceOption>* PROTOBUF_NONNULL ExplicitOptions::mutable_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ExplicitOptions.options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_options();
}
inline const ::dnd5e::api::v1alpha1::ChoiceOption& ExplicitOptions::options(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ExplicitOptions.options)
  return _internal_options().Get(index);
}
inline ::dnd5e::api::v1alpha1::ChoiceOption* PROTOBUF_NONNULL ExplicitOptions::add_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ChoiceOption* _add = _internal_mutable_options()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ExplicitOptions.options)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceOption>& ExplicitOptions::options() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ExplicitOptions.options)
  return _internal_options();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceOption>&
ExplicitOptions::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.options_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ChoiceOption>* PROTOBUF_NONNULL
ExplicitOptions::_internal_mutable_options() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.options_;
}

// -------------------------------------------------------------------

// CategoryReference

// string category_id = 1 [json_name = "categoryId"];
inline void CategoryReference::clear_category_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CategoryReference::category_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CategoryReference.category_id)
  return _internal_category_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CategoryReference::set_category_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.category_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CategoryReference.category_id)
}
inline ::std::string* PROTOBUF_NONNULL CategoryReference::mutable_category_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_category_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CategoryReference.category_id)
  return _s;
}
inline const ::std::string& CategoryReference::_internal_category_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.category_id_.Get();
}
inline void CategoryReference::_internal_set_category_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.category_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CategoryReference::_internal_mutable_category_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.category_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CategoryReference::release_category_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CategoryReference.category_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.category_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.category_id_.Set("", GetArena());
  }
  return released;
}
inline void CategoryReference::set_allocated_category_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.category_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.category_id_.IsDefault()) {
    _impl_.category_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CategoryReference.category_id)
}

// repeated string exclude_ids = 2 [json_name = "excludeIds"];
inline int CategoryReference::_internal_exclude_ids_size() const {
  return _internal_exclude_ids().size();
}
inline int CategoryReference::exclude_ids_size() const {
  return _internal_exclude_ids_size();
}
inline void CategoryReference::clear_exclude_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exclude_ids_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL CategoryReference::add_exclude_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_exclude_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.CategoryReference.exclude_ids)
  return _s;
}
inline const ::std::string& CategoryReference::exclude_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CategoryReference.exclude_ids)
  return _internal_exclude_ids().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL CategoryReference::mutable_exclude_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CategoryReference.exclude_ids)
  return _internal_mutable_exclude_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void CategoryReference::set_exclude_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_exclude_ids()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CategoryReference.exclude_ids)
}
template <typename Arg_, typename... Args_>
inline void CategoryReference::add_exclude_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_exclude_ids(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.CategoryReference.exclude_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& CategoryReference::exclude_ids()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.CategoryReference.exclude_ids)
  return _internal_exclude_ids();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
CategoryReference::mutable_exclude_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.CategoryReference.exclude_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_exclude_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
CategoryReference::_internal_exclude_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exclude_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
CategoryReference::_internal_mutable_exclude_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.exclude_ids_;
}

// -------------------------------------------------------------------

// ChoiceOption

// .dnd5e.api.v1alpha1.ItemReference item = 1 [json_name = "item"];
inline bool ChoiceOption::has_item() const {
  return option_type_case() == kItem;
}
inline bool ChoiceOption::_internal_has_item() const {
  return option_type_case() == kItem;
}
inline void ChoiceOption::set_has_item() {
  _impl_._oneof_case_[0] = kItem;
}
inline void ChoiceOption::clear_item() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_type_case() == kItem) {
    if (GetArena() == nullptr) {
      delete _impl_.option_type_.item_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.option_type_.item_);
    }
    clear_has_option_type();
  }
}
inline ::dnd5e::api::v1alpha1::ItemReference* PROTOBUF_NULLABLE ChoiceOption::release_item() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceOption.item)
  if (option_type_case() == kItem) {
    clear_has_option_type();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ItemReference*>(_impl_.option_type_.item_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.option_type_.item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::ItemReference& ChoiceOption::_internal_item() const {
  return option_type_case() == kItem ? *reinterpret_cast<::dnd5e::api::v1alpha1::ItemReference*>(_impl_.option_type_.item_) : reinterpret_cast<::dnd5e::api::v1alpha1::ItemReference&>(::dnd5e::api::v1alpha1::_ItemReference_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ItemReference& ChoiceOption::item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceOption.item)
  return _internal_item();
}
inline ::dnd5e::api::v1alpha1::ItemReference* PROTOBUF_NULLABLE ChoiceOption::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceOption.item)
  if (option_type_case() == kItem) {
    clear_has_option_type();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ItemReference*>(_impl_.option_type_.item_);
    _impl_.option_type_.item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceOption::unsafe_arena_set_allocated_item(
    ::dnd5e::api::v1alpha1::ItemReference* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_option_type();
  if (value) {
    set_has_item();
    _impl_.option_type_.item_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceOption.item)
}
inline ::dnd5e::api::v1alpha1::ItemReference* PROTOBUF_NONNULL ChoiceOption::_internal_mutable_item() {
  if (option_type_case() != kItem) {
    clear_option_type();
    set_has_item();
    _impl_.option_type_.item_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ItemReference>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::ItemReference*>(_impl_.option_type_.item_);
}
inline ::dnd5e::api::v1alpha1::ItemReference* PROTOBUF_NONNULL ChoiceOption::mutable_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::ItemReference* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceOption.item)
  return _msg;
}

// .dnd5e.api.v1alpha1.CountedItemReference counted_item = 2 [json_name = "countedItem"];
inline bool ChoiceOption::has_counted_item() const {
  return option_type_case() == kCountedItem;
}
inline bool ChoiceOption::_internal_has_counted_item() const {
  return option_type_case() == kCountedItem;
}
inline void ChoiceOption::set_has_counted_item() {
  _impl_._oneof_case_[0] = kCountedItem;
}
inline void ChoiceOption::clear_counted_item() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_type_case() == kCountedItem) {
    if (GetArena() == nullptr) {
      delete _impl_.option_type_.counted_item_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.option_type_.counted_item_);
    }
    clear_has_option_type();
  }
}
inline ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE ChoiceOption::release_counted_item() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceOption.counted_item)
  if (option_type_case() == kCountedItem) {
    clear_has_option_type();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::CountedItemReference*>(_impl_.option_type_.counted_item_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.option_type_.counted_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::CountedItemReference& ChoiceOption::_internal_counted_item() const {
  return option_type_case() == kCountedItem ? *reinterpret_cast<::dnd5e::api::v1alpha1::CountedItemReference*>(_impl_.option_type_.counted_item_) : reinterpret_cast<::dnd5e::api::v1alpha1::CountedItemReference&>(::dnd5e::api::v1alpha1::_CountedItemReference_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CountedItemReference& ChoiceOption::counted_item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceOption.counted_item)
  return _internal_counted_item();
}
inline ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE ChoiceOption::unsafe_arena_release_counted_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceOption.counted_item)
  if (option_type_case() == kCountedItem) {
    clear_has_option_type();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::CountedItemReference*>(_impl_.option_type_.counted_item_);
    _impl_.option_type_.counted_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceOption::unsafe_arena_set_allocated_counted_item(
    ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_option_type();
  if (value) {
    set_has_counted_item();
    _impl_.option_type_.counted_item_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceOption.counted_item)
}
inline ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NONNULL ChoiceOption::_internal_mutable_counted_item() {
  if (option_type_case() != kCountedItem) {
    clear_option_type();
    set_has_counted_item();
    _impl_.option_type_.counted_item_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CountedItemReference>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::CountedItemReference*>(_impl_.option_type_.counted_item_);
}
inline ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NONNULL ChoiceOption::mutable_counted_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::CountedItemReference* _msg = _internal_mutable_counted_item();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceOption.counted_item)
  return _msg;
}

// .dnd5e.api.v1alpha1.ItemBundle bundle = 3 [json_name = "bundle"];
inline bool ChoiceOption::has_bundle() const {
  return option_type_case() == kBundle;
}
inline bool ChoiceOption::_internal_has_bundle() const {
  return option_type_case() == kBundle;
}
inline void ChoiceOption::set_has_bundle() {
  _impl_._oneof_case_[0] = kBundle;
}
inline void ChoiceOption::clear_bundle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_type_case() == kBundle) {
    if (GetArena() == nullptr) {
      delete _impl_.option_type_.bundle_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.option_type_.bundle_);
    }
    clear_has_option_type();
  }
}
inline ::dnd5e::api::v1alpha1::ItemBundle* PROTOBUF_NULLABLE ChoiceOption::release_bundle() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceOption.bundle)
  if (option_type_case() == kBundle) {
    clear_has_option_type();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ItemBundle*>(_impl_.option_type_.bundle_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.option_type_.bundle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::ItemBundle& ChoiceOption::_internal_bundle() const {
  return option_type_case() == kBundle ? *reinterpret_cast<::dnd5e::api::v1alpha1::ItemBundle*>(_impl_.option_type_.bundle_) : reinterpret_cast<::dnd5e::api::v1alpha1::ItemBundle&>(::dnd5e::api::v1alpha1::_ItemBundle_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ItemBundle& ChoiceOption::bundle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceOption.bundle)
  return _internal_bundle();
}
inline ::dnd5e::api::v1alpha1::ItemBundle* PROTOBUF_NULLABLE ChoiceOption::unsafe_arena_release_bundle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceOption.bundle)
  if (option_type_case() == kBundle) {
    clear_has_option_type();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ItemBundle*>(_impl_.option_type_.bundle_);
    _impl_.option_type_.bundle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceOption::unsafe_arena_set_allocated_bundle(
    ::dnd5e::api::v1alpha1::ItemBundle* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_option_type();
  if (value) {
    set_has_bundle();
    _impl_.option_type_.bundle_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceOption.bundle)
}
inline ::dnd5e::api::v1alpha1::ItemBundle* PROTOBUF_NONNULL ChoiceOption::_internal_mutable_bundle() {
  if (option_type_case() != kBundle) {
    clear_option_type();
    set_has_bundle();
    _impl_.option_type_.bundle_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ItemBundle>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::ItemBundle*>(_impl_.option_type_.bundle_);
}
inline ::dnd5e::api::v1alpha1::ItemBundle* PROTOBUF_NONNULL ChoiceOption::mutable_bundle()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::ItemBundle* _msg = _internal_mutable_bundle();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceOption.bundle)
  return _msg;
}

// .dnd5e.api.v1alpha1.NestedChoice nested_choice = 4 [json_name = "nestedChoice"];
inline bool ChoiceOption::has_nested_choice() const {
  return option_type_case() == kNestedChoice;
}
inline bool ChoiceOption::_internal_has_nested_choice() const {
  return option_type_case() == kNestedChoice;
}
inline void ChoiceOption::set_has_nested_choice() {
  _impl_._oneof_case_[0] = kNestedChoice;
}
inline void ChoiceOption::clear_nested_choice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_type_case() == kNestedChoice) {
    if (GetArena() == nullptr) {
      delete _impl_.option_type_.nested_choice_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.option_type_.nested_choice_);
    }
    clear_has_option_type();
  }
}
inline ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE ChoiceOption::release_nested_choice() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceOption.nested_choice)
  if (option_type_case() == kNestedChoice) {
    clear_has_option_type();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::NestedChoice*>(_impl_.option_type_.nested_choice_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.option_type_.nested_choice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::NestedChoice& ChoiceOption::_internal_nested_choice() const {
  return option_type_case() == kNestedChoice ? *reinterpret_cast<::dnd5e::api::v1alpha1::NestedChoice*>(_impl_.option_type_.nested_choice_) : reinterpret_cast<::dnd5e::api::v1alpha1::NestedChoice&>(::dnd5e::api::v1alpha1::_NestedChoice_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::NestedChoice& ChoiceOption::nested_choice() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceOption.nested_choice)
  return _internal_nested_choice();
}
inline ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE ChoiceOption::unsafe_arena_release_nested_choice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceOption.nested_choice)
  if (option_type_case() == kNestedChoice) {
    clear_has_option_type();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::NestedChoice*>(_impl_.option_type_.nested_choice_);
    _impl_.option_type_.nested_choice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceOption::unsafe_arena_set_allocated_nested_choice(
    ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_option_type();
  if (value) {
    set_has_nested_choice();
    _impl_.option_type_.nested_choice_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceOption.nested_choice)
}
inline ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NONNULL ChoiceOption::_internal_mutable_nested_choice() {
  if (option_type_case() != kNestedChoice) {
    clear_option_type();
    set_has_nested_choice();
    _impl_.option_type_.nested_choice_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::NestedChoice>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::NestedChoice*>(_impl_.option_type_.nested_choice_);
}
inline ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NONNULL ChoiceOption::mutable_nested_choice()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::NestedChoice* _msg = _internal_mutable_nested_choice();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceOption.nested_choice)
  return _msg;
}

inline bool ChoiceOption::has_option_type() const {
  return option_type_case() != OPTION_TYPE_NOT_SET;
}
inline void ChoiceOption::clear_has_option_type() {
  _impl_._oneof_case_[0] = OPTION_TYPE_NOT_SET;
}
inline ChoiceOption::OptionTypeCase ChoiceOption::option_type_case() const {
  return ChoiceOption::OptionTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ItemReference

// string item_id = 1 [json_name = "itemId"];
inline void ItemReference::clear_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.item_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ItemReference::item_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ItemReference.item_id)
  return _internal_item_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ItemReference::set_item_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.item_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ItemReference.item_id)
}
inline ::std::string* PROTOBUF_NONNULL ItemReference::mutable_item_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ItemReference.item_id)
  return _s;
}
inline const ::std::string& ItemReference::_internal_item_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.item_id_.Get();
}
inline void ItemReference::_internal_set_item_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.item_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ItemReference::_internal_mutable_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.item_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ItemReference::release_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ItemReference.item_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.item_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.item_id_.Set("", GetArena());
  }
  return released;
}
inline void ItemReference::set_allocated_item_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.item_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ItemReference.item_id)
}

// string name = 2 [json_name = "name"];
inline void ItemReference::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& ItemReference::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ItemReference.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ItemReference::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ItemReference.name)
}
inline ::std::string* PROTOBUF_NONNULL ItemReference::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ItemReference.name)
  return _s;
}
inline const ::std::string& ItemReference::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ItemReference::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ItemReference::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ItemReference::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ItemReference.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void ItemReference::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ItemReference.name)
}

// -------------------------------------------------------------------

// CountedItemReference

// string item_id = 1 [json_name = "itemId"];
inline void CountedItemReference::clear_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.item_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CountedItemReference::item_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CountedItemReference.item_id)
  return _internal_item_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CountedItemReference::set_item_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.item_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CountedItemReference.item_id)
}
inline ::std::string* PROTOBUF_NONNULL CountedItemReference::mutable_item_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CountedItemReference.item_id)
  return _s;
}
inline const ::std::string& CountedItemReference::_internal_item_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.item_id_.Get();
}
inline void CountedItemReference::_internal_set_item_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.item_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CountedItemReference::_internal_mutable_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.item_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CountedItemReference::release_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CountedItemReference.item_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.item_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.item_id_.Set("", GetArena());
  }
  return released;
}
inline void CountedItemReference::set_allocated_item_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.item_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CountedItemReference.item_id)
}

// string name = 2 [json_name = "name"];
inline void CountedItemReference::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CountedItemReference::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CountedItemReference.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CountedItemReference::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CountedItemReference.name)
}
inline ::std::string* PROTOBUF_NONNULL CountedItemReference::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CountedItemReference.name)
  return _s;
}
inline const ::std::string& CountedItemReference::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void CountedItemReference::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CountedItemReference::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CountedItemReference::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CountedItemReference.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void CountedItemReference::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CountedItemReference.name)
}

// int32 quantity = 3 [json_name = "quantity"];
inline void CountedItemReference::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CountedItemReference::quantity() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CountedItemReference.quantity)
  return _internal_quantity();
}
inline void CountedItemReference::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CountedItemReference.quantity)
}
inline ::int32_t CountedItemReference::_internal_quantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_;
}
inline void CountedItemReference::_internal_set_quantity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// ItemBundle

// repeated .dnd5e.api.v1alpha1.BundleItem items = 1 [json_name = "items"];
inline int ItemBundle::_internal_items_size() const {
  return _internal_items().size();
}
inline int ItemBundle::items_size() const {
  return _internal_items_size();
}
inline void ItemBundle::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
}
inline ::dnd5e::api::v1alpha1::BundleItem* PROTOBUF_NONNULL ItemBundle::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ItemBundle.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BundleItem>* PROTOBUF_NONNULL ItemBundle::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ItemBundle.items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_items();
}
inline const ::dnd5e::api::v1alpha1::BundleItem& ItemBundle::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ItemBundle.items)
  return _internal_items().Get(index);
}
inline ::dnd5e::api::v1alpha1::BundleItem* PROTOBUF_NONNULL ItemBundle::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::BundleItem* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ItemBundle.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BundleItem>& ItemBundle::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ItemBundle.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BundleItem>&
ItemBundle::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BundleItem>* PROTOBUF_NONNULL
ItemBundle::_internal_mutable_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// BundleItem

// .dnd5e.api.v1alpha1.CountedItemReference concrete_item = 1 [json_name = "concreteItem"];
inline bool BundleItem::has_concrete_item() const {
  return item_type_case() == kConcreteItem;
}
inline bool BundleItem::_internal_has_concrete_item() const {
  return item_type_case() == kConcreteItem;
}
inline void BundleItem::set_has_concrete_item() {
  _impl_._oneof_case_[0] = kConcreteItem;
}
inline void BundleItem::clear_concrete_item() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (item_type_case() == kConcreteItem) {
    if (GetArena() == nullptr) {
      delete _impl_.item_type_.concrete_item_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.item_type_.concrete_item_);
    }
    clear_has_item_type();
  }
}
inline ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE BundleItem::release_concrete_item() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.BundleItem.concrete_item)
  if (item_type_case() == kConcreteItem) {
    clear_has_item_type();
    auto* temp = _impl_.item_type_.concrete_item_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.item_type_.concrete_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::CountedItemReference& BundleItem::_internal_concrete_item() const {
  return item_type_case() == kConcreteItem ? *_impl_.item_type_.concrete_item_ : reinterpret_cast<::dnd5e::api::v1alpha1::CountedItemReference&>(::dnd5e::api::v1alpha1::_CountedItemReference_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CountedItemReference& BundleItem::concrete_item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BundleItem.concrete_item)
  return _internal_concrete_item();
}
inline ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE BundleItem::unsafe_arena_release_concrete_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.BundleItem.concrete_item)
  if (item_type_case() == kConcreteItem) {
    clear_has_item_type();
    auto* temp = _impl_.item_type_.concrete_item_;
    _impl_.item_type_.concrete_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BundleItem::unsafe_arena_set_allocated_concrete_item(
    ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_item_type();
  if (value) {
    set_has_concrete_item();
    _impl_.item_type_.concrete_item_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.BundleItem.concrete_item)
}
inline ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NONNULL BundleItem::_internal_mutable_concrete_item() {
  if (item_type_case() != kConcreteItem) {
    clear_item_type();
    set_has_concrete_item();
    _impl_.item_type_.concrete_item_ = 
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CountedItemReference>(GetArena());
  }
  return _impl_.item_type_.concrete_item_;
}
inline ::dnd5e::api::v1alpha1::CountedItemReference* PROTOBUF_NONNULL BundleItem::mutable_concrete_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::CountedItemReference* _msg = _internal_mutable_concrete_item();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BundleItem.concrete_item)
  return _msg;
}

// .dnd5e.api.v1alpha1.NestedChoice choice_item = 2 [json_name = "choiceItem"];
inline bool BundleItem::has_choice_item() const {
  return item_type_case() == kChoiceItem;
}
inline bool BundleItem::_internal_has_choice_item() const {
  return item_type_case() == kChoiceItem;
}
inline void BundleItem::set_has_choice_item() {
  _impl_._oneof_case_[0] = kChoiceItem;
}
inline void BundleItem::clear_choice_item() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (item_type_case() == kChoiceItem) {
    if (GetArena() == nullptr) {
      delete _impl_.item_type_.choice_item_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.item_type_.choice_item_);
    }
    clear_has_item_type();
  }
}
inline ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE BundleItem::release_choice_item() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.BundleItem.choice_item)
  if (item_type_case() == kChoiceItem) {
    clear_has_item_type();
    auto* temp = _impl_.item_type_.choice_item_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.item_type_.choice_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::NestedChoice& BundleItem::_internal_choice_item() const {
  return item_type_case() == kChoiceItem ? *_impl_.item_type_.choice_item_ : reinterpret_cast<::dnd5e::api::v1alpha1::NestedChoice&>(::dnd5e::api::v1alpha1::_NestedChoice_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::NestedChoice& BundleItem::choice_item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BundleItem.choice_item)
  return _internal_choice_item();
}
inline ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE BundleItem::unsafe_arena_release_choice_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.BundleItem.choice_item)
  if (item_type_case() == kChoiceItem) {
    clear_has_item_type();
    auto* temp = _impl_.item_type_.choice_item_;
    _impl_.item_type_.choice_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BundleItem::unsafe_arena_set_allocated_choice_item(
    ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_item_type();
  if (value) {
    set_has_choice_item();
    _impl_.item_type_.choice_item_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.BundleItem.choice_item)
}
inline ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NONNULL BundleItem::_internal_mutable_choice_item() {
  if (item_type_case() != kChoiceItem) {
    clear_item_type();
    set_has_choice_item();
    _impl_.item_type_.choice_item_ = 
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::NestedChoice>(GetArena());
  }
  return _impl_.item_type_.choice_item_;
}
inline ::dnd5e::api::v1alpha1::NestedChoice* PROTOBUF_NONNULL BundleItem::mutable_choice_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::NestedChoice* _msg = _internal_mutable_choice_item();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BundleItem.choice_item)
  return _msg;
}

inline bool BundleItem::has_item_type() const {
  return item_type_case() != ITEM_TYPE_NOT_SET;
}
inline void BundleItem::clear_has_item_type() {
  _impl_._oneof_case_[0] = ITEM_TYPE_NOT_SET;
}
inline BundleItem::ItemTypeCase BundleItem::item_type_case() const {
  return BundleItem::ItemTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NestedChoice

// .dnd5e.api.v1alpha1.Choice choice = 1 [json_name = "choice"];
inline bool NestedChoice::has_choice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.choice_ != nullptr);
  return value;
}
inline void NestedChoice::clear_choice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.choice_ != nullptr) _impl_.choice_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::Choice& NestedChoice::_internal_choice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Choice* p = _impl_.choice_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Choice&>(::dnd5e::api::v1alpha1::_Choice_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Choice& NestedChoice::choice() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.NestedChoice.choice)
  return _internal_choice();
}
inline void NestedChoice::unsafe_arena_set_allocated_choice(
    ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.choice_);
  }
  _impl_.choice_ = reinterpret_cast<::dnd5e::api::v1alpha1::Choice*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.NestedChoice.choice)
}
inline ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NULLABLE NestedChoice::release_choice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Choice* released = _impl_.choice_;
  _impl_.choice_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NULLABLE NestedChoice::unsafe_arena_release_choice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.NestedChoice.choice)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Choice* temp = _impl_.choice_;
  _impl_.choice_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL NestedChoice::_internal_mutable_choice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.choice_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Choice>(GetArena());
    _impl_.choice_ = reinterpret_cast<::dnd5e::api::v1alpha1::Choice*>(p);
  }
  return _impl_.choice_;
}
inline ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL NestedChoice::mutable_choice()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::Choice* _msg = _internal_mutable_choice();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.NestedChoice.choice)
  return _msg;
}
inline void NestedChoice::set_allocated_choice(::dnd5e::api::v1alpha1::Choice* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.choice_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.choice_ = reinterpret_cast<::dnd5e::api::v1alpha1::Choice*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.NestedChoice.choice)
}

// -------------------------------------------------------------------

// ClassInfo

// string id = 1 [json_name = "id"];
inline void ClassInfo::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ClassInfo::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ClassInfo::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassInfo.id)
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.id)
  return _s;
}
inline const ::std::string& ClassInfo::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void ClassInfo::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ClassInfo::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ClassInfo.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void ClassInfo::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ClassInfo.id)
}

// string name = 2 [json_name = "name"];
inline void ClassInfo::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& ClassInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ClassInfo::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassInfo.name)
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.name)
  return _s;
}
inline const ::std::string& ClassInfo::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ClassInfo::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ClassInfo::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ClassInfo.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void ClassInfo::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ClassInfo.name)
}

// string description = 3 [json_name = "description"];
inline void ClassInfo::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& ClassInfo::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ClassInfo::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassInfo.description)
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.description)
  return _s;
}
inline const ::std::string& ClassInfo::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void ClassInfo::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ClassInfo::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ClassInfo.description)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void ClassInfo::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ClassInfo.description)
}

// string hit_die = 4 [json_name = "hitDie"];
inline void ClassInfo::clear_hit_die() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hit_die_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& ClassInfo::hit_die() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.hit_die)
  return _internal_hit_die();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ClassInfo::set_hit_die(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.hit_die_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassInfo.hit_die)
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::mutable_hit_die()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_hit_die();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.hit_die)
  return _s;
}
inline const ::std::string& ClassInfo::_internal_hit_die() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hit_die_.Get();
}
inline void ClassInfo::_internal_set_hit_die(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.hit_die_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::_internal_mutable_hit_die() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.hit_die_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ClassInfo::release_hit_die() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ClassInfo.hit_die)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.hit_die_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.hit_die_.Set("", GetArena());
  }
  return released;
}
inline void ClassInfo::set_allocated_hit_die(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.hit_die_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hit_die_.IsDefault()) {
    _impl_.hit_die_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ClassInfo.hit_die)
}

// repeated string primary_abilities = 5 [json_name = "primaryAbilities"];
inline int ClassInfo::_internal_primary_abilities_size() const {
  return _internal_primary_abilities().size();
}
inline int ClassInfo::primary_abilities_size() const {
  return _internal_primary_abilities_size();
}
inline void ClassInfo::clear_primary_abilities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_abilities_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::add_primary_abilities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_primary_abilities()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.ClassInfo.primary_abilities)
  return _s;
}
inline const ::std::string& ClassInfo::primary_abilities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.primary_abilities)
  return _internal_primary_abilities().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::mutable_primary_abilities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.primary_abilities)
  return _internal_mutable_primary_abilities()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::set_primary_abilities(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_primary_abilities()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassInfo.primary_abilities)
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::add_primary_abilities(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_primary_abilities(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ClassInfo.primary_abilities)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& ClassInfo::primary_abilities()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ClassInfo.primary_abilities)
  return _internal_primary_abilities();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::mutable_primary_abilities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ClassInfo.primary_abilities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_primary_abilities();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ClassInfo::_internal_primary_abilities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.primary_abilities_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::_internal_mutable_primary_abilities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.primary_abilities_;
}

// repeated string armor_proficiencies = 6 [json_name = "armorProficiencies"];
inline int ClassInfo::_internal_armor_proficiencies_size() const {
  return _internal_armor_proficiencies().size();
}
inline int ClassInfo::armor_proficiencies_size() const {
  return _internal_armor_proficiencies_size();
}
inline void ClassInfo::clear_armor_proficiencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.armor_proficiencies_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::add_armor_proficiencies()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_armor_proficiencies()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.ClassInfo.armor_proficiencies)
  return _s;
}
inline const ::std::string& ClassInfo::armor_proficiencies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.armor_proficiencies)
  return _internal_armor_proficiencies().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::mutable_armor_proficiencies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.armor_proficiencies)
  return _internal_mutable_armor_proficiencies()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::set_armor_proficiencies(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_armor_proficiencies()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassInfo.armor_proficiencies)
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::add_armor_proficiencies(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_armor_proficiencies(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ClassInfo.armor_proficiencies)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& ClassInfo::armor_proficiencies()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ClassInfo.armor_proficiencies)
  return _internal_armor_proficiencies();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::mutable_armor_proficiencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ClassInfo.armor_proficiencies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_armor_proficiencies();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ClassInfo::_internal_armor_proficiencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.armor_proficiencies_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::_internal_mutable_armor_proficiencies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.armor_proficiencies_;
}

// repeated string weapon_proficiencies = 7 [json_name = "weaponProficiencies"];
inline int ClassInfo::_internal_weapon_proficiencies_size() const {
  return _internal_weapon_proficiencies().size();
}
inline int ClassInfo::weapon_proficiencies_size() const {
  return _internal_weapon_proficiencies_size();
}
inline void ClassInfo::clear_weapon_proficiencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapon_proficiencies_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::add_weapon_proficiencies()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_weapon_proficiencies()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.ClassInfo.weapon_proficiencies)
  return _s;
}
inline const ::std::string& ClassInfo::weapon_proficiencies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.weapon_proficiencies)
  return _internal_weapon_proficiencies().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::mutable_weapon_proficiencies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.weapon_proficiencies)
  return _internal_mutable_weapon_proficiencies()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::set_weapon_proficiencies(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_weapon_proficiencies()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassInfo.weapon_proficiencies)
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::add_weapon_proficiencies(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_weapon_proficiencies(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ClassInfo.weapon_proficiencies)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& ClassInfo::weapon_proficiencies()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ClassInfo.weapon_proficiencies)
  return _internal_weapon_proficiencies();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::mutable_weapon_proficiencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ClassInfo.weapon_proficiencies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_weapon_proficiencies();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ClassInfo::_internal_weapon_proficiencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.weapon_proficiencies_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::_internal_mutable_weapon_proficiencies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.weapon_proficiencies_;
}

// repeated string tool_proficiencies = 8 [json_name = "toolProficiencies"];
inline int ClassInfo::_internal_tool_proficiencies_size() const {
  return _internal_tool_proficiencies().size();
}
inline int ClassInfo::tool_proficiencies_size() const {
  return _internal_tool_proficiencies_size();
}
inline void ClassInfo::clear_tool_proficiencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tool_proficiencies_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::add_tool_proficiencies()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_tool_proficiencies()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.ClassInfo.tool_proficiencies)
  return _s;
}
inline const ::std::string& ClassInfo::tool_proficiencies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.tool_proficiencies)
  return _internal_tool_proficiencies().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::mutable_tool_proficiencies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.tool_proficiencies)
  return _internal_mutable_tool_proficiencies()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::set_tool_proficiencies(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_tool_proficiencies()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassInfo.tool_proficiencies)
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::add_tool_proficiencies(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_tool_proficiencies(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ClassInfo.tool_proficiencies)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& ClassInfo::tool_proficiencies()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ClassInfo.tool_proficiencies)
  return _internal_tool_proficiencies();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::mutable_tool_proficiencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ClassInfo.tool_proficiencies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tool_proficiencies();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ClassInfo::_internal_tool_proficiencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tool_proficiencies_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::_internal_mutable_tool_proficiencies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tool_proficiencies_;
}

// repeated string saving_throw_proficiencies = 9 [json_name = "savingThrowProficiencies"];
inline int ClassInfo::_internal_saving_throw_proficiencies_size() const {
  return _internal_saving_throw_proficiencies().size();
}
inline int ClassInfo::saving_throw_proficiencies_size() const {
  return _internal_saving_throw_proficiencies_size();
}
inline void ClassInfo::clear_saving_throw_proficiencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.saving_throw_proficiencies_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::add_saving_throw_proficiencies()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_saving_throw_proficiencies()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.ClassInfo.saving_throw_proficiencies)
  return _s;
}
inline const ::std::string& ClassInfo::saving_throw_proficiencies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.saving_throw_proficiencies)
  return _internal_saving_throw_proficiencies().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::mutable_saving_throw_proficiencies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.saving_throw_proficiencies)
  return _internal_mutable_saving_throw_proficiencies()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::set_saving_throw_proficiencies(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_saving_throw_proficiencies()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassInfo.saving_throw_proficiencies)
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::add_saving_throw_proficiencies(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_saving_throw_proficiencies(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ClassInfo.saving_throw_proficiencies)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& ClassInfo::saving_throw_proficiencies()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ClassInfo.saving_throw_proficiencies)
  return _internal_saving_throw_proficiencies();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::mutable_saving_throw_proficiencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ClassInfo.saving_throw_proficiencies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_saving_throw_proficiencies();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ClassInfo::_internal_saving_throw_proficiencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.saving_throw_proficiencies_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::_internal_mutable_saving_throw_proficiencies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.saving_throw_proficiencies_;
}

// int32 skill_choices_count = 10 [json_name = "skillChoicesCount"];
inline void ClassInfo::clear_skill_choices_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skill_choices_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t ClassInfo::skill_choices_count() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.skill_choices_count)
  return _internal_skill_choices_count();
}
inline void ClassInfo::set_skill_choices_count(::int32_t value) {
  _internal_set_skill_choices_count(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassInfo.skill_choices_count)
}
inline ::int32_t ClassInfo::_internal_skill_choices_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skill_choices_count_;
}
inline void ClassInfo::_internal_set_skill_choices_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skill_choices_count_ = value;
}

// repeated string available_skills = 11 [json_name = "availableSkills"];
inline int ClassInfo::_internal_available_skills_size() const {
  return _internal_available_skills().size();
}
inline int ClassInfo::available_skills_size() const {
  return _internal_available_skills_size();
}
inline void ClassInfo::clear_available_skills() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_skills_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::add_available_skills()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_available_skills()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.ClassInfo.available_skills)
  return _s;
}
inline const ::std::string& ClassInfo::available_skills(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.available_skills)
  return _internal_available_skills().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::mutable_available_skills(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.available_skills)
  return _internal_mutable_available_skills()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::set_available_skills(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_available_skills()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassInfo.available_skills)
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::add_available_skills(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_available_skills(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ClassInfo.available_skills)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& ClassInfo::available_skills()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ClassInfo.available_skills)
  return _internal_available_skills();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::mutable_available_skills() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ClassInfo.available_skills)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_available_skills();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ClassInfo::_internal_available_skills() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.available_skills_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::_internal_mutable_available_skills() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.available_skills_;
}

// repeated string starting_equipment = 12 [json_name = "startingEquipment"];
inline int ClassInfo::_internal_starting_equipment_size() const {
  return _internal_starting_equipment().size();
}
inline int ClassInfo::starting_equipment_size() const {
  return _internal_starting_equipment_size();
}
inline void ClassInfo::clear_starting_equipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.starting_equipment_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::add_starting_equipment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_starting_equipment()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.ClassInfo.starting_equipment)
  return _s;
}
inline const ::std::string& ClassInfo::starting_equipment(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.starting_equipment)
  return _internal_starting_equipment().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL ClassInfo::mutable_starting_equipment(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.starting_equipment)
  return _internal_mutable_starting_equipment()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::set_starting_equipment(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_starting_equipment()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassInfo.starting_equipment)
}
template <typename Arg_, typename... Args_>
inline void ClassInfo::add_starting_equipment(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_starting_equipment(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ClassInfo.starting_equipment)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& ClassInfo::starting_equipment()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ClassInfo.starting_equipment)
  return _internal_starting_equipment();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::mutable_starting_equipment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ClassInfo.starting_equipment)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_starting_equipment();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ClassInfo::_internal_starting_equipment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.starting_equipment_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ClassInfo::_internal_mutable_starting_equipment() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.starting_equipment_;
}

// repeated .dnd5e.api.v1alpha1.FeatureInfo level_1_features = 13 [json_name = "level1Features"];
inline int ClassInfo::_internal_level_1_features_size() const {
  return _internal_level_1_features().size();
}
inline int ClassInfo::level_1_features_size() const {
  return _internal_level_1_features_size();
}
inline void ClassInfo::clear_level_1_features() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_1_features_.Clear();
}
inline ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NONNULL ClassInfo::mutable_level_1_features(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.level_1_features)
  return _internal_mutable_level_1_features()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::FeatureInfo>* PROTOBUF_NONNULL ClassInfo::mutable_level_1_features()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ClassInfo.level_1_features)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_level_1_features();
}
inline const ::dnd5e::api::v1alpha1::FeatureInfo& ClassInfo::level_1_features(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.level_1_features)
  return _internal_level_1_features().Get(index);
}
inline ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NONNULL ClassInfo::add_level_1_features()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::FeatureInfo* _add = _internal_mutable_level_1_features()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ClassInfo.level_1_features)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::FeatureInfo>& ClassInfo::level_1_features() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ClassInfo.level_1_features)
  return _internal_level_1_features();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::FeatureInfo>&
ClassInfo::_internal_level_1_features() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_1_features_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::FeatureInfo>* PROTOBUF_NONNULL
ClassInfo::_internal_mutable_level_1_features() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.level_1_features_;
}

// .dnd5e.api.v1alpha1.SpellcastingInfo spellcasting = 14 [json_name = "spellcasting"];
inline bool ClassInfo::has_spellcasting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spellcasting_ != nullptr);
  return value;
}
inline void ClassInfo::clear_spellcasting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.spellcasting_ != nullptr) _impl_.spellcasting_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::dnd5e::api::v1alpha1::SpellcastingInfo& ClassInfo::_internal_spellcasting() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::SpellcastingInfo* p = _impl_.spellcasting_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::SpellcastingInfo&>(::dnd5e::api::v1alpha1::_SpellcastingInfo_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SpellcastingInfo& ClassInfo::spellcasting() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.spellcasting)
  return _internal_spellcasting();
}
inline void ClassInfo::unsafe_arena_set_allocated_spellcasting(
    ::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spellcasting_);
  }
  _impl_.spellcasting_ = reinterpret_cast<::dnd5e::api::v1alpha1::SpellcastingInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ClassInfo.spellcasting)
}
inline ::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NULLABLE ClassInfo::release_spellcasting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::SpellcastingInfo* released = _impl_.spellcasting_;
  _impl_.spellcasting_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NULLABLE ClassInfo::unsafe_arena_release_spellcasting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ClassInfo.spellcasting)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::SpellcastingInfo* temp = _impl_.spellcasting_;
  _impl_.spellcasting_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NONNULL ClassInfo::_internal_mutable_spellcasting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.spellcasting_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SpellcastingInfo>(GetArena());
    _impl_.spellcasting_ = reinterpret_cast<::dnd5e::api::v1alpha1::SpellcastingInfo*>(p);
  }
  return _impl_.spellcasting_;
}
inline ::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NONNULL ClassInfo::mutable_spellcasting()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::dnd5e::api::v1alpha1::SpellcastingInfo* _msg = _internal_mutable_spellcasting();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.spellcasting)
  return _msg;
}
inline void ClassInfo::set_allocated_spellcasting(::dnd5e::api::v1alpha1::SpellcastingInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spellcasting_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.spellcasting_ = reinterpret_cast<::dnd5e::api::v1alpha1::SpellcastingInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ClassInfo.spellcasting)
}

// repeated .dnd5e.api.v1alpha1.Choice choices = 15 [json_name = "choices"];
inline int ClassInfo::_internal_choices_size() const {
  return _internal_choices().size();
}
inline int ClassInfo::choices_size() const {
  return _internal_choices_size();
}
inline void ClassInfo::clear_choices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choices_.Clear();
}
inline ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL ClassInfo::mutable_choices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ClassInfo.choices)
  return _internal_mutable_choices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>* PROTOBUF_NONNULL ClassInfo::mutable_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ClassInfo.choices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_choices();
}
inline const ::dnd5e::api::v1alpha1::Choice& ClassInfo::choices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassInfo.choices)
  return _internal_choices().Get(index);
}
inline ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL ClassInfo::add_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::Choice* _add = _internal_mutable_choices()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ClassInfo.choices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>& ClassInfo::choices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ClassInfo.choices)
  return _internal_choices();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>&
ClassInfo::_internal_choices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.choices_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>* PROTOBUF_NONNULL
ClassInfo::_internal_mutable_choices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.choices_;
}

// -------------------------------------------------------------------

// SpellcastingInfo

// string spellcasting_ability = 1 [json_name = "spellcastingAbility"];
inline void SpellcastingInfo::clear_spellcasting_ability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spellcasting_ability_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SpellcastingInfo::spellcasting_ability() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellcastingInfo.spellcasting_ability)
  return _internal_spellcasting_ability();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SpellcastingInfo::set_spellcasting_ability(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.spellcasting_ability_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellcastingInfo.spellcasting_ability)
}
inline ::std::string* PROTOBUF_NONNULL SpellcastingInfo::mutable_spellcasting_ability()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_spellcasting_ability();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SpellcastingInfo.spellcasting_ability)
  return _s;
}
inline const ::std::string& SpellcastingInfo::_internal_spellcasting_ability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spellcasting_ability_.Get();
}
inline void SpellcastingInfo::_internal_set_spellcasting_ability(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.spellcasting_ability_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SpellcastingInfo::_internal_mutable_spellcasting_ability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.spellcasting_ability_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SpellcastingInfo::release_spellcasting_ability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.SpellcastingInfo.spellcasting_ability)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.spellcasting_ability_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.spellcasting_ability_.Set("", GetArena());
  }
  return released;
}
inline void SpellcastingInfo::set_allocated_spellcasting_ability(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.spellcasting_ability_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.spellcasting_ability_.IsDefault()) {
    _impl_.spellcasting_ability_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.SpellcastingInfo.spellcasting_ability)
}

// bool ritual_casting = 2 [json_name = "ritualCasting"];
inline void SpellcastingInfo::clear_ritual_casting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ritual_casting_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SpellcastingInfo::ritual_casting() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellcastingInfo.ritual_casting)
  return _internal_ritual_casting();
}
inline void SpellcastingInfo::set_ritual_casting(bool value) {
  _internal_set_ritual_casting(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellcastingInfo.ritual_casting)
}
inline bool SpellcastingInfo::_internal_ritual_casting() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ritual_casting_;
}
inline void SpellcastingInfo::_internal_set_ritual_casting(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ritual_casting_ = value;
}

// string spellcasting_focus = 3 [json_name = "spellcastingFocus"];
inline void SpellcastingInfo::clear_spellcasting_focus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spellcasting_focus_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& SpellcastingInfo::spellcasting_focus() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellcastingInfo.spellcasting_focus)
  return _internal_spellcasting_focus();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SpellcastingInfo::set_spellcasting_focus(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.spellcasting_focus_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellcastingInfo.spellcasting_focus)
}
inline ::std::string* PROTOBUF_NONNULL SpellcastingInfo::mutable_spellcasting_focus()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_spellcasting_focus();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SpellcastingInfo.spellcasting_focus)
  return _s;
}
inline const ::std::string& SpellcastingInfo::_internal_spellcasting_focus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spellcasting_focus_.Get();
}
inline void SpellcastingInfo::_internal_set_spellcasting_focus(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.spellcasting_focus_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SpellcastingInfo::_internal_mutable_spellcasting_focus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.spellcasting_focus_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SpellcastingInfo::release_spellcasting_focus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.SpellcastingInfo.spellcasting_focus)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.spellcasting_focus_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.spellcasting_focus_.Set("", GetArena());
  }
  return released;
}
inline void SpellcastingInfo::set_allocated_spellcasting_focus(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.spellcasting_focus_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.spellcasting_focus_.IsDefault()) {
    _impl_.spellcasting_focus_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.SpellcastingInfo.spellcasting_focus)
}

// int32 cantrips_known = 4 [json_name = "cantripsKnown"];
inline void SpellcastingInfo::clear_cantrips_known() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cantrips_known_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SpellcastingInfo::cantrips_known() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellcastingInfo.cantrips_known)
  return _internal_cantrips_known();
}
inline void SpellcastingInfo::set_cantrips_known(::int32_t value) {
  _internal_set_cantrips_known(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellcastingInfo.cantrips_known)
}
inline ::int32_t SpellcastingInfo::_internal_cantrips_known() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cantrips_known_;
}
inline void SpellcastingInfo::_internal_set_cantrips_known(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cantrips_known_ = value;
}

// int32 spells_known = 5 [json_name = "spellsKnown"];
inline void SpellcastingInfo::clear_spells_known() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spells_known_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SpellcastingInfo::spells_known() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellcastingInfo.spells_known)
  return _internal_spells_known();
}
inline void SpellcastingInfo::set_spells_known(::int32_t value) {
  _internal_set_spells_known(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellcastingInfo.spells_known)
}
inline ::int32_t SpellcastingInfo::_internal_spells_known() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spells_known_;
}
inline void SpellcastingInfo::_internal_set_spells_known(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spells_known_ = value;
}

// int32 spell_slots_level_1 = 6 [json_name = "spellSlotsLevel1"];
inline void SpellcastingInfo::clear_spell_slots_level_1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spell_slots_level_1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t SpellcastingInfo::spell_slots_level_1() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellcastingInfo.spell_slots_level_1)
  return _internal_spell_slots_level_1();
}
inline void SpellcastingInfo::set_spell_slots_level_1(::int32_t value) {
  _internal_set_spell_slots_level_1(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellcastingInfo.spell_slots_level_1)
}
inline ::int32_t SpellcastingInfo::_internal_spell_slots_level_1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spell_slots_level_1_;
}
inline void SpellcastingInfo::_internal_set_spell_slots_level_1(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spell_slots_level_1_ = value;
}

// -------------------------------------------------------------------

// BackgroundInfo

// string id = 1 [json_name = "id"];
inline void BackgroundInfo::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BackgroundInfo::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BackgroundInfo::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.id)
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BackgroundInfo.id)
  return _s;
}
inline const ::std::string& BackgroundInfo::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void BackgroundInfo::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BackgroundInfo::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.BackgroundInfo.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void BackgroundInfo::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.BackgroundInfo.id)
}

// string name = 2 [json_name = "name"];
inline void BackgroundInfo::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& BackgroundInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BackgroundInfo::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.name)
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BackgroundInfo.name)
  return _s;
}
inline const ::std::string& BackgroundInfo::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void BackgroundInfo::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BackgroundInfo::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.BackgroundInfo.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void BackgroundInfo::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.BackgroundInfo.name)
}

// string description = 3 [json_name = "description"];
inline void BackgroundInfo::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& BackgroundInfo::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BackgroundInfo::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.description)
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BackgroundInfo.description)
  return _s;
}
inline const ::std::string& BackgroundInfo::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void BackgroundInfo::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BackgroundInfo::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.BackgroundInfo.description)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void BackgroundInfo::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.BackgroundInfo.description)
}

// repeated string skill_proficiencies = 4 [json_name = "skillProficiencies"];
inline int BackgroundInfo::_internal_skill_proficiencies_size() const {
  return _internal_skill_proficiencies().size();
}
inline int BackgroundInfo::skill_proficiencies_size() const {
  return _internal_skill_proficiencies_size();
}
inline void BackgroundInfo::clear_skill_proficiencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skill_proficiencies_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::add_skill_proficiencies()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_skill_proficiencies()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.BackgroundInfo.skill_proficiencies)
  return _s;
}
inline const ::std::string& BackgroundInfo::skill_proficiencies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.skill_proficiencies)
  return _internal_skill_proficiencies().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::mutable_skill_proficiencies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BackgroundInfo.skill_proficiencies)
  return _internal_mutable_skill_proficiencies()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::set_skill_proficiencies(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_skill_proficiencies()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.skill_proficiencies)
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::add_skill_proficiencies(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_skill_proficiencies(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.BackgroundInfo.skill_proficiencies)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& BackgroundInfo::skill_proficiencies()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.BackgroundInfo.skill_proficiencies)
  return _internal_skill_proficiencies();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::mutable_skill_proficiencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.BackgroundInfo.skill_proficiencies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_skill_proficiencies();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
BackgroundInfo::_internal_skill_proficiencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skill_proficiencies_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::_internal_mutable_skill_proficiencies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.skill_proficiencies_;
}

// repeated string tool_proficiencies = 5 [json_name = "toolProficiencies"];
inline int BackgroundInfo::_internal_tool_proficiencies_size() const {
  return _internal_tool_proficiencies().size();
}
inline int BackgroundInfo::tool_proficiencies_size() const {
  return _internal_tool_proficiencies_size();
}
inline void BackgroundInfo::clear_tool_proficiencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tool_proficiencies_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::add_tool_proficiencies()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_tool_proficiencies()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.BackgroundInfo.tool_proficiencies)
  return _s;
}
inline const ::std::string& BackgroundInfo::tool_proficiencies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.tool_proficiencies)
  return _internal_tool_proficiencies().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::mutable_tool_proficiencies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BackgroundInfo.tool_proficiencies)
  return _internal_mutable_tool_proficiencies()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::set_tool_proficiencies(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_tool_proficiencies()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.tool_proficiencies)
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::add_tool_proficiencies(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_tool_proficiencies(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.BackgroundInfo.tool_proficiencies)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& BackgroundInfo::tool_proficiencies()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.BackgroundInfo.tool_proficiencies)
  return _internal_tool_proficiencies();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::mutable_tool_proficiencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.BackgroundInfo.tool_proficiencies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tool_proficiencies();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
BackgroundInfo::_internal_tool_proficiencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tool_proficiencies_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::_internal_mutable_tool_proficiencies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tool_proficiencies_;
}

// repeated .dnd5e.api.v1alpha1.Language languages = 6 [json_name = "languages"];
inline int BackgroundInfo::_internal_languages_size() const {
  return _internal_languages().size();
}
inline int BackgroundInfo::languages_size() const {
  return _internal_languages_size();
}
inline void BackgroundInfo::clear_languages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.languages_.Clear();
}
inline ::dnd5e::api::v1alpha1::Language BackgroundInfo::languages(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.languages)
  return static_cast<::dnd5e::api::v1alpha1::Language>(_internal_languages().Get(index));
}
inline void BackgroundInfo::set_languages(int index, ::dnd5e::api::v1alpha1::Language value) {
  _internal_mutable_languages()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.languages)
}
inline void BackgroundInfo::add_languages(::dnd5e::api::v1alpha1::Language value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_languages()->Add(value);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.BackgroundInfo.languages)
}
inline const ::google::protobuf::RepeatedField<int>& BackgroundInfo::languages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.BackgroundInfo.languages)
  return _internal_languages();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL BackgroundInfo::mutable_languages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.BackgroundInfo.languages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_languages();
}
inline const ::google::protobuf::RepeatedField<int>& BackgroundInfo::_internal_languages()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.languages_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
BackgroundInfo::_internal_mutable_languages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.languages_;
}

// int32 additional_languages = 7 [json_name = "additionalLanguages"];
inline void BackgroundInfo::clear_additional_languages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.additional_languages_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t BackgroundInfo::additional_languages() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.additional_languages)
  return _internal_additional_languages();
}
inline void BackgroundInfo::set_additional_languages(::int32_t value) {
  _internal_set_additional_languages(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.additional_languages)
}
inline ::int32_t BackgroundInfo::_internal_additional_languages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.additional_languages_;
}
inline void BackgroundInfo::_internal_set_additional_languages(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.additional_languages_ = value;
}

// repeated string starting_equipment = 8 [json_name = "startingEquipment"];
inline int BackgroundInfo::_internal_starting_equipment_size() const {
  return _internal_starting_equipment().size();
}
inline int BackgroundInfo::starting_equipment_size() const {
  return _internal_starting_equipment_size();
}
inline void BackgroundInfo::clear_starting_equipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.starting_equipment_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::add_starting_equipment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_starting_equipment()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.BackgroundInfo.starting_equipment)
  return _s;
}
inline const ::std::string& BackgroundInfo::starting_equipment(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.starting_equipment)
  return _internal_starting_equipment().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::mutable_starting_equipment(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BackgroundInfo.starting_equipment)
  return _internal_mutable_starting_equipment()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::set_starting_equipment(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_starting_equipment()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.starting_equipment)
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::add_starting_equipment(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_starting_equipment(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.BackgroundInfo.starting_equipment)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& BackgroundInfo::starting_equipment()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.BackgroundInfo.starting_equipment)
  return _internal_starting_equipment();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::mutable_starting_equipment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.BackgroundInfo.starting_equipment)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_starting_equipment();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
BackgroundInfo::_internal_starting_equipment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.starting_equipment_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::_internal_mutable_starting_equipment() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.starting_equipment_;
}

// int32 starting_gold = 9 [json_name = "startingGold"];
inline void BackgroundInfo::clear_starting_gold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.starting_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t BackgroundInfo::starting_gold() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.starting_gold)
  return _internal_starting_gold();
}
inline void BackgroundInfo::set_starting_gold(::int32_t value) {
  _internal_set_starting_gold(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.starting_gold)
}
inline ::int32_t BackgroundInfo::_internal_starting_gold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.starting_gold_;
}
inline void BackgroundInfo::_internal_set_starting_gold(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.starting_gold_ = value;
}

// string feature_name = 10 [json_name = "featureName"];
inline void BackgroundInfo::clear_feature_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& BackgroundInfo::feature_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.feature_name)
  return _internal_feature_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BackgroundInfo::set_feature_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.feature_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.feature_name)
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::mutable_feature_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_feature_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BackgroundInfo.feature_name)
  return _s;
}
inline const ::std::string& BackgroundInfo::_internal_feature_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.feature_name_.Get();
}
inline void BackgroundInfo::_internal_set_feature_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.feature_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::_internal_mutable_feature_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.feature_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BackgroundInfo::release_feature_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.BackgroundInfo.feature_name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.feature_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.feature_name_.Set("", GetArena());
  }
  return released;
}
inline void BackgroundInfo::set_allocated_feature_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.feature_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.feature_name_.IsDefault()) {
    _impl_.feature_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.BackgroundInfo.feature_name)
}

// string feature_description = 11 [json_name = "featureDescription"];
inline void BackgroundInfo::clear_feature_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& BackgroundInfo::feature_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.feature_description)
  return _internal_feature_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BackgroundInfo::set_feature_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.feature_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.feature_description)
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::mutable_feature_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_feature_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BackgroundInfo.feature_description)
  return _s;
}
inline const ::std::string& BackgroundInfo::_internal_feature_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.feature_description_.Get();
}
inline void BackgroundInfo::_internal_set_feature_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.feature_description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::_internal_mutable_feature_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.feature_description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BackgroundInfo::release_feature_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.BackgroundInfo.feature_description)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.feature_description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.feature_description_.Set("", GetArena());
  }
  return released;
}
inline void BackgroundInfo::set_allocated_feature_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.feature_description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.feature_description_.IsDefault()) {
    _impl_.feature_description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.BackgroundInfo.feature_description)
}

// repeated string personality_traits = 12 [json_name = "personalityTraits"];
inline int BackgroundInfo::_internal_personality_traits_size() const {
  return _internal_personality_traits().size();
}
inline int BackgroundInfo::personality_traits_size() const {
  return _internal_personality_traits_size();
}
inline void BackgroundInfo::clear_personality_traits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.personality_traits_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::add_personality_traits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_personality_traits()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.BackgroundInfo.personality_traits)
  return _s;
}
inline const ::std::string& BackgroundInfo::personality_traits(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.personality_traits)
  return _internal_personality_traits().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::mutable_personality_traits(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BackgroundInfo.personality_traits)
  return _internal_mutable_personality_traits()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::set_personality_traits(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_personality_traits()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.personality_traits)
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::add_personality_traits(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_personality_traits(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.BackgroundInfo.personality_traits)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& BackgroundInfo::personality_traits()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.BackgroundInfo.personality_traits)
  return _internal_personality_traits();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::mutable_personality_traits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.BackgroundInfo.personality_traits)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_personality_traits();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
BackgroundInfo::_internal_personality_traits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.personality_traits_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::_internal_mutable_personality_traits() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.personality_traits_;
}

// repeated string ideals = 13 [json_name = "ideals"];
inline int BackgroundInfo::_internal_ideals_size() const {
  return _internal_ideals().size();
}
inline int BackgroundInfo::ideals_size() const {
  return _internal_ideals_size();
}
inline void BackgroundInfo::clear_ideals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ideals_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::add_ideals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_ideals()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.BackgroundInfo.ideals)
  return _s;
}
inline const ::std::string& BackgroundInfo::ideals(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.ideals)
  return _internal_ideals().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::mutable_ideals(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BackgroundInfo.ideals)
  return _internal_mutable_ideals()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::set_ideals(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_ideals()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.ideals)
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::add_ideals(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_ideals(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.BackgroundInfo.ideals)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& BackgroundInfo::ideals()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.BackgroundInfo.ideals)
  return _internal_ideals();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::mutable_ideals() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.BackgroundInfo.ideals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ideals();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
BackgroundInfo::_internal_ideals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ideals_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::_internal_mutable_ideals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ideals_;
}

// repeated string bonds = 14 [json_name = "bonds"];
inline int BackgroundInfo::_internal_bonds_size() const {
  return _internal_bonds().size();
}
inline int BackgroundInfo::bonds_size() const {
  return _internal_bonds_size();
}
inline void BackgroundInfo::clear_bonds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonds_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::add_bonds()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_bonds()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.BackgroundInfo.bonds)
  return _s;
}
inline const ::std::string& BackgroundInfo::bonds(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.bonds)
  return _internal_bonds().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::mutable_bonds(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BackgroundInfo.bonds)
  return _internal_mutable_bonds()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::set_bonds(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_bonds()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.bonds)
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::add_bonds(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_bonds(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.BackgroundInfo.bonds)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& BackgroundInfo::bonds()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.BackgroundInfo.bonds)
  return _internal_bonds();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::mutable_bonds() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.BackgroundInfo.bonds)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_bonds();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
BackgroundInfo::_internal_bonds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bonds_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::_internal_mutable_bonds() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.bonds_;
}

// repeated string flaws = 15 [json_name = "flaws"];
inline int BackgroundInfo::_internal_flaws_size() const {
  return _internal_flaws().size();
}
inline int BackgroundInfo::flaws_size() const {
  return _internal_flaws_size();
}
inline void BackgroundInfo::clear_flaws() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flaws_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::add_flaws()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_flaws()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.BackgroundInfo.flaws)
  return _s;
}
inline const ::std::string& BackgroundInfo::flaws(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.BackgroundInfo.flaws)
  return _internal_flaws().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL BackgroundInfo::mutable_flaws(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.BackgroundInfo.flaws)
  return _internal_mutable_flaws()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::set_flaws(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_flaws()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.BackgroundInfo.flaws)
}
template <typename Arg_, typename... Args_>
inline void BackgroundInfo::add_flaws(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_flaws(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.BackgroundInfo.flaws)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& BackgroundInfo::flaws()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.BackgroundInfo.flaws)
  return _internal_flaws();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::mutable_flaws() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.BackgroundInfo.flaws)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_flaws();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
BackgroundInfo::_internal_flaws() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.flaws_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BackgroundInfo::_internal_mutable_flaws() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.flaws_;
}

// -------------------------------------------------------------------

// FeatureInfo

// string id = 1 [json_name = "id"];
inline void FeatureInfo::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& FeatureInfo::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FeatureInfo.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FeatureInfo::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FeatureInfo.id)
}
inline ::std::string* PROTOBUF_NONNULL FeatureInfo::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.FeatureInfo.id)
  return _s;
}
inline const ::std::string& FeatureInfo::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void FeatureInfo::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FeatureInfo::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FeatureInfo::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.FeatureInfo.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void FeatureInfo::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.FeatureInfo.id)
}

// string name = 2 [json_name = "name"];
inline void FeatureInfo::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& FeatureInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FeatureInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FeatureInfo::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FeatureInfo.name)
}
inline ::std::string* PROTOBUF_NONNULL FeatureInfo::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.FeatureInfo.name)
  return _s;
}
inline const ::std::string& FeatureInfo::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void FeatureInfo::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FeatureInfo::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FeatureInfo::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.FeatureInfo.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void FeatureInfo::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.FeatureInfo.name)
}

// string description = 3 [json_name = "description"];
inline void FeatureInfo::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& FeatureInfo::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FeatureInfo.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FeatureInfo::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FeatureInfo.description)
}
inline ::std::string* PROTOBUF_NONNULL FeatureInfo::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.FeatureInfo.description)
  return _s;
}
inline const ::std::string& FeatureInfo::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void FeatureInfo::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FeatureInfo::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FeatureInfo::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.FeatureInfo.description)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void FeatureInfo::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.FeatureInfo.description)
}

// int32 level = 4 [json_name = "level"];
inline void FeatureInfo::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t FeatureInfo::level() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FeatureInfo.level)
  return _internal_level();
}
inline void FeatureInfo::set_level(::int32_t value) {
  _internal_set_level(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FeatureInfo.level)
}
inline ::int32_t FeatureInfo::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_;
}
inline void FeatureInfo::_internal_set_level(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = value;
}

// string class_name = 5 [json_name = "className"];
inline void FeatureInfo::clear_class_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& FeatureInfo::class_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FeatureInfo.class_name)
  return _internal_class_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FeatureInfo::set_class_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.class_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FeatureInfo.class_name)
}
inline ::std::string* PROTOBUF_NONNULL FeatureInfo::mutable_class_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.FeatureInfo.class_name)
  return _s;
}
inline const ::std::string& FeatureInfo::_internal_class_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.class_name_.Get();
}
inline void FeatureInfo::_internal_set_class_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.class_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FeatureInfo::_internal_mutable_class_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.class_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FeatureInfo::release_class_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.FeatureInfo.class_name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.class_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.class_name_.Set("", GetArena());
  }
  return released;
}
inline void FeatureInfo::set_allocated_class_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.class_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.class_name_.IsDefault()) {
    _impl_.class_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.FeatureInfo.class_name)
}

// repeated .dnd5e.api.v1alpha1.Choice choices = 6 [json_name = "choices"];
inline int FeatureInfo::_internal_choices_size() const {
  return _internal_choices().size();
}
inline int FeatureInfo::choices_size() const {
  return _internal_choices_size();
}
inline void FeatureInfo::clear_choices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choices_.Clear();
}
inline ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL FeatureInfo::mutable_choices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.FeatureInfo.choices)
  return _internal_mutable_choices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>* PROTOBUF_NONNULL FeatureInfo::mutable_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.FeatureInfo.choices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_choices();
}
inline const ::dnd5e::api::v1alpha1::Choice& FeatureInfo::choices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FeatureInfo.choices)
  return _internal_choices().Get(index);
}
inline ::dnd5e::api::v1alpha1::Choice* PROTOBUF_NONNULL FeatureInfo::add_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::Choice* _add = _internal_mutable_choices()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.FeatureInfo.choices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>& FeatureInfo::choices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.FeatureInfo.choices)
  return _internal_choices();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>&
FeatureInfo::_internal_choices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.choices_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Choice>* PROTOBUF_NONNULL
FeatureInfo::_internal_mutable_choices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.choices_;
}

// bool has_choices = 7 [json_name = "hasChoices"];
inline void FeatureInfo::clear_has_choices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_choices_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool FeatureInfo::has_choices() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FeatureInfo.has_choices)
  return _internal_has_choices();
}
inline void FeatureInfo::set_has_choices(bool value) {
  _internal_set_has_choices(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FeatureInfo.has_choices)
}
inline bool FeatureInfo::_internal_has_choices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_choices_;
}
inline void FeatureInfo::_internal_set_has_choices(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_choices_ = value;
}

// .dnd5e.api.v1alpha1.SpellSelectionInfo spell_selection = 8 [json_name = "spellSelection"];
inline bool FeatureInfo::has_spell_selection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spell_selection_ != nullptr);
  return value;
}
inline void FeatureInfo::clear_spell_selection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.spell_selection_ != nullptr) _impl_.spell_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::dnd5e::api::v1alpha1::SpellSelectionInfo& FeatureInfo::_internal_spell_selection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::SpellSelectionInfo* p = _impl_.spell_selection_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::SpellSelectionInfo&>(::dnd5e::api::v1alpha1::_SpellSelectionInfo_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SpellSelectionInfo& FeatureInfo::spell_selection() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FeatureInfo.spell_selection)
  return _internal_spell_selection();
}
inline void FeatureInfo::unsafe_arena_set_allocated_spell_selection(
    ::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spell_selection_);
  }
  _impl_.spell_selection_ = reinterpret_cast<::dnd5e::api::v1alpha1::SpellSelectionInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.FeatureInfo.spell_selection)
}
inline ::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NULLABLE FeatureInfo::release_spell_selection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::SpellSelectionInfo* released = _impl_.spell_selection_;
  _impl_.spell_selection_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NULLABLE FeatureInfo::unsafe_arena_release_spell_selection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.FeatureInfo.spell_selection)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::SpellSelectionInfo* temp = _impl_.spell_selection_;
  _impl_.spell_selection_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NONNULL FeatureInfo::_internal_mutable_spell_selection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.spell_selection_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SpellSelectionInfo>(GetArena());
    _impl_.spell_selection_ = reinterpret_cast<::dnd5e::api::v1alpha1::SpellSelectionInfo*>(p);
  }
  return _impl_.spell_selection_;
}
inline ::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NONNULL FeatureInfo::mutable_spell_selection()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::dnd5e::api::v1alpha1::SpellSelectionInfo* _msg = _internal_mutable_spell_selection();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.FeatureInfo.spell_selection)
  return _msg;
}
inline void FeatureInfo::set_allocated_spell_selection(::dnd5e::api::v1alpha1::SpellSelectionInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spell_selection_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.spell_selection_ = reinterpret_cast<::dnd5e::api::v1alpha1::SpellSelectionInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.FeatureInfo.spell_selection)
}

// -------------------------------------------------------------------

// SpellSelectionInfo

// int32 spells_to_select = 1 [json_name = "spellsToSelect"];
inline void SpellSelectionInfo::clear_spells_to_select() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spells_to_select_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SpellSelectionInfo::spells_to_select() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellSelectionInfo.spells_to_select)
  return _internal_spells_to_select();
}
inline void SpellSelectionInfo::set_spells_to_select(::int32_t value) {
  _internal_set_spells_to_select(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellSelectionInfo.spells_to_select)
}
inline ::int32_t SpellSelectionInfo::_internal_spells_to_select() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spells_to_select_;
}
inline void SpellSelectionInfo::_internal_set_spells_to_select(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spells_to_select_ = value;
}

// repeated int32 spell_levels = 2 [json_name = "spellLevels"];
inline int SpellSelectionInfo::_internal_spell_levels_size() const {
  return _internal_spell_levels().size();
}
inline int SpellSelectionInfo::spell_levels_size() const {
  return _internal_spell_levels_size();
}
inline void SpellSelectionInfo::clear_spell_levels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spell_levels_.Clear();
}
inline ::int32_t SpellSelectionInfo::spell_levels(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellSelectionInfo.spell_levels)
  return _internal_spell_levels().Get(index);
}
inline void SpellSelectionInfo::set_spell_levels(int index, ::int32_t value) {
  _internal_mutable_spell_levels()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellSelectionInfo.spell_levels)
}
inline void SpellSelectionInfo::add_spell_levels(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_spell_levels()->Add(value);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.SpellSelectionInfo.spell_levels)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SpellSelectionInfo::spell_levels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.SpellSelectionInfo.spell_levels)
  return _internal_spell_levels();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL SpellSelectionInfo::mutable_spell_levels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.SpellSelectionInfo.spell_levels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_spell_levels();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SpellSelectionInfo::_internal_spell_levels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spell_levels_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
SpellSelectionInfo::_internal_mutable_spell_levels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.spell_levels_;
}

// repeated string spell_lists = 3 [json_name = "spellLists"];
inline int SpellSelectionInfo::_internal_spell_lists_size() const {
  return _internal_spell_lists().size();
}
inline int SpellSelectionInfo::spell_lists_size() const {
  return _internal_spell_lists_size();
}
inline void SpellSelectionInfo::clear_spell_lists() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spell_lists_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL SpellSelectionInfo::add_spell_lists()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_spell_lists()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.SpellSelectionInfo.spell_lists)
  return _s;
}
inline const ::std::string& SpellSelectionInfo::spell_lists(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellSelectionInfo.spell_lists)
  return _internal_spell_lists().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL SpellSelectionInfo::mutable_spell_lists(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SpellSelectionInfo.spell_lists)
  return _internal_mutable_spell_lists()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SpellSelectionInfo::set_spell_lists(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_spell_lists()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellSelectionInfo.spell_lists)
}
template <typename Arg_, typename... Args_>
inline void SpellSelectionInfo::add_spell_lists(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_spell_lists(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.SpellSelectionInfo.spell_lists)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& SpellSelectionInfo::spell_lists()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.SpellSelectionInfo.spell_lists)
  return _internal_spell_lists();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SpellSelectionInfo::mutable_spell_lists() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.SpellSelectionInfo.spell_lists)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_spell_lists();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SpellSelectionInfo::_internal_spell_lists() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spell_lists_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SpellSelectionInfo::_internal_mutable_spell_lists() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.spell_lists_;
}

// .dnd5e.api.v1alpha1.SpellSelectionType selection_type = 4 [json_name = "selectionType"];
inline void SpellSelectionInfo::clear_selection_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.selection_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::dnd5e::api::v1alpha1::SpellSelectionType SpellSelectionInfo::selection_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellSelectionInfo.selection_type)
  return _internal_selection_type();
}
inline void SpellSelectionInfo::set_selection_type(::dnd5e::api::v1alpha1::SpellSelectionType value) {
  _internal_set_selection_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellSelectionInfo.selection_type)
}
inline ::dnd5e::api::v1alpha1::SpellSelectionType SpellSelectionInfo::_internal_selection_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::SpellSelectionType>(_impl_.selection_type_);
}
inline void SpellSelectionInfo::_internal_set_selection_type(::dnd5e::api::v1alpha1::SpellSelectionType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.selection_type_ = value;
}

// bool requires_replace = 5 [json_name = "requiresReplace"];
inline void SpellSelectionInfo::clear_requires_replace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requires_replace_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SpellSelectionInfo::requires_replace() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellSelectionInfo.requires_replace)
  return _internal_requires_replace();
}
inline void SpellSelectionInfo::set_requires_replace(bool value) {
  _internal_set_requires_replace(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellSelectionInfo.requires_replace)
}
inline bool SpellSelectionInfo::_internal_requires_replace() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.requires_replace_;
}
inline void SpellSelectionInfo::_internal_set_requires_replace(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requires_replace_ = value;
}

// -------------------------------------------------------------------

// ListRacesRequest

// int32 page_size = 1 [json_name = "pageSize"];
inline void ListRacesRequest::clear_page_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ListRacesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListRacesRequest.page_size)
  return _internal_page_size();
}
inline void ListRacesRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListRacesRequest.page_size)
}
inline ::int32_t ListRacesRequest::_internal_page_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_size_;
}
inline void ListRacesRequest::_internal_set_page_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = value;
}

// string page_token = 2 [json_name = "pageToken"];
inline void ListRacesRequest::clear_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListRacesRequest::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListRacesRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListRacesRequest::set_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListRacesRequest.page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListRacesRequest::mutable_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListRacesRequest.page_token)
  return _s;
}
inline const ::std::string& ListRacesRequest::_internal_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_token_.Get();
}
inline void ListRacesRequest::_internal_set_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListRacesRequest::_internal_mutable_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListRacesRequest::release_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListRacesRequest.page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListRacesRequest::set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListRacesRequest.page_token)
}

// bool include_subraces = 3 [json_name = "includeSubraces"];
inline void ListRacesRequest::clear_include_subraces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_subraces_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ListRacesRequest::include_subraces() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListRacesRequest.include_subraces)
  return _internal_include_subraces();
}
inline void ListRacesRequest::set_include_subraces(bool value) {
  _internal_set_include_subraces(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListRacesRequest.include_subraces)
}
inline bool ListRacesRequest::_internal_include_subraces() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.include_subraces_;
}
inline void ListRacesRequest::_internal_set_include_subraces(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_subraces_ = value;
}

// -------------------------------------------------------------------

// ListRacesResponse

// repeated .dnd5e.api.v1alpha1.RaceInfo races = 1 [json_name = "races"];
inline int ListRacesResponse::_internal_races_size() const {
  return _internal_races().size();
}
inline int ListRacesResponse::races_size() const {
  return _internal_races_size();
}
inline void ListRacesResponse::clear_races() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.races_.Clear();
}
inline ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NONNULL ListRacesResponse::mutable_races(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListRacesResponse.races)
  return _internal_mutable_races()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RaceInfo>* PROTOBUF_NONNULL ListRacesResponse::mutable_races()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ListRacesResponse.races)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_races();
}
inline const ::dnd5e::api::v1alpha1::RaceInfo& ListRacesResponse::races(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListRacesResponse.races)
  return _internal_races().Get(index);
}
inline ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NONNULL ListRacesResponse::add_races()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::RaceInfo* _add = _internal_mutable_races()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ListRacesResponse.races)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RaceInfo>& ListRacesResponse::races() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ListRacesResponse.races)
  return _internal_races();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RaceInfo>&
ListRacesResponse::_internal_races() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.races_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RaceInfo>* PROTOBUF_NONNULL
ListRacesResponse::_internal_mutable_races() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.races_;
}

// string next_page_token = 2 [json_name = "nextPageToken"];
inline void ListRacesResponse::clear_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListRacesResponse::next_page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListRacesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListRacesResponse::set_next_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListRacesResponse.next_page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListRacesResponse::mutable_next_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListRacesResponse.next_page_token)
  return _s;
}
inline const ::std::string& ListRacesResponse::_internal_next_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_page_token_.Get();
}
inline void ListRacesResponse::_internal_set_next_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListRacesResponse::_internal_mutable_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.next_page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListRacesResponse::release_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListRacesResponse.next_page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.next_page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListRacesResponse::set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.next_page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListRacesResponse.next_page_token)
}

// int32 total_size = 3 [json_name = "totalSize"];
inline void ListRacesResponse::clear_total_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ListRacesResponse::total_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListRacesResponse.total_size)
  return _internal_total_size();
}
inline void ListRacesResponse::set_total_size(::int32_t value) {
  _internal_set_total_size(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListRacesResponse.total_size)
}
inline ::int32_t ListRacesResponse::_internal_total_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_size_;
}
inline void ListRacesResponse::_internal_set_total_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = value;
}

// -------------------------------------------------------------------

// ListClassesRequest

// int32 page_size = 1 [json_name = "pageSize"];
inline void ListClassesRequest::clear_page_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ListClassesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListClassesRequest.page_size)
  return _internal_page_size();
}
inline void ListClassesRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListClassesRequest.page_size)
}
inline ::int32_t ListClassesRequest::_internal_page_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_size_;
}
inline void ListClassesRequest::_internal_set_page_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = value;
}

// string page_token = 2 [json_name = "pageToken"];
inline void ListClassesRequest::clear_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListClassesRequest::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListClassesRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListClassesRequest::set_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListClassesRequest.page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListClassesRequest::mutable_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListClassesRequest.page_token)
  return _s;
}
inline const ::std::string& ListClassesRequest::_internal_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_token_.Get();
}
inline void ListClassesRequest::_internal_set_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListClassesRequest::_internal_mutable_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListClassesRequest::release_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListClassesRequest.page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListClassesRequest::set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListClassesRequest.page_token)
}

// bool include_spellcasters_only = 3 [json_name = "includeSpellcastersOnly"];
inline void ListClassesRequest::clear_include_spellcasters_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_spellcasters_only_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ListClassesRequest::include_spellcasters_only() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListClassesRequest.include_spellcasters_only)
  return _internal_include_spellcasters_only();
}
inline void ListClassesRequest::set_include_spellcasters_only(bool value) {
  _internal_set_include_spellcasters_only(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListClassesRequest.include_spellcasters_only)
}
inline bool ListClassesRequest::_internal_include_spellcasters_only() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.include_spellcasters_only_;
}
inline void ListClassesRequest::_internal_set_include_spellcasters_only(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_spellcasters_only_ = value;
}

// bool include_features = 4 [json_name = "includeFeatures"];
inline void ListClassesRequest::clear_include_features() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_features_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ListClassesRequest::include_features() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListClassesRequest.include_features)
  return _internal_include_features();
}
inline void ListClassesRequest::set_include_features(bool value) {
  _internal_set_include_features(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListClassesRequest.include_features)
}
inline bool ListClassesRequest::_internal_include_features() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.include_features_;
}
inline void ListClassesRequest::_internal_set_include_features(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_features_ = value;
}

// -------------------------------------------------------------------

// ListClassesResponse

// repeated .dnd5e.api.v1alpha1.ClassInfo classes = 1 [json_name = "classes"];
inline int ListClassesResponse::_internal_classes_size() const {
  return _internal_classes().size();
}
inline int ListClassesResponse::classes_size() const {
  return _internal_classes_size();
}
inline void ListClassesResponse::clear_classes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.classes_.Clear();
}
inline ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NONNULL ListClassesResponse::mutable_classes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListClassesResponse.classes)
  return _internal_mutable_classes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ClassInfo>* PROTOBUF_NONNULL ListClassesResponse::mutable_classes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ListClassesResponse.classes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_classes();
}
inline const ::dnd5e::api::v1alpha1::ClassInfo& ListClassesResponse::classes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListClassesResponse.classes)
  return _internal_classes().Get(index);
}
inline ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NONNULL ListClassesResponse::add_classes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::ClassInfo* _add = _internal_mutable_classes()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ListClassesResponse.classes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ClassInfo>& ListClassesResponse::classes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ListClassesResponse.classes)
  return _internal_classes();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ClassInfo>&
ListClassesResponse::_internal_classes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.classes_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::ClassInfo>* PROTOBUF_NONNULL
ListClassesResponse::_internal_mutable_classes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.classes_;
}

// string next_page_token = 2 [json_name = "nextPageToken"];
inline void ListClassesResponse::clear_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListClassesResponse::next_page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListClassesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListClassesResponse::set_next_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListClassesResponse.next_page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListClassesResponse::mutable_next_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListClassesResponse.next_page_token)
  return _s;
}
inline const ::std::string& ListClassesResponse::_internal_next_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_page_token_.Get();
}
inline void ListClassesResponse::_internal_set_next_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListClassesResponse::_internal_mutable_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.next_page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListClassesResponse::release_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListClassesResponse.next_page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.next_page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListClassesResponse::set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.next_page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListClassesResponse.next_page_token)
}

// int32 total_size = 3 [json_name = "totalSize"];
inline void ListClassesResponse::clear_total_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ListClassesResponse::total_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListClassesResponse.total_size)
  return _internal_total_size();
}
inline void ListClassesResponse::set_total_size(::int32_t value) {
  _internal_set_total_size(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListClassesResponse.total_size)
}
inline ::int32_t ListClassesResponse::_internal_total_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_size_;
}
inline void ListClassesResponse::_internal_set_total_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = value;
}

// -------------------------------------------------------------------

// ListBackgroundsRequest

// int32 page_size = 1 [json_name = "pageSize"];
inline void ListBackgroundsRequest::clear_page_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ListBackgroundsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListBackgroundsRequest.page_size)
  return _internal_page_size();
}
inline void ListBackgroundsRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListBackgroundsRequest.page_size)
}
inline ::int32_t ListBackgroundsRequest::_internal_page_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_size_;
}
inline void ListBackgroundsRequest::_internal_set_page_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = value;
}

// string page_token = 2 [json_name = "pageToken"];
inline void ListBackgroundsRequest::clear_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListBackgroundsRequest::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListBackgroundsRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListBackgroundsRequest::set_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListBackgroundsRequest.page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListBackgroundsRequest::mutable_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListBackgroundsRequest.page_token)
  return _s;
}
inline const ::std::string& ListBackgroundsRequest::_internal_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_token_.Get();
}
inline void ListBackgroundsRequest::_internal_set_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListBackgroundsRequest::_internal_mutable_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListBackgroundsRequest::release_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListBackgroundsRequest.page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListBackgroundsRequest::set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListBackgroundsRequest.page_token)
}

// -------------------------------------------------------------------

// ListBackgroundsResponse

// repeated .dnd5e.api.v1alpha1.BackgroundInfo backgrounds = 1 [json_name = "backgrounds"];
inline int ListBackgroundsResponse::_internal_backgrounds_size() const {
  return _internal_backgrounds().size();
}
inline int ListBackgroundsResponse::backgrounds_size() const {
  return _internal_backgrounds_size();
}
inline void ListBackgroundsResponse::clear_backgrounds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backgrounds_.Clear();
}
inline ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NONNULL ListBackgroundsResponse::mutable_backgrounds(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListBackgroundsResponse.backgrounds)
  return _internal_mutable_backgrounds()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BackgroundInfo>* PROTOBUF_NONNULL ListBackgroundsResponse::mutable_backgrounds()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ListBackgroundsResponse.backgrounds)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_backgrounds();
}
inline const ::dnd5e::api::v1alpha1::BackgroundInfo& ListBackgroundsResponse::backgrounds(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListBackgroundsResponse.backgrounds)
  return _internal_backgrounds().Get(index);
}
inline ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NONNULL ListBackgroundsResponse::add_backgrounds()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::BackgroundInfo* _add = _internal_mutable_backgrounds()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ListBackgroundsResponse.backgrounds)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BackgroundInfo>& ListBackgroundsResponse::backgrounds() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ListBackgroundsResponse.backgrounds)
  return _internal_backgrounds();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BackgroundInfo>&
ListBackgroundsResponse::_internal_backgrounds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.backgrounds_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::BackgroundInfo>* PROTOBUF_NONNULL
ListBackgroundsResponse::_internal_mutable_backgrounds() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.backgrounds_;
}

// string next_page_token = 2 [json_name = "nextPageToken"];
inline void ListBackgroundsResponse::clear_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListBackgroundsResponse::next_page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListBackgroundsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListBackgroundsResponse::set_next_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListBackgroundsResponse.next_page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListBackgroundsResponse::mutable_next_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListBackgroundsResponse.next_page_token)
  return _s;
}
inline const ::std::string& ListBackgroundsResponse::_internal_next_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_page_token_.Get();
}
inline void ListBackgroundsResponse::_internal_set_next_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListBackgroundsResponse::_internal_mutable_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.next_page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListBackgroundsResponse::release_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListBackgroundsResponse.next_page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.next_page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListBackgroundsResponse::set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.next_page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListBackgroundsResponse.next_page_token)
}

// int32 total_size = 3 [json_name = "totalSize"];
inline void ListBackgroundsResponse::clear_total_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ListBackgroundsResponse::total_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListBackgroundsResponse.total_size)
  return _internal_total_size();
}
inline void ListBackgroundsResponse::set_total_size(::int32_t value) {
  _internal_set_total_size(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListBackgroundsResponse.total_size)
}
inline ::int32_t ListBackgroundsResponse::_internal_total_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_size_;
}
inline void ListBackgroundsResponse::_internal_set_total_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = value;
}

// -------------------------------------------------------------------

// GetRaceDetailsRequest

// string race_id = 1 [json_name = "raceId"];
inline void GetRaceDetailsRequest::clear_race_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.race_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetRaceDetailsRequest::race_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetRaceDetailsRequest.race_id)
  return _internal_race_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetRaceDetailsRequest::set_race_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.race_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetRaceDetailsRequest.race_id)
}
inline ::std::string* PROTOBUF_NONNULL GetRaceDetailsRequest::mutable_race_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_race_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetRaceDetailsRequest.race_id)
  return _s;
}
inline const ::std::string& GetRaceDetailsRequest::_internal_race_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.race_id_.Get();
}
inline void GetRaceDetailsRequest::_internal_set_race_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.race_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetRaceDetailsRequest::_internal_mutable_race_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.race_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetRaceDetailsRequest::release_race_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetRaceDetailsRequest.race_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.race_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.race_id_.Set("", GetArena());
  }
  return released;
}
inline void GetRaceDetailsRequest::set_allocated_race_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.race_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.race_id_.IsDefault()) {
    _impl_.race_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetRaceDetailsRequest.race_id)
}

// -------------------------------------------------------------------

// GetRaceDetailsResponse

// .dnd5e.api.v1alpha1.RaceInfo race = 1 [json_name = "race"];
inline bool GetRaceDetailsResponse::has_race() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.race_ != nullptr);
  return value;
}
inline void GetRaceDetailsResponse::clear_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.race_ != nullptr) _impl_.race_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::RaceInfo& GetRaceDetailsResponse::_internal_race() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::RaceInfo* p = _impl_.race_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::RaceInfo&>(::dnd5e::api::v1alpha1::_RaceInfo_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::RaceInfo& GetRaceDetailsResponse::race() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetRaceDetailsResponse.race)
  return _internal_race();
}
inline void GetRaceDetailsResponse::unsafe_arena_set_allocated_race(
    ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.race_);
  }
  _impl_.race_ = reinterpret_cast<::dnd5e::api::v1alpha1::RaceInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetRaceDetailsResponse.race)
}
inline ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE GetRaceDetailsResponse::release_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::RaceInfo* released = _impl_.race_;
  _impl_.race_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE GetRaceDetailsResponse::unsafe_arena_release_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetRaceDetailsResponse.race)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::RaceInfo* temp = _impl_.race_;
  _impl_.race_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NONNULL GetRaceDetailsResponse::_internal_mutable_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.race_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::RaceInfo>(GetArena());
    _impl_.race_ = reinterpret_cast<::dnd5e::api::v1alpha1::RaceInfo*>(p);
  }
  return _impl_.race_;
}
inline ::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NONNULL GetRaceDetailsResponse::mutable_race()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::RaceInfo* _msg = _internal_mutable_race();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetRaceDetailsResponse.race)
  return _msg;
}
inline void GetRaceDetailsResponse::set_allocated_race(::dnd5e::api::v1alpha1::RaceInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.race_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.race_ = reinterpret_cast<::dnd5e::api::v1alpha1::RaceInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetRaceDetailsResponse.race)
}

// -------------------------------------------------------------------

// GetClassDetailsRequest

// string class_id = 1 [json_name = "classId"];
inline void GetClassDetailsRequest::clear_class_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetClassDetailsRequest::class_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetClassDetailsRequest.class_id)
  return _internal_class_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetClassDetailsRequest::set_class_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.class_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetClassDetailsRequest.class_id)
}
inline ::std::string* PROTOBUF_NONNULL GetClassDetailsRequest::mutable_class_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_class_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetClassDetailsRequest.class_id)
  return _s;
}
inline const ::std::string& GetClassDetailsRequest::_internal_class_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.class_id_.Get();
}
inline void GetClassDetailsRequest::_internal_set_class_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.class_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetClassDetailsRequest::_internal_mutable_class_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.class_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetClassDetailsRequest::release_class_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetClassDetailsRequest.class_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.class_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.class_id_.Set("", GetArena());
  }
  return released;
}
inline void GetClassDetailsRequest::set_allocated_class_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.class_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.class_id_.IsDefault()) {
    _impl_.class_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetClassDetailsRequest.class_id)
}

// -------------------------------------------------------------------

// GetClassDetailsResponse

// .dnd5e.api.v1alpha1.ClassInfo class = 1 [json_name = "class"];
inline bool GetClassDetailsResponse::has_class_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.class__ != nullptr);
  return value;
}
inline void GetClassDetailsResponse::clear_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.class__ != nullptr) _impl_.class__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::ClassInfo& GetClassDetailsResponse::_internal_class_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::ClassInfo* p = _impl_.class__;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::ClassInfo&>(::dnd5e::api::v1alpha1::_ClassInfo_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ClassInfo& GetClassDetailsResponse::class_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetClassDetailsResponse.class)
  return _internal_class_();
}
inline void GetClassDetailsResponse::unsafe_arena_set_allocated_class_(
    ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.class__);
  }
  _impl_.class__ = reinterpret_cast<::dnd5e::api::v1alpha1::ClassInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetClassDetailsResponse.class)
}
inline ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE GetClassDetailsResponse::release_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::ClassInfo* released = _impl_.class__;
  _impl_.class__ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE GetClassDetailsResponse::unsafe_arena_release_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetClassDetailsResponse.class)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::ClassInfo* temp = _impl_.class__;
  _impl_.class__ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NONNULL GetClassDetailsResponse::_internal_mutable_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.class__ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ClassInfo>(GetArena());
    _impl_.class__ = reinterpret_cast<::dnd5e::api::v1alpha1::ClassInfo*>(p);
  }
  return _impl_.class__;
}
inline ::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NONNULL GetClassDetailsResponse::mutable_class_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::ClassInfo* _msg = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetClassDetailsResponse.class)
  return _msg;
}
inline void GetClassDetailsResponse::set_allocated_class_(::dnd5e::api::v1alpha1::ClassInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.class__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.class__ = reinterpret_cast<::dnd5e::api::v1alpha1::ClassInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetClassDetailsResponse.class)
}

// -------------------------------------------------------------------

// GetBackgroundDetailsRequest

// string background_id = 1 [json_name = "backgroundId"];
inline void GetBackgroundDetailsRequest::clear_background_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.background_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetBackgroundDetailsRequest::background_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetBackgroundDetailsRequest.background_id)
  return _internal_background_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetBackgroundDetailsRequest::set_background_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.background_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetBackgroundDetailsRequest.background_id)
}
inline ::std::string* PROTOBUF_NONNULL GetBackgroundDetailsRequest::mutable_background_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_background_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetBackgroundDetailsRequest.background_id)
  return _s;
}
inline const ::std::string& GetBackgroundDetailsRequest::_internal_background_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.background_id_.Get();
}
inline void GetBackgroundDetailsRequest::_internal_set_background_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.background_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetBackgroundDetailsRequest::_internal_mutable_background_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.background_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetBackgroundDetailsRequest::release_background_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetBackgroundDetailsRequest.background_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.background_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.background_id_.Set("", GetArena());
  }
  return released;
}
inline void GetBackgroundDetailsRequest::set_allocated_background_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.background_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.background_id_.IsDefault()) {
    _impl_.background_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetBackgroundDetailsRequest.background_id)
}

// -------------------------------------------------------------------

// GetBackgroundDetailsResponse

// .dnd5e.api.v1alpha1.BackgroundInfo background = 1 [json_name = "background"];
inline bool GetBackgroundDetailsResponse::has_background() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.background_ != nullptr);
  return value;
}
inline void GetBackgroundDetailsResponse::clear_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.background_ != nullptr) _impl_.background_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::BackgroundInfo& GetBackgroundDetailsResponse::_internal_background() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::BackgroundInfo* p = _impl_.background_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::BackgroundInfo&>(::dnd5e::api::v1alpha1::_BackgroundInfo_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::BackgroundInfo& GetBackgroundDetailsResponse::background() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetBackgroundDetailsResponse.background)
  return _internal_background();
}
inline void GetBackgroundDetailsResponse::unsafe_arena_set_allocated_background(
    ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.background_);
  }
  _impl_.background_ = reinterpret_cast<::dnd5e::api::v1alpha1::BackgroundInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetBackgroundDetailsResponse.background)
}
inline ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE GetBackgroundDetailsResponse::release_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::BackgroundInfo* released = _impl_.background_;
  _impl_.background_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE GetBackgroundDetailsResponse::unsafe_arena_release_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetBackgroundDetailsResponse.background)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::BackgroundInfo* temp = _impl_.background_;
  _impl_.background_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NONNULL GetBackgroundDetailsResponse::_internal_mutable_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.background_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::BackgroundInfo>(GetArena());
    _impl_.background_ = reinterpret_cast<::dnd5e::api::v1alpha1::BackgroundInfo*>(p);
  }
  return _impl_.background_;
}
inline ::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NONNULL GetBackgroundDetailsResponse::mutable_background()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::BackgroundInfo* _msg = _internal_mutable_background();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetBackgroundDetailsResponse.background)
  return _msg;
}
inline void GetBackgroundDetailsResponse::set_allocated_background(::dnd5e::api::v1alpha1::BackgroundInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.background_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.background_ = reinterpret_cast<::dnd5e::api::v1alpha1::BackgroundInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetBackgroundDetailsResponse.background)
}

// -------------------------------------------------------------------

// GetFeatureRequest

// string feature_id = 1 [json_name = "featureId"];
inline void GetFeatureRequest::clear_feature_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetFeatureRequest::feature_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetFeatureRequest.feature_id)
  return _internal_feature_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetFeatureRequest::set_feature_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.feature_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetFeatureRequest.feature_id)
}
inline ::std::string* PROTOBUF_NONNULL GetFeatureRequest::mutable_feature_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_feature_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetFeatureRequest.feature_id)
  return _s;
}
inline const ::std::string& GetFeatureRequest::_internal_feature_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.feature_id_.Get();
}
inline void GetFeatureRequest::_internal_set_feature_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.feature_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetFeatureRequest::_internal_mutable_feature_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.feature_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetFeatureRequest::release_feature_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetFeatureRequest.feature_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.feature_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.feature_id_.Set("", GetArena());
  }
  return released;
}
inline void GetFeatureRequest::set_allocated_feature_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.feature_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.feature_id_.IsDefault()) {
    _impl_.feature_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetFeatureRequest.feature_id)
}

// -------------------------------------------------------------------

// GetFeatureResponse

// .dnd5e.api.v1alpha1.FeatureInfo feature = 1 [json_name = "feature"];
inline bool GetFeatureResponse::has_feature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.feature_ != nullptr);
  return value;
}
inline void GetFeatureResponse::clear_feature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.feature_ != nullptr) _impl_.feature_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::FeatureInfo& GetFeatureResponse::_internal_feature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::FeatureInfo* p = _impl_.feature_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::FeatureInfo&>(::dnd5e::api::v1alpha1::_FeatureInfo_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::FeatureInfo& GetFeatureResponse::feature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetFeatureResponse.feature)
  return _internal_feature();
}
inline void GetFeatureResponse::unsafe_arena_set_allocated_feature(
    ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.feature_);
  }
  _impl_.feature_ = reinterpret_cast<::dnd5e::api::v1alpha1::FeatureInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetFeatureResponse.feature)
}
inline ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NULLABLE GetFeatureResponse::release_feature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::FeatureInfo* released = _impl_.feature_;
  _impl_.feature_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NULLABLE GetFeatureResponse::unsafe_arena_release_feature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetFeatureResponse.feature)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::FeatureInfo* temp = _impl_.feature_;
  _impl_.feature_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NONNULL GetFeatureResponse::_internal_mutable_feature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.feature_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::FeatureInfo>(GetArena());
    _impl_.feature_ = reinterpret_cast<::dnd5e::api::v1alpha1::FeatureInfo*>(p);
  }
  return _impl_.feature_;
}
inline ::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NONNULL GetFeatureResponse::mutable_feature()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::FeatureInfo* _msg = _internal_mutable_feature();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetFeatureResponse.feature)
  return _msg;
}
inline void GetFeatureResponse::set_allocated_feature(::dnd5e::api::v1alpha1::FeatureInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.feature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.feature_ = reinterpret_cast<::dnd5e::api::v1alpha1::FeatureInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetFeatureResponse.feature)
}

// -------------------------------------------------------------------

// RollAbilityScoresRequest

// string draft_id = 1 [json_name = "draftId"];
inline void RollAbilityScoresRequest::clear_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.draft_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& RollAbilityScoresRequest::draft_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RollAbilityScoresRequest.draft_id)
  return _internal_draft_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RollAbilityScoresRequest::set_draft_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RollAbilityScoresRequest.draft_id)
}
inline ::std::string* PROTOBUF_NONNULL RollAbilityScoresRequest::mutable_draft_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_draft_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RollAbilityScoresRequest.draft_id)
  return _s;
}
inline const ::std::string& RollAbilityScoresRequest::_internal_draft_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.draft_id_.Get();
}
inline void RollAbilityScoresRequest::_internal_set_draft_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.draft_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RollAbilityScoresRequest::_internal_mutable_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.draft_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RollAbilityScoresRequest::release_draft_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RollAbilityScoresRequest.draft_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.draft_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  return released;
}
inline void RollAbilityScoresRequest::set_allocated_draft_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.draft_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.draft_id_.IsDefault()) {
    _impl_.draft_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RollAbilityScoresRequest.draft_id)
}

// -------------------------------------------------------------------

// AbilityScoreRoll

// string roll_id = 1 [json_name = "rollId"];
inline void AbilityScoreRoll::clear_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.roll_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& AbilityScoreRoll::roll_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScoreRoll.roll_id)
  return _internal_roll_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AbilityScoreRoll::set_roll_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.roll_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScoreRoll.roll_id)
}
inline ::std::string* PROTOBUF_NONNULL AbilityScoreRoll::mutable_roll_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_roll_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AbilityScoreRoll.roll_id)
  return _s;
}
inline const ::std::string& AbilityScoreRoll::_internal_roll_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.roll_id_.Get();
}
inline void AbilityScoreRoll::_internal_set_roll_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.roll_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AbilityScoreRoll::_internal_mutable_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.roll_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AbilityScoreRoll::release_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AbilityScoreRoll.roll_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.roll_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.roll_id_.Set("", GetArena());
  }
  return released;
}
inline void AbilityScoreRoll::set_allocated_roll_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.roll_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.roll_id_.IsDefault()) {
    _impl_.roll_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AbilityScoreRoll.roll_id)
}

// repeated int32 dice = 2 [json_name = "dice"];
inline int AbilityScoreRoll::_internal_dice_size() const {
  return _internal_dice().size();
}
inline int AbilityScoreRoll::dice_size() const {
  return _internal_dice_size();
}
inline void AbilityScoreRoll::clear_dice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dice_.Clear();
}
inline ::int32_t AbilityScoreRoll::dice(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScoreRoll.dice)
  return _internal_dice().Get(index);
}
inline void AbilityScoreRoll::set_dice(int index, ::int32_t value) {
  _internal_mutable_dice()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScoreRoll.dice)
}
inline void AbilityScoreRoll::add_dice(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_dice()->Add(value);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.AbilityScoreRoll.dice)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& AbilityScoreRoll::dice() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.AbilityScoreRoll.dice)
  return _internal_dice();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL AbilityScoreRoll::mutable_dice()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.AbilityScoreRoll.dice)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dice();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
AbilityScoreRoll::_internal_dice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dice_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
AbilityScoreRoll::_internal_mutable_dice() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dice_;
}

// int32 total = 3 [json_name = "total"];
inline void AbilityScoreRoll::clear_total() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t AbilityScoreRoll::total() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScoreRoll.total)
  return _internal_total();
}
inline void AbilityScoreRoll::set_total(::int32_t value) {
  _internal_set_total(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScoreRoll.total)
}
inline ::int32_t AbilityScoreRoll::_internal_total() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_;
}
inline void AbilityScoreRoll::_internal_set_total(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_ = value;
}

// int32 dropped = 4 [json_name = "dropped"];
inline void AbilityScoreRoll::clear_dropped() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dropped_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t AbilityScoreRoll::dropped() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScoreRoll.dropped)
  return _internal_dropped();
}
inline void AbilityScoreRoll::set_dropped(::int32_t value) {
  _internal_set_dropped(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScoreRoll.dropped)
}
inline ::int32_t AbilityScoreRoll::_internal_dropped() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dropped_;
}
inline void AbilityScoreRoll::_internal_set_dropped(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dropped_ = value;
}

// string notation = 5 [json_name = "notation"];
inline void AbilityScoreRoll::clear_notation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.notation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& AbilityScoreRoll::notation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScoreRoll.notation)
  return _internal_notation();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AbilityScoreRoll::set_notation(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.notation_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScoreRoll.notation)
}
inline ::std::string* PROTOBUF_NONNULL AbilityScoreRoll::mutable_notation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_notation();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AbilityScoreRoll.notation)
  return _s;
}
inline const ::std::string& AbilityScoreRoll::_internal_notation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.notation_.Get();
}
inline void AbilityScoreRoll::_internal_set_notation(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.notation_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AbilityScoreRoll::_internal_mutable_notation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.notation_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AbilityScoreRoll::release_notation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AbilityScoreRoll.notation)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.notation_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.notation_.Set("", GetArena());
  }
  return released;
}
inline void AbilityScoreRoll::set_allocated_notation(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.notation_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.notation_.IsDefault()) {
    _impl_.notation_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AbilityScoreRoll.notation)
}

// -------------------------------------------------------------------

// RollAbilityScoresResponse

// repeated .dnd5e.api.v1alpha1.AbilityScoreRoll rolls = 1 [json_name = "rolls"];
inline int RollAbilityScoresResponse::_internal_rolls_size() const {
  return _internal_rolls().size();
}
inline int RollAbilityScoresResponse::rolls_size() const {
  return _internal_rolls_size();
}
inline void RollAbilityScoresResponse::clear_rolls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rolls_.Clear();
}
inline ::dnd5e::api::v1alpha1::AbilityScoreRoll* PROTOBUF_NONNULL RollAbilityScoresResponse::mutable_rolls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RollAbilityScoresResponse.rolls)
  return _internal_mutable_rolls()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreRoll>* PROTOBUF_NONNULL RollAbilityScoresResponse::mutable_rolls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.RollAbilityScoresResponse.rolls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_rolls();
}
inline const ::dnd5e::api::v1alpha1::AbilityScoreRoll& RollAbilityScoresResponse::rolls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RollAbilityScoresResponse.rolls)
  return _internal_rolls().Get(index);
}
inline ::dnd5e::api::v1alpha1::AbilityScoreRoll* PROTOBUF_NONNULL RollAbilityScoresResponse::add_rolls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::AbilityScoreRoll* _add = _internal_mutable_rolls()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.RollAbilityScoresResponse.rolls)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreRoll>& RollAbilityScoresResponse::rolls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.RollAbilityScoresResponse.rolls)
  return _internal_rolls();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreRoll>&
RollAbilityScoresResponse::_internal_rolls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rolls_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreRoll>* PROTOBUF_NONNULL
RollAbilityScoresResponse::_internal_mutable_rolls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.rolls_;
}

// int64 expires_at = 2 [json_name = "expiresAt"];
inline void RollAbilityScoresResponse::clear_expires_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t RollAbilityScoresResponse::expires_at() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RollAbilityScoresResponse.expires_at)
  return _internal_expires_at();
}
inline void RollAbilityScoresResponse::set_expires_at(::int64_t value) {
  _internal_set_expires_at(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RollAbilityScoresResponse.expires_at)
}
inline ::int64_t RollAbilityScoresResponse::_internal_expires_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expires_at_;
}
inline void RollAbilityScoresResponse::_internal_set_expires_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_at_ = value;
}

// -------------------------------------------------------------------

// RollAssignments

// string strength_roll_id = 1 [json_name = "strengthRollId"];
inline void RollAssignments::clear_strength_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strength_roll_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& RollAssignments::strength_roll_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RollAssignments.strength_roll_id)
  return _internal_strength_roll_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RollAssignments::set_strength_roll_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.strength_roll_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RollAssignments.strength_roll_id)
}
inline ::std::string* PROTOBUF_NONNULL RollAssignments::mutable_strength_roll_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_strength_roll_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RollAssignments.strength_roll_id)
  return _s;
}
inline const ::std::string& RollAssignments::_internal_strength_roll_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strength_roll_id_.Get();
}
inline void RollAssignments::_internal_set_strength_roll_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.strength_roll_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RollAssignments::_internal_mutable_strength_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.strength_roll_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RollAssignments::release_strength_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RollAssignments.strength_roll_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.strength_roll_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.strength_roll_id_.Set("", GetArena());
  }
  return released;
}
inline void RollAssignments::set_allocated_strength_roll_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.strength_roll_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.strength_roll_id_.IsDefault()) {
    _impl_.strength_roll_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RollAssignments.strength_roll_id)
}

// string dexterity_roll_id = 2 [json_name = "dexterityRollId"];
inline void RollAssignments::clear_dexterity_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dexterity_roll_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& RollAssignments::dexterity_roll_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RollAssignments.dexterity_roll_id)
  return _internal_dexterity_roll_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RollAssignments::set_dexterity_roll_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dexterity_roll_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RollAssignments.dexterity_roll_id)
}
inline ::std::string* PROTOBUF_NONNULL RollAssignments::mutable_dexterity_roll_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_dexterity_roll_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RollAssignments.dexterity_roll_id)
  return _s;
}
inline const ::std::string& RollAssignments::_internal_dexterity_roll_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dexterity_roll_id_.Get();
}
inline void RollAssignments::_internal_set_dexterity_roll_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dexterity_roll_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RollAssignments::_internal_mutable_dexterity_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dexterity_roll_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RollAssignments::release_dexterity_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RollAssignments.dexterity_roll_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dexterity_roll_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dexterity_roll_id_.Set("", GetArena());
  }
  return released;
}
inline void RollAssignments::set_allocated_dexterity_roll_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dexterity_roll_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dexterity_roll_id_.IsDefault()) {
    _impl_.dexterity_roll_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RollAssignments.dexterity_roll_id)
}

// string constitution_roll_id = 3 [json_name = "constitutionRollId"];
inline void RollAssignments::clear_constitution_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constitution_roll_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& RollAssignments::constitution_roll_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RollAssignments.constitution_roll_id)
  return _internal_constitution_roll_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RollAssignments::set_constitution_roll_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.constitution_roll_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RollAssignments.constitution_roll_id)
}
inline ::std::string* PROTOBUF_NONNULL RollAssignments::mutable_constitution_roll_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_constitution_roll_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RollAssignments.constitution_roll_id)
  return _s;
}
inline const ::std::string& RollAssignments::_internal_constitution_roll_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.constitution_roll_id_.Get();
}
inline void RollAssignments::_internal_set_constitution_roll_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.constitution_roll_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RollAssignments::_internal_mutable_constitution_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.constitution_roll_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RollAssignments::release_constitution_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RollAssignments.constitution_roll_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.constitution_roll_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.constitution_roll_id_.Set("", GetArena());
  }
  return released;
}
inline void RollAssignments::set_allocated_constitution_roll_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.constitution_roll_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.constitution_roll_id_.IsDefault()) {
    _impl_.constitution_roll_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RollAssignments.constitution_roll_id)
}

// string intelligence_roll_id = 4 [json_name = "intelligenceRollId"];
inline void RollAssignments::clear_intelligence_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.intelligence_roll_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& RollAssignments::intelligence_roll_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RollAssignments.intelligence_roll_id)
  return _internal_intelligence_roll_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RollAssignments::set_intelligence_roll_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.intelligence_roll_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RollAssignments.intelligence_roll_id)
}
inline ::std::string* PROTOBUF_NONNULL RollAssignments::mutable_intelligence_roll_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_intelligence_roll_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RollAssignments.intelligence_roll_id)
  return _s;
}
inline const ::std::string& RollAssignments::_internal_intelligence_roll_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.intelligence_roll_id_.Get();
}
inline void RollAssignments::_internal_set_intelligence_roll_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.intelligence_roll_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RollAssignments::_internal_mutable_intelligence_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.intelligence_roll_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RollAssignments::release_intelligence_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RollAssignments.intelligence_roll_id)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.intelligence_roll_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.intelligence_roll_id_.Set("", GetArena());
  }
  return released;
}
inline void RollAssignments::set_allocated_intelligence_roll_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.intelligence_roll_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.intelligence_roll_id_.IsDefault()) {
    _impl_.intelligence_roll_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RollAssignments.intelligence_roll_id)
}

// string wisdom_roll_id = 5 [json_name = "wisdomRollId"];
inline void RollAssignments::clear_wisdom_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wisdom_roll_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& RollAssignments::wisdom_roll_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RollAssignments.wisdom_roll_id)
  return _internal_wisdom_roll_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RollAssignments::set_wisdom_roll_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.wisdom_roll_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RollAssignments.wisdom_roll_id)
}
inline ::std::string* PROTOBUF_NONNULL RollAssignments::mutable_wisdom_roll_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_wisdom_roll_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RollAssignments.wisdom_roll_id)
  return _s;
}
inline const ::std::string& RollAssignments::_internal_wisdom_roll_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wisdom_roll_id_.Get();
}
inline void RollAssignments::_internal_set_wisdom_roll_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.wisdom_roll_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RollAssignments::_internal_mutable_wisdom_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.wisdom_roll_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RollAssignments::release_wisdom_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RollAssignments.wisdom_roll_id)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.wisdom_roll_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.wisdom_roll_id_.Set("", GetArena());
  }
  return released;
}
inline void RollAssignments::set_allocated_wisdom_roll_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.wisdom_roll_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.wisdom_roll_id_.IsDefault()) {
    _impl_.wisdom_roll_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RollAssignments.wisdom_roll_id)
}

// string charisma_roll_id = 6 [json_name = "charismaRollId"];
inline void RollAssignments::clear_charisma_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.charisma_roll_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& RollAssignments::charisma_roll_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RollAssignments.charisma_roll_id)
  return _internal_charisma_roll_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RollAssignments::set_charisma_roll_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.charisma_roll_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RollAssignments.charisma_roll_id)
}
inline ::std::string* PROTOBUF_NONNULL RollAssignments::mutable_charisma_roll_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_charisma_roll_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RollAssignments.charisma_roll_id)
  return _s;
}
inline const ::std::string& RollAssignments::_internal_charisma_roll_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.charisma_roll_id_.Get();
}
inline void RollAssignments::_internal_set_charisma_roll_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.charisma_roll_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RollAssignments::_internal_mutable_charisma_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.charisma_roll_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RollAssignments::release_charisma_roll_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RollAssignments.charisma_roll_id)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.charisma_roll_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.charisma_roll_id_.Set("", GetArena());
  }
  return released;
}
inline void RollAssignments::set_allocated_charisma_roll_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.charisma_roll_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.charisma_roll_id_.IsDefault()) {
    _impl_.charisma_roll_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RollAssignments.charisma_roll_id)
}

// -------------------------------------------------------------------

// Cost

// int32 quantity = 1 [json_name = "quantity"];
inline void Cost::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Cost::quantity() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Cost.quantity)
  return _internal_quantity();
}
inline void Cost::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Cost.quantity)
}
inline ::int32_t Cost::_internal_quantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_;
}
inline void Cost::_internal_set_quantity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = value;
}

// string unit = 2 [json_name = "unit"];
inline void Cost::clear_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Cost::unit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Cost.unit)
  return _internal_unit();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Cost::set_unit(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.unit_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Cost.unit)
}
inline ::std::string* PROTOBUF_NONNULL Cost::mutable_unit()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Cost.unit)
  return _s;
}
inline const ::std::string& Cost::_internal_unit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unit_.Get();
}
inline void Cost::_internal_set_unit(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.unit_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Cost::_internal_mutable_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.unit_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Cost::release_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Cost.unit)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.unit_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.unit_.Set("", GetArena());
  }
  return released;
}
inline void Cost::set_allocated_unit(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.unit_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Cost.unit)
}

// -------------------------------------------------------------------

// Weight

// int32 quantity = 1 [json_name = "quantity"];
inline void Weight::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Weight::quantity() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Weight.quantity)
  return _internal_quantity();
}
inline void Weight::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Weight.quantity)
}
inline ::int32_t Weight::_internal_quantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_;
}
inline void Weight::_internal_set_quantity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = value;
}

// string unit = 2 [json_name = "unit"];
inline void Weight::clear_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Weight::unit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Weight.unit)
  return _internal_unit();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Weight::set_unit(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.unit_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Weight.unit)
}
inline ::std::string* PROTOBUF_NONNULL Weight::mutable_unit()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Weight.unit)
  return _s;
}
inline const ::std::string& Weight::_internal_unit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unit_.Get();
}
inline void Weight::_internal_set_unit(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.unit_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Weight::_internal_mutable_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.unit_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Weight::release_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Weight.unit)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.unit_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.unit_.Set("", GetArena());
  }
  return released;
}
inline void Weight::set_allocated_unit(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.unit_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Weight.unit)
}

// -------------------------------------------------------------------

// Equipment

// string id = 1 [json_name = "id"];
inline void Equipment::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Equipment::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Equipment.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Equipment::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Equipment.id)
}
inline ::std::string* PROTOBUF_NONNULL Equipment::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Equipment.id)
  return _s;
}
inline const ::std::string& Equipment::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Equipment::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Equipment::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Equipment::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Equipment.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void Equipment::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Equipment.id)
}

// string name = 2 [json_name = "name"];
inline void Equipment::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Equipment::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Equipment.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Equipment::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Equipment.name)
}
inline ::std::string* PROTOBUF_NONNULL Equipment::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Equipment.name)
  return _s;
}
inline const ::std::string& Equipment::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Equipment::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Equipment::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Equipment::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Equipment.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void Equipment::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Equipment.name)
}

// string category = 3 [json_name = "category"];
inline void Equipment::clear_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& Equipment::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Equipment.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Equipment::set_category(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Equipment.category)
}
inline ::std::string* PROTOBUF_NONNULL Equipment::mutable_category()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Equipment.category)
  return _s;
}
inline const ::std::string& Equipment::_internal_category() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.category_.Get();
}
inline void Equipment::_internal_set_category(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.category_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Equipment::_internal_mutable_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.category_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Equipment::release_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Equipment.category)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.category_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.category_.Set("", GetArena());
  }
  return released;
}
inline void Equipment::set_allocated_category(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.category_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Equipment.category)
}

// .dnd5e.api.v1alpha1.Cost cost = 4 [json_name = "cost"];
inline bool Equipment::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cost_ != nullptr);
  return value;
}
inline void Equipment::clear_cost() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cost_ != nullptr) _impl_.cost_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::dnd5e::api::v1alpha1::Cost& Equipment::_internal_cost() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Cost* p = _impl_.cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Cost&>(::dnd5e::api::v1alpha1::_Cost_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Cost& Equipment::cost() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Equipment.cost)
  return _internal_cost();
}
inline void Equipment::unsafe_arena_set_allocated_cost(
    ::dnd5e::api::v1alpha1::Cost* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cost_);
  }
  _impl_.cost_ = reinterpret_cast<::dnd5e::api::v1alpha1::Cost*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Equipment.cost)
}
inline ::dnd5e::api::v1alpha1::Cost* PROTOBUF_NULLABLE Equipment::release_cost() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::Cost* released = _impl_.cost_;
  _impl_.cost_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Cost* PROTOBUF_NULLABLE Equipment::unsafe_arena_release_cost() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Equipment.cost)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::Cost* temp = _impl_.cost_;
  _impl_.cost_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Cost* PROTOBUF_NONNULL Equipment::_internal_mutable_cost() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cost_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Cost>(GetArena());
    _impl_.cost_ = reinterpret_cast<::dnd5e::api::v1alpha1::Cost*>(p);
  }
  return _impl_.cost_;
}
inline ::dnd5e::api::v1alpha1::Cost* PROTOBUF_NONNULL Equipment::mutable_cost()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::dnd5e::api::v1alpha1::Cost* _msg = _internal_mutable_cost();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Equipment.cost)
  return _msg;
}
inline void Equipment::set_allocated_cost(::dnd5e::api::v1alpha1::Cost* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cost_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.cost_ = reinterpret_cast<::dnd5e::api::v1alpha1::Cost*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Equipment.cost)
}

// .dnd5e.api.v1alpha1.Weight weight = 5 [json_name = "weight"];
inline bool Equipment::has_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.weight_ != nullptr);
  return value;
}
inline void Equipment::clear_weight() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.weight_ != nullptr) _impl_.weight_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::dnd5e::api::v1alpha1::Weight& Equipment::_internal_weight() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Weight* p = _impl_.weight_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Weight&>(::dnd5e::api::v1alpha1::_Weight_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Weight& Equipment::weight() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Equipment.weight)
  return _internal_weight();
}
inline void Equipment::unsafe_arena_set_allocated_weight(
    ::dnd5e::api::v1alpha1::Weight* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.weight_);
  }
  _impl_.weight_ = reinterpret_cast<::dnd5e::api::v1alpha1::Weight*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Equipment.weight)
}
inline ::dnd5e::api::v1alpha1::Weight* PROTOBUF_NULLABLE Equipment::release_weight() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::dnd5e::api::v1alpha1::Weight* released = _impl_.weight_;
  _impl_.weight_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Weight* PROTOBUF_NULLABLE Equipment::unsafe_arena_release_weight() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Equipment.weight)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::dnd5e::api::v1alpha1::Weight* temp = _impl_.weight_;
  _impl_.weight_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Weight* PROTOBUF_NONNULL Equipment::_internal_mutable_weight() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.weight_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Weight>(GetArena());
    _impl_.weight_ = reinterpret_cast<::dnd5e::api::v1alpha1::Weight*>(p);
  }
  return _impl_.weight_;
}
inline ::dnd5e::api::v1alpha1::Weight* PROTOBUF_NONNULL Equipment::mutable_weight()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::dnd5e::api::v1alpha1::Weight* _msg = _internal_mutable_weight();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Equipment.weight)
  return _msg;
}
inline void Equipment::set_allocated_weight(::dnd5e::api::v1alpha1::Weight* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.weight_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.weight_ = reinterpret_cast<::dnd5e::api::v1alpha1::Weight*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Equipment.weight)
}

// string description = 6 [json_name = "description"];
inline void Equipment::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& Equipment::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Equipment.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Equipment::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Equipment.description)
}
inline ::std::string* PROTOBUF_NONNULL Equipment::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Equipment.description)
  return _s;
}
inline const ::std::string& Equipment::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void Equipment::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Equipment::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Equipment::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Equipment.description)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void Equipment::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Equipment.description)
}

// .dnd5e.api.v1alpha1.WeaponData weapon_data = 7 [json_name = "weaponData"];
inline bool Equipment::has_weapon_data() const {
  return equipment_data_case() == kWeaponData;
}
inline bool Equipment::_internal_has_weapon_data() const {
  return equipment_data_case() == kWeaponData;
}
inline void Equipment::set_has_weapon_data() {
  _impl_._oneof_case_[0] = kWeaponData;
}
inline void Equipment::clear_weapon_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (equipment_data_case() == kWeaponData) {
    if (GetArena() == nullptr) {
      delete _impl_.equipment_data_.weapon_data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.equipment_data_.weapon_data_);
    }
    clear_has_equipment_data();
  }
}
inline ::dnd5e::api::v1alpha1::WeaponData* PROTOBUF_NULLABLE Equipment::release_weapon_data() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Equipment.weapon_data)
  if (equipment_data_case() == kWeaponData) {
    clear_has_equipment_data();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::WeaponData*>(_impl_.equipment_data_.weapon_data_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.equipment_data_.weapon_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::WeaponData& Equipment::_internal_weapon_data() const {
  return equipment_data_case() == kWeaponData ? *reinterpret_cast<::dnd5e::api::v1alpha1::WeaponData*>(_impl_.equipment_data_.weapon_data_) : reinterpret_cast<::dnd5e::api::v1alpha1::WeaponData&>(::dnd5e::api::v1alpha1::_WeaponData_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::WeaponData& Equipment::weapon_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Equipment.weapon_data)
  return _internal_weapon_data();
}
inline ::dnd5e::api::v1alpha1::WeaponData* PROTOBUF_NULLABLE Equipment::unsafe_arena_release_weapon_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.Equipment.weapon_data)
  if (equipment_data_case() == kWeaponData) {
    clear_has_equipment_data();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::WeaponData*>(_impl_.equipment_data_.weapon_data_);
    _impl_.equipment_data_.weapon_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Equipment::unsafe_arena_set_allocated_weapon_data(
    ::dnd5e::api::v1alpha1::WeaponData* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_equipment_data();
  if (value) {
    set_has_weapon_data();
    _impl_.equipment_data_.weapon_data_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Equipment.weapon_data)
}
inline ::dnd5e::api::v1alpha1::WeaponData* PROTOBUF_NONNULL Equipment::_internal_mutable_weapon_data() {
  if (equipment_data_case() != kWeaponData) {
    clear_equipment_data();
    set_has_weapon_data();
    _impl_.equipment_data_.weapon_data_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::WeaponData>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::WeaponData*>(_impl_.equipment_data_.weapon_data_);
}
inline ::dnd5e::api::v1alpha1::WeaponData* PROTOBUF_NONNULL Equipment::mutable_weapon_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::WeaponData* _msg = _internal_mutable_weapon_data();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Equipment.weapon_data)
  return _msg;
}

// .dnd5e.api.v1alpha1.ArmorData armor_data = 8 [json_name = "armorData"];
inline bool Equipment::has_armor_data() const {
  return equipment_data_case() == kArmorData;
}
inline bool Equipment::_internal_has_armor_data() const {
  return equipment_data_case() == kArmorData;
}
inline void Equipment::set_has_armor_data() {
  _impl_._oneof_case_[0] = kArmorData;
}
inline void Equipment::clear_armor_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (equipment_data_case() == kArmorData) {
    if (GetArena() == nullptr) {
      delete _impl_.equipment_data_.armor_data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.equipment_data_.armor_data_);
    }
    clear_has_equipment_data();
  }
}
inline ::dnd5e::api::v1alpha1::ArmorData* PROTOBUF_NULLABLE Equipment::release_armor_data() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Equipment.armor_data)
  if (equipment_data_case() == kArmorData) {
    clear_has_equipment_data();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ArmorData*>(_impl_.equipment_data_.armor_data_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.equipment_data_.armor_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::ArmorData& Equipment::_internal_armor_data() const {
  return equipment_data_case() == kArmorData ? *reinterpret_cast<::dnd5e::api::v1alpha1::ArmorData*>(_impl_.equipment_data_.armor_data_) : reinterpret_cast<::dnd5e::api::v1alpha1::ArmorData&>(::dnd5e::api::v1alpha1::_ArmorData_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ArmorData& Equipment::armor_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Equipment.armor_data)
  return _internal_armor_data();
}
inline ::dnd5e::api::v1alpha1::ArmorData* PROTOBUF_NULLABLE Equipment::unsafe_arena_release_armor_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.Equipment.armor_data)
  if (equipment_data_case() == kArmorData) {
    clear_has_equipment_data();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ArmorData*>(_impl_.equipment_data_.armor_data_);
    _impl_.equipment_data_.armor_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Equipment::unsafe_arena_set_allocated_armor_data(
    ::dnd5e::api::v1alpha1::ArmorData* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_equipment_data();
  if (value) {
    set_has_armor_data();
    _impl_.equipment_data_.armor_data_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Equipment.armor_data)
}
inline ::dnd5e::api::v1alpha1::ArmorData* PROTOBUF_NONNULL Equipment::_internal_mutable_armor_data() {
  if (equipment_data_case() != kArmorData) {
    clear_equipment_data();
    set_has_armor_data();
    _impl_.equipment_data_.armor_data_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ArmorData>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::ArmorData*>(_impl_.equipment_data_.armor_data_);
}
inline ::dnd5e::api::v1alpha1::ArmorData* PROTOBUF_NONNULL Equipment::mutable_armor_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::ArmorData* _msg = _internal_mutable_armor_data();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Equipment.armor_data)
  return _msg;
}

// .dnd5e.api.v1alpha1.GearData gear_data = 9 [json_name = "gearData"];
inline bool Equipment::has_gear_data() const {
  return equipment_data_case() == kGearData;
}
inline bool Equipment::_internal_has_gear_data() const {
  return equipment_data_case() == kGearData;
}
inline void Equipment::set_has_gear_data() {
  _impl_._oneof_case_[0] = kGearData;
}
inline void Equipment::clear_gear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (equipment_data_case() == kGearData) {
    if (GetArena() == nullptr) {
      delete _impl_.equipment_data_.gear_data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.equipment_data_.gear_data_);
    }
    clear_has_equipment_data();
  }
}
inline ::dnd5e::api::v1alpha1::GearData* PROTOBUF_NULLABLE Equipment::release_gear_data() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Equipment.gear_data)
  if (equipment_data_case() == kGearData) {
    clear_has_equipment_data();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::GearData*>(_impl_.equipment_data_.gear_data_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.equipment_data_.gear_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::GearData& Equipment::_internal_gear_data() const {
  return equipment_data_case() == kGearData ? *reinterpret_cast<::dnd5e::api::v1alpha1::GearData*>(_impl_.equipment_data_.gear_data_) : reinterpret_cast<::dnd5e::api::v1alpha1::GearData&>(::dnd5e::api::v1alpha1::_GearData_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::GearData& Equipment::gear_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Equipment.gear_data)
  return _internal_gear_data();
}
inline ::dnd5e::api::v1alpha1::GearData* PROTOBUF_NULLABLE Equipment::unsafe_arena_release_gear_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.Equipment.gear_data)
  if (equipment_data_case() == kGearData) {
    clear_has_equipment_data();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::GearData*>(_impl_.equipment_data_.gear_data_);
    _impl_.equipment_data_.gear_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Equipment::unsafe_arena_set_allocated_gear_data(
    ::dnd5e::api::v1alpha1::GearData* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_equipment_data();
  if (value) {
    set_has_gear_data();
    _impl_.equipment_data_.gear_data_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Equipment.gear_data)
}
inline ::dnd5e::api::v1alpha1::GearData* PROTOBUF_NONNULL Equipment::_internal_mutable_gear_data() {
  if (equipment_data_case() != kGearData) {
    clear_equipment_data();
    set_has_gear_data();
    _impl_.equipment_data_.gear_data_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::GearData>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::GearData*>(_impl_.equipment_data_.gear_data_);
}
inline ::dnd5e::api::v1alpha1::GearData* PROTOBUF_NONNULL Equipment::mutable_gear_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::GearData* _msg = _internal_mutable_gear_data();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Equipment.gear_data)
  return _msg;
}

inline bool Equipment::has_equipment_data() const {
  return equipment_data_case() != EQUIPMENT_DATA_NOT_SET;
}
inline void Equipment::clear_has_equipment_data() {
  _impl_._oneof_case_[0] = EQUIPMENT_DATA_NOT_SET;
}
inline Equipment::EquipmentDataCase Equipment::equipment_data_case() const {
  return Equipment::EquipmentDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WeaponData

// string weapon_category = 1 [json_name = "weaponCategory"];
inline void WeaponData::clear_weapon_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapon_category_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& WeaponData::weapon_category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.WeaponData.weapon_category)
  return _internal_weapon_category();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void WeaponData::set_weapon_category(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.weapon_category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.WeaponData.weapon_category)
}
inline ::std::string* PROTOBUF_NONNULL WeaponData::mutable_weapon_category()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_weapon_category();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.WeaponData.weapon_category)
  return _s;
}
inline const ::std::string& WeaponData::_internal_weapon_category() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.weapon_category_.Get();
}
inline void WeaponData::_internal_set_weapon_category(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.weapon_category_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL WeaponData::_internal_mutable_weapon_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.weapon_category_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE WeaponData::release_weapon_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.WeaponData.weapon_category)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.weapon_category_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.weapon_category_.Set("", GetArena());
  }
  return released;
}
inline void WeaponData::set_allocated_weapon_category(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.weapon_category_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.weapon_category_.IsDefault()) {
    _impl_.weapon_category_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.WeaponData.weapon_category)
}

// string damage_dice = 2 [json_name = "damageDice"];
inline void WeaponData::clear_damage_dice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_dice_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& WeaponData::damage_dice() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.WeaponData.damage_dice)
  return _internal_damage_dice();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void WeaponData::set_damage_dice(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.damage_dice_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.WeaponData.damage_dice)
}
inline ::std::string* PROTOBUF_NONNULL WeaponData::mutable_damage_dice()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_damage_dice();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.WeaponData.damage_dice)
  return _s;
}
inline const ::std::string& WeaponData::_internal_damage_dice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_dice_.Get();
}
inline void WeaponData::_internal_set_damage_dice(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.damage_dice_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL WeaponData::_internal_mutable_damage_dice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.damage_dice_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE WeaponData::release_damage_dice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.WeaponData.damage_dice)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.damage_dice_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.damage_dice_.Set("", GetArena());
  }
  return released;
}
inline void WeaponData::set_allocated_damage_dice(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.damage_dice_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.damage_dice_.IsDefault()) {
    _impl_.damage_dice_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.WeaponData.damage_dice)
}

// string damage_type = 3 [json_name = "damageType"];
inline void WeaponData::clear_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& WeaponData::damage_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.WeaponData.damage_type)
  return _internal_damage_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void WeaponData::set_damage_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.damage_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.WeaponData.damage_type)
}
inline ::std::string* PROTOBUF_NONNULL WeaponData::mutable_damage_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_damage_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.WeaponData.damage_type)
  return _s;
}
inline const ::std::string& WeaponData::_internal_damage_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_type_.Get();
}
inline void WeaponData::_internal_set_damage_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.damage_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL WeaponData::_internal_mutable_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.damage_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE WeaponData::release_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.WeaponData.damage_type)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.damage_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  return released;
}
inline void WeaponData::set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.damage_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.damage_type_.IsDefault()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.WeaponData.damage_type)
}

// repeated string properties = 4 [json_name = "properties"];
inline int WeaponData::_internal_properties_size() const {
  return _internal_properties().size();
}
inline int WeaponData::properties_size() const {
  return _internal_properties_size();
}
inline void WeaponData::clear_properties() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.properties_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL WeaponData::add_properties()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_properties()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.WeaponData.properties)
  return _s;
}
inline const ::std::string& WeaponData::properties(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.WeaponData.properties)
  return _internal_properties().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL WeaponData::mutable_properties(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.WeaponData.properties)
  return _internal_mutable_properties()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void WeaponData::set_properties(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_properties()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.WeaponData.properties)
}
template <typename Arg_, typename... Args_>
inline void WeaponData::add_properties(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_properties(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.WeaponData.properties)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& WeaponData::properties()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.WeaponData.properties)
  return _internal_properties();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
WeaponData::mutable_properties() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.WeaponData.properties)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_properties();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
WeaponData::_internal_properties() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.properties_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
WeaponData::_internal_mutable_properties() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.properties_;
}

// string range = 5 [json_name = "range"];
inline void WeaponData::clear_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.range_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& WeaponData::range() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.WeaponData.range)
  return _internal_range();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void WeaponData::set_range(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.range_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.WeaponData.range)
}
inline ::std::string* PROTOBUF_NONNULL WeaponData::mutable_range()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.WeaponData.range)
  return _s;
}
inline const ::std::string& WeaponData::_internal_range() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.range_.Get();
}
inline void WeaponData::_internal_set_range(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.range_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL WeaponData::_internal_mutable_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.range_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE WeaponData::release_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.WeaponData.range)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.range_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.range_.Set("", GetArena());
  }
  return released;
}
inline void WeaponData::set_allocated_range(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.range_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.range_.IsDefault()) {
    _impl_.range_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.WeaponData.range)
}

// int32 normal_range = 6 [json_name = "normalRange"];
inline void WeaponData::clear_normal_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.normal_range_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t WeaponData::normal_range() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.WeaponData.normal_range)
  return _internal_normal_range();
}
inline void WeaponData::set_normal_range(::int32_t value) {
  _internal_set_normal_range(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.WeaponData.normal_range)
}
inline ::int32_t WeaponData::_internal_normal_range() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.normal_range_;
}
inline void WeaponData::_internal_set_normal_range(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.normal_range_ = value;
}

// int32 long_range = 7 [json_name = "longRange"];
inline void WeaponData::clear_long_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.long_range_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t WeaponData::long_range() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.WeaponData.long_range)
  return _internal_long_range();
}
inline void WeaponData::set_long_range(::int32_t value) {
  _internal_set_long_range(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.WeaponData.long_range)
}
inline ::int32_t WeaponData::_internal_long_range() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.long_range_;
}
inline void WeaponData::_internal_set_long_range(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.long_range_ = value;
}

// -------------------------------------------------------------------

// ArmorData

// string armor_category = 1 [json_name = "armorCategory"];
inline void ArmorData::clear_armor_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.armor_category_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ArmorData::armor_category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ArmorData.armor_category)
  return _internal_armor_category();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ArmorData::set_armor_category(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.armor_category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ArmorData.armor_category)
}
inline ::std::string* PROTOBUF_NONNULL ArmorData::mutable_armor_category()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_armor_category();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ArmorData.armor_category)
  return _s;
}
inline const ::std::string& ArmorData::_internal_armor_category() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.armor_category_.Get();
}
inline void ArmorData::_internal_set_armor_category(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.armor_category_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ArmorData::_internal_mutable_armor_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.armor_category_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ArmorData::release_armor_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ArmorData.armor_category)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.armor_category_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.armor_category_.Set("", GetArena());
  }
  return released;
}
inline void ArmorData::set_allocated_armor_category(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.armor_category_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.armor_category_.IsDefault()) {
    _impl_.armor_category_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ArmorData.armor_category)
}

// int32 base_ac = 2 [json_name = "baseAc"];
inline void ArmorData::clear_base_ac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.base_ac_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ArmorData::base_ac() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ArmorData.base_ac)
  return _internal_base_ac();
}
inline void ArmorData::set_base_ac(::int32_t value) {
  _internal_set_base_ac(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ArmorData.base_ac)
}
inline ::int32_t ArmorData::_internal_base_ac() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.base_ac_;
}
inline void ArmorData::_internal_set_base_ac(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.base_ac_ = value;
}

// bool dex_bonus = 3 [json_name = "dexBonus"];
inline void ArmorData::clear_dex_bonus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dex_bonus_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ArmorData::dex_bonus() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ArmorData.dex_bonus)
  return _internal_dex_bonus();
}
inline void ArmorData::set_dex_bonus(bool value) {
  _internal_set_dex_bonus(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ArmorData.dex_bonus)
}
inline bool ArmorData::_internal_dex_bonus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dex_bonus_;
}
inline void ArmorData::_internal_set_dex_bonus(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dex_bonus_ = value;
}

// bool has_dex_limit = 4 [json_name = "hasDexLimit"];
inline void ArmorData::clear_has_dex_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_dex_limit_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ArmorData::has_dex_limit() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ArmorData.has_dex_limit)
  return _internal_has_dex_limit();
}
inline void ArmorData::set_has_dex_limit(bool value) {
  _internal_set_has_dex_limit(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ArmorData.has_dex_limit)
}
inline bool ArmorData::_internal_has_dex_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_dex_limit_;
}
inline void ArmorData::_internal_set_has_dex_limit(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_dex_limit_ = value;
}

// int32 max_dex_bonus = 5 [json_name = "maxDexBonus"];
inline void ArmorData::clear_max_dex_bonus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_dex_bonus_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t ArmorData::max_dex_bonus() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ArmorData.max_dex_bonus)
  return _internal_max_dex_bonus();
}
inline void ArmorData::set_max_dex_bonus(::int32_t value) {
  _internal_set_max_dex_bonus(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ArmorData.max_dex_bonus)
}
inline ::int32_t ArmorData::_internal_max_dex_bonus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_dex_bonus_;
}
inline void ArmorData::_internal_set_max_dex_bonus(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_dex_bonus_ = value;
}

// int32 str_minimum = 6 [json_name = "strMinimum"];
inline void ArmorData::clear_str_minimum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.str_minimum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t ArmorData::str_minimum() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ArmorData.str_minimum)
  return _internal_str_minimum();
}
inline void ArmorData::set_str_minimum(::int32_t value) {
  _internal_set_str_minimum(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ArmorData.str_minimum)
}
inline ::int32_t ArmorData::_internal_str_minimum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.str_minimum_;
}
inline void ArmorData::_internal_set_str_minimum(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.str_minimum_ = value;
}

// bool stealth_disadvantage = 7 [json_name = "stealthDisadvantage"];
inline void ArmorData::clear_stealth_disadvantage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stealth_disadvantage_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ArmorData::stealth_disadvantage() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ArmorData.stealth_disadvantage)
  return _internal_stealth_disadvantage();
}
inline void ArmorData::set_stealth_disadvantage(bool value) {
  _internal_set_stealth_disadvantage(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ArmorData.stealth_disadvantage)
}
inline bool ArmorData::_internal_stealth_disadvantage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stealth_disadvantage_;
}
inline void ArmorData::_internal_set_stealth_disadvantage(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stealth_disadvantage_ = value;
}

// -------------------------------------------------------------------

// GearData

// string gear_category = 1 [json_name = "gearCategory"];
inline void GearData::clear_gear_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gear_category_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GearData::gear_category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GearData.gear_category)
  return _internal_gear_category();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GearData::set_gear_category(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gear_category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GearData.gear_category)
}
inline ::std::string* PROTOBUF_NONNULL GearData::mutable_gear_category()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_gear_category();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GearData.gear_category)
  return _s;
}
inline const ::std::string& GearData::_internal_gear_category() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gear_category_.Get();
}
inline void GearData::_internal_set_gear_category(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gear_category_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GearData::_internal_mutable_gear_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.gear_category_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GearData::release_gear_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GearData.gear_category)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.gear_category_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.gear_category_.Set("", GetArena());
  }
  return released;
}
inline void GearData::set_allocated_gear_category(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.gear_category_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.gear_category_.IsDefault()) {
    _impl_.gear_category_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GearData.gear_category)
}

// repeated string properties = 2 [json_name = "properties"];
inline int GearData::_internal_properties_size() const {
  return _internal_properties().size();
}
inline int GearData::properties_size() const {
  return _internal_properties_size();
}
inline void GearData::clear_properties() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.properties_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL GearData::add_properties()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_properties()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.GearData.properties)
  return _s;
}
inline const ::std::string& GearData::properties(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GearData.properties)
  return _internal_properties().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL GearData::mutable_properties(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GearData.properties)
  return _internal_mutable_properties()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void GearData::set_properties(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_properties()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GearData.properties)
}
template <typename Arg_, typename... Args_>
inline void GearData::add_properties(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_properties(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.GearData.properties)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& GearData::properties()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.GearData.properties)
  return _internal_properties();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
GearData::mutable_properties() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.GearData.properties)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_properties();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
GearData::_internal_properties() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.properties_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
GearData::_internal_mutable_properties() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.properties_;
}

// -------------------------------------------------------------------

// EquipmentSlots

// .dnd5e.api.v1alpha1.InventoryItem main_hand = 1 [json_name = "mainHand"];
inline bool EquipmentSlots::has_main_hand() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.main_hand_ != nullptr);
  return value;
}
inline void EquipmentSlots::clear_main_hand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.main_hand_ != nullptr) _impl_.main_hand_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::_internal_main_hand() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::InventoryItem* p = _impl_.main_hand_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::InventoryItem&>(::dnd5e::api::v1alpha1::_InventoryItem_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::main_hand() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSlots.main_hand)
  return _internal_main_hand();
}
inline void EquipmentSlots::unsafe_arena_set_allocated_main_hand(
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.main_hand_);
  }
  _impl_.main_hand_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.main_hand)
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::release_main_hand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::InventoryItem* released = _impl_.main_hand_;
  _impl_.main_hand_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::unsafe_arena_release_main_hand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentSlots.main_hand)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::InventoryItem* temp = _impl_.main_hand_;
  _impl_.main_hand_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::_internal_mutable_main_hand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.main_hand_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::InventoryItem>(GetArena());
    _impl_.main_hand_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(p);
  }
  return _impl_.main_hand_;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::mutable_main_hand()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::InventoryItem* _msg = _internal_mutable_main_hand();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSlots.main_hand)
  return _msg;
}
inline void EquipmentSlots::set_allocated_main_hand(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.main_hand_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.main_hand_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.main_hand)
}

// .dnd5e.api.v1alpha1.InventoryItem off_hand = 2 [json_name = "offHand"];
inline bool EquipmentSlots::has_off_hand() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.off_hand_ != nullptr);
  return value;
}
inline void EquipmentSlots::clear_off_hand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.off_hand_ != nullptr) _impl_.off_hand_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::_internal_off_hand() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::InventoryItem* p = _impl_.off_hand_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::InventoryItem&>(::dnd5e::api::v1alpha1::_InventoryItem_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::off_hand() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSlots.off_hand)
  return _internal_off_hand();
}
inline void EquipmentSlots::unsafe_arena_set_allocated_off_hand(
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.off_hand_);
  }
  _impl_.off_hand_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.off_hand)
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::release_off_hand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::InventoryItem* released = _impl_.off_hand_;
  _impl_.off_hand_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::unsafe_arena_release_off_hand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentSlots.off_hand)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::InventoryItem* temp = _impl_.off_hand_;
  _impl_.off_hand_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::_internal_mutable_off_hand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.off_hand_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::InventoryItem>(GetArena());
    _impl_.off_hand_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(p);
  }
  return _impl_.off_hand_;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::mutable_off_hand()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::dnd5e::api::v1alpha1::InventoryItem* _msg = _internal_mutable_off_hand();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSlots.off_hand)
  return _msg;
}
inline void EquipmentSlots::set_allocated_off_hand(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.off_hand_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.off_hand_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.off_hand)
}

// .dnd5e.api.v1alpha1.InventoryItem armor = 3 [json_name = "armor"];
inline bool EquipmentSlots::has_armor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.armor_ != nullptr);
  return value;
}
inline void EquipmentSlots::clear_armor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.armor_ != nullptr) _impl_.armor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::_internal_armor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::InventoryItem* p = _impl_.armor_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::InventoryItem&>(::dnd5e::api::v1alpha1::_InventoryItem_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::armor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSlots.armor)
  return _internal_armor();
}
inline void EquipmentSlots::unsafe_arena_set_allocated_armor(
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.armor_);
  }
  _impl_.armor_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.armor)
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::release_armor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dnd5e::api::v1alpha1::InventoryItem* released = _impl_.armor_;
  _impl_.armor_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::unsafe_arena_release_armor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentSlots.armor)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dnd5e::api::v1alpha1::InventoryItem* temp = _impl_.armor_;
  _impl_.armor_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::_internal_mutable_armor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.armor_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::InventoryItem>(GetArena());
    _impl_.armor_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(p);
  }
  return _impl_.armor_;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::mutable_armor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::dnd5e::api::v1alpha1::InventoryItem* _msg = _internal_mutable_armor();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSlots.armor)
  return _msg;
}
inline void EquipmentSlots::set_allocated_armor(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.armor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.armor_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.armor)
}

// .dnd5e.api.v1alpha1.InventoryItem helmet = 4 [json_name = "helmet"];
inline bool EquipmentSlots::has_helmet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.helmet_ != nullptr);
  return value;
}
inline void EquipmentSlots::clear_helmet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.helmet_ != nullptr) _impl_.helmet_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::_internal_helmet() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::InventoryItem* p = _impl_.helmet_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::InventoryItem&>(::dnd5e::api::v1alpha1::_InventoryItem_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::helmet() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSlots.helmet)
  return _internal_helmet();
}
inline void EquipmentSlots::unsafe_arena_set_allocated_helmet(
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.helmet_);
  }
  _impl_.helmet_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.helmet)
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::release_helmet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::dnd5e::api::v1alpha1::InventoryItem* released = _impl_.helmet_;
  _impl_.helmet_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::unsafe_arena_release_helmet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentSlots.helmet)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::dnd5e::api::v1alpha1::InventoryItem* temp = _impl_.helmet_;
  _impl_.helmet_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::_internal_mutable_helmet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.helmet_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::InventoryItem>(GetArena());
    _impl_.helmet_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(p);
  }
  return _impl_.helmet_;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::mutable_helmet()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::dnd5e::api::v1alpha1::InventoryItem* _msg = _internal_mutable_helmet();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSlots.helmet)
  return _msg;
}
inline void EquipmentSlots::set_allocated_helmet(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.helmet_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.helmet_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.helmet)
}

// .dnd5e.api.v1alpha1.InventoryItem boots = 5 [json_name = "boots"];
inline bool EquipmentSlots::has_boots() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.boots_ != nullptr);
  return value;
}
inline void EquipmentSlots::clear_boots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.boots_ != nullptr) _impl_.boots_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::_internal_boots() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::InventoryItem* p = _impl_.boots_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::InventoryItem&>(::dnd5e::api::v1alpha1::_InventoryItem_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::boots() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSlots.boots)
  return _internal_boots();
}
inline void EquipmentSlots::unsafe_arena_set_allocated_boots(
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.boots_);
  }
  _impl_.boots_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.boots)
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::release_boots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::InventoryItem* released = _impl_.boots_;
  _impl_.boots_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::unsafe_arena_release_boots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentSlots.boots)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::dnd5e::api::v1alpha1::InventoryItem* temp = _impl_.boots_;
  _impl_.boots_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::_internal_mutable_boots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.boots_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::InventoryItem>(GetArena());
    _impl_.boots_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(p);
  }
  return _impl_.boots_;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::mutable_boots()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::dnd5e::api::v1alpha1::InventoryItem* _msg = _internal_mutable_boots();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSlots.boots)
  return _msg;
}
inline void EquipmentSlots::set_allocated_boots(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.boots_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.boots_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.boots)
}

// .dnd5e.api.v1alpha1.InventoryItem gloves = 6 [json_name = "gloves"];
inline bool EquipmentSlots::has_gloves() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gloves_ != nullptr);
  return value;
}
inline void EquipmentSlots::clear_gloves() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gloves_ != nullptr) _impl_.gloves_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::_internal_gloves() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::InventoryItem* p = _impl_.gloves_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::InventoryItem&>(::dnd5e::api::v1alpha1::_InventoryItem_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::gloves() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSlots.gloves)
  return _internal_gloves();
}
inline void EquipmentSlots::unsafe_arena_set_allocated_gloves(
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gloves_);
  }
  _impl_.gloves_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.gloves)
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::release_gloves() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::dnd5e::api::v1alpha1::InventoryItem* released = _impl_.gloves_;
  _impl_.gloves_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::unsafe_arena_release_gloves() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentSlots.gloves)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::dnd5e::api::v1alpha1::InventoryItem* temp = _impl_.gloves_;
  _impl_.gloves_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::_internal_mutable_gloves() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gloves_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::InventoryItem>(GetArena());
    _impl_.gloves_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(p);
  }
  return _impl_.gloves_;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::mutable_gloves()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::dnd5e::api::v1alpha1::InventoryItem* _msg = _internal_mutable_gloves();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSlots.gloves)
  return _msg;
}
inline void EquipmentSlots::set_allocated_gloves(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gloves_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.gloves_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.gloves)
}

// .dnd5e.api.v1alpha1.InventoryItem cloak = 7 [json_name = "cloak"];
inline bool EquipmentSlots::has_cloak() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cloak_ != nullptr);
  return value;
}
inline void EquipmentSlots::clear_cloak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cloak_ != nullptr) _impl_.cloak_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::_internal_cloak() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::InventoryItem* p = _impl_.cloak_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::InventoryItem&>(::dnd5e::api::v1alpha1::_InventoryItem_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::cloak() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSlots.cloak)
  return _internal_cloak();
}
inline void EquipmentSlots::unsafe_arena_set_allocated_cloak(
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cloak_);
  }
  _impl_.cloak_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.cloak)
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::release_cloak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::dnd5e::api::v1alpha1::InventoryItem* released = _impl_.cloak_;
  _impl_.cloak_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::unsafe_arena_release_cloak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentSlots.cloak)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::dnd5e::api::v1alpha1::InventoryItem* temp = _impl_.cloak_;
  _impl_.cloak_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::_internal_mutable_cloak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cloak_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::InventoryItem>(GetArena());
    _impl_.cloak_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(p);
  }
  return _impl_.cloak_;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::mutable_cloak()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::dnd5e::api::v1alpha1::InventoryItem* _msg = _internal_mutable_cloak();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSlots.cloak)
  return _msg;
}
inline void EquipmentSlots::set_allocated_cloak(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cloak_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.cloak_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.cloak)
}

// .dnd5e.api.v1alpha1.InventoryItem amulet = 8 [json_name = "amulet"];
inline bool EquipmentSlots::has_amulet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amulet_ != nullptr);
  return value;
}
inline void EquipmentSlots::clear_amulet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.amulet_ != nullptr) _impl_.amulet_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::_internal_amulet() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::InventoryItem* p = _impl_.amulet_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::InventoryItem&>(::dnd5e::api::v1alpha1::_InventoryItem_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::amulet() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSlots.amulet)
  return _internal_amulet();
}
inline void EquipmentSlots::unsafe_arena_set_allocated_amulet(
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.amulet_);
  }
  _impl_.amulet_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.amulet)
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::release_amulet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::dnd5e::api::v1alpha1::InventoryItem* released = _impl_.amulet_;
  _impl_.amulet_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::unsafe_arena_release_amulet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentSlots.amulet)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::dnd5e::api::v1alpha1::InventoryItem* temp = _impl_.amulet_;
  _impl_.amulet_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::_internal_mutable_amulet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.amulet_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::InventoryItem>(GetArena());
    _impl_.amulet_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(p);
  }
  return _impl_.amulet_;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::mutable_amulet()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::dnd5e::api::v1alpha1::InventoryItem* _msg = _internal_mutable_amulet();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSlots.amulet)
  return _msg;
}
inline void EquipmentSlots::set_allocated_amulet(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.amulet_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.amulet_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.amulet)
}

// .dnd5e.api.v1alpha1.InventoryItem ring_1 = 9 [json_name = "ring1"];
inline bool EquipmentSlots::has_ring_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ring_1_ != nullptr);
  return value;
}
inline void EquipmentSlots::clear_ring_1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ring_1_ != nullptr) _impl_.ring_1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::_internal_ring_1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::InventoryItem* p = _impl_.ring_1_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::InventoryItem&>(::dnd5e::api::v1alpha1::_InventoryItem_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::ring_1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSlots.ring_1)
  return _internal_ring_1();
}
inline void EquipmentSlots::unsafe_arena_set_allocated_ring_1(
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ring_1_);
  }
  _impl_.ring_1_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.ring_1)
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::release_ring_1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::dnd5e::api::v1alpha1::InventoryItem* released = _impl_.ring_1_;
  _impl_.ring_1_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::unsafe_arena_release_ring_1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentSlots.ring_1)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::dnd5e::api::v1alpha1::InventoryItem* temp = _impl_.ring_1_;
  _impl_.ring_1_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::_internal_mutable_ring_1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ring_1_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::InventoryItem>(GetArena());
    _impl_.ring_1_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(p);
  }
  return _impl_.ring_1_;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::mutable_ring_1()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::dnd5e::api::v1alpha1::InventoryItem* _msg = _internal_mutable_ring_1();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSlots.ring_1)
  return _msg;
}
inline void EquipmentSlots::set_allocated_ring_1(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ring_1_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.ring_1_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.ring_1)
}

// .dnd5e.api.v1alpha1.InventoryItem ring_2 = 10 [json_name = "ring2"];
inline bool EquipmentSlots::has_ring_2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ring_2_ != nullptr);
  return value;
}
inline void EquipmentSlots::clear_ring_2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ring_2_ != nullptr) _impl_.ring_2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::_internal_ring_2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::InventoryItem* p = _impl_.ring_2_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::InventoryItem&>(::dnd5e::api::v1alpha1::_InventoryItem_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::ring_2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSlots.ring_2)
  return _internal_ring_2();
}
inline void EquipmentSlots::unsafe_arena_set_allocated_ring_2(
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ring_2_);
  }
  _impl_.ring_2_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.ring_2)
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::release_ring_2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::dnd5e::api::v1alpha1::InventoryItem* released = _impl_.ring_2_;
  _impl_.ring_2_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::unsafe_arena_release_ring_2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentSlots.ring_2)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::dnd5e::api::v1alpha1::InventoryItem* temp = _impl_.ring_2_;
  _impl_.ring_2_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::_internal_mutable_ring_2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ring_2_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::InventoryItem>(GetArena());
    _impl_.ring_2_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(p);
  }
  return _impl_.ring_2_;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::mutable_ring_2()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::dnd5e::api::v1alpha1::InventoryItem* _msg = _internal_mutable_ring_2();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSlots.ring_2)
  return _msg;
}
inline void EquipmentSlots::set_allocated_ring_2(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ring_2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.ring_2_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.ring_2)
}

// .dnd5e.api.v1alpha1.InventoryItem belt = 11 [json_name = "belt"];
inline bool EquipmentSlots::has_belt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.belt_ != nullptr);
  return value;
}
inline void EquipmentSlots::clear_belt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.belt_ != nullptr) _impl_.belt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::_internal_belt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::InventoryItem* p = _impl_.belt_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::InventoryItem&>(::dnd5e::api::v1alpha1::_InventoryItem_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipmentSlots::belt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentSlots.belt)
  return _internal_belt();
}
inline void EquipmentSlots::unsafe_arena_set_allocated_belt(
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.belt_);
  }
  _impl_.belt_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.belt)
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::release_belt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::dnd5e::api::v1alpha1::InventoryItem* released = _impl_.belt_;
  _impl_.belt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipmentSlots::unsafe_arena_release_belt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipmentSlots.belt)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::dnd5e::api::v1alpha1::InventoryItem* temp = _impl_.belt_;
  _impl_.belt_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::_internal_mutable_belt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.belt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::InventoryItem>(GetArena());
    _impl_.belt_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(p);
  }
  return _impl_.belt_;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipmentSlots::mutable_belt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::dnd5e::api::v1alpha1::InventoryItem* _msg = _internal_mutable_belt();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentSlots.belt)
  return _msg;
}
inline void EquipmentSlots::set_allocated_belt(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.belt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.belt_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipmentSlots.belt)
}

// -------------------------------------------------------------------

// InventoryItem

// string item_id = 1 [json_name = "itemId"];
inline void InventoryItem::clear_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.item_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& InventoryItem::item_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InventoryItem.item_id)
  return _internal_item_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InventoryItem::set_item_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.item_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InventoryItem.item_id)
}
inline ::std::string* PROTOBUF_NONNULL InventoryItem::mutable_item_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.InventoryItem.item_id)
  return _s;
}
inline const ::std::string& InventoryItem::_internal_item_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.item_id_.Get();
}
inline void InventoryItem::_internal_set_item_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.item_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InventoryItem::_internal_mutable_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.item_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InventoryItem::release_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.InventoryItem.item_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.item_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.item_id_.Set("", GetArena());
  }
  return released;
}
inline void InventoryItem::set_allocated_item_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.item_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.InventoryItem.item_id)
}

// int32 quantity = 2 [json_name = "quantity"];
inline void InventoryItem::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t InventoryItem::quantity() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InventoryItem.quantity)
  return _internal_quantity();
}
inline void InventoryItem::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InventoryItem.quantity)
}
inline ::int32_t InventoryItem::_internal_quantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_;
}
inline void InventoryItem::_internal_set_quantity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = value;
}

// bool is_attuned = 3 [json_name = "isAttuned"];
inline void InventoryItem::clear_is_attuned() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_attuned_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool InventoryItem::is_attuned() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InventoryItem.is_attuned)
  return _internal_is_attuned();
}
inline void InventoryItem::set_is_attuned(bool value) {
  _internal_set_is_attuned(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InventoryItem.is_attuned)
}
inline bool InventoryItem::_internal_is_attuned() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_attuned_;
}
inline void InventoryItem::_internal_set_is_attuned(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_attuned_ = value;
}

// string custom_name = 4 [json_name = "customName"];
inline void InventoryItem::clear_custom_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.custom_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& InventoryItem::custom_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InventoryItem.custom_name)
  return _internal_custom_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InventoryItem::set_custom_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.custom_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InventoryItem.custom_name)
}
inline ::std::string* PROTOBUF_NONNULL InventoryItem::mutable_custom_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_custom_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.InventoryItem.custom_name)
  return _s;
}
inline const ::std::string& InventoryItem::_internal_custom_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.custom_name_.Get();
}
inline void InventoryItem::_internal_set_custom_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.custom_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InventoryItem::_internal_mutable_custom_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.custom_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InventoryItem::release_custom_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.InventoryItem.custom_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.custom_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.custom_name_.Set("", GetArena());
  }
  return released;
}
inline void InventoryItem::set_allocated_custom_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.custom_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.custom_name_.IsDefault()) {
    _impl_.custom_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.InventoryItem.custom_name)
}

// .dnd5e.api.v1alpha1.Equipment equipment = 5 [json_name = "equipment"];
inline bool InventoryItem::has_equipment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.equipment_ != nullptr);
  return value;
}
inline void InventoryItem::clear_equipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.equipment_ != nullptr) _impl_.equipment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::dnd5e::api::v1alpha1::Equipment& InventoryItem::_internal_equipment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Equipment* p = _impl_.equipment_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Equipment&>(::dnd5e::api::v1alpha1::_Equipment_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Equipment& InventoryItem::equipment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InventoryItem.equipment)
  return _internal_equipment();
}
inline void InventoryItem::unsafe_arena_set_allocated_equipment(
    ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.equipment_);
  }
  _impl_.equipment_ = reinterpret_cast<::dnd5e::api::v1alpha1::Equipment*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.InventoryItem.equipment)
}
inline ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NULLABLE InventoryItem::release_equipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dnd5e::api::v1alpha1::Equipment* released = _impl_.equipment_;
  _impl_.equipment_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NULLABLE InventoryItem::unsafe_arena_release_equipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.InventoryItem.equipment)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dnd5e::api::v1alpha1::Equipment* temp = _impl_.equipment_;
  _impl_.equipment_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NONNULL InventoryItem::_internal_mutable_equipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.equipment_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Equipment>(GetArena());
    _impl_.equipment_ = reinterpret_cast<::dnd5e::api::v1alpha1::Equipment*>(p);
  }
  return _impl_.equipment_;
}
inline ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NONNULL InventoryItem::mutable_equipment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::dnd5e::api::v1alpha1::Equipment* _msg = _internal_mutable_equipment();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.InventoryItem.equipment)
  return _msg;
}
inline void InventoryItem::set_allocated_equipment(::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.equipment_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.equipment_ = reinterpret_cast<::dnd5e::api::v1alpha1::Equipment*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.InventoryItem.equipment)
}

// -------------------------------------------------------------------

// EncumbranceInfo

// int32 current_weight = 1 [json_name = "currentWeight"];
inline void EncumbranceInfo::clear_current_weight() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_weight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t EncumbranceInfo::current_weight() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncumbranceInfo.current_weight)
  return _internal_current_weight();
}
inline void EncumbranceInfo::set_current_weight(::int32_t value) {
  _internal_set_current_weight(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EncumbranceInfo.current_weight)
}
inline ::int32_t EncumbranceInfo::_internal_current_weight() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_weight_;
}
inline void EncumbranceInfo::_internal_set_current_weight(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_weight_ = value;
}

// int32 carrying_capacity = 2 [json_name = "carryingCapacity"];
inline void EncumbranceInfo::clear_carrying_capacity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.carrying_capacity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t EncumbranceInfo::carrying_capacity() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncumbranceInfo.carrying_capacity)
  return _internal_carrying_capacity();
}
inline void EncumbranceInfo::set_carrying_capacity(::int32_t value) {
  _internal_set_carrying_capacity(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EncumbranceInfo.carrying_capacity)
}
inline ::int32_t EncumbranceInfo::_internal_carrying_capacity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.carrying_capacity_;
}
inline void EncumbranceInfo::_internal_set_carrying_capacity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.carrying_capacity_ = value;
}

// int32 max_capacity = 3 [json_name = "maxCapacity"];
inline void EncumbranceInfo::clear_max_capacity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_capacity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t EncumbranceInfo::max_capacity() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncumbranceInfo.max_capacity)
  return _internal_max_capacity();
}
inline void EncumbranceInfo::set_max_capacity(::int32_t value) {
  _internal_set_max_capacity(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EncumbranceInfo.max_capacity)
}
inline ::int32_t EncumbranceInfo::_internal_max_capacity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_capacity_;
}
inline void EncumbranceInfo::_internal_set_max_capacity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_capacity_ = value;
}

// .dnd5e.api.v1alpha1.EncumbranceLevel level = 4 [json_name = "level"];
inline void EncumbranceInfo::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::dnd5e::api::v1alpha1::EncumbranceLevel EncumbranceInfo::level() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncumbranceInfo.level)
  return _internal_level();
}
inline void EncumbranceInfo::set_level(::dnd5e::api::v1alpha1::EncumbranceLevel value) {
  _internal_set_level(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EncumbranceInfo.level)
}
inline ::dnd5e::api::v1alpha1::EncumbranceLevel EncumbranceInfo::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::EncumbranceLevel>(_impl_.level_);
}
inline void EncumbranceInfo::_internal_set_level(::dnd5e::api::v1alpha1::EncumbranceLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = value;
}

// -------------------------------------------------------------------

// Spell

// string id = 1 [json_name = "id"];
inline void Spell::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Spell::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Spell::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Spell.id)
}
inline ::std::string* PROTOBUF_NONNULL Spell::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Spell.id)
  return _s;
}
inline const ::std::string& Spell::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Spell::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Spell::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Spell::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Spell.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void Spell::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Spell.id)
}

// string name = 2 [json_name = "name"];
inline void Spell::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Spell::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Spell::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Spell.name)
}
inline ::std::string* PROTOBUF_NONNULL Spell::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Spell.name)
  return _s;
}
inline const ::std::string& Spell::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Spell::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Spell::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Spell::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Spell.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void Spell::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Spell.name)
}

// int32 level = 3 [json_name = "level"];
inline void Spell::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int32_t Spell::level() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.level)
  return _internal_level();
}
inline void Spell::set_level(::int32_t value) {
  _internal_set_level(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Spell.level)
}
inline ::int32_t Spell::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_;
}
inline void Spell::_internal_set_level(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = value;
}

// string school = 4 [json_name = "school"];
inline void Spell::clear_school() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.school_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& Spell::school() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.school)
  return _internal_school();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Spell::set_school(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.school_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Spell.school)
}
inline ::std::string* PROTOBUF_NONNULL Spell::mutable_school()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_school();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Spell.school)
  return _s;
}
inline const ::std::string& Spell::_internal_school() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.school_.Get();
}
inline void Spell::_internal_set_school(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.school_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Spell::_internal_mutable_school() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.school_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Spell::release_school() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Spell.school)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.school_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.school_.Set("", GetArena());
  }
  return released;
}
inline void Spell::set_allocated_school(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.school_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.school_.IsDefault()) {
    _impl_.school_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Spell.school)
}

// repeated string classes = 5 [json_name = "classes"];
inline int Spell::_internal_classes_size() const {
  return _internal_classes().size();
}
inline int Spell::classes_size() const {
  return _internal_classes_size();
}
inline void Spell::clear_classes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.classes_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL Spell::add_classes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_classes()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.Spell.classes)
  return _s;
}
inline const ::std::string& Spell::classes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.classes)
  return _internal_classes().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL Spell::mutable_classes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Spell.classes)
  return _internal_mutable_classes()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Spell::set_classes(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_classes()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Spell.classes)
}
template <typename Arg_, typename... Args_>
inline void Spell::add_classes(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_classes(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.Spell.classes)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& Spell::classes()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.Spell.classes)
  return _internal_classes();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
Spell::mutable_classes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.Spell.classes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_classes();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Spell::_internal_classes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.classes_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
Spell::_internal_mutable_classes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.classes_;
}

// string casting_time = 6 [json_name = "castingTime"];
inline void Spell::clear_casting_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.casting_time_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& Spell::casting_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.casting_time)
  return _internal_casting_time();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Spell::set_casting_time(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.casting_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Spell.casting_time)
}
inline ::std::string* PROTOBUF_NONNULL Spell::mutable_casting_time()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_casting_time();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Spell.casting_time)
  return _s;
}
inline const ::std::string& Spell::_internal_casting_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.casting_time_.Get();
}
inline void Spell::_internal_set_casting_time(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.casting_time_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Spell::_internal_mutable_casting_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.casting_time_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Spell::release_casting_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Spell.casting_time)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.casting_time_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.casting_time_.Set("", GetArena());
  }
  return released;
}
inline void Spell::set_allocated_casting_time(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.casting_time_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.casting_time_.IsDefault()) {
    _impl_.casting_time_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Spell.casting_time)
}

// string range = 7 [json_name = "range"];
inline void Spell::clear_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.range_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& Spell::range() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.range)
  return _internal_range();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Spell::set_range(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.range_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Spell.range)
}
inline ::std::string* PROTOBUF_NONNULL Spell::mutable_range()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Spell.range)
  return _s;
}
inline const ::std::string& Spell::_internal_range() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.range_.Get();
}
inline void Spell::_internal_set_range(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.range_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Spell::_internal_mutable_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.range_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Spell::release_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Spell.range)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.range_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.range_.Set("", GetArena());
  }
  return released;
}
inline void Spell::set_allocated_range(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.range_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.range_.IsDefault()) {
    _impl_.range_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Spell.range)
}

// string duration = 8 [json_name = "duration"];
inline void Spell::clear_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& Spell::duration() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.duration)
  return _internal_duration();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Spell::set_duration(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.duration_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Spell.duration)
}
inline ::std::string* PROTOBUF_NONNULL Spell::mutable_duration()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Spell.duration)
  return _s;
}
inline const ::std::string& Spell::_internal_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_.Get();
}
inline void Spell::_internal_set_duration(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.duration_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Spell::_internal_mutable_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.duration_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Spell::release_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Spell.duration)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.duration_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.duration_.Set("", GetArena());
  }
  return released;
}
inline void Spell::set_allocated_duration(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.duration_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.duration_.IsDefault()) {
    _impl_.duration_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Spell.duration)
}

// bool ritual = 9 [json_name = "ritual"];
inline void Spell::clear_ritual() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ritual_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool Spell::ritual() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.ritual)
  return _internal_ritual();
}
inline void Spell::set_ritual(bool value) {
  _internal_set_ritual(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Spell.ritual)
}
inline bool Spell::_internal_ritual() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ritual_;
}
inline void Spell::_internal_set_ritual(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ritual_ = value;
}

// bool concentration = 10 [json_name = "concentration"];
inline void Spell::clear_concentration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.concentration_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool Spell::concentration() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.concentration)
  return _internal_concentration();
}
inline void Spell::set_concentration(bool value) {
  _internal_set_concentration(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Spell.concentration)
}
inline bool Spell::_internal_concentration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.concentration_;
}
inline void Spell::_internal_set_concentration(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.concentration_ = value;
}

// string components = 11 [json_name = "components"];
inline void Spell::clear_components() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.components_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::std::string& Spell::components() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.components)
  return _internal_components();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Spell::set_components(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.components_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Spell.components)
}
inline ::std::string* PROTOBUF_NONNULL Spell::mutable_components()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_components();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Spell.components)
  return _s;
}
inline const ::std::string& Spell::_internal_components() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.components_.Get();
}
inline void Spell::_internal_set_components(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.components_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Spell::_internal_mutable_components() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.components_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Spell::release_components() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Spell.components)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.components_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.components_.Set("", GetArena());
  }
  return released;
}
inline void Spell::set_allocated_components(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.components_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.components_.IsDefault()) {
    _impl_.components_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Spell.components)
}

// string description = 12 [json_name = "description"];
inline void Spell::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::std::string& Spell::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Spell::set_description(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Spell.description)
}
inline ::std::string* PROTOBUF_NONNULL Spell::mutable_description()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Spell.description)
  return _s;
}
inline const ::std::string& Spell::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void Spell::_internal_set_description(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.description_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Spell::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.description_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Spell::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Spell.description)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void Spell::set_allocated_description(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Spell.description)
}

// .dnd5e.api.v1alpha1.SpellDamage damage = 13 [json_name = "damage"];
inline bool Spell::has_damage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.damage_ != nullptr);
  return value;
}
inline void Spell::clear_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.damage_ != nullptr) _impl_.damage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::dnd5e::api::v1alpha1::SpellDamage& Spell::_internal_damage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::SpellDamage* p = _impl_.damage_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::SpellDamage&>(::dnd5e::api::v1alpha1::_SpellDamage_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SpellDamage& Spell::damage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.damage)
  return _internal_damage();
}
inline void Spell::unsafe_arena_set_allocated_damage(
    ::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.damage_);
  }
  _impl_.damage_ = reinterpret_cast<::dnd5e::api::v1alpha1::SpellDamage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Spell.damage)
}
inline ::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NULLABLE Spell::release_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::dnd5e::api::v1alpha1::SpellDamage* released = _impl_.damage_;
  _impl_.damage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NULLABLE Spell::unsafe_arena_release_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Spell.damage)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::dnd5e::api::v1alpha1::SpellDamage* temp = _impl_.damage_;
  _impl_.damage_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NONNULL Spell::_internal_mutable_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.damage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SpellDamage>(GetArena());
    _impl_.damage_ = reinterpret_cast<::dnd5e::api::v1alpha1::SpellDamage*>(p);
  }
  return _impl_.damage_;
}
inline ::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NONNULL Spell::mutable_damage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::dnd5e::api::v1alpha1::SpellDamage* _msg = _internal_mutable_damage();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Spell.damage)
  return _msg;
}
inline void Spell::set_allocated_damage(::dnd5e::api::v1alpha1::SpellDamage* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.damage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.damage_ = reinterpret_cast<::dnd5e::api::v1alpha1::SpellDamage*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Spell.damage)
}

// .dnd5e.api.v1alpha1.AreaOfEffect area_of_effect = 14 [json_name = "areaOfEffect"];
inline bool Spell::has_area_of_effect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.area_of_effect_ != nullptr);
  return value;
}
inline void Spell::clear_area_of_effect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.area_of_effect_ != nullptr) _impl_.area_of_effect_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::dnd5e::api::v1alpha1::AreaOfEffect& Spell::_internal_area_of_effect() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::AreaOfEffect* p = _impl_.area_of_effect_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::AreaOfEffect&>(::dnd5e::api::v1alpha1::_AreaOfEffect_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AreaOfEffect& Spell::area_of_effect() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Spell.area_of_effect)
  return _internal_area_of_effect();
}
inline void Spell::unsafe_arena_set_allocated_area_of_effect(
    ::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.area_of_effect_);
  }
  _impl_.area_of_effect_ = reinterpret_cast<::dnd5e::api::v1alpha1::AreaOfEffect*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.Spell.area_of_effect)
}
inline ::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NULLABLE Spell::release_area_of_effect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::dnd5e::api::v1alpha1::AreaOfEffect* released = _impl_.area_of_effect_;
  _impl_.area_of_effect_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NULLABLE Spell::unsafe_arena_release_area_of_effect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Spell.area_of_effect)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::dnd5e::api::v1alpha1::AreaOfEffect* temp = _impl_.area_of_effect_;
  _impl_.area_of_effect_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NONNULL Spell::_internal_mutable_area_of_effect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.area_of_effect_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AreaOfEffect>(GetArena());
    _impl_.area_of_effect_ = reinterpret_cast<::dnd5e::api::v1alpha1::AreaOfEffect*>(p);
  }
  return _impl_.area_of_effect_;
}
inline ::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NONNULL Spell::mutable_area_of_effect()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::dnd5e::api::v1alpha1::AreaOfEffect* _msg = _internal_mutable_area_of_effect();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Spell.area_of_effect)
  return _msg;
}
inline void Spell::set_allocated_area_of_effect(::dnd5e::api::v1alpha1::AreaOfEffect* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.area_of_effect_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.area_of_effect_ = reinterpret_cast<::dnd5e::api::v1alpha1::AreaOfEffect*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Spell.area_of_effect)
}

// -------------------------------------------------------------------

// ChoiceData

// .dnd5e.api.v1alpha1.ChoiceCategory category = 1 [json_name = "category"];
inline void ChoiceData::clear_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::dnd5e::api::v1alpha1::ChoiceCategory ChoiceData::category() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.category)
  return _internal_category();
}
inline void ChoiceData::set_category(::dnd5e::api::v1alpha1::ChoiceCategory value) {
  _internal_set_category(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceData.category)
}
inline ::dnd5e::api::v1alpha1::ChoiceCategory ChoiceData::_internal_category() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::ChoiceCategory>(_impl_.category_);
}
inline void ChoiceData::_internal_set_category(::dnd5e::api::v1alpha1::ChoiceCategory value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_ = value;
}

// .dnd5e.api.v1alpha1.ChoiceSource source = 2 [json_name = "source"];
inline void ChoiceData::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::dnd5e::api::v1alpha1::ChoiceSource ChoiceData::source() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.source)
  return _internal_source();
}
inline void ChoiceData::set_source(::dnd5e::api::v1alpha1::ChoiceSource value) {
  _internal_set_source(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceData.source)
}
inline ::dnd5e::api::v1alpha1::ChoiceSource ChoiceData::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::ChoiceSource>(_impl_.source_);
}
inline void ChoiceData::_internal_set_source(::dnd5e::api::v1alpha1::ChoiceSource value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = value;
}

// string choice_id = 3 [json_name = "choiceId"];
inline void ChoiceData::clear_choice_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choice_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ChoiceData::choice_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.choice_id)
  return _internal_choice_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChoiceData::set_choice_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.choice_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceData.choice_id)
}
inline ::std::string* PROTOBUF_NONNULL ChoiceData::mutable_choice_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_choice_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.choice_id)
  return _s;
}
inline const ::std::string& ChoiceData::_internal_choice_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.choice_id_.Get();
}
inline void ChoiceData::_internal_set_choice_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.choice_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChoiceData::_internal_mutable_choice_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.choice_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChoiceData::release_choice_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.choice_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.choice_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.choice_id_.Set("", GetArena());
  }
  return released;
}
inline void ChoiceData::set_allocated_choice_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.choice_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.choice_id_.IsDefault()) {
    _impl_.choice_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.choice_id)
}

// string name = 4 [json_name = "name"];
inline bool ChoiceData::has_name() const {
  return selection_case() == kName;
}
inline void ChoiceData::set_has_name() {
  _impl_._oneof_case_[0] = kName;
}
inline void ChoiceData::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kName) {
    _impl_.selection_.name_.Destroy();
    clear_has_selection();
  }
}
inline const ::std::string& ChoiceData::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChoiceData::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() != kName) {
    clear_selection();

    set_has_name();
    _impl_.selection_.name_.InitDefault();
  }
  _impl_.selection_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceData.name)
}
inline ::std::string* PROTOBUF_NONNULL ChoiceData::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.name)
  return _s;
}
inline const ::std::string& ChoiceData::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (selection_case() != kName) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.selection_.name_.Get();
}
inline void ChoiceData::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() != kName) {
    clear_selection();

    set_has_name();
    _impl_.selection_.name_.InitDefault();
  }
  _impl_.selection_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChoiceData::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() != kName) {
    clear_selection();

    set_has_name();
    _impl_.selection_.name_.InitDefault();
  }
  return _impl_.selection_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChoiceData::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.name)
  if (selection_case() != kName) {
    return nullptr;
  }
  clear_has_selection();
  return _impl_.selection_.name_.Release();
}
inline void ChoiceData::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_selection()) {
    clear_selection();
  }
  if (value != nullptr) {
    set_has_name();
    _impl_.selection_.name_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.name)
}

// .dnd5e.api.v1alpha1.SkillList skills = 5 [json_name = "skills"];
inline bool ChoiceData::has_skills() const {
  return selection_case() == kSkills;
}
inline bool ChoiceData::_internal_has_skills() const {
  return selection_case() == kSkills;
}
inline void ChoiceData::set_has_skills() {
  _impl_._oneof_case_[0] = kSkills;
}
inline void ChoiceData::clear_skills() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kSkills) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.skills_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.skills_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::SkillList* PROTOBUF_NULLABLE ChoiceData::release_skills() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.skills)
  if (selection_case() == kSkills) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SkillList*>(_impl_.selection_.skills_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.skills_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::SkillList& ChoiceData::_internal_skills() const {
  return selection_case() == kSkills ? *reinterpret_cast<::dnd5e::api::v1alpha1::SkillList*>(_impl_.selection_.skills_) : reinterpret_cast<::dnd5e::api::v1alpha1::SkillList&>(::dnd5e::api::v1alpha1::_SkillList_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SkillList& ChoiceData::skills() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.skills)
  return _internal_skills();
}
inline ::dnd5e::api::v1alpha1::SkillList* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_skills() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.skills)
  if (selection_case() == kSkills) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SkillList*>(_impl_.selection_.skills_);
    _impl_.selection_.skills_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_skills(
    ::dnd5e::api::v1alpha1::SkillList* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_skills();
    _impl_.selection_.skills_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.skills)
}
inline ::dnd5e::api::v1alpha1::SkillList* PROTOBUF_NONNULL ChoiceData::_internal_mutable_skills() {
  if (selection_case() != kSkills) {
    clear_selection();
    set_has_skills();
    _impl_.selection_.skills_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SkillList>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::SkillList*>(_impl_.selection_.skills_);
}
inline ::dnd5e::api::v1alpha1::SkillList* PROTOBUF_NONNULL ChoiceData::mutable_skills()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::SkillList* _msg = _internal_mutable_skills();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.skills)
  return _msg;
}

// .dnd5e.api.v1alpha1.LanguageList languages = 6 [json_name = "languages"];
inline bool ChoiceData::has_languages() const {
  return selection_case() == kLanguages;
}
inline bool ChoiceData::_internal_has_languages() const {
  return selection_case() == kLanguages;
}
inline void ChoiceData::set_has_languages() {
  _impl_._oneof_case_[0] = kLanguages;
}
inline void ChoiceData::clear_languages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kLanguages) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.languages_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.languages_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::LanguageList* PROTOBUF_NULLABLE ChoiceData::release_languages() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.languages)
  if (selection_case() == kLanguages) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::LanguageList*>(_impl_.selection_.languages_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.languages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::LanguageList& ChoiceData::_internal_languages() const {
  return selection_case() == kLanguages ? *reinterpret_cast<::dnd5e::api::v1alpha1::LanguageList*>(_impl_.selection_.languages_) : reinterpret_cast<::dnd5e::api::v1alpha1::LanguageList&>(::dnd5e::api::v1alpha1::_LanguageList_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::LanguageList& ChoiceData::languages() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.languages)
  return _internal_languages();
}
inline ::dnd5e::api::v1alpha1::LanguageList* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_languages() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.languages)
  if (selection_case() == kLanguages) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::LanguageList*>(_impl_.selection_.languages_);
    _impl_.selection_.languages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_languages(
    ::dnd5e::api::v1alpha1::LanguageList* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_languages();
    _impl_.selection_.languages_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.languages)
}
inline ::dnd5e::api::v1alpha1::LanguageList* PROTOBUF_NONNULL ChoiceData::_internal_mutable_languages() {
  if (selection_case() != kLanguages) {
    clear_selection();
    set_has_languages();
    _impl_.selection_.languages_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::LanguageList>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::LanguageList*>(_impl_.selection_.languages_);
}
inline ::dnd5e::api::v1alpha1::LanguageList* PROTOBUF_NONNULL ChoiceData::mutable_languages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::LanguageList* _msg = _internal_mutable_languages();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.languages)
  return _msg;
}

// .dnd5e.api.v1alpha1.AbilityScores ability_scores = 7 [json_name = "abilityScores"];
inline bool ChoiceData::has_ability_scores() const {
  return selection_case() == kAbilityScores;
}
inline bool ChoiceData::_internal_has_ability_scores() const {
  return selection_case() == kAbilityScores;
}
inline void ChoiceData::set_has_ability_scores() {
  _impl_._oneof_case_[0] = kAbilityScores;
}
inline void ChoiceData::clear_ability_scores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kAbilityScores) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.ability_scores_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.ability_scores_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE ChoiceData::release_ability_scores() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.ability_scores)
  if (selection_case() == kAbilityScores) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(_impl_.selection_.ability_scores_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.ability_scores_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::AbilityScores& ChoiceData::_internal_ability_scores() const {
  return selection_case() == kAbilityScores ? *reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(_impl_.selection_.ability_scores_) : reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores&>(::dnd5e::api::v1alpha1::_AbilityScores_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AbilityScores& ChoiceData::ability_scores() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.ability_scores)
  return _internal_ability_scores();
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_ability_scores() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.ability_scores)
  if (selection_case() == kAbilityScores) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(_impl_.selection_.ability_scores_);
    _impl_.selection_.ability_scores_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_ability_scores(
    ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_ability_scores();
    _impl_.selection_.ability_scores_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.ability_scores)
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL ChoiceData::_internal_mutable_ability_scores() {
  if (selection_case() != kAbilityScores) {
    clear_selection();
    set_has_ability_scores();
    _impl_.selection_.ability_scores_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AbilityScores>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::AbilityScores*>(_impl_.selection_.ability_scores_);
}
inline ::dnd5e::api::v1alpha1::AbilityScores* PROTOBUF_NONNULL ChoiceData::mutable_ability_scores()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::AbilityScores* _msg = _internal_mutable_ability_scores();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.ability_scores)
  return _msg;
}

// string fighting_style = 8 [json_name = "fightingStyle"];
inline bool ChoiceData::has_fighting_style() const {
  return selection_case() == kFightingStyle;
}
inline void ChoiceData::set_has_fighting_style() {
  _impl_._oneof_case_[0] = kFightingStyle;
}
inline void ChoiceData::clear_fighting_style() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kFightingStyle) {
    _impl_.selection_.fighting_style_.Destroy();
    clear_has_selection();
  }
}
inline const ::std::string& ChoiceData::fighting_style() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.fighting_style)
  return _internal_fighting_style();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChoiceData::set_fighting_style(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() != kFightingStyle) {
    clear_selection();

    set_has_fighting_style();
    _impl_.selection_.fighting_style_.InitDefault();
  }
  _impl_.selection_.fighting_style_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceData.fighting_style)
}
inline ::std::string* PROTOBUF_NONNULL ChoiceData::mutable_fighting_style()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_fighting_style();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.fighting_style)
  return _s;
}
inline const ::std::string& ChoiceData::_internal_fighting_style() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (selection_case() != kFightingStyle) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.selection_.fighting_style_.Get();
}
inline void ChoiceData::_internal_set_fighting_style(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() != kFightingStyle) {
    clear_selection();

    set_has_fighting_style();
    _impl_.selection_.fighting_style_.InitDefault();
  }
  _impl_.selection_.fighting_style_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChoiceData::_internal_mutable_fighting_style() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() != kFightingStyle) {
    clear_selection();

    set_has_fighting_style();
    _impl_.selection_.fighting_style_.InitDefault();
  }
  return _impl_.selection_.fighting_style_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChoiceData::release_fighting_style() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.fighting_style)
  if (selection_case() != kFightingStyle) {
    return nullptr;
  }
  clear_has_selection();
  return _impl_.selection_.fighting_style_.Release();
}
inline void ChoiceData::set_allocated_fighting_style(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_selection()) {
    clear_selection();
  }
  if (value != nullptr) {
    set_has_fighting_style();
    _impl_.selection_.fighting_style_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceData.fighting_style)
}

// .dnd5e.api.v1alpha1.EquipmentList equipment = 9 [json_name = "equipment"];
inline bool ChoiceData::has_equipment() const {
  return selection_case() == kEquipment;
}
inline bool ChoiceData::_internal_has_equipment() const {
  return selection_case() == kEquipment;
}
inline void ChoiceData::set_has_equipment() {
  _impl_._oneof_case_[0] = kEquipment;
}
inline void ChoiceData::clear_equipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kEquipment) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.equipment_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.equipment_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::EquipmentList* PROTOBUF_NULLABLE ChoiceData::release_equipment() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.equipment)
  if (selection_case() == kEquipment) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentList*>(_impl_.selection_.equipment_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.equipment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::EquipmentList& ChoiceData::_internal_equipment() const {
  return selection_case() == kEquipment ? *reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentList*>(_impl_.selection_.equipment_) : reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentList&>(::dnd5e::api::v1alpha1::_EquipmentList_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::EquipmentList& ChoiceData::equipment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.equipment)
  return _internal_equipment();
}
inline ::dnd5e::api::v1alpha1::EquipmentList* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_equipment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.equipment)
  if (selection_case() == kEquipment) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentList*>(_impl_.selection_.equipment_);
    _impl_.selection_.equipment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_equipment(
    ::dnd5e::api::v1alpha1::EquipmentList* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_equipment();
    _impl_.selection_.equipment_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.equipment)
}
inline ::dnd5e::api::v1alpha1::EquipmentList* PROTOBUF_NONNULL ChoiceData::_internal_mutable_equipment() {
  if (selection_case() != kEquipment) {
    clear_selection();
    set_has_equipment();
    _impl_.selection_.equipment_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::EquipmentList>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentList*>(_impl_.selection_.equipment_);
}
inline ::dnd5e::api::v1alpha1::EquipmentList* PROTOBUF_NONNULL ChoiceData::mutable_equipment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::EquipmentList* _msg = _internal_mutable_equipment();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.equipment)
  return _msg;
}

// .dnd5e.api.v1alpha1.RaceChoice race = 10 [json_name = "race"];
inline bool ChoiceData::has_race() const {
  return selection_case() == kRace;
}
inline bool ChoiceData::_internal_has_race() const {
  return selection_case() == kRace;
}
inline void ChoiceData::set_has_race() {
  _impl_._oneof_case_[0] = kRace;
}
inline void ChoiceData::clear_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kRace) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.race_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.race_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::RaceChoice* PROTOBUF_NULLABLE ChoiceData::release_race() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.race)
  if (selection_case() == kRace) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::RaceChoice*>(_impl_.selection_.race_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.race_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::RaceChoice& ChoiceData::_internal_race() const {
  return selection_case() == kRace ? *reinterpret_cast<::dnd5e::api::v1alpha1::RaceChoice*>(_impl_.selection_.race_) : reinterpret_cast<::dnd5e::api::v1alpha1::RaceChoice&>(::dnd5e::api::v1alpha1::_RaceChoice_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::RaceChoice& ChoiceData::race() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.race)
  return _internal_race();
}
inline ::dnd5e::api::v1alpha1::RaceChoice* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_race() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.race)
  if (selection_case() == kRace) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::RaceChoice*>(_impl_.selection_.race_);
    _impl_.selection_.race_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_race(
    ::dnd5e::api::v1alpha1::RaceChoice* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_race();
    _impl_.selection_.race_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.race)
}
inline ::dnd5e::api::v1alpha1::RaceChoice* PROTOBUF_NONNULL ChoiceData::_internal_mutable_race() {
  if (selection_case() != kRace) {
    clear_selection();
    set_has_race();
    _impl_.selection_.race_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::RaceChoice>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::RaceChoice*>(_impl_.selection_.race_);
}
inline ::dnd5e::api::v1alpha1::RaceChoice* PROTOBUF_NONNULL ChoiceData::mutable_race()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::RaceChoice* _msg = _internal_mutable_race();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.race)
  return _msg;
}

// .dnd5e.api.v1alpha1.ClassChoice class = 11 [json_name = "class"];
inline bool ChoiceData::has_class_() const {
  return selection_case() == kClass;
}
inline bool ChoiceData::_internal_has_class_() const {
  return selection_case() == kClass;
}
inline void ChoiceData::set_has_class_() {
  _impl_._oneof_case_[0] = kClass;
}
inline void ChoiceData::clear_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kClass) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.class__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.class__);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::ClassChoice* PROTOBUF_NULLABLE ChoiceData::release_class_() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.class)
  if (selection_case() == kClass) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ClassChoice*>(_impl_.selection_.class__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.class__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::ClassChoice& ChoiceData::_internal_class_() const {
  return selection_case() == kClass ? *reinterpret_cast<::dnd5e::api::v1alpha1::ClassChoice*>(_impl_.selection_.class__) : reinterpret_cast<::dnd5e::api::v1alpha1::ClassChoice&>(::dnd5e::api::v1alpha1::_ClassChoice_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::ClassChoice& ChoiceData::class_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.class)
  return _internal_class_();
}
inline ::dnd5e::api::v1alpha1::ClassChoice* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_class_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.class)
  if (selection_case() == kClass) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::ClassChoice*>(_impl_.selection_.class__);
    _impl_.selection_.class__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_class_(
    ::dnd5e::api::v1alpha1::ClassChoice* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_class_();
    _impl_.selection_.class__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.class)
}
inline ::dnd5e::api::v1alpha1::ClassChoice* PROTOBUF_NONNULL ChoiceData::_internal_mutable_class_() {
  if (selection_case() != kClass) {
    clear_selection();
    set_has_class_();
    _impl_.selection_.class__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::ClassChoice>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::ClassChoice*>(_impl_.selection_.class__);
}
inline ::dnd5e::api::v1alpha1::ClassChoice* PROTOBUF_NONNULL ChoiceData::mutable_class_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::ClassChoice* _msg = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.class)
  return _msg;
}

// .dnd5e.api.v1alpha1.Background background = 12 [json_name = "background"];
inline bool ChoiceData::has_background() const {
  return selection_case() == kBackground;
}
inline void ChoiceData::set_has_background() {
  _impl_._oneof_case_[0] = kBackground;
}
inline void ChoiceData::clear_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kBackground) {
    _impl_.selection_.background_ = 0;
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::Background ChoiceData::background() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.background)
  return _internal_background();
}
inline void ChoiceData::set_background(::dnd5e::api::v1alpha1::Background value) {
  if (selection_case() != kBackground) {
    clear_selection();
    set_has_background();
  }
  _impl_.selection_.background_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceData.background)
}
inline ::dnd5e::api::v1alpha1::Background ChoiceData::_internal_background() const {
  if (selection_case() == kBackground) {
    return static_cast<::dnd5e::api::v1alpha1::Background>(_impl_.selection_.background_);
  }
  return static_cast<::dnd5e::api::v1alpha1::Background>(0);
}

// .dnd5e.api.v1alpha1.SpellList spells = 13 [json_name = "spells"];
inline bool ChoiceData::has_spells() const {
  return selection_case() == kSpells;
}
inline bool ChoiceData::_internal_has_spells() const {
  return selection_case() == kSpells;
}
inline void ChoiceData::set_has_spells() {
  _impl_._oneof_case_[0] = kSpells;
}
inline void ChoiceData::clear_spells() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kSpells) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.spells_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.spells_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::SpellList* PROTOBUF_NULLABLE ChoiceData::release_spells() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.spells)
  if (selection_case() == kSpells) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SpellList*>(_impl_.selection_.spells_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.spells_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::SpellList& ChoiceData::_internal_spells() const {
  return selection_case() == kSpells ? *reinterpret_cast<::dnd5e::api::v1alpha1::SpellList*>(_impl_.selection_.spells_) : reinterpret_cast<::dnd5e::api::v1alpha1::SpellList&>(::dnd5e::api::v1alpha1::_SpellList_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SpellList& ChoiceData::spells() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.spells)
  return _internal_spells();
}
inline ::dnd5e::api::v1alpha1::SpellList* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_spells() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.spells)
  if (selection_case() == kSpells) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::SpellList*>(_impl_.selection_.spells_);
    _impl_.selection_.spells_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_spells(
    ::dnd5e::api::v1alpha1::SpellList* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_spells();
    _impl_.selection_.spells_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.spells)
}
inline ::dnd5e::api::v1alpha1::SpellList* PROTOBUF_NONNULL ChoiceData::_internal_mutable_spells() {
  if (selection_case() != kSpells) {
    clear_selection();
    set_has_spells();
    _impl_.selection_.spells_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SpellList>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::SpellList*>(_impl_.selection_.spells_);
}
inline ::dnd5e::api::v1alpha1::SpellList* PROTOBUF_NONNULL ChoiceData::mutable_spells()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::SpellList* _msg = _internal_mutable_spells();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.spells)
  return _msg;
}

// .dnd5e.api.v1alpha1.CantripList cantrips = 14 [json_name = "cantrips"];
inline bool ChoiceData::has_cantrips() const {
  return selection_case() == kCantrips;
}
inline bool ChoiceData::_internal_has_cantrips() const {
  return selection_case() == kCantrips;
}
inline void ChoiceData::set_has_cantrips() {
  _impl_._oneof_case_[0] = kCantrips;
}
inline void ChoiceData::clear_cantrips() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (selection_case() == kCantrips) {
    if (GetArena() == nullptr) {
      delete _impl_.selection_.cantrips_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.selection_.cantrips_);
    }
    clear_has_selection();
  }
}
inline ::dnd5e::api::v1alpha1::CantripList* PROTOBUF_NULLABLE ChoiceData::release_cantrips() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceData.cantrips)
  if (selection_case() == kCantrips) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::CantripList*>(_impl_.selection_.cantrips_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.selection_.cantrips_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::CantripList& ChoiceData::_internal_cantrips() const {
  return selection_case() == kCantrips ? *reinterpret_cast<::dnd5e::api::v1alpha1::CantripList*>(_impl_.selection_.cantrips_) : reinterpret_cast<::dnd5e::api::v1alpha1::CantripList&>(::dnd5e::api::v1alpha1::_CantripList_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CantripList& ChoiceData::cantrips() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceData.cantrips)
  return _internal_cantrips();
}
inline ::dnd5e::api::v1alpha1::CantripList* PROTOBUF_NULLABLE ChoiceData::unsafe_arena_release_cantrips() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.ChoiceData.cantrips)
  if (selection_case() == kCantrips) {
    clear_has_selection();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::CantripList*>(_impl_.selection_.cantrips_);
    _impl_.selection_.cantrips_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChoiceData::unsafe_arena_set_allocated_cantrips(
    ::dnd5e::api::v1alpha1::CantripList* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_selection();
  if (value) {
    set_has_cantrips();
    _impl_.selection_.cantrips_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ChoiceData.cantrips)
}
inline ::dnd5e::api::v1alpha1::CantripList* PROTOBUF_NONNULL ChoiceData::_internal_mutable_cantrips() {
  if (selection_case() != kCantrips) {
    clear_selection();
    set_has_cantrips();
    _impl_.selection_.cantrips_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CantripList>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::CantripList*>(_impl_.selection_.cantrips_);
}
inline ::dnd5e::api::v1alpha1::CantripList* PROTOBUF_NONNULL ChoiceData::mutable_cantrips()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::CantripList* _msg = _internal_mutable_cantrips();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceData.cantrips)
  return _msg;
}

inline bool ChoiceData::has_selection() const {
  return selection_case() != SELECTION_NOT_SET;
}
inline void ChoiceData::clear_has_selection() {
  _impl_._oneof_case_[0] = SELECTION_NOT_SET;
}
inline ChoiceData::SelectionCase ChoiceData::selection_case() const {
  return ChoiceData::SelectionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SkillList

// repeated .dnd5e.api.v1alpha1.Skill skills = 1 [json_name = "skills"];
inline int SkillList::_internal_skills_size() const {
  return _internal_skills().size();
}
inline int SkillList::skills_size() const {
  return _internal_skills_size();
}
inline void SkillList::clear_skills() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skills_.Clear();
}
inline ::dnd5e::api::v1alpha1::Skill SkillList::skills(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SkillList.skills)
  return static_cast<::dnd5e::api::v1alpha1::Skill>(_internal_skills().Get(index));
}
inline void SkillList::set_skills(int index, ::dnd5e::api::v1alpha1::Skill value) {
  _internal_mutable_skills()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SkillList.skills)
}
inline void SkillList::add_skills(::dnd5e::api::v1alpha1::Skill value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_skills()->Add(value);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.SkillList.skills)
}
inline const ::google::protobuf::RepeatedField<int>& SkillList::skills() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.SkillList.skills)
  return _internal_skills();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL SkillList::mutable_skills()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.SkillList.skills)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_skills();
}
inline const ::google::protobuf::RepeatedField<int>& SkillList::_internal_skills()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skills_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
SkillList::_internal_mutable_skills() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.skills_;
}

// -------------------------------------------------------------------

// LanguageList

// repeated .dnd5e.api.v1alpha1.Language languages = 1 [json_name = "languages"];
inline int LanguageList::_internal_languages_size() const {
  return _internal_languages().size();
}
inline int LanguageList::languages_size() const {
  return _internal_languages_size();
}
inline void LanguageList::clear_languages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.languages_.Clear();
}
inline ::dnd5e::api::v1alpha1::Language LanguageList::languages(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.LanguageList.languages)
  return static_cast<::dnd5e::api::v1alpha1::Language>(_internal_languages().Get(index));
}
inline void LanguageList::set_languages(int index, ::dnd5e::api::v1alpha1::Language value) {
  _internal_mutable_languages()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.LanguageList.languages)
}
inline void LanguageList::add_languages(::dnd5e::api::v1alpha1::Language value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_languages()->Add(value);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.LanguageList.languages)
}
inline const ::google::protobuf::RepeatedField<int>& LanguageList::languages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.LanguageList.languages)
  return _internal_languages();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL LanguageList::mutable_languages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.LanguageList.languages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_languages();
}
inline const ::google::protobuf::RepeatedField<int>& LanguageList::_internal_languages()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.languages_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
LanguageList::_internal_mutable_languages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.languages_;
}

// -------------------------------------------------------------------

// EquipmentList

// repeated string items = 1 [json_name = "items"];
inline int EquipmentList::_internal_items_size() const {
  return _internal_items().size();
}
inline int EquipmentList::items_size() const {
  return _internal_items_size();
}
inline void EquipmentList::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL EquipmentList::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.EquipmentList.items)
  return _s;
}
inline const ::std::string& EquipmentList::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipmentList.items)
  return _internal_items().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL EquipmentList::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipmentList.items)
  return _internal_mutable_items()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void EquipmentList::set_items(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_items()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipmentList.items)
}
template <typename Arg_, typename... Args_>
inline void EquipmentList::add_items(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_items(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.EquipmentList.items)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& EquipmentList::items()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.EquipmentList.items)
  return _internal_items();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
EquipmentList::mutable_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.EquipmentList.items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_items();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
EquipmentList::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
EquipmentList::_internal_mutable_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// SpellList

// repeated string spells = 1 [json_name = "spells"];
inline int SpellList::_internal_spells_size() const {
  return _internal_spells().size();
}
inline int SpellList::spells_size() const {
  return _internal_spells_size();
}
inline void SpellList::clear_spells() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spells_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL SpellList::add_spells()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_spells()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.SpellList.spells)
  return _s;
}
inline const ::std::string& SpellList::spells(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellList.spells)
  return _internal_spells().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL SpellList::mutable_spells(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SpellList.spells)
  return _internal_mutable_spells()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SpellList::set_spells(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_spells()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellList.spells)
}
template <typename Arg_, typename... Args_>
inline void SpellList::add_spells(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_spells(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.SpellList.spells)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& SpellList::spells()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.SpellList.spells)
  return _internal_spells();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SpellList::mutable_spells() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.SpellList.spells)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_spells();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SpellList::_internal_spells() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spells_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
SpellList::_internal_mutable_spells() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.spells_;
}

// -------------------------------------------------------------------

// CantripList

// repeated string cantrips = 1 [json_name = "cantrips"];
inline int CantripList::_internal_cantrips_size() const {
  return _internal_cantrips().size();
}
inline int CantripList::cantrips_size() const {
  return _internal_cantrips_size();
}
inline void CantripList::clear_cantrips() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cantrips_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL CantripList::add_cantrips()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_cantrips()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.CantripList.cantrips)
  return _s;
}
inline const ::std::string& CantripList::cantrips(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CantripList.cantrips)
  return _internal_cantrips().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL CantripList::mutable_cantrips(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CantripList.cantrips)
  return _internal_mutable_cantrips()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void CantripList::set_cantrips(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_cantrips()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CantripList.cantrips)
}
template <typename Arg_, typename... Args_>
inline void CantripList::add_cantrips(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_cantrips(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.CantripList.cantrips)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& CantripList::cantrips()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.CantripList.cantrips)
  return _internal_cantrips();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
CantripList::mutable_cantrips() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.CantripList.cantrips)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cantrips();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
CantripList::_internal_cantrips() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cantrips_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
CantripList::_internal_mutable_cantrips() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cantrips_;
}

// -------------------------------------------------------------------

// RaceChoice

// .dnd5e.api.v1alpha1.Race race = 1 [json_name = "race"];
inline void RaceChoice::clear_race() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.race_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::dnd5e::api::v1alpha1::Race RaceChoice::race() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceChoice.race)
  return _internal_race();
}
inline void RaceChoice::set_race(::dnd5e::api::v1alpha1::Race value) {
  _internal_set_race(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RaceChoice.race)
}
inline ::dnd5e::api::v1alpha1::Race RaceChoice::_internal_race() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Race>(_impl_.race_);
}
inline void RaceChoice::_internal_set_race(::dnd5e::api::v1alpha1::Race value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.race_ = value;
}

// .dnd5e.api.v1alpha1.Subrace subrace = 2 [json_name = "subrace"];
inline void RaceChoice::clear_subrace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subrace_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::dnd5e::api::v1alpha1::Subrace RaceChoice::subrace() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RaceChoice.subrace)
  return _internal_subrace();
}
inline void RaceChoice::set_subrace(::dnd5e::api::v1alpha1::Subrace value) {
  _internal_set_subrace(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RaceChoice.subrace)
}
inline ::dnd5e::api::v1alpha1::Subrace RaceChoice::_internal_subrace() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Subrace>(_impl_.subrace_);
}
inline void RaceChoice::_internal_set_subrace(::dnd5e::api::v1alpha1::Subrace value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subrace_ = value;
}

// -------------------------------------------------------------------

// ClassChoice

// .dnd5e.api.v1alpha1.Class class = 1 [json_name = "class"];
inline void ClassChoice::clear_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::dnd5e::api::v1alpha1::Class ClassChoice::class_() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ClassChoice.class)
  return _internal_class_();
}
inline void ClassChoice::set_class_(::dnd5e::api::v1alpha1::Class value) {
  _internal_set_class_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ClassChoice.class)
}
inline ::dnd5e::api::v1alpha1::Class ClassChoice::_internal_class_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Class>(_impl_.class__);
}
inline void ClassChoice::_internal_set_class_(::dnd5e::api::v1alpha1::Class value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class__ = value;
}

// -------------------------------------------------------------------

// ChoiceSelection

// string choice_id = 1 [json_name = "choiceId"];
inline void ChoiceSelection::clear_choice_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choice_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ChoiceSelection::choice_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSelection.choice_id)
  return _internal_choice_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ChoiceSelection::set_choice_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.choice_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceSelection.choice_id)
}
inline ::std::string* PROTOBUF_NONNULL ChoiceSelection::mutable_choice_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_choice_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSelection.choice_id)
  return _s;
}
inline const ::std::string& ChoiceSelection::_internal_choice_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.choice_id_.Get();
}
inline void ChoiceSelection::_internal_set_choice_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.choice_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ChoiceSelection::_internal_mutable_choice_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.choice_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ChoiceSelection::release_choice_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ChoiceSelection.choice_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.choice_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.choice_id_.Set("", GetArena());
  }
  return released;
}
inline void ChoiceSelection::set_allocated_choice_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.choice_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.choice_id_.IsDefault()) {
    _impl_.choice_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ChoiceSelection.choice_id)
}

// .dnd5e.api.v1alpha1.ChoiceCategory choice_type = 2 [json_name = "choiceType"];
inline void ChoiceSelection::clear_choice_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choice_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::dnd5e::api::v1alpha1::ChoiceCategory ChoiceSelection::choice_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSelection.choice_type)
  return _internal_choice_type();
}
inline void ChoiceSelection::set_choice_type(::dnd5e::api::v1alpha1::ChoiceCategory value) {
  _internal_set_choice_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceSelection.choice_type)
}
inline ::dnd5e::api::v1alpha1::ChoiceCategory ChoiceSelection::_internal_choice_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::ChoiceCategory>(_impl_.choice_type_);
}
inline void ChoiceSelection::_internal_set_choice_type(::dnd5e::api::v1alpha1::ChoiceCategory value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.choice_type_ = value;
}

// .dnd5e.api.v1alpha1.ChoiceSource source = 3 [json_name = "source"];
inline void ChoiceSelection::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::dnd5e::api::v1alpha1::ChoiceSource ChoiceSelection::source() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSelection.source)
  return _internal_source();
}
inline void ChoiceSelection::set_source(::dnd5e::api::v1alpha1::ChoiceSource value) {
  _internal_set_source(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceSelection.source)
}
inline ::dnd5e::api::v1alpha1::ChoiceSource ChoiceSelection::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::ChoiceSource>(_impl_.source_);
}
inline void ChoiceSelection::_internal_set_source(::dnd5e::api::v1alpha1::ChoiceSource value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = value;
}

// repeated string selected_keys = 4 [json_name = "selectedKeys"];
inline int ChoiceSelection::_internal_selected_keys_size() const {
  return _internal_selected_keys().size();
}
inline int ChoiceSelection::selected_keys_size() const {
  return _internal_selected_keys_size();
}
inline void ChoiceSelection::clear_selected_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.selected_keys_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL ChoiceSelection::add_selected_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_selected_keys()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.ChoiceSelection.selected_keys)
  return _s;
}
inline const ::std::string& ChoiceSelection::selected_keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSelection.selected_keys)
  return _internal_selected_keys().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL ChoiceSelection::mutable_selected_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSelection.selected_keys)
  return _internal_mutable_selected_keys()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ChoiceSelection::set_selected_keys(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_selected_keys()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ChoiceSelection.selected_keys)
}
template <typename Arg_, typename... Args_>
inline void ChoiceSelection::add_selected_keys(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_selected_keys(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ChoiceSelection.selected_keys)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& ChoiceSelection::selected_keys()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ChoiceSelection.selected_keys)
  return _internal_selected_keys();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ChoiceSelection::mutable_selected_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ChoiceSelection.selected_keys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_selected_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ChoiceSelection::_internal_selected_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.selected_keys_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
ChoiceSelection::_internal_mutable_selected_keys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.selected_keys_;
}

// repeated .dnd5e.api.v1alpha1.AbilityScoreChoice ability_score_choices = 5 [json_name = "abilityScoreChoices"];
inline int ChoiceSelection::_internal_ability_score_choices_size() const {
  return _internal_ability_score_choices().size();
}
inline int ChoiceSelection::ability_score_choices_size() const {
  return _internal_ability_score_choices_size();
}
inline void ChoiceSelection::clear_ability_score_choices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ability_score_choices_.Clear();
}
inline ::dnd5e::api::v1alpha1::AbilityScoreChoice* PROTOBUF_NONNULL ChoiceSelection::mutable_ability_score_choices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ChoiceSelection.ability_score_choices)
  return _internal_mutable_ability_score_choices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreChoice>* PROTOBUF_NONNULL ChoiceSelection::mutable_ability_score_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ChoiceSelection.ability_score_choices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ability_score_choices();
}
inline const ::dnd5e::api::v1alpha1::AbilityScoreChoice& ChoiceSelection::ability_score_choices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ChoiceSelection.ability_score_choices)
  return _internal_ability_score_choices().Get(index);
}
inline ::dnd5e::api::v1alpha1::AbilityScoreChoice* PROTOBUF_NONNULL ChoiceSelection::add_ability_score_choices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::AbilityScoreChoice* _add = _internal_mutable_ability_score_choices()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ChoiceSelection.ability_score_choices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreChoice>& ChoiceSelection::ability_score_choices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ChoiceSelection.ability_score_choices)
  return _internal_ability_score_choices();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreChoice>&
ChoiceSelection::_internal_ability_score_choices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ability_score_choices_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::AbilityScoreChoice>* PROTOBUF_NONNULL
ChoiceSelection::_internal_mutable_ability_score_choices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ability_score_choices_;
}

// -------------------------------------------------------------------

// AbilityScoreChoice

// .dnd5e.api.v1alpha1.Ability ability = 1 [json_name = "ability"];
inline void AbilityScoreChoice::clear_ability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::dnd5e::api::v1alpha1::Ability AbilityScoreChoice::ability() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScoreChoice.ability)
  return _internal_ability();
}
inline void AbilityScoreChoice::set_ability(::dnd5e::api::v1alpha1::Ability value) {
  _internal_set_ability(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScoreChoice.ability)
}
inline ::dnd5e::api::v1alpha1::Ability AbilityScoreChoice::_internal_ability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Ability>(_impl_.ability_);
}
inline void AbilityScoreChoice::_internal_set_ability(::dnd5e::api::v1alpha1::Ability value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ability_ = value;
}

// int32 bonus = 2 [json_name = "bonus"];
inline void AbilityScoreChoice::clear_bonus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonus_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AbilityScoreChoice::bonus() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AbilityScoreChoice.bonus)
  return _internal_bonus();
}
inline void AbilityScoreChoice::set_bonus(::int32_t value) {
  _internal_set_bonus(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AbilityScoreChoice.bonus)
}
inline ::int32_t AbilityScoreChoice::_internal_bonus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bonus_;
}
inline void AbilityScoreChoice::_internal_set_bonus(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonus_ = value;
}

// -------------------------------------------------------------------

// SpellDamage

// string damage_type = 1 [json_name = "damageType"];
inline void SpellDamage::clear_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SpellDamage::damage_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellDamage.damage_type)
  return _internal_damage_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SpellDamage::set_damage_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.damage_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SpellDamage.damage_type)
}
inline ::std::string* PROTOBUF_NONNULL SpellDamage::mutable_damage_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_damage_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SpellDamage.damage_type)
  return _s;
}
inline const ::std::string& SpellDamage::_internal_damage_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_type_.Get();
}
inline void SpellDamage::_internal_set_damage_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.damage_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SpellDamage::_internal_mutable_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.damage_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SpellDamage::release_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.SpellDamage.damage_type)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.damage_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  return released;
}
inline void SpellDamage::set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.damage_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.damage_type_.IsDefault()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.SpellDamage.damage_type)
}

// repeated .dnd5e.api.v1alpha1.DamageAtSlotLevel damage_at_slot_level = 2 [json_name = "damageAtSlotLevel"];
inline int SpellDamage::_internal_damage_at_slot_level_size() const {
  return _internal_damage_at_slot_level().size();
}
inline int SpellDamage::damage_at_slot_level_size() const {
  return _internal_damage_at_slot_level_size();
}
inline void SpellDamage::clear_damage_at_slot_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_at_slot_level_.Clear();
}
inline ::dnd5e::api::v1alpha1::DamageAtSlotLevel* PROTOBUF_NONNULL SpellDamage::mutable_damage_at_slot_level(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SpellDamage.damage_at_slot_level)
  return _internal_mutable_damage_at_slot_level()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageAtSlotLevel>* PROTOBUF_NONNULL SpellDamage::mutable_damage_at_slot_level()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.SpellDamage.damage_at_slot_level)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_damage_at_slot_level();
}
inline const ::dnd5e::api::v1alpha1::DamageAtSlotLevel& SpellDamage::damage_at_slot_level(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SpellDamage.damage_at_slot_level)
  return _internal_damage_at_slot_level().Get(index);
}
inline ::dnd5e::api::v1alpha1::DamageAtSlotLevel* PROTOBUF_NONNULL SpellDamage::add_damage_at_slot_level()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::DamageAtSlotLevel* _add = _internal_mutable_damage_at_slot_level()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.SpellDamage.damage_at_slot_level)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageAtSlotLevel>& SpellDamage::damage_at_slot_level() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.SpellDamage.damage_at_slot_level)
  return _internal_damage_at_slot_level();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageAtSlotLevel>&
SpellDamage::_internal_damage_at_slot_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_at_slot_level_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageAtSlotLevel>* PROTOBUF_NONNULL
SpellDamage::_internal_mutable_damage_at_slot_level() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.damage_at_slot_level_;
}

// -------------------------------------------------------------------

// DamageAtSlotLevel

// int32 slot_level = 1 [json_name = "slotLevel"];
inline void DamageAtSlotLevel::clear_slot_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t DamageAtSlotLevel::slot_level() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageAtSlotLevel.slot_level)
  return _internal_slot_level();
}
inline void DamageAtSlotLevel::set_slot_level(::int32_t value) {
  _internal_set_slot_level(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageAtSlotLevel.slot_level)
}
inline ::int32_t DamageAtSlotLevel::_internal_slot_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_level_;
}
inline void DamageAtSlotLevel::_internal_set_slot_level(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_level_ = value;
}

// string damage_dice = 2 [json_name = "damageDice"];
inline void DamageAtSlotLevel::clear_damage_dice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_dice_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DamageAtSlotLevel::damage_dice() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageAtSlotLevel.damage_dice)
  return _internal_damage_dice();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DamageAtSlotLevel::set_damage_dice(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.damage_dice_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageAtSlotLevel.damage_dice)
}
inline ::std::string* PROTOBUF_NONNULL DamageAtSlotLevel::mutable_damage_dice()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_damage_dice();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageAtSlotLevel.damage_dice)
  return _s;
}
inline const ::std::string& DamageAtSlotLevel::_internal_damage_dice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_dice_.Get();
}
inline void DamageAtSlotLevel::_internal_set_damage_dice(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.damage_dice_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DamageAtSlotLevel::_internal_mutable_damage_dice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.damage_dice_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DamageAtSlotLevel::release_damage_dice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DamageAtSlotLevel.damage_dice)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.damage_dice_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.damage_dice_.Set("", GetArena());
  }
  return released;
}
inline void DamageAtSlotLevel::set_allocated_damage_dice(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.damage_dice_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.damage_dice_.IsDefault()) {
    _impl_.damage_dice_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DamageAtSlotLevel.damage_dice)
}

// -------------------------------------------------------------------

// AreaOfEffect

// string type = 1 [json_name = "type"];
inline void AreaOfEffect::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& AreaOfEffect::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AreaOfEffect.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AreaOfEffect::set_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AreaOfEffect.type)
}
inline ::std::string* PROTOBUF_NONNULL AreaOfEffect::mutable_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AreaOfEffect.type)
  return _s;
}
inline const ::std::string& AreaOfEffect::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void AreaOfEffect::_internal_set_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AreaOfEffect::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AreaOfEffect::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AreaOfEffect.type)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.type_.Set("", GetArena());
  }
  return released;
}
inline void AreaOfEffect::set_allocated_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AreaOfEffect.type)
}

// int32 size = 2 [json_name = "size"];
inline void AreaOfEffect::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AreaOfEffect::size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AreaOfEffect.size)
  return _internal_size();
}
inline void AreaOfEffect::set_size(::int32_t value) {
  _internal_set_size(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AreaOfEffect.size)
}
inline ::int32_t AreaOfEffect::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void AreaOfEffect::_internal_set_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// ListEquipmentByTypeRequest

// .dnd5e.api.v1alpha1.EquipmentType equipment_type = 1 [json_name = "equipmentType"];
inline void ListEquipmentByTypeRequest::clear_equipment_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.equipment_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::dnd5e::api::v1alpha1::EquipmentType ListEquipmentByTypeRequest::equipment_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListEquipmentByTypeRequest.equipment_type)
  return _internal_equipment_type();
}
inline void ListEquipmentByTypeRequest::set_equipment_type(::dnd5e::api::v1alpha1::EquipmentType value) {
  _internal_set_equipment_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListEquipmentByTypeRequest.equipment_type)
}
inline ::dnd5e::api::v1alpha1::EquipmentType ListEquipmentByTypeRequest::_internal_equipment_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::EquipmentType>(_impl_.equipment_type_);
}
inline void ListEquipmentByTypeRequest::_internal_set_equipment_type(::dnd5e::api::v1alpha1::EquipmentType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.equipment_type_ = value;
}

// int32 page_size = 2 [json_name = "pageSize"];
inline void ListEquipmentByTypeRequest::clear_page_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t ListEquipmentByTypeRequest::page_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListEquipmentByTypeRequest.page_size)
  return _internal_page_size();
}
inline void ListEquipmentByTypeRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListEquipmentByTypeRequest.page_size)
}
inline ::int32_t ListEquipmentByTypeRequest::_internal_page_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_size_;
}
inline void ListEquipmentByTypeRequest::_internal_set_page_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = value;
}

// string page_token = 3 [json_name = "pageToken"];
inline void ListEquipmentByTypeRequest::clear_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListEquipmentByTypeRequest::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListEquipmentByTypeRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListEquipmentByTypeRequest::set_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListEquipmentByTypeRequest.page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListEquipmentByTypeRequest::mutable_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListEquipmentByTypeRequest.page_token)
  return _s;
}
inline const ::std::string& ListEquipmentByTypeRequest::_internal_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_token_.Get();
}
inline void ListEquipmentByTypeRequest::_internal_set_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListEquipmentByTypeRequest::_internal_mutable_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListEquipmentByTypeRequest::release_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListEquipmentByTypeRequest.page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListEquipmentByTypeRequest::set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListEquipmentByTypeRequest.page_token)
}

// -------------------------------------------------------------------

// ListEquipmentByTypeResponse

// repeated .dnd5e.api.v1alpha1.Equipment equipment = 1 [json_name = "equipment"];
inline int ListEquipmentByTypeResponse::_internal_equipment_size() const {
  return _internal_equipment().size();
}
inline int ListEquipmentByTypeResponse::equipment_size() const {
  return _internal_equipment_size();
}
inline void ListEquipmentByTypeResponse::clear_equipment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.equipment_.Clear();
}
inline ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NONNULL ListEquipmentByTypeResponse::mutable_equipment(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse.equipment)
  return _internal_mutable_equipment()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Equipment>* PROTOBUF_NONNULL ListEquipmentByTypeResponse::mutable_equipment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse.equipment)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_equipment();
}
inline const ::dnd5e::api::v1alpha1::Equipment& ListEquipmentByTypeResponse::equipment(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse.equipment)
  return _internal_equipment().Get(index);
}
inline ::dnd5e::api::v1alpha1::Equipment* PROTOBUF_NONNULL ListEquipmentByTypeResponse::add_equipment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::Equipment* _add = _internal_mutable_equipment()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse.equipment)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Equipment>& ListEquipmentByTypeResponse::equipment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse.equipment)
  return _internal_equipment();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Equipment>&
ListEquipmentByTypeResponse::_internal_equipment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.equipment_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Equipment>* PROTOBUF_NONNULL
ListEquipmentByTypeResponse::_internal_mutable_equipment() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.equipment_;
}

// string next_page_token = 2 [json_name = "nextPageToken"];
inline void ListEquipmentByTypeResponse::clear_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListEquipmentByTypeResponse::next_page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListEquipmentByTypeResponse::set_next_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse.next_page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListEquipmentByTypeResponse::mutable_next_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse.next_page_token)
  return _s;
}
inline const ::std::string& ListEquipmentByTypeResponse::_internal_next_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_page_token_.Get();
}
inline void ListEquipmentByTypeResponse::_internal_set_next_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListEquipmentByTypeResponse::_internal_mutable_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.next_page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListEquipmentByTypeResponse::release_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse.next_page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.next_page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListEquipmentByTypeResponse::set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.next_page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse.next_page_token)
}

// int32 total_size = 3 [json_name = "totalSize"];
inline void ListEquipmentByTypeResponse::clear_total_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ListEquipmentByTypeResponse::total_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse.total_size)
  return _internal_total_size();
}
inline void ListEquipmentByTypeResponse::set_total_size(::int32_t value) {
  _internal_set_total_size(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListEquipmentByTypeResponse.total_size)
}
inline ::int32_t ListEquipmentByTypeResponse::_internal_total_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_size_;
}
inline void ListEquipmentByTypeResponse::_internal_set_total_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = value;
}

// -------------------------------------------------------------------

// ListSpellsByLevelRequest

// int32 level = 1 [json_name = "level"];
inline void ListSpellsByLevelRequest::clear_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ListSpellsByLevelRequest::level() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListSpellsByLevelRequest.level)
  return _internal_level();
}
inline void ListSpellsByLevelRequest::set_level(::int32_t value) {
  _internal_set_level(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListSpellsByLevelRequest.level)
}
inline ::int32_t ListSpellsByLevelRequest::_internal_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_;
}
inline void ListSpellsByLevelRequest::_internal_set_level(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_ = value;
}

// .dnd5e.api.v1alpha1.Class class = 2 [json_name = "class"];
inline void ListSpellsByLevelRequest::clear_class_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class__ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::dnd5e::api::v1alpha1::Class ListSpellsByLevelRequest::class_() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListSpellsByLevelRequest.class)
  return _internal_class_();
}
inline void ListSpellsByLevelRequest::set_class_(::dnd5e::api::v1alpha1::Class value) {
  _internal_set_class_(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListSpellsByLevelRequest.class)
}
inline ::dnd5e::api::v1alpha1::Class ListSpellsByLevelRequest::_internal_class_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::Class>(_impl_.class__);
}
inline void ListSpellsByLevelRequest::_internal_set_class_(::dnd5e::api::v1alpha1::Class value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.class__ = value;
}

// int32 page_size = 3 [json_name = "pageSize"];
inline void ListSpellsByLevelRequest::clear_page_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t ListSpellsByLevelRequest::page_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListSpellsByLevelRequest.page_size)
  return _internal_page_size();
}
inline void ListSpellsByLevelRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListSpellsByLevelRequest.page_size)
}
inline ::int32_t ListSpellsByLevelRequest::_internal_page_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_size_;
}
inline void ListSpellsByLevelRequest::_internal_set_page_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = value;
}

// string page_token = 4 [json_name = "pageToken"];
inline void ListSpellsByLevelRequest::clear_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListSpellsByLevelRequest::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListSpellsByLevelRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListSpellsByLevelRequest::set_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListSpellsByLevelRequest.page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListSpellsByLevelRequest::mutable_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListSpellsByLevelRequest.page_token)
  return _s;
}
inline const ::std::string& ListSpellsByLevelRequest::_internal_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_token_.Get();
}
inline void ListSpellsByLevelRequest::_internal_set_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListSpellsByLevelRequest::_internal_mutable_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListSpellsByLevelRequest::release_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListSpellsByLevelRequest.page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListSpellsByLevelRequest::set_allocated_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListSpellsByLevelRequest.page_token)
}

// -------------------------------------------------------------------

// ListSpellsByLevelResponse

// repeated .dnd5e.api.v1alpha1.Spell spells = 1 [json_name = "spells"];
inline int ListSpellsByLevelResponse::_internal_spells_size() const {
  return _internal_spells().size();
}
inline int ListSpellsByLevelResponse::spells_size() const {
  return _internal_spells_size();
}
inline void ListSpellsByLevelResponse::clear_spells() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spells_.Clear();
}
inline ::dnd5e::api::v1alpha1::Spell* PROTOBUF_NONNULL ListSpellsByLevelResponse::mutable_spells(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListSpellsByLevelResponse.spells)
  return _internal_mutable_spells()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Spell>* PROTOBUF_NONNULL ListSpellsByLevelResponse::mutable_spells()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.ListSpellsByLevelResponse.spells)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_spells();
}
inline const ::dnd5e::api::v1alpha1::Spell& ListSpellsByLevelResponse::spells(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListSpellsByLevelResponse.spells)
  return _internal_spells().Get(index);
}
inline ::dnd5e::api::v1alpha1::Spell* PROTOBUF_NONNULL ListSpellsByLevelResponse::add_spells()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::Spell* _add = _internal_mutable_spells()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.ListSpellsByLevelResponse.spells)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Spell>& ListSpellsByLevelResponse::spells() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.ListSpellsByLevelResponse.spells)
  return _internal_spells();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Spell>&
ListSpellsByLevelResponse::_internal_spells() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spells_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Spell>* PROTOBUF_NONNULL
ListSpellsByLevelResponse::_internal_mutable_spells() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.spells_;
}

// string next_page_token = 2 [json_name = "nextPageToken"];
inline void ListSpellsByLevelResponse::clear_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ListSpellsByLevelResponse::next_page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListSpellsByLevelResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListSpellsByLevelResponse::set_next_page_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListSpellsByLevelResponse.next_page_token)
}
inline ::std::string* PROTOBUF_NONNULL ListSpellsByLevelResponse::mutable_next_page_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ListSpellsByLevelResponse.next_page_token)
  return _s;
}
inline const ::std::string& ListSpellsByLevelResponse::_internal_next_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_page_token_.Get();
}
inline void ListSpellsByLevelResponse::_internal_set_next_page_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_page_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ListSpellsByLevelResponse::_internal_mutable_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.next_page_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ListSpellsByLevelResponse::release_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ListSpellsByLevelResponse.next_page_token)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.next_page_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  return released;
}
inline void ListSpellsByLevelResponse::set_allocated_next_page_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.next_page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ListSpellsByLevelResponse.next_page_token)
}

// int32 total_size = 3 [json_name = "totalSize"];
inline void ListSpellsByLevelResponse::clear_total_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ListSpellsByLevelResponse::total_size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ListSpellsByLevelResponse.total_size)
  return _internal_total_size();
}
inline void ListSpellsByLevelResponse::set_total_size(::int32_t value) {
  _internal_set_total_size(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ListSpellsByLevelResponse.total_size)
}
inline ::int32_t ListSpellsByLevelResponse::_internal_total_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_size_;
}
inline void ListSpellsByLevelResponse::_internal_set_total_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = value;
}

// -------------------------------------------------------------------

// GetCharacterInventoryRequest

// string character_id = 1 [json_name = "characterId"];
inline void GetCharacterInventoryRequest::clear_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetCharacterInventoryRequest::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCharacterInventoryRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetCharacterInventoryRequest::set_character_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetCharacterInventoryRequest.character_id)
}
inline ::std::string* PROTOBUF_NONNULL GetCharacterInventoryRequest::mutable_character_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCharacterInventoryRequest.character_id)
  return _s;
}
inline const ::std::string& GetCharacterInventoryRequest::_internal_character_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_id_.Get();
}
inline void GetCharacterInventoryRequest::_internal_set_character_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetCharacterInventoryRequest::_internal_mutable_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.character_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetCharacterInventoryRequest::release_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCharacterInventoryRequest.character_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.character_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.character_id_.Set("", GetArena());
  }
  return released;
}
inline void GetCharacterInventoryRequest::set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.character_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCharacterInventoryRequest.character_id)
}

// -------------------------------------------------------------------

// GetCharacterInventoryResponse

// .dnd5e.api.v1alpha1.EquipmentSlots equipment_slots = 1 [json_name = "equipmentSlots"];
inline bool GetCharacterInventoryResponse::has_equipment_slots() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.equipment_slots_ != nullptr);
  return value;
}
inline void GetCharacterInventoryResponse::clear_equipment_slots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.equipment_slots_ != nullptr) _impl_.equipment_slots_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::EquipmentSlots& GetCharacterInventoryResponse::_internal_equipment_slots() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::EquipmentSlots* p = _impl_.equipment_slots_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::EquipmentSlots&>(::dnd5e::api::v1alpha1::_EquipmentSlots_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::EquipmentSlots& GetCharacterInventoryResponse::equipment_slots() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.equipment_slots)
  return _internal_equipment_slots();
}
inline void GetCharacterInventoryResponse::unsafe_arena_set_allocated_equipment_slots(
    ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.equipment_slots_);
  }
  _impl_.equipment_slots_ = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSlots*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.equipment_slots)
}
inline ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE GetCharacterInventoryResponse::release_equipment_slots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::EquipmentSlots* released = _impl_.equipment_slots_;
  _impl_.equipment_slots_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE GetCharacterInventoryResponse::unsafe_arena_release_equipment_slots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.equipment_slots)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::EquipmentSlots* temp = _impl_.equipment_slots_;
  _impl_.equipment_slots_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NONNULL GetCharacterInventoryResponse::_internal_mutable_equipment_slots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.equipment_slots_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::EquipmentSlots>(GetArena());
    _impl_.equipment_slots_ = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSlots*>(p);
  }
  return _impl_.equipment_slots_;
}
inline ::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NONNULL GetCharacterInventoryResponse::mutable_equipment_slots()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::EquipmentSlots* _msg = _internal_mutable_equipment_slots();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.equipment_slots)
  return _msg;
}
inline void GetCharacterInventoryResponse::set_allocated_equipment_slots(::dnd5e::api::v1alpha1::EquipmentSlots* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.equipment_slots_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.equipment_slots_ = reinterpret_cast<::dnd5e::api::v1alpha1::EquipmentSlots*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.equipment_slots)
}

// repeated .dnd5e.api.v1alpha1.InventoryItem inventory = 2 [json_name = "inventory"];
inline int GetCharacterInventoryResponse::_internal_inventory_size() const {
  return _internal_inventory().size();
}
inline int GetCharacterInventoryResponse::inventory_size() const {
  return _internal_inventory_size();
}
inline void GetCharacterInventoryResponse::clear_inventory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inventory_.Clear();
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL GetCharacterInventoryResponse::mutable_inventory(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.inventory)
  return _internal_mutable_inventory()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>* PROTOBUF_NONNULL GetCharacterInventoryResponse::mutable_inventory()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.inventory)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inventory();
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& GetCharacterInventoryResponse::inventory(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.inventory)
  return _internal_inventory().Get(index);
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL GetCharacterInventoryResponse::add_inventory()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::InventoryItem* _add = _internal_mutable_inventory()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.inventory)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>& GetCharacterInventoryResponse::inventory() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.inventory)
  return _internal_inventory();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>&
GetCharacterInventoryResponse::_internal_inventory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inventory_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryItem>* PROTOBUF_NONNULL
GetCharacterInventoryResponse::_internal_mutable_inventory() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inventory_;
}

// .dnd5e.api.v1alpha1.EncumbranceInfo encumbrance = 3 [json_name = "encumbrance"];
inline bool GetCharacterInventoryResponse::has_encumbrance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.encumbrance_ != nullptr);
  return value;
}
inline void GetCharacterInventoryResponse::clear_encumbrance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.encumbrance_ != nullptr) _impl_.encumbrance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dnd5e::api::v1alpha1::EncumbranceInfo& GetCharacterInventoryResponse::_internal_encumbrance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::EncumbranceInfo* p = _impl_.encumbrance_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::EncumbranceInfo&>(::dnd5e::api::v1alpha1::_EncumbranceInfo_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::EncumbranceInfo& GetCharacterInventoryResponse::encumbrance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.encumbrance)
  return _internal_encumbrance();
}
inline void GetCharacterInventoryResponse::unsafe_arena_set_allocated_encumbrance(
    ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.encumbrance_);
  }
  _impl_.encumbrance_ = reinterpret_cast<::dnd5e::api::v1alpha1::EncumbranceInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.encumbrance)
}
inline ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE GetCharacterInventoryResponse::release_encumbrance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::EncumbranceInfo* released = _impl_.encumbrance_;
  _impl_.encumbrance_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE GetCharacterInventoryResponse::unsafe_arena_release_encumbrance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.encumbrance)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::EncumbranceInfo* temp = _impl_.encumbrance_;
  _impl_.encumbrance_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NONNULL GetCharacterInventoryResponse::_internal_mutable_encumbrance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.encumbrance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::EncumbranceInfo>(GetArena());
    _impl_.encumbrance_ = reinterpret_cast<::dnd5e::api::v1alpha1::EncumbranceInfo*>(p);
  }
  return _impl_.encumbrance_;
}
inline ::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NONNULL GetCharacterInventoryResponse::mutable_encumbrance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::dnd5e::api::v1alpha1::EncumbranceInfo* _msg = _internal_mutable_encumbrance();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.encumbrance)
  return _msg;
}
inline void GetCharacterInventoryResponse::set_allocated_encumbrance(::dnd5e::api::v1alpha1::EncumbranceInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.encumbrance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.encumbrance_ = reinterpret_cast<::dnd5e::api::v1alpha1::EncumbranceInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.encumbrance)
}

// int32 attunement_slots_used = 4 [json_name = "attunementSlotsUsed"];
inline void GetCharacterInventoryResponse::clear_attunement_slots_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attunement_slots_used_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t GetCharacterInventoryResponse::attunement_slots_used() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.attunement_slots_used)
  return _internal_attunement_slots_used();
}
inline void GetCharacterInventoryResponse::set_attunement_slots_used(::int32_t value) {
  _internal_set_attunement_slots_used(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.attunement_slots_used)
}
inline ::int32_t GetCharacterInventoryResponse::_internal_attunement_slots_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attunement_slots_used_;
}
inline void GetCharacterInventoryResponse::_internal_set_attunement_slots_used(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attunement_slots_used_ = value;
}

// int32 attunement_slots_max = 5 [json_name = "attunementSlotsMax"];
inline void GetCharacterInventoryResponse::clear_attunement_slots_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attunement_slots_max_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t GetCharacterInventoryResponse::attunement_slots_max() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.attunement_slots_max)
  return _internal_attunement_slots_max();
}
inline void GetCharacterInventoryResponse::set_attunement_slots_max(::int32_t value) {
  _internal_set_attunement_slots_max(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetCharacterInventoryResponse.attunement_slots_max)
}
inline ::int32_t GetCharacterInventoryResponse::_internal_attunement_slots_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attunement_slots_max_;
}
inline void GetCharacterInventoryResponse::_internal_set_attunement_slots_max(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attunement_slots_max_ = value;
}

// -------------------------------------------------------------------

// EquipItemRequest

// string character_id = 1 [json_name = "characterId"];
inline void EquipItemRequest::clear_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EquipItemRequest::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipItemRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EquipItemRequest::set_character_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipItemRequest.character_id)
}
inline ::std::string* PROTOBUF_NONNULL EquipItemRequest::mutable_character_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipItemRequest.character_id)
  return _s;
}
inline const ::std::string& EquipItemRequest::_internal_character_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_id_.Get();
}
inline void EquipItemRequest::_internal_set_character_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EquipItemRequest::_internal_mutable_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.character_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EquipItemRequest::release_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipItemRequest.character_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.character_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.character_id_.Set("", GetArena());
  }
  return released;
}
inline void EquipItemRequest::set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.character_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipItemRequest.character_id)
}

// string item_id = 2 [json_name = "itemId"];
inline void EquipItemRequest::clear_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.item_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& EquipItemRequest::item_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipItemRequest.item_id)
  return _internal_item_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EquipItemRequest::set_item_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.item_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipItemRequest.item_id)
}
inline ::std::string* PROTOBUF_NONNULL EquipItemRequest::mutable_item_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipItemRequest.item_id)
  return _s;
}
inline const ::std::string& EquipItemRequest::_internal_item_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.item_id_.Get();
}
inline void EquipItemRequest::_internal_set_item_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.item_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EquipItemRequest::_internal_mutable_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.item_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EquipItemRequest::release_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipItemRequest.item_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.item_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.item_id_.Set("", GetArena());
  }
  return released;
}
inline void EquipItemRequest::set_allocated_item_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.item_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipItemRequest.item_id)
}

// .dnd5e.api.v1alpha1.EquipmentSlot slot = 3 [json_name = "slot"];
inline void EquipItemRequest::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::dnd5e::api::v1alpha1::EquipmentSlot EquipItemRequest::slot() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipItemRequest.slot)
  return _internal_slot();
}
inline void EquipItemRequest::set_slot(::dnd5e::api::v1alpha1::EquipmentSlot value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EquipItemRequest.slot)
}
inline ::dnd5e::api::v1alpha1::EquipmentSlot EquipItemRequest::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::EquipmentSlot>(_impl_.slot_);
}
inline void EquipItemRequest::_internal_set_slot(::dnd5e::api::v1alpha1::EquipmentSlot value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// -------------------------------------------------------------------

// EquipItemResponse

// .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
inline bool EquipItemResponse::has_character() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.character_ != nullptr);
  return value;
}
inline void EquipItemResponse::clear_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ != nullptr) _impl_.character_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::Character& EquipItemResponse::_internal_character() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.character_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& EquipItemResponse::character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipItemResponse.character)
  return _internal_character();
}
inline void EquipItemResponse::unsafe_arena_set_allocated_character(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }
  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipItemResponse.character)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE EquipItemResponse::release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* released = _impl_.character_;
  _impl_.character_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE EquipItemResponse::unsafe_arena_release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipItemResponse.character)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.character_;
  _impl_.character_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL EquipItemResponse::_internal_mutable_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.character_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL EquipItemResponse::mutable_character()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipItemResponse.character)
  return _msg;
}
inline void EquipItemResponse::set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipItemResponse.character)
}

// .dnd5e.api.v1alpha1.InventoryItem previously_equipped_item = 2 [json_name = "previouslyEquippedItem"];
inline bool EquipItemResponse::has_previously_equipped_item() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.previously_equipped_item_ != nullptr);
  return value;
}
inline void EquipItemResponse::clear_previously_equipped_item() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.previously_equipped_item_ != nullptr) _impl_.previously_equipped_item_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipItemResponse::_internal_previously_equipped_item() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::InventoryItem* p = _impl_.previously_equipped_item_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::InventoryItem&>(::dnd5e::api::v1alpha1::_InventoryItem_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::InventoryItem& EquipItemResponse::previously_equipped_item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EquipItemResponse.previously_equipped_item)
  return _internal_previously_equipped_item();
}
inline void EquipItemResponse::unsafe_arena_set_allocated_previously_equipped_item(
    ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.previously_equipped_item_);
  }
  _impl_.previously_equipped_item_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EquipItemResponse.previously_equipped_item)
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipItemResponse::release_previously_equipped_item() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::InventoryItem* released = _impl_.previously_equipped_item_;
  _impl_.previously_equipped_item_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE EquipItemResponse::unsafe_arena_release_previously_equipped_item() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EquipItemResponse.previously_equipped_item)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::dnd5e::api::v1alpha1::InventoryItem* temp = _impl_.previously_equipped_item_;
  _impl_.previously_equipped_item_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipItemResponse::_internal_mutable_previously_equipped_item() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.previously_equipped_item_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::InventoryItem>(GetArena());
    _impl_.previously_equipped_item_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(p);
  }
  return _impl_.previously_equipped_item_;
}
inline ::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NONNULL EquipItemResponse::mutable_previously_equipped_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::dnd5e::api::v1alpha1::InventoryItem* _msg = _internal_mutable_previously_equipped_item();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EquipItemResponse.previously_equipped_item)
  return _msg;
}
inline void EquipItemResponse::set_allocated_previously_equipped_item(::dnd5e::api::v1alpha1::InventoryItem* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.previously_equipped_item_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.previously_equipped_item_ = reinterpret_cast<::dnd5e::api::v1alpha1::InventoryItem*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EquipItemResponse.previously_equipped_item)
}

// -------------------------------------------------------------------

// UnequipItemRequest

// string character_id = 1 [json_name = "characterId"];
inline void UnequipItemRequest::clear_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UnequipItemRequest::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UnequipItemRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UnequipItemRequest::set_character_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UnequipItemRequest.character_id)
}
inline ::std::string* PROTOBUF_NONNULL UnequipItemRequest::mutable_character_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UnequipItemRequest.character_id)
  return _s;
}
inline const ::std::string& UnequipItemRequest::_internal_character_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_id_.Get();
}
inline void UnequipItemRequest::_internal_set_character_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UnequipItemRequest::_internal_mutable_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.character_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UnequipItemRequest::release_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UnequipItemRequest.character_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.character_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.character_id_.Set("", GetArena());
  }
  return released;
}
inline void UnequipItemRequest::set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.character_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UnequipItemRequest.character_id)
}

// .dnd5e.api.v1alpha1.EquipmentSlot slot = 2 [json_name = "slot"];
inline void UnequipItemRequest::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::dnd5e::api::v1alpha1::EquipmentSlot UnequipItemRequest::slot() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UnequipItemRequest.slot)
  return _internal_slot();
}
inline void UnequipItemRequest::set_slot(::dnd5e::api::v1alpha1::EquipmentSlot value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.UnequipItemRequest.slot)
}
inline ::dnd5e::api::v1alpha1::EquipmentSlot UnequipItemRequest::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::EquipmentSlot>(_impl_.slot_);
}
inline void UnequipItemRequest::_internal_set_slot(::dnd5e::api::v1alpha1::EquipmentSlot value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// -------------------------------------------------------------------

// UnequipItemResponse

// .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
inline bool UnequipItemResponse::has_character() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.character_ != nullptr);
  return value;
}
inline void UnequipItemResponse::clear_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ != nullptr) _impl_.character_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::Character& UnequipItemResponse::_internal_character() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.character_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& UnequipItemResponse::character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.UnequipItemResponse.character)
  return _internal_character();
}
inline void UnequipItemResponse::unsafe_arena_set_allocated_character(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }
  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.UnequipItemResponse.character)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE UnequipItemResponse::release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* released = _impl_.character_;
  _impl_.character_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE UnequipItemResponse::unsafe_arena_release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.UnequipItemResponse.character)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.character_;
  _impl_.character_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL UnequipItemResponse::_internal_mutable_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.character_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL UnequipItemResponse::mutable_character()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.UnequipItemResponse.character)
  return _msg;
}
inline void UnequipItemResponse::set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.UnequipItemResponse.character)
}

// -------------------------------------------------------------------

// AddToInventoryRequest

// string character_id = 1 [json_name = "characterId"];
inline void AddToInventoryRequest::clear_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& AddToInventoryRequest::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AddToInventoryRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AddToInventoryRequest::set_character_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AddToInventoryRequest.character_id)
}
inline ::std::string* PROTOBUF_NONNULL AddToInventoryRequest::mutable_character_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AddToInventoryRequest.character_id)
  return _s;
}
inline const ::std::string& AddToInventoryRequest::_internal_character_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_id_.Get();
}
inline void AddToInventoryRequest::_internal_set_character_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AddToInventoryRequest::_internal_mutable_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.character_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AddToInventoryRequest::release_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AddToInventoryRequest.character_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.character_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.character_id_.Set("", GetArena());
  }
  return released;
}
inline void AddToInventoryRequest::set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.character_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AddToInventoryRequest.character_id)
}

// repeated .dnd5e.api.v1alpha1.InventoryAddition items = 2 [json_name = "items"];
inline int AddToInventoryRequest::_internal_items_size() const {
  return _internal_items().size();
}
inline int AddToInventoryRequest::items_size() const {
  return _internal_items_size();
}
inline void AddToInventoryRequest::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
}
inline ::dnd5e::api::v1alpha1::InventoryAddition* PROTOBUF_NONNULL AddToInventoryRequest::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AddToInventoryRequest.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryAddition>* PROTOBUF_NONNULL AddToInventoryRequest::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.AddToInventoryRequest.items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_items();
}
inline const ::dnd5e::api::v1alpha1::InventoryAddition& AddToInventoryRequest::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AddToInventoryRequest.items)
  return _internal_items().Get(index);
}
inline ::dnd5e::api::v1alpha1::InventoryAddition* PROTOBUF_NONNULL AddToInventoryRequest::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::InventoryAddition* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.AddToInventoryRequest.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryAddition>& AddToInventoryRequest::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.AddToInventoryRequest.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryAddition>&
AddToInventoryRequest::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InventoryAddition>* PROTOBUF_NONNULL
AddToInventoryRequest::_internal_mutable_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// InventoryAddition

// string item_id = 1 [json_name = "itemId"];
inline void InventoryAddition::clear_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.item_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& InventoryAddition::item_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InventoryAddition.item_id)
  return _internal_item_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InventoryAddition::set_item_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.item_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InventoryAddition.item_id)
}
inline ::std::string* PROTOBUF_NONNULL InventoryAddition::mutable_item_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.InventoryAddition.item_id)
  return _s;
}
inline const ::std::string& InventoryAddition::_internal_item_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.item_id_.Get();
}
inline void InventoryAddition::_internal_set_item_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.item_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InventoryAddition::_internal_mutable_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.item_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InventoryAddition::release_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.InventoryAddition.item_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.item_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.item_id_.Set("", GetArena());
  }
  return released;
}
inline void InventoryAddition::set_allocated_item_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.item_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.InventoryAddition.item_id)
}

// int32 quantity = 2 [json_name = "quantity"];
inline void InventoryAddition::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t InventoryAddition::quantity() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InventoryAddition.quantity)
  return _internal_quantity();
}
inline void InventoryAddition::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InventoryAddition.quantity)
}
inline ::int32_t InventoryAddition::_internal_quantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_;
}
inline void InventoryAddition::_internal_set_quantity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// AddToInventoryResponse

// .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
inline bool AddToInventoryResponse::has_character() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.character_ != nullptr);
  return value;
}
inline void AddToInventoryResponse::clear_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ != nullptr) _impl_.character_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::Character& AddToInventoryResponse::_internal_character() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.character_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& AddToInventoryResponse::character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AddToInventoryResponse.character)
  return _internal_character();
}
inline void AddToInventoryResponse::unsafe_arena_set_allocated_character(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }
  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AddToInventoryResponse.character)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE AddToInventoryResponse::release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* released = _impl_.character_;
  _impl_.character_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE AddToInventoryResponse::unsafe_arena_release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AddToInventoryResponse.character)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.character_;
  _impl_.character_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL AddToInventoryResponse::_internal_mutable_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.character_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL AddToInventoryResponse::mutable_character()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AddToInventoryResponse.character)
  return _msg;
}
inline void AddToInventoryResponse::set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AddToInventoryResponse.character)
}

// repeated string errors = 2 [json_name = "errors"];
inline int AddToInventoryResponse::_internal_errors_size() const {
  return _internal_errors().size();
}
inline int AddToInventoryResponse::errors_size() const {
  return _internal_errors_size();
}
inline void AddToInventoryResponse::clear_errors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.errors_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL AddToInventoryResponse::add_errors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_errors()->Add();
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.AddToInventoryResponse.errors)
  return _s;
}
inline const ::std::string& AddToInventoryResponse::errors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AddToInventoryResponse.errors)
  return _internal_errors().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL AddToInventoryResponse::mutable_errors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AddToInventoryResponse.errors)
  return _internal_mutable_errors()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void AddToInventoryResponse::set_errors(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_errors()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AddToInventoryResponse.errors)
}
template <typename Arg_, typename... Args_>
inline void AddToInventoryResponse::add_errors(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_errors(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.AddToInventoryResponse.errors)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& AddToInventoryResponse::errors()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.AddToInventoryResponse.errors)
  return _internal_errors();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
AddToInventoryResponse::mutable_errors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.AddToInventoryResponse.errors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_errors();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
AddToInventoryResponse::_internal_errors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.errors_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
AddToInventoryResponse::_internal_mutable_errors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.errors_;
}

// -------------------------------------------------------------------

// RemoveFromInventoryRequest

// string character_id = 1 [json_name = "characterId"];
inline void RemoveFromInventoryRequest::clear_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& RemoveFromInventoryRequest::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RemoveFromInventoryRequest::set_character_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.character_id)
}
inline ::std::string* PROTOBUF_NONNULL RemoveFromInventoryRequest::mutable_character_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.character_id)
  return _s;
}
inline const ::std::string& RemoveFromInventoryRequest::_internal_character_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_id_.Get();
}
inline void RemoveFromInventoryRequest::_internal_set_character_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.character_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RemoveFromInventoryRequest::_internal_mutable_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.character_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RemoveFromInventoryRequest::release_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.character_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.character_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.character_id_.Set("", GetArena());
  }
  return released;
}
inline void RemoveFromInventoryRequest::set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.character_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.character_id)
}

// string item_id = 2 [json_name = "itemId"];
inline void RemoveFromInventoryRequest::clear_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.item_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& RemoveFromInventoryRequest::item_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.item_id)
  return _internal_item_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RemoveFromInventoryRequest::set_item_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.item_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.item_id)
}
inline ::std::string* PROTOBUF_NONNULL RemoveFromInventoryRequest::mutable_item_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.item_id)
  return _s;
}
inline const ::std::string& RemoveFromInventoryRequest::_internal_item_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.item_id_.Get();
}
inline void RemoveFromInventoryRequest::_internal_set_item_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.item_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RemoveFromInventoryRequest::_internal_mutable_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.item_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RemoveFromInventoryRequest::release_item_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.item_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.item_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.item_id_.Set("", GetArena());
  }
  return released;
}
inline void RemoveFromInventoryRequest::set_allocated_item_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.item_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.item_id)
}

// int32 quantity = 3 [json_name = "quantity"];
inline bool RemoveFromInventoryRequest::has_quantity() const {
  return removal_amount_case() == kQuantity;
}
inline void RemoveFromInventoryRequest::set_has_quantity() {
  _impl_._oneof_case_[0] = kQuantity;
}
inline void RemoveFromInventoryRequest::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (removal_amount_case() == kQuantity) {
    _impl_.removal_amount_.quantity_ = 0;
    clear_has_removal_amount();
  }
}
inline ::int32_t RemoveFromInventoryRequest::quantity() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.quantity)
  return _internal_quantity();
}
inline void RemoveFromInventoryRequest::set_quantity(::int32_t value) {
  if (removal_amount_case() != kQuantity) {
    clear_removal_amount();
    set_has_quantity();
  }
  _impl_.removal_amount_.quantity_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.quantity)
}
inline ::int32_t RemoveFromInventoryRequest::_internal_quantity() const {
  if (removal_amount_case() == kQuantity) {
    return _impl_.removal_amount_.quantity_;
  }
  return 0;
}

// bool remove_all = 4 [json_name = "removeAll"];
inline bool RemoveFromInventoryRequest::has_remove_all() const {
  return removal_amount_case() == kRemoveAll;
}
inline void RemoveFromInventoryRequest::set_has_remove_all() {
  _impl_._oneof_case_[0] = kRemoveAll;
}
inline void RemoveFromInventoryRequest::clear_remove_all() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (removal_amount_case() == kRemoveAll) {
    _impl_.removal_amount_.remove_all_ = false;
    clear_has_removal_amount();
  }
}
inline bool RemoveFromInventoryRequest::remove_all() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.remove_all)
  return _internal_remove_all();
}
inline void RemoveFromInventoryRequest::set_remove_all(bool value) {
  if (removal_amount_case() != kRemoveAll) {
    clear_removal_amount();
    set_has_remove_all();
  }
  _impl_.removal_amount_.remove_all_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RemoveFromInventoryRequest.remove_all)
}
inline bool RemoveFromInventoryRequest::_internal_remove_all() const {
  if (removal_amount_case() == kRemoveAll) {
    return _impl_.removal_amount_.remove_all_;
  }
  return false;
}

inline bool RemoveFromInventoryRequest::has_removal_amount() const {
  return removal_amount_case() != REMOVAL_AMOUNT_NOT_SET;
}
inline void RemoveFromInventoryRequest::clear_has_removal_amount() {
  _impl_._oneof_case_[0] = REMOVAL_AMOUNT_NOT_SET;
}
inline RemoveFromInventoryRequest::RemovalAmountCase RemoveFromInventoryRequest::removal_amount_case() const {
  return RemoveFromInventoryRequest::RemovalAmountCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RemoveFromInventoryResponse

// .dnd5e.api.v1alpha1.Character character = 1 [json_name = "character"];
inline bool RemoveFromInventoryResponse::has_character() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.character_ != nullptr);
  return value;
}
inline void RemoveFromInventoryResponse::clear_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ != nullptr) _impl_.character_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dnd5e::api::v1alpha1::Character& RemoveFromInventoryResponse::_internal_character() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.character_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& RemoveFromInventoryResponse::character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RemoveFromInventoryResponse.character)
  return _internal_character();
}
inline void RemoveFromInventoryResponse::unsafe_arena_set_allocated_character(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }
  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.RemoveFromInventoryResponse.character)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE RemoveFromInventoryResponse::release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* released = _impl_.character_;
  _impl_.character_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE RemoveFromInventoryResponse::unsafe_arena_release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RemoveFromInventoryResponse.character)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.character_;
  _impl_.character_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL RemoveFromInventoryResponse::_internal_mutable_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.character_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL RemoveFromInventoryResponse::mutable_character()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RemoveFromInventoryResponse.character)
  return _msg;
}
inline void RemoveFromInventoryResponse::set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RemoveFromInventoryResponse.character)
}

// int32 quantity_removed = 2 [json_name = "quantityRemoved"];
inline void RemoveFromInventoryResponse::clear_quantity_removed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_removed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t RemoveFromInventoryResponse::quantity_removed() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RemoveFromInventoryResponse.quantity_removed)
  return _internal_quantity_removed();
}
inline void RemoveFromInventoryResponse::set_quantity_removed(::int32_t value) {
  _internal_set_quantity_removed(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RemoveFromInventoryResponse.quantity_removed)
}
inline ::int32_t RemoveFromInventoryResponse::_internal_quantity_removed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_removed_;
}
inline void RemoveFromInventoryResponse::_internal_set_quantity_removed(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_removed_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::CreationStep> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::CreationStep>() {
  return ::dnd5e::api::v1alpha1::CreationStep_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::WarningType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::WarningType>() {
  return ::dnd5e::api::v1alpha1::WarningType_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::ChoiceCategory> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::ChoiceCategory>() {
  return ::dnd5e::api::v1alpha1::ChoiceCategory_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::Size> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::Size>() {
  return ::dnd5e::api::v1alpha1::Size_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::SpellSelectionType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::SpellSelectionType>() {
  return ::dnd5e::api::v1alpha1::SpellSelectionType_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::EncumbranceLevel> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::EncumbranceLevel>() {
  return ::dnd5e::api::v1alpha1::EncumbranceLevel_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::ChoiceSource> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::ChoiceSource>() {
  return ::dnd5e::api::v1alpha1::ChoiceSource_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::EquipmentSlot> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::EquipmentSlot>() {
  return ::dnd5e::api::v1alpha1::EquipmentSlot_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // dnd5e_2fapi_2fv1alpha1_2fcharacter_2eproto_2epb_2eh
