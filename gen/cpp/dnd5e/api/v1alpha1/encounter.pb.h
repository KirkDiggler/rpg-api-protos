// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: dnd5e/api/v1alpha1/encounter.proto
// Protobuf C++ Version: 6.33.2

#ifndef dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_2epb_2eh
#define dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/v1alpha1/room_common.pb.h"
#include "dnd5e/api/v1alpha1/character.pb.h"
#include "dnd5e/api/v1alpha1/common.pb.h"
#include "dnd5e/api/v1alpha1/enums.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
}  // extern "C"
namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum EncounterEndReason : int;
extern const uint32_t EncounterEndReason_internal_data_[];
enum EncounterState : int;
extern const uint32_t EncounterState_internal_data_[];
enum MovementError_ErrorCode : int;
extern const uint32_t MovementError_ErrorCode_internal_data_[];
class ActivateFeatureRequest;
struct ActivateFeatureRequestDefaultTypeInternal;
extern ActivateFeatureRequestDefaultTypeInternal _ActivateFeatureRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ActivateFeatureRequest_class_data_;
class ActivateFeatureResponse;
struct ActivateFeatureResponseDefaultTypeInternal;
extern ActivateFeatureResponseDefaultTypeInternal _ActivateFeatureResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ActivateFeatureResponse_class_data_;
class AttackRequest;
struct AttackRequestDefaultTypeInternal;
extern AttackRequestDefaultTypeInternal _AttackRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AttackRequest_class_data_;
class AttackResolvedEvent;
struct AttackResolvedEventDefaultTypeInternal;
extern AttackResolvedEventDefaultTypeInternal _AttackResolvedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AttackResolvedEvent_class_data_;
class AttackResponse;
struct AttackResponseDefaultTypeInternal;
extern AttackResponseDefaultTypeInternal _AttackResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AttackResponse_class_data_;
class AttackResult;
struct AttackResultDefaultTypeInternal;
extern AttackResultDefaultTypeInternal _AttackResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AttackResult_class_data_;
class CombatEndedEvent;
struct CombatEndedEventDefaultTypeInternal;
extern CombatEndedEventDefaultTypeInternal _CombatEndedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CombatEndedEvent_class_data_;
class CombatPausedEvent;
struct CombatPausedEventDefaultTypeInternal;
extern CombatPausedEventDefaultTypeInternal _CombatPausedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CombatPausedEvent_class_data_;
class CombatResumedEvent;
struct CombatResumedEventDefaultTypeInternal;
extern CombatResumedEventDefaultTypeInternal _CombatResumedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CombatResumedEvent_class_data_;
class CombatStartedEvent;
struct CombatStartedEventDefaultTypeInternal;
extern CombatStartedEventDefaultTypeInternal _CombatStartedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CombatStartedEvent_class_data_;
class CombatState;
struct CombatStateDefaultTypeInternal;
extern CombatStateDefaultTypeInternal _CombatState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CombatState_class_data_;
class CreateEncounterRequest;
struct CreateEncounterRequestDefaultTypeInternal;
extern CreateEncounterRequestDefaultTypeInternal _CreateEncounterRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateEncounterRequest_class_data_;
class CreateEncounterResponse;
struct CreateEncounterResponseDefaultTypeInternal;
extern CreateEncounterResponseDefaultTypeInternal _CreateEncounterResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateEncounterResponse_class_data_;
class DamageBreakdown;
struct DamageBreakdownDefaultTypeInternal;
extern DamageBreakdownDefaultTypeInternal _DamageBreakdown_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DamageBreakdown_class_data_;
class DamageComponent;
struct DamageComponentDefaultTypeInternal;
extern DamageComponentDefaultTypeInternal _DamageComponent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DamageComponent_class_data_;
class DoorInfo;
struct DoorInfoDefaultTypeInternal;
extern DoorInfoDefaultTypeInternal _DoorInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DoorInfo_class_data_;
class DungeonFailureEvent;
struct DungeonFailureEventDefaultTypeInternal;
extern DungeonFailureEventDefaultTypeInternal _DungeonFailureEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DungeonFailureEvent_class_data_;
class DungeonStartRequest;
struct DungeonStartRequestDefaultTypeInternal;
extern DungeonStartRequestDefaultTypeInternal _DungeonStartRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DungeonStartRequest_class_data_;
class DungeonStartResponse;
struct DungeonStartResponseDefaultTypeInternal;
extern DungeonStartResponseDefaultTypeInternal _DungeonStartResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DungeonStartResponse_class_data_;
class DungeonVictoryEvent;
struct DungeonVictoryEventDefaultTypeInternal;
extern DungeonVictoryEventDefaultTypeInternal _DungeonVictoryEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DungeonVictoryEvent_class_data_;
class EncounterEvent;
struct EncounterEventDefaultTypeInternal;
extern EncounterEventDefaultTypeInternal _EncounterEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EncounterEvent_class_data_;
class EncounterResult;
struct EncounterResultDefaultTypeInternal;
extern EncounterResultDefaultTypeInternal _EncounterResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EncounterResult_class_data_;
class EndTurnRequest;
struct EndTurnRequestDefaultTypeInternal;
extern EndTurnRequestDefaultTypeInternal _EndTurnRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EndTurnRequest_class_data_;
class EndTurnResponse;
struct EndTurnResponseDefaultTypeInternal;
extern EndTurnResponseDefaultTypeInternal _EndTurnResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EndTurnResponse_class_data_;
class EntityPlacement;
struct EntityPlacementDefaultTypeInternal;
extern EntityPlacementDefaultTypeInternal _EntityPlacement_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EntityPlacement_class_data_;
class FeatureActivatedEvent;
struct FeatureActivatedEventDefaultTypeInternal;
extern FeatureActivatedEventDefaultTypeInternal _FeatureActivatedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FeatureActivatedEvent_class_data_;
class GetCombatStateRequest;
struct GetCombatStateRequestDefaultTypeInternal;
extern GetCombatStateRequestDefaultTypeInternal _GetCombatStateRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCombatStateRequest_class_data_;
class GetCombatStateResponse;
struct GetCombatStateResponseDefaultTypeInternal;
extern GetCombatStateResponseDefaultTypeInternal _GetCombatStateResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetCombatStateResponse_class_data_;
class GetEncounterHistoryRequest;
struct GetEncounterHistoryRequestDefaultTypeInternal;
extern GetEncounterHistoryRequestDefaultTypeInternal _GetEncounterHistoryRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetEncounterHistoryRequest_class_data_;
class GetEncounterHistoryResponse;
struct GetEncounterHistoryResponseDefaultTypeInternal;
extern GetEncounterHistoryResponseDefaultTypeInternal _GetEncounterHistoryResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetEncounterHistoryResponse_class_data_;
class GetEncounterStateRequest;
struct GetEncounterStateRequestDefaultTypeInternal;
extern GetEncounterStateRequestDefaultTypeInternal _GetEncounterStateRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetEncounterStateRequest_class_data_;
class GetEncounterStateResponse;
struct GetEncounterStateResponseDefaultTypeInternal;
extern GetEncounterStateResponseDefaultTypeInternal _GetEncounterStateResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetEncounterStateResponse_class_data_;
class GrantedAction;
struct GrantedActionDefaultTypeInternal;
extern GrantedActionDefaultTypeInternal _GrantedAction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GrantedAction_class_data_;
class HealResult;
struct HealResultDefaultTypeInternal;
extern HealResultDefaultTypeInternal _HealResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HealResult_class_data_;
class InitiativeEntry;
struct InitiativeEntryDefaultTypeInternal;
extern InitiativeEntryDefaultTypeInternal _InitiativeEntry_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InitiativeEntry_class_data_;
class JoinEncounterRequest;
struct JoinEncounterRequestDefaultTypeInternal;
extern JoinEncounterRequestDefaultTypeInternal _JoinEncounterRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull JoinEncounterRequest_class_data_;
class JoinEncounterResponse;
struct JoinEncounterResponseDefaultTypeInternal;
extern JoinEncounterResponseDefaultTypeInternal _JoinEncounterResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull JoinEncounterResponse_class_data_;
class LeaveEncounterRequest;
struct LeaveEncounterRequestDefaultTypeInternal;
extern LeaveEncounterRequestDefaultTypeInternal _LeaveEncounterRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LeaveEncounterRequest_class_data_;
class LeaveEncounterResponse;
struct LeaveEncounterResponseDefaultTypeInternal;
extern LeaveEncounterResponseDefaultTypeInternal _LeaveEncounterResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LeaveEncounterResponse_class_data_;
class MonsterCombatState;
struct MonsterCombatStateDefaultTypeInternal;
extern MonsterCombatStateDefaultTypeInternal _MonsterCombatState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MonsterCombatState_class_data_;
class MonsterExecutedAction;
struct MonsterExecutedActionDefaultTypeInternal;
extern MonsterExecutedActionDefaultTypeInternal _MonsterExecutedAction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MonsterExecutedAction_class_data_;
class MonsterTurnCompletedEvent;
struct MonsterTurnCompletedEventDefaultTypeInternal;
extern MonsterTurnCompletedEventDefaultTypeInternal _MonsterTurnCompletedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MonsterTurnCompletedEvent_class_data_;
class MonsterTurnResult;
struct MonsterTurnResultDefaultTypeInternal;
extern MonsterTurnResultDefaultTypeInternal _MonsterTurnResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MonsterTurnResult_class_data_;
class MoveCharacterRequest;
struct MoveCharacterRequestDefaultTypeInternal;
extern MoveCharacterRequestDefaultTypeInternal _MoveCharacterRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MoveCharacterRequest_class_data_;
class MoveCharacterResponse;
struct MoveCharacterResponseDefaultTypeInternal;
extern MoveCharacterResponseDefaultTypeInternal _MoveCharacterResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MoveCharacterResponse_class_data_;
class MovementCompletedEvent;
struct MovementCompletedEventDefaultTypeInternal;
extern MovementCompletedEventDefaultTypeInternal _MovementCompletedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MovementCompletedEvent_class_data_;
class MovementError;
struct MovementErrorDefaultTypeInternal;
extern MovementErrorDefaultTypeInternal _MovementError_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MovementError_class_data_;
class MovementError_DetailsEntry_DoNotUse;
struct MovementError_DetailsEntry_DoNotUseDefaultTypeInternal;
extern MovementError_DetailsEntry_DoNotUseDefaultTypeInternal _MovementError_DetailsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MovementError_DetailsEntry_DoNotUse_class_data_;
class OpenDoorRequest;
struct OpenDoorRequestDefaultTypeInternal;
extern OpenDoorRequestDefaultTypeInternal _OpenDoorRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull OpenDoorRequest_class_data_;
class OpenDoorResponse;
struct OpenDoorResponseDefaultTypeInternal;
extern OpenDoorResponseDefaultTypeInternal _OpenDoorResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull OpenDoorResponse_class_data_;
class PartyMember;
struct PartyMemberDefaultTypeInternal;
extern PartyMemberDefaultTypeInternal _PartyMember_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PartyMember_class_data_;
class PlayerDisconnectedEvent;
struct PlayerDisconnectedEventDefaultTypeInternal;
extern PlayerDisconnectedEventDefaultTypeInternal _PlayerDisconnectedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerDisconnectedEvent_class_data_;
class PlayerJoinedEvent;
struct PlayerJoinedEventDefaultTypeInternal;
extern PlayerJoinedEventDefaultTypeInternal _PlayerJoinedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerJoinedEvent_class_data_;
class PlayerLeftEvent;
struct PlayerLeftEventDefaultTypeInternal;
extern PlayerLeftEventDefaultTypeInternal _PlayerLeftEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerLeftEvent_class_data_;
class PlayerReadyEvent;
struct PlayerReadyEventDefaultTypeInternal;
extern PlayerReadyEventDefaultTypeInternal _PlayerReadyEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerReadyEvent_class_data_;
class PlayerReconnectedEvent;
struct PlayerReconnectedEventDefaultTypeInternal;
extern PlayerReconnectedEventDefaultTypeInternal _PlayerReconnectedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerReconnectedEvent_class_data_;
class RerollEvent;
struct RerollEventDefaultTypeInternal;
extern RerollEventDefaultTypeInternal _RerollEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RerollEvent_class_data_;
class Room;
struct RoomDefaultTypeInternal;
extern RoomDefaultTypeInternal _Room_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Room_class_data_;
class RoomRevealedEvent;
struct RoomRevealedEventDefaultTypeInternal;
extern RoomRevealedEventDefaultTypeInternal _RoomRevealedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoomRevealedEvent_class_data_;
class Room_EntitiesEntry_DoNotUse;
struct Room_EntitiesEntry_DoNotUseDefaultTypeInternal;
extern Room_EntitiesEntry_DoNotUseDefaultTypeInternal _Room_EntitiesEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Room_EntitiesEntry_DoNotUse_class_data_;
class SetReadyRequest;
struct SetReadyRequestDefaultTypeInternal;
extern SetReadyRequestDefaultTypeInternal _SetReadyRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SetReadyRequest_class_data_;
class SetReadyResponse;
struct SetReadyResponseDefaultTypeInternal;
extern SetReadyResponseDefaultTypeInternal _SetReadyResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SetReadyResponse_class_data_;
class StartCombatRequest;
struct StartCombatRequestDefaultTypeInternal;
extern StartCombatRequestDefaultTypeInternal _StartCombatRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StartCombatRequest_class_data_;
class StartCombatResponse;
struct StartCombatResponseDefaultTypeInternal;
extern StartCombatResponseDefaultTypeInternal _StartCombatResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StartCombatResponse_class_data_;
class StreamEncounterEventsRequest;
struct StreamEncounterEventsRequestDefaultTypeInternal;
extern StreamEncounterEventsRequestDefaultTypeInternal _StreamEncounterEventsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StreamEncounterEventsRequest_class_data_;
class TurnChangeEvent;
struct TurnChangeEventDefaultTypeInternal;
extern TurnChangeEventDefaultTypeInternal _TurnChangeEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TurnChangeEvent_class_data_;
class TurnEndedEvent;
struct TurnEndedEventDefaultTypeInternal;
extern TurnEndedEventDefaultTypeInternal _TurnEndedEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TurnEndedEvent_class_data_;
class TurnState;
struct TurnStateDefaultTypeInternal;
extern TurnStateDefaultTypeInternal _TurnState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TurnState_class_data_;
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::EncounterEndReason_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::EncounterEndReason>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::EncounterState_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::EncounterState>;
template <>
internal::EnumTraitsT<::dnd5e::api::v1alpha1::MovementError_ErrorCode_internal_data_>
    internal::EnumTraitsImpl::value<::dnd5e::api::v1alpha1::MovementError_ErrorCode>;
}  // namespace protobuf
}  // namespace google

namespace dnd5e {
namespace api {
namespace v1alpha1 {
enum MovementError_ErrorCode : int {
  MovementError_ErrorCode_ERROR_CODE_UNSPECIFIED = 0,
  MovementError_ErrorCode_ERROR_CODE_INVALID_POSITION = 1,
  MovementError_ErrorCode_ERROR_CODE_INSUFFICIENT_MOVEMENT = 2,
  MovementError_ErrorCode_ERROR_CODE_PATH_BLOCKED = 3,
  MovementError_ErrorCode_ERROR_CODE_POSITION_OCCUPIED = 4,
  MovementError_ErrorCode_ERROR_CODE_OUT_OF_BOUNDS = 5,
  MovementError_ErrorCode_ERROR_CODE_NOT_YOUR_TURN = 6,
  MovementError_ErrorCode_MovementError_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MovementError_ErrorCode_MovementError_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MovementError_ErrorCode_internal_data_[];
inline constexpr MovementError_ErrorCode MovementError_ErrorCode_ErrorCode_MIN =
    static_cast<MovementError_ErrorCode>(0);
inline constexpr MovementError_ErrorCode MovementError_ErrorCode_ErrorCode_MAX =
    static_cast<MovementError_ErrorCode>(6);
inline bool MovementError_ErrorCode_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int MovementError_ErrorCode_ErrorCode_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MovementError_ErrorCode_descriptor();
template <typename T>
const ::std::string& MovementError_ErrorCode_Name(T value) {
  static_assert(::std::is_same<T, MovementError_ErrorCode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ErrorCode_Name().");
  return MovementError_ErrorCode_Name(static_cast<MovementError_ErrorCode>(value));
}
template <>
inline const ::std::string& MovementError_ErrorCode_Name(MovementError_ErrorCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MovementError_ErrorCode_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool MovementError_ErrorCode_Parse(
    ::absl::string_view name, MovementError_ErrorCode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MovementError_ErrorCode>(MovementError_ErrorCode_descriptor(), name,
                                           value);
}
enum EncounterEndReason : int {
  ENCOUNTER_END_REASON_UNSPECIFIED = 0,
  ENCOUNTER_END_REASON_VICTORY = 1,
  ENCOUNTER_END_REASON_DEFEAT = 2,
  EncounterEndReason_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EncounterEndReason_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EncounterEndReason_internal_data_[];
inline constexpr EncounterEndReason EncounterEndReason_MIN =
    static_cast<EncounterEndReason>(0);
inline constexpr EncounterEndReason EncounterEndReason_MAX =
    static_cast<EncounterEndReason>(2);
inline bool EncounterEndReason_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int EncounterEndReason_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EncounterEndReason_descriptor();
template <typename T>
const ::std::string& EncounterEndReason_Name(T value) {
  static_assert(::std::is_same<T, EncounterEndReason>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EncounterEndReason_Name().");
  return EncounterEndReason_Name(static_cast<EncounterEndReason>(value));
}
template <>
inline const ::std::string& EncounterEndReason_Name(EncounterEndReason value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EncounterEndReason_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool EncounterEndReason_Parse(
    ::absl::string_view name, EncounterEndReason* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncounterEndReason>(EncounterEndReason_descriptor(), name,
                                           value);
}
enum EncounterState : int {
  ENCOUNTER_STATE_UNSPECIFIED = 0,
  ENCOUNTER_STATE_WAITING = 1,
  ENCOUNTER_STATE_ACTIVE = 2,
  ENCOUNTER_STATE_PAUSED = 3,
  ENCOUNTER_STATE_COMPLETED = 4,
  EncounterState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EncounterState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EncounterState_internal_data_[];
inline constexpr EncounterState EncounterState_MIN =
    static_cast<EncounterState>(0);
inline constexpr EncounterState EncounterState_MAX =
    static_cast<EncounterState>(4);
inline bool EncounterState_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int EncounterState_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EncounterState_descriptor();
template <typename T>
const ::std::string& EncounterState_Name(T value) {
  static_assert(::std::is_same<T, EncounterState>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EncounterState_Name().");
  return EncounterState_Name(static_cast<EncounterState>(value));
}
template <>
inline const ::std::string& EncounterState_Name(EncounterState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EncounterState_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool EncounterState_Parse(
    ::absl::string_view name, EncounterState* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncounterState>(EncounterState_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class TurnChangeEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.TurnChangeEvent) */ {
 public:
  inline TurnChangeEvent() : TurnChangeEvent(nullptr) {}
  ~TurnChangeEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TurnChangeEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TurnChangeEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TurnChangeEvent(::google::protobuf::internal::ConstantInitialized);

  inline TurnChangeEvent(const TurnChangeEvent& from) : TurnChangeEvent(nullptr, from) {}
  inline TurnChangeEvent(TurnChangeEvent&& from) noexcept
      : TurnChangeEvent(nullptr, ::std::move(from)) {}
  inline TurnChangeEvent& operator=(const TurnChangeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnChangeEvent& operator=(TurnChangeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnChangeEvent& default_instance() {
    return *reinterpret_cast<const TurnChangeEvent*>(
        &_TurnChangeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(TurnChangeEvent& a, TurnChangeEvent& b) { a.Swap(&b); }
  inline void Swap(TurnChangeEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnChangeEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnChangeEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TurnChangeEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TurnChangeEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TurnChangeEvent& from) { TurnChangeEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TurnChangeEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.TurnChangeEvent"; }

  explicit TurnChangeEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TurnChangeEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TurnChangeEvent& from);
  TurnChangeEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TurnChangeEvent&& from) noexcept
      : TurnChangeEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPreviousEntityIdFieldNumber = 1,
    kNextEntityIdFieldNumber = 2,
    kRoundFieldNumber = 3,
    kNewRoundFieldNumber = 4,
  };
  // string previous_entity_id = 1 [json_name = "previousEntityId"];
  void clear_previous_entity_id() ;
  const ::std::string& previous_entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_previous_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_previous_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_previous_entity_id();
  void set_allocated_previous_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_previous_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_previous_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_previous_entity_id();

  public:
  // string next_entity_id = 2 [json_name = "nextEntityId"];
  void clear_next_entity_id() ;
  const ::std::string& next_entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_next_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_next_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_next_entity_id();
  void set_allocated_next_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_next_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_next_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_next_entity_id();

  public:
  // int32 round = 3 [json_name = "round"];
  void clear_round() ;
  ::int32_t round() const;
  void set_round(::int32_t value);

  private:
  ::int32_t _internal_round() const;
  void _internal_set_round(::int32_t value);

  public:
  // bool new_round = 4 [json_name = "newRound"];
  void clear_new_round() ;
  bool new_round() const;
  void set_new_round(bool value);

  private:
  bool _internal_new_round() const;
  void _internal_set_new_round(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.TurnChangeEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 75,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TurnChangeEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr previous_entity_id_;
    ::google::protobuf::internal::ArenaStringPtr next_entity_id_;
    ::int32_t round_;
    bool new_round_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TurnChangeEvent_class_data_;
// -------------------------------------------------------------------

class StreamEncounterEventsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.StreamEncounterEventsRequest) */ {
 public:
  inline StreamEncounterEventsRequest() : StreamEncounterEventsRequest(nullptr) {}
  ~StreamEncounterEventsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StreamEncounterEventsRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StreamEncounterEventsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StreamEncounterEventsRequest(::google::protobuf::internal::ConstantInitialized);

  inline StreamEncounterEventsRequest(const StreamEncounterEventsRequest& from) : StreamEncounterEventsRequest(nullptr, from) {}
  inline StreamEncounterEventsRequest(StreamEncounterEventsRequest&& from) noexcept
      : StreamEncounterEventsRequest(nullptr, ::std::move(from)) {}
  inline StreamEncounterEventsRequest& operator=(const StreamEncounterEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamEncounterEventsRequest& operator=(StreamEncounterEventsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamEncounterEventsRequest& default_instance() {
    return *reinterpret_cast<const StreamEncounterEventsRequest*>(
        &_StreamEncounterEventsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 49;
  friend void swap(StreamEncounterEventsRequest& a, StreamEncounterEventsRequest& b) { a.Swap(&b); }
  inline void Swap(StreamEncounterEventsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamEncounterEventsRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamEncounterEventsRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StreamEncounterEventsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamEncounterEventsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StreamEncounterEventsRequest& from) { StreamEncounterEventsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StreamEncounterEventsRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.StreamEncounterEventsRequest"; }

  explicit StreamEncounterEventsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StreamEncounterEventsRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StreamEncounterEventsRequest& from);
  StreamEncounterEventsRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StreamEncounterEventsRequest&& from) noexcept
      : StreamEncounterEventsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string player_id = 2 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.StreamEncounterEventsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 77,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StreamEncounterEventsRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StreamEncounterEventsRequest_class_data_;
// -------------------------------------------------------------------

class StartCombatRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.StartCombatRequest) */ {
 public:
  inline StartCombatRequest() : StartCombatRequest(nullptr) {}
  ~StartCombatRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StartCombatRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StartCombatRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StartCombatRequest(::google::protobuf::internal::ConstantInitialized);

  inline StartCombatRequest(const StartCombatRequest& from) : StartCombatRequest(nullptr, from) {}
  inline StartCombatRequest(StartCombatRequest&& from) noexcept
      : StartCombatRequest(nullptr, ::std::move(from)) {}
  inline StartCombatRequest& operator=(const StartCombatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartCombatRequest& operator=(StartCombatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartCombatRequest& default_instance() {
    return *reinterpret_cast<const StartCombatRequest*>(
        &_StartCombatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(StartCombatRequest& a, StartCombatRequest& b) { a.Swap(&b); }
  inline void Swap(StartCombatRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartCombatRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartCombatRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StartCombatRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StartCombatRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StartCombatRequest& from) { StartCombatRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StartCombatRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.StartCombatRequest"; }

  explicit StartCombatRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StartCombatRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StartCombatRequest& from);
  StartCombatRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StartCombatRequest&& from) noexcept
      : StartCombatRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kThemeFieldNumber = 2,
    kDifficultyFieldNumber = 3,
    kLengthFieldNumber = 4,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // .dnd5e.api.v1alpha1.DungeonTheme theme = 2 [json_name = "theme"];
  void clear_theme() ;
  ::dnd5e::api::v1alpha1::DungeonTheme theme() const;
  void set_theme(::dnd5e::api::v1alpha1::DungeonTheme value);

  private:
  ::dnd5e::api::v1alpha1::DungeonTheme _internal_theme() const;
  void _internal_set_theme(::dnd5e::api::v1alpha1::DungeonTheme value);

  public:
  // .dnd5e.api.v1alpha1.DungeonDifficulty difficulty = 3 [json_name = "difficulty"];
  void clear_difficulty() ;
  ::dnd5e::api::v1alpha1::DungeonDifficulty difficulty() const;
  void set_difficulty(::dnd5e::api::v1alpha1::DungeonDifficulty value);

  private:
  ::dnd5e::api::v1alpha1::DungeonDifficulty _internal_difficulty() const;
  void _internal_set_difficulty(::dnd5e::api::v1alpha1::DungeonDifficulty value);

  public:
  // .dnd5e.api.v1alpha1.DungeonLength length = 4 [json_name = "length"];
  void clear_length() ;
  ::dnd5e::api::v1alpha1::DungeonLength length() const;
  void set_length(::dnd5e::api::v1alpha1::DungeonLength value);

  private:
  ::dnd5e::api::v1alpha1::DungeonLength _internal_length() const;
  void _internal_set_length(::dnd5e::api::v1alpha1::DungeonLength value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.StartCombatRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StartCombatRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    int theme_;
    int difficulty_;
    int length_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StartCombatRequest_class_data_;
// -------------------------------------------------------------------

class SetReadyResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.SetReadyResponse) */ {
 public:
  inline SetReadyResponse() : SetReadyResponse(nullptr) {}
  ~SetReadyResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetReadyResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetReadyResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetReadyResponse(::google::protobuf::internal::ConstantInitialized);

  inline SetReadyResponse(const SetReadyResponse& from) : SetReadyResponse(nullptr, from) {}
  inline SetReadyResponse(SetReadyResponse&& from) noexcept
      : SetReadyResponse(nullptr, ::std::move(from)) {}
  inline SetReadyResponse& operator=(const SetReadyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetReadyResponse& operator=(SetReadyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetReadyResponse& default_instance() {
    return *reinterpret_cast<const SetReadyResponse*>(
        &_SetReadyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(SetReadyResponse& a, SetReadyResponse& b) { a.Swap(&b); }
  inline void Swap(SetReadyResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetReadyResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetReadyResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetReadyResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetReadyResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetReadyResponse& from) { SetReadyResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetReadyResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.SetReadyResponse"; }

  explicit SetReadyResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SetReadyResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SetReadyResponse& from);
  SetReadyResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SetReadyResponse&& from) noexcept
      : SetReadyResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.SetReadyResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SetReadyResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SetReadyResponse_class_data_;
// -------------------------------------------------------------------

class SetReadyRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.SetReadyRequest) */ {
 public:
  inline SetReadyRequest() : SetReadyRequest(nullptr) {}
  ~SetReadyRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetReadyRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetReadyRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetReadyRequest(::google::protobuf::internal::ConstantInitialized);

  inline SetReadyRequest(const SetReadyRequest& from) : SetReadyRequest(nullptr, from) {}
  inline SetReadyRequest(SetReadyRequest&& from) noexcept
      : SetReadyRequest(nullptr, ::std::move(from)) {}
  inline SetReadyRequest& operator=(const SetReadyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetReadyRequest& operator=(SetReadyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetReadyRequest& default_instance() {
    return *reinterpret_cast<const SetReadyRequest*>(
        &_SetReadyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(SetReadyRequest& a, SetReadyRequest& b) { a.Swap(&b); }
  inline void Swap(SetReadyRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetReadyRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetReadyRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetReadyRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetReadyRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetReadyRequest& from) { SetReadyRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetReadyRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.SetReadyRequest"; }

  explicit SetReadyRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SetReadyRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SetReadyRequest& from);
  SetReadyRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SetReadyRequest&& from) noexcept
      : SetReadyRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kIsReadyFieldNumber = 3,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string player_id = 2 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // bool is_ready = 3 [json_name = "isReady"];
  void clear_is_ready() ;
  bool is_ready() const;
  void set_is_ready(bool value);

  private:
  bool _internal_is_ready() const;
  void _internal_set_is_ready(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.SetReadyRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 64,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SetReadyRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    bool is_ready_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SetReadyRequest_class_data_;
// -------------------------------------------------------------------

class RerollEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.RerollEvent) */ {
 public:
  inline RerollEvent() : RerollEvent(nullptr) {}
  ~RerollEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RerollEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RerollEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RerollEvent(::google::protobuf::internal::ConstantInitialized);

  inline RerollEvent(const RerollEvent& from) : RerollEvent(nullptr, from) {}
  inline RerollEvent(RerollEvent&& from) noexcept
      : RerollEvent(nullptr, ::std::move(from)) {}
  inline RerollEvent& operator=(const RerollEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RerollEvent& operator=(RerollEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RerollEvent& default_instance() {
    return *reinterpret_cast<const RerollEvent*>(
        &_RerollEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(RerollEvent& a, RerollEvent& b) { a.Swap(&b); }
  inline void Swap(RerollEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RerollEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RerollEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RerollEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RerollEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RerollEvent& from) { RerollEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RerollEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.RerollEvent"; }

  explicit RerollEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RerollEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RerollEvent& from);
  RerollEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RerollEvent&& from) noexcept
      : RerollEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 4,
    kDieIndexFieldNumber = 1,
    kBeforeFieldNumber = 2,
    kAfterFieldNumber = 3,
  };
  // string reason = 4 [json_name = "reason"];
  void clear_reason() ;
  const ::std::string& reason() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_reason();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_reason();
  void set_allocated_reason(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_reason() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_reason();

  public:
  // int32 die_index = 1 [json_name = "dieIndex"];
  void clear_die_index() ;
  ::int32_t die_index() const;
  void set_die_index(::int32_t value);

  private:
  ::int32_t _internal_die_index() const;
  void _internal_set_die_index(::int32_t value);

  public:
  // int32 before = 2 [json_name = "before"];
  void clear_before() ;
  ::int32_t before() const;
  void set_before(::int32_t value);

  private:
  ::int32_t _internal_before() const;
  void _internal_set_before(::int32_t value);

  public:
  // int32 after = 3 [json_name = "after"];
  void clear_after() ;
  ::int32_t after() const;
  void set_after(::int32_t value);

  private:
  ::int32_t _internal_after() const;
  void _internal_set_after(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.RerollEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 45,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RerollEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::int32_t die_index_;
    ::int32_t before_;
    ::int32_t after_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RerollEvent_class_data_;
// -------------------------------------------------------------------

class PlayerReadyEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.PlayerReadyEvent) */ {
 public:
  inline PlayerReadyEvent() : PlayerReadyEvent(nullptr) {}
  ~PlayerReadyEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerReadyEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerReadyEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerReadyEvent(::google::protobuf::internal::ConstantInitialized);

  inline PlayerReadyEvent(const PlayerReadyEvent& from) : PlayerReadyEvent(nullptr, from) {}
  inline PlayerReadyEvent(PlayerReadyEvent&& from) noexcept
      : PlayerReadyEvent(nullptr, ::std::move(from)) {}
  inline PlayerReadyEvent& operator=(const PlayerReadyEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReadyEvent& operator=(PlayerReadyEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerReadyEvent& default_instance() {
    return *reinterpret_cast<const PlayerReadyEvent*>(
        &_PlayerReadyEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 53;
  friend void swap(PlayerReadyEvent& a, PlayerReadyEvent& b) { a.Swap(&b); }
  inline void Swap(PlayerReadyEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReadyEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerReadyEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerReadyEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerReadyEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerReadyEvent& from) { PlayerReadyEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerReadyEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.PlayerReadyEvent"; }

  explicit PlayerReadyEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerReadyEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerReadyEvent& from);
  PlayerReadyEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerReadyEvent&& from) noexcept
      : PlayerReadyEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerIdFieldNumber = 1,
    kIsReadyFieldNumber = 2,
  };
  // string player_id = 1 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // bool is_ready = 2 [json_name = "isReady"];
  void clear_is_ready() ;
  bool is_ready() const;
  void set_is_ready(bool value);

  private:
  bool _internal_is_ready() const;
  void _internal_set_is_ready(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.PlayerReadyEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 53,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerReadyEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    bool is_ready_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerReadyEvent_class_data_;
// -------------------------------------------------------------------

class PlayerLeftEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.PlayerLeftEvent) */ {
 public:
  inline PlayerLeftEvent() : PlayerLeftEvent(nullptr) {}
  ~PlayerLeftEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerLeftEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerLeftEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerLeftEvent(::google::protobuf::internal::ConstantInitialized);

  inline PlayerLeftEvent(const PlayerLeftEvent& from) : PlayerLeftEvent(nullptr, from) {}
  inline PlayerLeftEvent(PlayerLeftEvent&& from) noexcept
      : PlayerLeftEvent(nullptr, ::std::move(from)) {}
  inline PlayerLeftEvent& operator=(const PlayerLeftEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerLeftEvent& operator=(PlayerLeftEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerLeftEvent& default_instance() {
    return *reinterpret_cast<const PlayerLeftEvent*>(
        &_PlayerLeftEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 52;
  friend void swap(PlayerLeftEvent& a, PlayerLeftEvent& b) { a.Swap(&b); }
  inline void Swap(PlayerLeftEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerLeftEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerLeftEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerLeftEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerLeftEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerLeftEvent& from) { PlayerLeftEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerLeftEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.PlayerLeftEvent"; }

  explicit PlayerLeftEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerLeftEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerLeftEvent& from);
  PlayerLeftEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerLeftEvent&& from) noexcept
      : PlayerLeftEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerIdFieldNumber = 1,
    kCharacterIdFieldNumber = 2,
  };
  // string player_id = 1 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // string character_id = 2 [json_name = "characterId"];
  void clear_character_id() ;
  const ::std::string& character_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_character_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_character_id();
  void set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_character_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_character_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.PlayerLeftEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 64,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerLeftEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerLeftEvent_class_data_;
// -------------------------------------------------------------------

class PlayerDisconnectedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.PlayerDisconnectedEvent) */ {
 public:
  inline PlayerDisconnectedEvent() : PlayerDisconnectedEvent(nullptr) {}
  ~PlayerDisconnectedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerDisconnectedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerDisconnectedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerDisconnectedEvent(::google::protobuf::internal::ConstantInitialized);

  inline PlayerDisconnectedEvent(const PlayerDisconnectedEvent& from) : PlayerDisconnectedEvent(nullptr, from) {}
  inline PlayerDisconnectedEvent(PlayerDisconnectedEvent&& from) noexcept
      : PlayerDisconnectedEvent(nullptr, ::std::move(from)) {}
  inline PlayerDisconnectedEvent& operator=(const PlayerDisconnectedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerDisconnectedEvent& operator=(PlayerDisconnectedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerDisconnectedEvent& default_instance() {
    return *reinterpret_cast<const PlayerDisconnectedEvent*>(
        &_PlayerDisconnectedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 61;
  friend void swap(PlayerDisconnectedEvent& a, PlayerDisconnectedEvent& b) { a.Swap(&b); }
  inline void Swap(PlayerDisconnectedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerDisconnectedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerDisconnectedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerDisconnectedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerDisconnectedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerDisconnectedEvent& from) { PlayerDisconnectedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerDisconnectedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.PlayerDisconnectedEvent"; }

  explicit PlayerDisconnectedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerDisconnectedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerDisconnectedEvent& from);
  PlayerDisconnectedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerDisconnectedEvent&& from) noexcept
      : PlayerDisconnectedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerIdFieldNumber = 1,
    kCharacterIdFieldNumber = 2,
  };
  // string player_id = 1 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // string character_id = 2 [json_name = "characterId"];
  void clear_character_id() ;
  const ::std::string& character_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_character_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_character_id();
  void set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_character_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_character_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.PlayerDisconnectedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 72,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerDisconnectedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerDisconnectedEvent_class_data_;
// -------------------------------------------------------------------

class OpenDoorRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.OpenDoorRequest) */ {
 public:
  inline OpenDoorRequest() : OpenDoorRequest(nullptr) {}
  ~OpenDoorRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OpenDoorRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OpenDoorRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OpenDoorRequest(::google::protobuf::internal::ConstantInitialized);

  inline OpenDoorRequest(const OpenDoorRequest& from) : OpenDoorRequest(nullptr, from) {}
  inline OpenDoorRequest(OpenDoorRequest&& from) noexcept
      : OpenDoorRequest(nullptr, ::std::move(from)) {}
  inline OpenDoorRequest& operator=(const OpenDoorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenDoorRequest& operator=(OpenDoorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenDoorRequest& default_instance() {
    return *reinterpret_cast<const OpenDoorRequest*>(
        &_OpenDoorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(OpenDoorRequest& a, OpenDoorRequest& b) { a.Swap(&b); }
  inline void Swap(OpenDoorRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenDoorRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenDoorRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OpenDoorRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpenDoorRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OpenDoorRequest& from) { OpenDoorRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OpenDoorRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.OpenDoorRequest"; }

  explicit OpenDoorRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OpenDoorRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OpenDoorRequest& from);
  OpenDoorRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OpenDoorRequest&& from) noexcept
      : OpenDoorRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDungeonIdFieldNumber = 1,
    kConnectionIdFieldNumber = 2,
  };
  // string dungeon_id = 1 [json_name = "dungeonId"];
  void clear_dungeon_id() ;
  const ::std::string& dungeon_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dungeon_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dungeon_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dungeon_id();
  void set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dungeon_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dungeon_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dungeon_id();

  public:
  // string connection_id = 2 [json_name = "connectionId"];
  void clear_connection_id() ;
  const ::std::string& connection_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_connection_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_connection_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_connection_id();
  void set_allocated_connection_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_connection_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_connection_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_connection_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.OpenDoorRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 66,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OpenDoorRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dungeon_id_;
    ::google::protobuf::internal::ArenaStringPtr connection_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull OpenDoorRequest_class_data_;
// -------------------------------------------------------------------

class MovementError_DetailsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::std::string,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  MovementError_DetailsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MovementError_DetailsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit MovementError_DetailsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_MovementError_DetailsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 62,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull MovementError_DetailsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class MonsterCombatState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MonsterCombatState) */ {
 public:
  inline MonsterCombatState() : MonsterCombatState(nullptr) {}
  ~MonsterCombatState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MonsterCombatState* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MonsterCombatState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MonsterCombatState(::google::protobuf::internal::ConstantInitialized);

  inline MonsterCombatState(const MonsterCombatState& from) : MonsterCombatState(nullptr, from) {}
  inline MonsterCombatState(MonsterCombatState&& from) noexcept
      : MonsterCombatState(nullptr, ::std::move(from)) {}
  inline MonsterCombatState& operator=(const MonsterCombatState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterCombatState& operator=(MonsterCombatState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterCombatState& default_instance() {
    return *reinterpret_cast<const MonsterCombatState*>(
        &_MonsterCombatState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(MonsterCombatState& a, MonsterCombatState& b) { a.Swap(&b); }
  inline void Swap(MonsterCombatState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterCombatState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterCombatState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MonsterCombatState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MonsterCombatState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MonsterCombatState& from) { MonsterCombatState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MonsterCombatState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MonsterCombatState"; }

  explicit MonsterCombatState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MonsterCombatState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MonsterCombatState& from);
  MonsterCombatState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MonsterCombatState&& from) noexcept
      : MonsterCombatState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMonsterIdFieldNumber = 1,
    kMonsterNameFieldNumber = 2,
    kCurrentHitPointsFieldNumber = 3,
    kMaxHitPointsFieldNumber = 4,
    kMonsterTypeFieldNumber = 5,
  };
  // string monster_id = 1 [json_name = "monsterId"];
  void clear_monster_id() ;
  const ::std::string& monster_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_monster_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_monster_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_monster_id();
  void set_allocated_monster_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_monster_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_monster_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_monster_id();

  public:
  // string monster_name = 2 [json_name = "monsterName"];
  void clear_monster_name() ;
  const ::std::string& monster_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_monster_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_monster_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_monster_name();
  void set_allocated_monster_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_monster_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_monster_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_monster_name();

  public:
  // int32 current_hit_points = 3 [json_name = "currentHitPoints"];
  void clear_current_hit_points() ;
  ::int32_t current_hit_points() const;
  void set_current_hit_points(::int32_t value);

  private:
  ::int32_t _internal_current_hit_points() const;
  void _internal_set_current_hit_points(::int32_t value);

  public:
  // int32 max_hit_points = 4 [json_name = "maxHitPoints"];
  void clear_max_hit_points() ;
  ::int32_t max_hit_points() const;
  void set_max_hit_points(::int32_t value);

  private:
  ::int32_t _internal_max_hit_points() const;
  void _internal_set_max_hit_points(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.MonsterType monster_type = 5 [json_name = "monsterType"];
  void clear_monster_type() ;
  ::dnd5e::api::v1alpha1::MonsterType monster_type() const;
  void set_monster_type(::dnd5e::api::v1alpha1::MonsterType value);

  private:
  ::dnd5e::api::v1alpha1::MonsterType _internal_monster_type() const;
  void _internal_set_monster_type(::dnd5e::api::v1alpha1::MonsterType value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MonsterCombatState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 68,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MonsterCombatState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr monster_id_;
    ::google::protobuf::internal::ArenaStringPtr monster_name_;
    ::int32_t current_hit_points_;
    ::int32_t max_hit_points_;
    int monster_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MonsterCombatState_class_data_;
// -------------------------------------------------------------------

class LeaveEncounterResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.LeaveEncounterResponse) */ {
 public:
  inline LeaveEncounterResponse() : LeaveEncounterResponse(nullptr) {}
  ~LeaveEncounterResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LeaveEncounterResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LeaveEncounterResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LeaveEncounterResponse(::google::protobuf::internal::ConstantInitialized);

  inline LeaveEncounterResponse(const LeaveEncounterResponse& from) : LeaveEncounterResponse(nullptr, from) {}
  inline LeaveEncounterResponse(LeaveEncounterResponse&& from) noexcept
      : LeaveEncounterResponse(nullptr, ::std::move(from)) {}
  inline LeaveEncounterResponse& operator=(const LeaveEncounterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveEncounterResponse& operator=(LeaveEncounterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveEncounterResponse& default_instance() {
    return *reinterpret_cast<const LeaveEncounterResponse*>(
        &_LeaveEncounterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 48;
  friend void swap(LeaveEncounterResponse& a, LeaveEncounterResponse& b) { a.Swap(&b); }
  inline void Swap(LeaveEncounterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveEncounterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveEncounterResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LeaveEncounterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LeaveEncounterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LeaveEncounterResponse& from) { LeaveEncounterResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LeaveEncounterResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.LeaveEncounterResponse"; }

  explicit LeaveEncounterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LeaveEncounterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LeaveEncounterResponse& from);
  LeaveEncounterResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LeaveEncounterResponse&& from) noexcept
      : LeaveEncounterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.LeaveEncounterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LeaveEncounterResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LeaveEncounterResponse_class_data_;
// -------------------------------------------------------------------

class LeaveEncounterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.LeaveEncounterRequest) */ {
 public:
  inline LeaveEncounterRequest() : LeaveEncounterRequest(nullptr) {}
  ~LeaveEncounterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LeaveEncounterRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LeaveEncounterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LeaveEncounterRequest(::google::protobuf::internal::ConstantInitialized);

  inline LeaveEncounterRequest(const LeaveEncounterRequest& from) : LeaveEncounterRequest(nullptr, from) {}
  inline LeaveEncounterRequest(LeaveEncounterRequest&& from) noexcept
      : LeaveEncounterRequest(nullptr, ::std::move(from)) {}
  inline LeaveEncounterRequest& operator=(const LeaveEncounterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveEncounterRequest& operator=(LeaveEncounterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveEncounterRequest& default_instance() {
    return *reinterpret_cast<const LeaveEncounterRequest*>(
        &_LeaveEncounterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 47;
  friend void swap(LeaveEncounterRequest& a, LeaveEncounterRequest& b) { a.Swap(&b); }
  inline void Swap(LeaveEncounterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveEncounterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveEncounterRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LeaveEncounterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LeaveEncounterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LeaveEncounterRequest& from) { LeaveEncounterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LeaveEncounterRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.LeaveEncounterRequest"; }

  explicit LeaveEncounterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LeaveEncounterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LeaveEncounterRequest& from);
  LeaveEncounterRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LeaveEncounterRequest&& from) noexcept
      : LeaveEncounterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string player_id = 2 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.LeaveEncounterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 70,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LeaveEncounterRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LeaveEncounterRequest_class_data_;
// -------------------------------------------------------------------

class JoinEncounterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.JoinEncounterRequest) */ {
 public:
  inline JoinEncounterRequest() : JoinEncounterRequest(nullptr) {}
  ~JoinEncounterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(JoinEncounterRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(JoinEncounterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JoinEncounterRequest(::google::protobuf::internal::ConstantInitialized);

  inline JoinEncounterRequest(const JoinEncounterRequest& from) : JoinEncounterRequest(nullptr, from) {}
  inline JoinEncounterRequest(JoinEncounterRequest&& from) noexcept
      : JoinEncounterRequest(nullptr, ::std::move(from)) {}
  inline JoinEncounterRequest& operator=(const JoinEncounterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinEncounterRequest& operator=(JoinEncounterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinEncounterRequest& default_instance() {
    return *reinterpret_cast<const JoinEncounterRequest*>(
        &_JoinEncounterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(JoinEncounterRequest& a, JoinEncounterRequest& b) { a.Swap(&b); }
  inline void Swap(JoinEncounterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinEncounterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinEncounterRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<JoinEncounterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JoinEncounterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JoinEncounterRequest& from) { JoinEncounterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(JoinEncounterRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.JoinEncounterRequest"; }

  explicit JoinEncounterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  JoinEncounterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const JoinEncounterRequest& from);
  JoinEncounterRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, JoinEncounterRequest&& from) noexcept
      : JoinEncounterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterIdsFieldNumber = 2,
    kJoinCodeFieldNumber = 1,
  };
  // repeated string character_ids = 2 [json_name = "characterIds"];
  int character_ids_size() const;
  private:
  int _internal_character_ids_size() const;

  public:
  void clear_character_ids() ;
  const ::std::string& character_ids(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_character_ids(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_ids(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_character_ids();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_character_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& character_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_character_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_character_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_character_ids();

  public:
  // string join_code = 1 [json_name = "joinCode"];
  void clear_join_code() ;
  const ::std::string& join_code() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_join_code(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_join_code();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_join_code();
  void set_allocated_join_code(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_join_code() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_join_code(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_join_code();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.JoinEncounterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 70,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const JoinEncounterRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> character_ids_;
    ::google::protobuf::internal::ArenaStringPtr join_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull JoinEncounterRequest_class_data_;
// -------------------------------------------------------------------

class InitiativeEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.InitiativeEntry) */ {
 public:
  inline InitiativeEntry() : InitiativeEntry(nullptr) {}
  ~InitiativeEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InitiativeEntry* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InitiativeEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InitiativeEntry(::google::protobuf::internal::ConstantInitialized);

  inline InitiativeEntry(const InitiativeEntry& from) : InitiativeEntry(nullptr, from) {}
  inline InitiativeEntry(InitiativeEntry&& from) noexcept
      : InitiativeEntry(nullptr, ::std::move(from)) {}
  inline InitiativeEntry& operator=(const InitiativeEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitiativeEntry& operator=(InitiativeEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitiativeEntry& default_instance() {
    return *reinterpret_cast<const InitiativeEntry*>(
        &_InitiativeEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(InitiativeEntry& a, InitiativeEntry& b) { a.Swap(&b); }
  inline void Swap(InitiativeEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitiativeEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitiativeEntry* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InitiativeEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InitiativeEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InitiativeEntry& from) { InitiativeEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InitiativeEntry* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.InitiativeEntry"; }

  explicit InitiativeEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InitiativeEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InitiativeEntry& from);
  InitiativeEntry(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InitiativeEntry&& from) noexcept
      : InitiativeEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kEntityTypeFieldNumber = 2,
    kInitiativeFieldNumber = 3,
    kModifierFieldNumber = 4,
    kHasActedFieldNumber = 5,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // string entity_type = 2 [json_name = "entityType"];
  void clear_entity_type() ;
  const ::std::string& entity_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_type();
  void set_allocated_entity_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_type();

  public:
  // int32 initiative = 3 [json_name = "initiative"];
  void clear_initiative() ;
  ::int32_t initiative() const;
  void set_initiative(::int32_t value);

  private:
  ::int32_t _internal_initiative() const;
  void _internal_set_initiative(::int32_t value);

  public:
  // int32 modifier = 4 [json_name = "modifier"];
  void clear_modifier() ;
  ::int32_t modifier() const;
  void set_modifier(::int32_t value);

  private:
  ::int32_t _internal_modifier() const;
  void _internal_set_modifier(::int32_t value);

  public:
  // bool has_acted = 5 [json_name = "hasActed"];
  void clear_has_acted() ;
  bool has_acted() const;
  void set_has_acted(bool value);

  private:
  bool _internal_has_acted() const;
  void _internal_set_has_acted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.InitiativeEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 63,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InitiativeEntry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr entity_type_;
    ::int32_t initiative_;
    ::int32_t modifier_;
    bool has_acted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InitiativeEntry_class_data_;
// -------------------------------------------------------------------

class HealResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.HealResult) */ {
 public:
  inline HealResult() : HealResult(nullptr) {}
  ~HealResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HealResult* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HealResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HealResult(::google::protobuf::internal::ConstantInitialized);

  inline HealResult(const HealResult& from) : HealResult(nullptr, from) {}
  inline HealResult(HealResult&& from) noexcept
      : HealResult(nullptr, ::std::move(from)) {}
  inline HealResult& operator=(const HealResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealResult& operator=(HealResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealResult& default_instance() {
    return *reinterpret_cast<const HealResult*>(
        &_HealResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(HealResult& a, HealResult& b) { a.Swap(&b); }
  inline void Swap(HealResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HealResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HealResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HealResult& from) { HealResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HealResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.HealResult"; }

  explicit HealResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HealResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HealResult& from);
  HealResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HealResult&& from) noexcept
      : HealResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAmountHealedFieldNumber = 1,
    kNewHpFieldNumber = 2,
    kMaxHpFieldNumber = 3,
  };
  // int32 amount_healed = 1 [json_name = "amountHealed"];
  void clear_amount_healed() ;
  ::int32_t amount_healed() const;
  void set_amount_healed(::int32_t value);

  private:
  ::int32_t _internal_amount_healed() const;
  void _internal_set_amount_healed(::int32_t value);

  public:
  // int32 new_hp = 2 [json_name = "newHp"];
  void clear_new_hp() ;
  ::int32_t new_hp() const;
  void set_new_hp(::int32_t value);

  private:
  ::int32_t _internal_new_hp() const;
  void _internal_set_new_hp(::int32_t value);

  public:
  // int32 max_hp = 3 [json_name = "maxHp"];
  void clear_max_hp() ;
  ::int32_t max_hp() const;
  void set_max_hp(::int32_t value);

  private:
  ::int32_t _internal_max_hp() const;
  void _internal_set_max_hp(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.HealResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HealResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t amount_healed_;
    ::int32_t new_hp_;
    ::int32_t max_hp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HealResult_class_data_;
// -------------------------------------------------------------------

class GrantedAction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GrantedAction) */ {
 public:
  inline GrantedAction() : GrantedAction(nullptr) {}
  ~GrantedAction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GrantedAction* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GrantedAction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GrantedAction(::google::protobuf::internal::ConstantInitialized);

  inline GrantedAction(const GrantedAction& from) : GrantedAction(nullptr, from) {}
  inline GrantedAction(GrantedAction&& from) noexcept
      : GrantedAction(nullptr, ::std::move(from)) {}
  inline GrantedAction& operator=(const GrantedAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrantedAction& operator=(GrantedAction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrantedAction& default_instance() {
    return *reinterpret_cast<const GrantedAction*>(
        &_GrantedAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(GrantedAction& a, GrantedAction& b) { a.Swap(&b); }
  inline void Swap(GrantedAction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrantedAction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrantedAction* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GrantedAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GrantedAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GrantedAction& from) { GrantedAction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GrantedAction* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GrantedAction"; }

  explicit GrantedAction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GrantedAction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GrantedAction& from);
  GrantedAction(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GrantedAction&& from) noexcept
      : GrantedAction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kNameFieldNumber = 3,
    kReasonFieldNumber = 4,
    kWeaponIdFieldNumber = 5,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string type = 2 [json_name = "type"];
  void clear_type() ;
  const ::std::string& type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_type();
  void set_allocated_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_type();

  public:
  // string name = 3 [json_name = "name"];
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string reason = 4 [json_name = "reason"];
  void clear_reason() ;
  const ::std::string& reason() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_reason();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_reason();
  void set_allocated_reason(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_reason() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_reason();

  public:
  // string weapon_id = 5 [json_name = "weaponId"];
  void clear_weapon_id() ;
  const ::std::string& weapon_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_weapon_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_weapon_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_weapon_id();
  void set_allocated_weapon_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_weapon_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_weapon_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_weapon_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GrantedAction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 66,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GrantedAction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::google::protobuf::internal::ArenaStringPtr weapon_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GrantedAction_class_data_;
// -------------------------------------------------------------------

class GetEncounterStateRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetEncounterStateRequest) */ {
 public:
  inline GetEncounterStateRequest() : GetEncounterStateRequest(nullptr) {}
  ~GetEncounterStateRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetEncounterStateRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetEncounterStateRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetEncounterStateRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetEncounterStateRequest(const GetEncounterStateRequest& from) : GetEncounterStateRequest(nullptr, from) {}
  inline GetEncounterStateRequest(GetEncounterStateRequest&& from) noexcept
      : GetEncounterStateRequest(nullptr, ::std::move(from)) {}
  inline GetEncounterStateRequest& operator=(const GetEncounterStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEncounterStateRequest& operator=(GetEncounterStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEncounterStateRequest& default_instance() {
    return *reinterpret_cast<const GetEncounterStateRequest*>(
        &_GetEncounterStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(GetEncounterStateRequest& a, GetEncounterStateRequest& b) { a.Swap(&b); }
  inline void Swap(GetEncounterStateRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEncounterStateRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEncounterStateRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetEncounterStateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetEncounterStateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetEncounterStateRequest& from) { GetEncounterStateRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetEncounterStateRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetEncounterStateRequest"; }

  explicit GetEncounterStateRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetEncounterStateRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetEncounterStateRequest& from);
  GetEncounterStateRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetEncounterStateRequest&& from) noexcept
      : GetEncounterStateRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string player_id = 2 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetEncounterStateRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 73,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetEncounterStateRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetEncounterStateRequest_class_data_;
// -------------------------------------------------------------------

class GetEncounterHistoryRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetEncounterHistoryRequest) */ {
 public:
  inline GetEncounterHistoryRequest() : GetEncounterHistoryRequest(nullptr) {}
  ~GetEncounterHistoryRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetEncounterHistoryRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetEncounterHistoryRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetEncounterHistoryRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetEncounterHistoryRequest(const GetEncounterHistoryRequest& from) : GetEncounterHistoryRequest(nullptr, from) {}
  inline GetEncounterHistoryRequest(GetEncounterHistoryRequest&& from) noexcept
      : GetEncounterHistoryRequest(nullptr, ::std::move(from)) {}
  inline GetEncounterHistoryRequest& operator=(const GetEncounterHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEncounterHistoryRequest& operator=(GetEncounterHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEncounterHistoryRequest& default_instance() {
    return *reinterpret_cast<const GetEncounterHistoryRequest*>(
        &_GetEncounterHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(GetEncounterHistoryRequest& a, GetEncounterHistoryRequest& b) { a.Swap(&b); }
  inline void Swap(GetEncounterHistoryRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEncounterHistoryRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEncounterHistoryRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetEncounterHistoryRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetEncounterHistoryRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetEncounterHistoryRequest& from) { GetEncounterHistoryRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetEncounterHistoryRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetEncounterHistoryRequest"; }

  explicit GetEncounterHistoryRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetEncounterHistoryRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetEncounterHistoryRequest& from);
  GetEncounterHistoryRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetEncounterHistoryRequest&& from) noexcept
      : GetEncounterHistoryRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kUpToEventIdFieldNumber = 2,
    kLimitFieldNumber = 3,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string up_to_event_id = 2 [json_name = "upToEventId"];
  void clear_up_to_event_id() ;
  const ::std::string& up_to_event_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_up_to_event_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_up_to_event_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_up_to_event_id();
  void set_allocated_up_to_event_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_up_to_event_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_up_to_event_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_up_to_event_id();

  public:
  // int32 limit = 3 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetEncounterHistoryRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 80,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetEncounterHistoryRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr up_to_event_id_;
    ::int32_t limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetEncounterHistoryRequest_class_data_;
// -------------------------------------------------------------------

class GetCombatStateRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetCombatStateRequest) */ {
 public:
  inline GetCombatStateRequest() : GetCombatStateRequest(nullptr) {}
  ~GetCombatStateRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCombatStateRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCombatStateRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCombatStateRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetCombatStateRequest(const GetCombatStateRequest& from) : GetCombatStateRequest(nullptr, from) {}
  inline GetCombatStateRequest(GetCombatStateRequest&& from) noexcept
      : GetCombatStateRequest(nullptr, ::std::move(from)) {}
  inline GetCombatStateRequest& operator=(const GetCombatStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCombatStateRequest& operator=(GetCombatStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCombatStateRequest& default_instance() {
    return *reinterpret_cast<const GetCombatStateRequest*>(
        &_GetCombatStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(GetCombatStateRequest& a, GetCombatStateRequest& b) { a.Swap(&b); }
  inline void Swap(GetCombatStateRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCombatStateRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCombatStateRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCombatStateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCombatStateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCombatStateRequest& from) { GetCombatStateRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCombatStateRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetCombatStateRequest"; }

  explicit GetCombatStateRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCombatStateRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCombatStateRequest& from);
  GetCombatStateRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCombatStateRequest&& from) noexcept
      : GetCombatStateRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetCombatStateRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 61,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCombatStateRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCombatStateRequest_class_data_;
// -------------------------------------------------------------------

class EndTurnRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EndTurnRequest) */ {
 public:
  inline EndTurnRequest() : EndTurnRequest(nullptr) {}
  ~EndTurnRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EndTurnRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EndTurnRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EndTurnRequest(::google::protobuf::internal::ConstantInitialized);

  inline EndTurnRequest(const EndTurnRequest& from) : EndTurnRequest(nullptr, from) {}
  inline EndTurnRequest(EndTurnRequest&& from) noexcept
      : EndTurnRequest(nullptr, ::std::move(from)) {}
  inline EndTurnRequest& operator=(const EndTurnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndTurnRequest& operator=(EndTurnRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndTurnRequest& default_instance() {
    return *reinterpret_cast<const EndTurnRequest*>(
        &_EndTurnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(EndTurnRequest& a, EndTurnRequest& b) { a.Swap(&b); }
  inline void Swap(EndTurnRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndTurnRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndTurnRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EndTurnRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EndTurnRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EndTurnRequest& from) { EndTurnRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EndTurnRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EndTurnRequest"; }

  explicit EndTurnRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EndTurnRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EndTurnRequest& from);
  EndTurnRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EndTurnRequest&& from) noexcept
      : EndTurnRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kEntityIdFieldNumber = 2,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string entity_id = 2 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EndTurnRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 63,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EndTurnRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EndTurnRequest_class_data_;
// -------------------------------------------------------------------

class EncounterResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EncounterResult) */ {
 public:
  inline EncounterResult() : EncounterResult(nullptr) {}
  ~EncounterResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EncounterResult* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EncounterResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EncounterResult(::google::protobuf::internal::ConstantInitialized);

  inline EncounterResult(const EncounterResult& from) : EncounterResult(nullptr, from) {}
  inline EncounterResult(EncounterResult&& from) noexcept
      : EncounterResult(nullptr, ::std::move(from)) {}
  inline EncounterResult& operator=(const EncounterResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncounterResult& operator=(EncounterResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncounterResult& default_instance() {
    return *reinterpret_cast<const EncounterResult*>(
        &_EncounterResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(EncounterResult& a, EncounterResult& b) { a.Swap(&b); }
  inline void Swap(EncounterResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncounterResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncounterResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EncounterResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EncounterResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EncounterResult& from) { EncounterResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EncounterResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EncounterResult"; }

  explicit EncounterResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EncounterResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EncounterResult& from);
  EncounterResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EncounterResult&& from) noexcept
      : EncounterResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.EncounterEndReason reason = 1 [json_name = "reason"];
  void clear_reason() ;
  ::dnd5e::api::v1alpha1::EncounterEndReason reason() const;
  void set_reason(::dnd5e::api::v1alpha1::EncounterEndReason value);

  private:
  ::dnd5e::api::v1alpha1::EncounterEndReason _internal_reason() const;
  void _internal_set_reason(::dnd5e::api::v1alpha1::EncounterEndReason value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EncounterResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EncounterResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int reason_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EncounterResult_class_data_;
// -------------------------------------------------------------------

class DungeonVictoryEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DungeonVictoryEvent) */ {
 public:
  inline DungeonVictoryEvent() : DungeonVictoryEvent(nullptr) {}
  ~DungeonVictoryEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DungeonVictoryEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DungeonVictoryEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DungeonVictoryEvent(::google::protobuf::internal::ConstantInitialized);

  inline DungeonVictoryEvent(const DungeonVictoryEvent& from) : DungeonVictoryEvent(nullptr, from) {}
  inline DungeonVictoryEvent(DungeonVictoryEvent&& from) noexcept
      : DungeonVictoryEvent(nullptr, ::std::move(from)) {}
  inline DungeonVictoryEvent& operator=(const DungeonVictoryEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonVictoryEvent& operator=(DungeonVictoryEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonVictoryEvent& default_instance() {
    return *reinterpret_cast<const DungeonVictoryEvent*>(
        &_DungeonVictoryEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 66;
  friend void swap(DungeonVictoryEvent& a, DungeonVictoryEvent& b) { a.Swap(&b); }
  inline void Swap(DungeonVictoryEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonVictoryEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonVictoryEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DungeonVictoryEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DungeonVictoryEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DungeonVictoryEvent& from) { DungeonVictoryEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DungeonVictoryEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DungeonVictoryEvent"; }

  explicit DungeonVictoryEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DungeonVictoryEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DungeonVictoryEvent& from);
  DungeonVictoryEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DungeonVictoryEvent&& from) noexcept
      : DungeonVictoryEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDungeonIdFieldNumber = 1,
    kRoomsClearedFieldNumber = 2,
    kDungeonStateFieldNumber = 3,
  };
  // string dungeon_id = 1 [json_name = "dungeonId"];
  void clear_dungeon_id() ;
  const ::std::string& dungeon_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dungeon_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dungeon_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dungeon_id();
  void set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dungeon_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dungeon_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dungeon_id();

  public:
  // int32 rooms_cleared = 2 [json_name = "roomsCleared"];
  void clear_rooms_cleared() ;
  ::int32_t rooms_cleared() const;
  void set_rooms_cleared(::int32_t value);

  private:
  ::int32_t _internal_rooms_cleared() const;
  void _internal_set_rooms_cleared(::int32_t value);

  public:
  // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 3 [json_name = "dungeonState"];
  void clear_dungeon_state() ;
  ::dnd5e::api::v1alpha1::DungeonState dungeon_state() const;
  void set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value);

  private:
  ::dnd5e::api::v1alpha1::DungeonState _internal_dungeon_state() const;
  void _internal_set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DungeonVictoryEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 57,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DungeonVictoryEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dungeon_id_;
    ::int32_t rooms_cleared_;
    int dungeon_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DungeonVictoryEvent_class_data_;
// -------------------------------------------------------------------

class DungeonStartRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DungeonStartRequest) */ {
 public:
  inline DungeonStartRequest() : DungeonStartRequest(nullptr) {}
  ~DungeonStartRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DungeonStartRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DungeonStartRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DungeonStartRequest(::google::protobuf::internal::ConstantInitialized);

  inline DungeonStartRequest(const DungeonStartRequest& from) : DungeonStartRequest(nullptr, from) {}
  inline DungeonStartRequest(DungeonStartRequest&& from) noexcept
      : DungeonStartRequest(nullptr, ::std::move(from)) {}
  inline DungeonStartRequest& operator=(const DungeonStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonStartRequest& operator=(DungeonStartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonStartRequest& default_instance() {
    return *reinterpret_cast<const DungeonStartRequest*>(
        &_DungeonStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(DungeonStartRequest& a, DungeonStartRequest& b) { a.Swap(&b); }
  inline void Swap(DungeonStartRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonStartRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonStartRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DungeonStartRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DungeonStartRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DungeonStartRequest& from) { DungeonStartRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DungeonStartRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DungeonStartRequest"; }

  explicit DungeonStartRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DungeonStartRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DungeonStartRequest& from);
  DungeonStartRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DungeonStartRequest&& from) noexcept
      : DungeonStartRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterIdsFieldNumber = 1,
    kThemeFieldNumber = 2,
    kDifficultyFieldNumber = 3,
    kLengthFieldNumber = 4,
  };
  // repeated string character_ids = 1 [json_name = "characterIds"];
  int character_ids_size() const;
  private:
  int _internal_character_ids_size() const;

  public:
  void clear_character_ids() ;
  const ::std::string& character_ids(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_character_ids(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_ids(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_character_ids();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_character_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& character_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_character_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_character_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_character_ids();

  public:
  // .dnd5e.api.v1alpha1.DungeonTheme theme = 2 [json_name = "theme"];
  void clear_theme() ;
  ::dnd5e::api::v1alpha1::DungeonTheme theme() const;
  void set_theme(::dnd5e::api::v1alpha1::DungeonTheme value);

  private:
  ::dnd5e::api::v1alpha1::DungeonTheme _internal_theme() const;
  void _internal_set_theme(::dnd5e::api::v1alpha1::DungeonTheme value);

  public:
  // .dnd5e.api.v1alpha1.DungeonDifficulty difficulty = 3 [json_name = "difficulty"];
  void clear_difficulty() ;
  ::dnd5e::api::v1alpha1::DungeonDifficulty difficulty() const;
  void set_difficulty(::dnd5e::api::v1alpha1::DungeonDifficulty value);

  private:
  ::dnd5e::api::v1alpha1::DungeonDifficulty _internal_difficulty() const;
  void _internal_set_difficulty(::dnd5e::api::v1alpha1::DungeonDifficulty value);

  public:
  // .dnd5e.api.v1alpha1.DungeonLength length = 4 [json_name = "length"];
  void clear_length() ;
  ::dnd5e::api::v1alpha1::DungeonLength length() const;
  void set_length(::dnd5e::api::v1alpha1::DungeonLength value);

  private:
  ::dnd5e::api::v1alpha1::DungeonLength _internal_length() const;
  void _internal_set_length(::dnd5e::api::v1alpha1::DungeonLength value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DungeonStartRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DungeonStartRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> character_ids_;
    int theme_;
    int difficulty_;
    int length_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DungeonStartRequest_class_data_;
// -------------------------------------------------------------------

class DungeonFailureEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DungeonFailureEvent) */ {
 public:
  inline DungeonFailureEvent() : DungeonFailureEvent(nullptr) {}
  ~DungeonFailureEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DungeonFailureEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DungeonFailureEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DungeonFailureEvent(::google::protobuf::internal::ConstantInitialized);

  inline DungeonFailureEvent(const DungeonFailureEvent& from) : DungeonFailureEvent(nullptr, from) {}
  inline DungeonFailureEvent(DungeonFailureEvent&& from) noexcept
      : DungeonFailureEvent(nullptr, ::std::move(from)) {}
  inline DungeonFailureEvent& operator=(const DungeonFailureEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonFailureEvent& operator=(DungeonFailureEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonFailureEvent& default_instance() {
    return *reinterpret_cast<const DungeonFailureEvent*>(
        &_DungeonFailureEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 67;
  friend void swap(DungeonFailureEvent& a, DungeonFailureEvent& b) { a.Swap(&b); }
  inline void Swap(DungeonFailureEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonFailureEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonFailureEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DungeonFailureEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DungeonFailureEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DungeonFailureEvent& from) { DungeonFailureEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DungeonFailureEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DungeonFailureEvent"; }

  explicit DungeonFailureEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DungeonFailureEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DungeonFailureEvent& from);
  DungeonFailureEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DungeonFailureEvent&& from) noexcept
      : DungeonFailureEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDungeonIdFieldNumber = 1,
    kFinalRoomIdFieldNumber = 2,
    kDungeonStateFieldNumber = 3,
  };
  // string dungeon_id = 1 [json_name = "dungeonId"];
  void clear_dungeon_id() ;
  const ::std::string& dungeon_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dungeon_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dungeon_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dungeon_id();
  void set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dungeon_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dungeon_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dungeon_id();

  public:
  // string final_room_id = 2 [json_name = "finalRoomId"];
  void clear_final_room_id() ;
  const ::std::string& final_room_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_final_room_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_final_room_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_final_room_id();
  void set_allocated_final_room_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_final_room_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_final_room_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_final_room_id();

  public:
  // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 3 [json_name = "dungeonState"];
  void clear_dungeon_state() ;
  ::dnd5e::api::v1alpha1::DungeonState dungeon_state() const;
  void set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value);

  private:
  ::dnd5e::api::v1alpha1::DungeonState _internal_dungeon_state() const;
  void _internal_set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DungeonFailureEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 70,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DungeonFailureEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dungeon_id_;
    ::google::protobuf::internal::ArenaStringPtr final_room_id_;
    int dungeon_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DungeonFailureEvent_class_data_;
// -------------------------------------------------------------------

class CreateEncounterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CreateEncounterRequest) */ {
 public:
  inline CreateEncounterRequest() : CreateEncounterRequest(nullptr) {}
  ~CreateEncounterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateEncounterRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateEncounterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateEncounterRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateEncounterRequest(const CreateEncounterRequest& from) : CreateEncounterRequest(nullptr, from) {}
  inline CreateEncounterRequest(CreateEncounterRequest&& from) noexcept
      : CreateEncounterRequest(nullptr, ::std::move(from)) {}
  inline CreateEncounterRequest& operator=(const CreateEncounterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEncounterRequest& operator=(CreateEncounterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEncounterRequest& default_instance() {
    return *reinterpret_cast<const CreateEncounterRequest*>(
        &_CreateEncounterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(CreateEncounterRequest& a, CreateEncounterRequest& b) { a.Swap(&b); }
  inline void Swap(CreateEncounterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEncounterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateEncounterRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateEncounterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateEncounterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateEncounterRequest& from) { CreateEncounterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateEncounterRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CreateEncounterRequest"; }

  explicit CreateEncounterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreateEncounterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreateEncounterRequest& from);
  CreateEncounterRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreateEncounterRequest&& from) noexcept
      : CreateEncounterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterIdsFieldNumber = 1,
  };
  // repeated string character_ids = 1 [json_name = "characterIds"];
  int character_ids_size() const;
  private:
  int _internal_character_ids_size() const;

  public:
  void clear_character_ids() ;
  const ::std::string& character_ids(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_character_ids(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_ids(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_character_ids();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_character_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& character_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_character_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_character_ids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_character_ids();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CreateEncounterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 63,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CreateEncounterRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> character_ids_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreateEncounterRequest_class_data_;
// -------------------------------------------------------------------

class CombatPausedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CombatPausedEvent) */ {
 public:
  inline CombatPausedEvent() : CombatPausedEvent(nullptr) {}
  ~CombatPausedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CombatPausedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CombatPausedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CombatPausedEvent(::google::protobuf::internal::ConstantInitialized);

  inline CombatPausedEvent(const CombatPausedEvent& from) : CombatPausedEvent(nullptr, from) {}
  inline CombatPausedEvent(CombatPausedEvent&& from) noexcept
      : CombatPausedEvent(nullptr, ::std::move(from)) {}
  inline CombatPausedEvent& operator=(const CombatPausedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombatPausedEvent& operator=(CombatPausedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombatPausedEvent& default_instance() {
    return *reinterpret_cast<const CombatPausedEvent*>(
        &_CombatPausedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 63;
  friend void swap(CombatPausedEvent& a, CombatPausedEvent& b) { a.Swap(&b); }
  inline void Swap(CombatPausedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombatPausedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombatPausedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CombatPausedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CombatPausedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CombatPausedEvent& from) { CombatPausedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CombatPausedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CombatPausedEvent"; }

  explicit CombatPausedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CombatPausedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CombatPausedEvent& from);
  CombatPausedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CombatPausedEvent&& from) noexcept
      : CombatPausedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 1,
    kDisconnectedPlayerIdFieldNumber = 2,
  };
  // string reason = 1 [json_name = "reason"];
  void clear_reason() ;
  const ::std::string& reason() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_reason();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_reason();
  void set_allocated_reason(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_reason() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_reason();

  public:
  // string disconnected_player_id = 2 [json_name = "disconnectedPlayerId"];
  void clear_disconnected_player_id() ;
  const ::std::string& disconnected_player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_disconnected_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_disconnected_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_disconnected_player_id();
  void set_allocated_disconnected_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_disconnected_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_disconnected_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_disconnected_player_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CombatPausedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 73,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CombatPausedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::google::protobuf::internal::ArenaStringPtr disconnected_player_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CombatPausedEvent_class_data_;
// -------------------------------------------------------------------

class AttackRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AttackRequest) */ {
 public:
  inline AttackRequest() : AttackRequest(nullptr) {}
  ~AttackRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackRequest(::google::protobuf::internal::ConstantInitialized);

  inline AttackRequest(const AttackRequest& from) : AttackRequest(nullptr, from) {}
  inline AttackRequest(AttackRequest&& from) noexcept
      : AttackRequest(nullptr, ::std::move(from)) {}
  inline AttackRequest& operator=(const AttackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackRequest& operator=(AttackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackRequest& default_instance() {
    return *reinterpret_cast<const AttackRequest*>(
        &_AttackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(AttackRequest& a, AttackRequest& b) { a.Swap(&b); }
  inline void Swap(AttackRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackRequest& from) { AttackRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AttackRequest"; }

  explicit AttackRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AttackRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AttackRequest& from);
  AttackRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AttackRequest&& from) noexcept
      : AttackRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kAttackerIdFieldNumber = 2,
    kTargetIdFieldNumber = 3,
    kWeaponIdFieldNumber = 4,
    kAttackHandFieldNumber = 5,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string attacker_id = 2 [json_name = "attackerId"];
  void clear_attacker_id() ;
  const ::std::string& attacker_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_attacker_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_attacker_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_attacker_id();
  void set_allocated_attacker_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_attacker_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_attacker_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_attacker_id();

  public:
  // string target_id = 3 [json_name = "targetId"];
  void clear_target_id() ;
  const ::std::string& target_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_target_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_target_id();
  void set_allocated_target_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_target_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_target_id();

  public:
  // string weapon_id = 4 [json_name = "weaponId"];
  void clear_weapon_id() ;
  const ::std::string& weapon_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_weapon_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_weapon_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_weapon_id();
  void set_allocated_weapon_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_weapon_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_weapon_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_weapon_id();

  public:
  // .dnd5e.api.v1alpha1.AttackHand attack_hand = 5 [json_name = "attackHand"];
  void clear_attack_hand() ;
  ::dnd5e::api::v1alpha1::AttackHand attack_hand() const;
  void set_attack_hand(::dnd5e::api::v1alpha1::AttackHand value);

  private:
  ::dnd5e::api::v1alpha1::AttackHand _internal_attack_hand() const;
  void _internal_set_attack_hand(::dnd5e::api::v1alpha1::AttackHand value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AttackRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 82,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AttackRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr attacker_id_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    ::google::protobuf::internal::ArenaStringPtr weapon_id_;
    int attack_hand_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AttackRequest_class_data_;
// -------------------------------------------------------------------

class ActivateFeatureRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ActivateFeatureRequest) */ {
 public:
  inline ActivateFeatureRequest() : ActivateFeatureRequest(nullptr) {}
  ~ActivateFeatureRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActivateFeatureRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActivateFeatureRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActivateFeatureRequest(::google::protobuf::internal::ConstantInitialized);

  inline ActivateFeatureRequest(const ActivateFeatureRequest& from) : ActivateFeatureRequest(nullptr, from) {}
  inline ActivateFeatureRequest(ActivateFeatureRequest&& from) noexcept
      : ActivateFeatureRequest(nullptr, ::std::move(from)) {}
  inline ActivateFeatureRequest& operator=(const ActivateFeatureRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivateFeatureRequest& operator=(ActivateFeatureRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivateFeatureRequest& default_instance() {
    return *reinterpret_cast<const ActivateFeatureRequest*>(
        &_ActivateFeatureRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(ActivateFeatureRequest& a, ActivateFeatureRequest& b) { a.Swap(&b); }
  inline void Swap(ActivateFeatureRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivateFeatureRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivateFeatureRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActivateFeatureRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActivateFeatureRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActivateFeatureRequest& from) { ActivateFeatureRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActivateFeatureRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ActivateFeatureRequest"; }

  explicit ActivateFeatureRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ActivateFeatureRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ActivateFeatureRequest& from);
  ActivateFeatureRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ActivateFeatureRequest&& from) noexcept
      : ActivateFeatureRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kCharacterIdFieldNumber = 2,
    kFeatureIdFieldNumber = 3,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string character_id = 2 [json_name = "characterId"];
  void clear_character_id() ;
  const ::std::string& character_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_character_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_character_id();
  void set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_character_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_character_id();

  public:
  // .dnd5e.api.v1alpha1.FeatureId feature_id = 3 [json_name = "featureId"];
  void clear_feature_id() ;
  ::dnd5e::api::v1alpha1::FeatureId feature_id() const;
  void set_feature_id(::dnd5e::api::v1alpha1::FeatureId value);

  private:
  ::dnd5e::api::v1alpha1::FeatureId _internal_feature_id() const;
  void _internal_set_feature_id(::dnd5e::api::v1alpha1::FeatureId value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ActivateFeatureRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 74,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ActivateFeatureRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    int feature_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ActivateFeatureRequest_class_data_;
// -------------------------------------------------------------------

class TurnState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.TurnState) */ {
 public:
  inline TurnState() : TurnState(nullptr) {}
  ~TurnState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TurnState* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TurnState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TurnState(::google::protobuf::internal::ConstantInitialized);

  inline TurnState(const TurnState& from) : TurnState(nullptr, from) {}
  inline TurnState(TurnState&& from) noexcept
      : TurnState(nullptr, ::std::move(from)) {}
  inline TurnState& operator=(const TurnState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnState& operator=(TurnState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnState& default_instance() {
    return *reinterpret_cast<const TurnState*>(
        &_TurnState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(TurnState& a, TurnState& b) { a.Swap(&b); }
  inline void Swap(TurnState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TurnState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TurnState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TurnState& from) { TurnState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TurnState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.TurnState"; }

  explicit TurnState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TurnState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TurnState& from);
  TurnState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TurnState&& from) noexcept
      : TurnState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kPositionFieldNumber = 7,
    kMovementUsedFieldNumber = 2,
    kMovementMaxFieldNumber = 3,
    kActionUsedFieldNumber = 4,
    kBonusActionUsedFieldNumber = 5,
    kReactionAvailableFieldNumber = 6,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // .api.v1alpha1.Position position = 7 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::api::v1alpha1::Position& position() const;
  [[nodiscard]] ::api::v1alpha1::Position* PROTOBUF_NULLABLE release_position();
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  ::api::v1alpha1::Position* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::api::v1alpha1::Position& _internal_position() const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // int32 movement_used = 2 [json_name = "movementUsed"];
  void clear_movement_used() ;
  ::int32_t movement_used() const;
  void set_movement_used(::int32_t value);

  private:
  ::int32_t _internal_movement_used() const;
  void _internal_set_movement_used(::int32_t value);

  public:
  // int32 movement_max = 3 [json_name = "movementMax"];
  void clear_movement_max() ;
  ::int32_t movement_max() const;
  void set_movement_max(::int32_t value);

  private:
  ::int32_t _internal_movement_max() const;
  void _internal_set_movement_max(::int32_t value);

  public:
  // bool action_used = 4 [json_name = "actionUsed"];
  void clear_action_used() ;
  bool action_used() const;
  void set_action_used(bool value);

  private:
  bool _internal_action_used() const;
  void _internal_set_action_used(bool value);

  public:
  // bool bonus_action_used = 5 [json_name = "bonusActionUsed"];
  void clear_bonus_action_used() ;
  bool bonus_action_used() const;
  void set_bonus_action_used(bool value);

  private:
  bool _internal_bonus_action_used() const;
  void _internal_set_bonus_action_used(bool value);

  public:
  // bool reaction_available = 6 [json_name = "reactionAvailable"];
  void clear_reaction_available() ;
  bool reaction_available() const;
  void set_reaction_available(bool value);

  private:
  bool _internal_reaction_available() const;
  void _internal_set_reaction_available(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.TurnState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   1, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TurnState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE position_;
    ::int32_t movement_used_;
    ::int32_t movement_max_;
    bool action_used_;
    bool bonus_action_used_;
    bool reaction_available_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TurnState_class_data_;
// -------------------------------------------------------------------

class MovementError final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MovementError) */ {
 public:
  inline MovementError() : MovementError(nullptr) {}
  ~MovementError() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MovementError* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MovementError));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MovementError(::google::protobuf::internal::ConstantInitialized);

  inline MovementError(const MovementError& from) : MovementError(nullptr, from) {}
  inline MovementError(MovementError&& from) noexcept
      : MovementError(nullptr, ::std::move(from)) {}
  inline MovementError& operator=(const MovementError& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovementError& operator=(MovementError&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovementError& default_instance() {
    return *reinterpret_cast<const MovementError*>(
        &_MovementError_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(MovementError& a, MovementError& b) { a.Swap(&b); }
  inline void Swap(MovementError* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovementError* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MovementError* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MovementError>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MovementError& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MovementError& from) { MovementError::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MovementError* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MovementError"; }

  explicit MovementError(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MovementError(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MovementError& from);
  MovementError(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MovementError&& from) noexcept
      : MovementError(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ErrorCode = MovementError_ErrorCode;
  static constexpr ErrorCode ERROR_CODE_UNSPECIFIED = MovementError_ErrorCode_ERROR_CODE_UNSPECIFIED;
  static constexpr ErrorCode ERROR_CODE_INVALID_POSITION = MovementError_ErrorCode_ERROR_CODE_INVALID_POSITION;
  static constexpr ErrorCode ERROR_CODE_INSUFFICIENT_MOVEMENT = MovementError_ErrorCode_ERROR_CODE_INSUFFICIENT_MOVEMENT;
  static constexpr ErrorCode ERROR_CODE_PATH_BLOCKED = MovementError_ErrorCode_ERROR_CODE_PATH_BLOCKED;
  static constexpr ErrorCode ERROR_CODE_POSITION_OCCUPIED = MovementError_ErrorCode_ERROR_CODE_POSITION_OCCUPIED;
  static constexpr ErrorCode ERROR_CODE_OUT_OF_BOUNDS = MovementError_ErrorCode_ERROR_CODE_OUT_OF_BOUNDS;
  static constexpr ErrorCode ERROR_CODE_NOT_YOUR_TURN = MovementError_ErrorCode_ERROR_CODE_NOT_YOUR_TURN;
  static inline bool ErrorCode_IsValid(int value) {
    return MovementError_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN = MovementError_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX = MovementError_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE = MovementError_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ErrorCode_descriptor() {
    return MovementError_ErrorCode_descriptor();
  }
  template <typename T>
  static inline const ::std::string& ErrorCode_Name(T value) {
    return MovementError_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(
      ::absl::string_view name, ErrorCode* PROTOBUF_NONNULL value) {
    return MovementError_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
    kDetailsFieldNumber = 3,
  };
  // string message = 2 [json_name = "message"];
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // .dnd5e.api.v1alpha1.MovementError.ErrorCode code = 1 [json_name = "code"];
  void clear_code() ;
  ::dnd5e::api::v1alpha1::MovementError_ErrorCode code() const;
  void set_code(::dnd5e::api::v1alpha1::MovementError_ErrorCode value);

  private:
  ::dnd5e::api::v1alpha1::MovementError_ErrorCode _internal_code() const;
  void _internal_set_code(::dnd5e::api::v1alpha1::MovementError_ErrorCode value);

  public:
  // map<string, string> details = 3 [json_name = "details"];
  int details_size() const;
  private:
  int _internal_details_size() const;

  public:
  void clear_details() ;
  const ::google::protobuf::Map<::std::string, ::std::string>& details() const;
  ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL mutable_details();

  private:
  const ::google::protobuf::Map<::std::string, ::std::string>& _internal_details() const;
  ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL _internal_mutable_details();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MovementError)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 3,
                                   1, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MovementError& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    int code_;
    ::google::protobuf::internal::MapField<MovementError_DetailsEntry_DoNotUse, ::std::string, ::std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        details_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MovementError_class_data_;
// -------------------------------------------------------------------

class MoveCharacterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MoveCharacterRequest) */ {
 public:
  inline MoveCharacterRequest() : MoveCharacterRequest(nullptr) {}
  ~MoveCharacterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MoveCharacterRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MoveCharacterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveCharacterRequest(::google::protobuf::internal::ConstantInitialized);

  inline MoveCharacterRequest(const MoveCharacterRequest& from) : MoveCharacterRequest(nullptr, from) {}
  inline MoveCharacterRequest(MoveCharacterRequest&& from) noexcept
      : MoveCharacterRequest(nullptr, ::std::move(from)) {}
  inline MoveCharacterRequest& operator=(const MoveCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveCharacterRequest& operator=(MoveCharacterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveCharacterRequest& default_instance() {
    return *reinterpret_cast<const MoveCharacterRequest*>(
        &_MoveCharacterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(MoveCharacterRequest& a, MoveCharacterRequest& b) { a.Swap(&b); }
  inline void Swap(MoveCharacterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveCharacterRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveCharacterRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MoveCharacterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveCharacterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveCharacterRequest& from) { MoveCharacterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MoveCharacterRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MoveCharacterRequest"; }

  explicit MoveCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MoveCharacterRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MoveCharacterRequest& from);
  MoveCharacterRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MoveCharacterRequest&& from) noexcept
      : MoveCharacterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 3,
    kEncounterIdFieldNumber = 1,
    kEntityIdFieldNumber = 2,
  };
  // repeated .api.v1alpha1.Position path = 3 [json_name = "path"];
  int path_size() const;
  private:
  int _internal_path_size() const;

  public:
  void clear_path() ;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_path(int index);
  ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL mutable_path();

  private:
  const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>& _internal_path() const;
  ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL _internal_mutable_path();
  public:
  const ::api::v1alpha1::Position& path(int index) const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL add_path();
  const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>& path() const;
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string entity_id = 2 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MoveCharacterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 69,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MoveCharacterRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::api::v1alpha1::Position > path_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MoveCharacterRequest_class_data_;
// -------------------------------------------------------------------

class EntityPlacement final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EntityPlacement) */ {
 public:
  inline EntityPlacement() : EntityPlacement(nullptr) {}
  ~EntityPlacement() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EntityPlacement* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EntityPlacement));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntityPlacement(::google::protobuf::internal::ConstantInitialized);

  inline EntityPlacement(const EntityPlacement& from) : EntityPlacement(nullptr, from) {}
  inline EntityPlacement(EntityPlacement&& from) noexcept
      : EntityPlacement(nullptr, ::std::move(from)) {}
  inline EntityPlacement& operator=(const EntityPlacement& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityPlacement& operator=(EntityPlacement&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityPlacement& default_instance() {
    return *reinterpret_cast<const EntityPlacement*>(
        &_EntityPlacement_default_instance_);
  }
  enum VisualTypeCase {
    kMonsterType = 7,
    kObstacleType = 8,
    VISUAL_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(EntityPlacement& a, EntityPlacement& b) { a.Swap(&b); }
  inline void Swap(EntityPlacement* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityPlacement* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityPlacement* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EntityPlacement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntityPlacement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntityPlacement& from) { EntityPlacement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EntityPlacement* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EntityPlacement"; }

  explicit EntityPlacement(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EntityPlacement(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EntityPlacement& from);
  EntityPlacement(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EntityPlacement&& from) noexcept
      : EntityPlacement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kPositionFieldNumber = 3,
    kEntityTypeFieldNumber = 2,
    kSizeFieldNumber = 4,
    kBlocksMovementFieldNumber = 5,
    kBlocksLineOfSightFieldNumber = 6,
    kMonsterTypeFieldNumber = 7,
    kObstacleTypeFieldNumber = 8,
  };
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // .api.v1alpha1.Position position = 3 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::api::v1alpha1::Position& position() const;
  [[nodiscard]] ::api::v1alpha1::Position* PROTOBUF_NULLABLE release_position();
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  ::api::v1alpha1::Position* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::api::v1alpha1::Position& _internal_position() const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // .dnd5e.api.v1alpha1.EntityType entity_type = 2 [json_name = "entityType"];
  void clear_entity_type() ;
  ::dnd5e::api::v1alpha1::EntityType entity_type() const;
  void set_entity_type(::dnd5e::api::v1alpha1::EntityType value);

  private:
  ::dnd5e::api::v1alpha1::EntityType _internal_entity_type() const;
  void _internal_set_entity_type(::dnd5e::api::v1alpha1::EntityType value);

  public:
  // .dnd5e.api.v1alpha1.EntitySize size = 4 [json_name = "size"];
  void clear_size() ;
  ::dnd5e::api::v1alpha1::EntitySize size() const;
  void set_size(::dnd5e::api::v1alpha1::EntitySize value);

  private:
  ::dnd5e::api::v1alpha1::EntitySize _internal_size() const;
  void _internal_set_size(::dnd5e::api::v1alpha1::EntitySize value);

  public:
  // bool blocks_movement = 5 [json_name = "blocksMovement"];
  void clear_blocks_movement() ;
  bool blocks_movement() const;
  void set_blocks_movement(bool value);

  private:
  bool _internal_blocks_movement() const;
  void _internal_set_blocks_movement(bool value);

  public:
  // bool blocks_line_of_sight = 6 [json_name = "blocksLineOfSight"];
  void clear_blocks_line_of_sight() ;
  bool blocks_line_of_sight() const;
  void set_blocks_line_of_sight(bool value);

  private:
  bool _internal_blocks_line_of_sight() const;
  void _internal_set_blocks_line_of_sight(bool value);

  public:
  // .dnd5e.api.v1alpha1.MonsterType monster_type = 7 [json_name = "monsterType"];
  bool has_monster_type() const;
  void clear_monster_type() ;
  ::dnd5e::api::v1alpha1::MonsterType monster_type() const;
  void set_monster_type(::dnd5e::api::v1alpha1::MonsterType value);

  private:
  ::dnd5e::api::v1alpha1::MonsterType _internal_monster_type() const;
  void _internal_set_monster_type(::dnd5e::api::v1alpha1::MonsterType value);

  public:
  // .dnd5e.api.v1alpha1.ObstacleType obstacle_type = 8 [json_name = "obstacleType"];
  bool has_obstacle_type() const;
  void clear_obstacle_type() ;
  ::dnd5e::api::v1alpha1::ObstacleType obstacle_type() const;
  void set_obstacle_type(::dnd5e::api::v1alpha1::ObstacleType value);

  private:
  ::dnd5e::api::v1alpha1::ObstacleType _internal_obstacle_type() const;
  void _internal_set_obstacle_type(::dnd5e::api::v1alpha1::ObstacleType value);

  public:
  void clear_visual_type();
  VisualTypeCase visual_type_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EntityPlacement)
 private:
  class _Internal;
  void set_has_monster_type();
  void set_has_obstacle_type();
  inline bool has_visual_type() const;
  inline void clear_has_visual_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   1, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EntityPlacement& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE position_;
    int entity_type_;
    int size_;
    bool blocks_movement_;
    bool blocks_line_of_sight_;
    union VisualTypeUnion {
      constexpr VisualTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int monster_type_;
      int obstacle_type_;
    } visual_type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EntityPlacement_class_data_;
// -------------------------------------------------------------------

class DoorInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DoorInfo) */ {
 public:
  inline DoorInfo() : DoorInfo(nullptr) {}
  ~DoorInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DoorInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DoorInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DoorInfo(::google::protobuf::internal::ConstantInitialized);

  inline DoorInfo(const DoorInfo& from) : DoorInfo(nullptr, from) {}
  inline DoorInfo(DoorInfo&& from) noexcept
      : DoorInfo(nullptr, ::std::move(from)) {}
  inline DoorInfo& operator=(const DoorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoorInfo& operator=(DoorInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoorInfo& default_instance() {
    return *reinterpret_cast<const DoorInfo*>(
        &_DoorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(DoorInfo& a, DoorInfo& b) { a.Swap(&b); }
  inline void Swap(DoorInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoorInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoorInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DoorInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoorInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DoorInfo& from) { DoorInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DoorInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DoorInfo"; }

  explicit DoorInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DoorInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DoorInfo& from);
  DoorInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DoorInfo&& from) noexcept
      : DoorInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConnectionIdFieldNumber = 1,
    kPhysicalHintFieldNumber = 3,
    kLeadsToRoomIdFieldNumber = 5,
    kPositionFieldNumber = 2,
    kIsOpenFieldNumber = 4,
  };
  // string connection_id = 1 [json_name = "connectionId"];
  void clear_connection_id() ;
  const ::std::string& connection_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_connection_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_connection_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_connection_id();
  void set_allocated_connection_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_connection_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_connection_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_connection_id();

  public:
  // string physical_hint = 3 [json_name = "physicalHint"];
  void clear_physical_hint() ;
  const ::std::string& physical_hint() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_physical_hint(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_physical_hint();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_physical_hint();
  void set_allocated_physical_hint(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_physical_hint() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_physical_hint(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_physical_hint();

  public:
  // string leads_to_room_id = 5 [json_name = "leadsToRoomId"];
  void clear_leads_to_room_id() ;
  const ::std::string& leads_to_room_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_leads_to_room_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_leads_to_room_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_leads_to_room_id();
  void set_allocated_leads_to_room_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_leads_to_room_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_leads_to_room_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_leads_to_room_id();

  public:
  // .api.v1alpha1.Position position = 2 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::api::v1alpha1::Position& position() const;
  [[nodiscard]] ::api::v1alpha1::Position* PROTOBUF_NULLABLE release_position();
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  ::api::v1alpha1::Position* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::api::v1alpha1::Position& _internal_position() const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // bool is_open = 4 [json_name = "isOpen"];
  void clear_is_open() ;
  bool is_open() const;
  void set_is_open(bool value);

  private:
  bool _internal_is_open() const;
  void _internal_set_is_open(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DoorInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   1, 78,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DoorInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr connection_id_;
    ::google::protobuf::internal::ArenaStringPtr physical_hint_;
    ::google::protobuf::internal::ArenaStringPtr leads_to_room_id_;
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE position_;
    bool is_open_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DoorInfo_class_data_;
// -------------------------------------------------------------------

class DamageComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DamageComponent) */ {
 public:
  inline DamageComponent() : DamageComponent(nullptr) {}
  ~DamageComponent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DamageComponent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DamageComponent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DamageComponent(::google::protobuf::internal::ConstantInitialized);

  inline DamageComponent(const DamageComponent& from) : DamageComponent(nullptr, from) {}
  inline DamageComponent(DamageComponent&& from) noexcept
      : DamageComponent(nullptr, ::std::move(from)) {}
  inline DamageComponent& operator=(const DamageComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DamageComponent& operator=(DamageComponent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DamageComponent& default_instance() {
    return *reinterpret_cast<const DamageComponent*>(
        &_DamageComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(DamageComponent& a, DamageComponent& b) { a.Swap(&b); }
  inline void Swap(DamageComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DamageComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DamageComponent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DamageComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DamageComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DamageComponent& from) { DamageComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DamageComponent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DamageComponent"; }

  explicit DamageComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DamageComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DamageComponent& from);
  DamageComponent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DamageComponent&& from) noexcept
      : DamageComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOriginalDiceRollsFieldNumber = 2,
    kFinalDiceRollsFieldNumber = 3,
    kRerollsFieldNumber = 4,
    kSourceFieldNumber = 1,
    kDamageTypeFieldNumber = 6,
    kSourceRefFieldNumber = 8,
    kFlatBonusFieldNumber = 5,
    kIsCriticalFieldNumber = 7,
    kMultiplierFieldNumber = 9,
  };
  // repeated int32 original_dice_rolls = 2 [json_name = "originalDiceRolls"];
  int original_dice_rolls_size() const;
  private:
  int _internal_original_dice_rolls_size() const;

  public:
  void clear_original_dice_rolls() ;
  ::int32_t original_dice_rolls(int index) const;
  void set_original_dice_rolls(int index, ::int32_t value);
  void add_original_dice_rolls(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& original_dice_rolls() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_original_dice_rolls();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_original_dice_rolls() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_original_dice_rolls();

  public:
  // repeated int32 final_dice_rolls = 3 [json_name = "finalDiceRolls"];
  int final_dice_rolls_size() const;
  private:
  int _internal_final_dice_rolls_size() const;

  public:
  void clear_final_dice_rolls() ;
  ::int32_t final_dice_rolls(int index) const;
  void set_final_dice_rolls(int index, ::int32_t value);
  void add_final_dice_rolls(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& final_dice_rolls() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_final_dice_rolls();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_final_dice_rolls() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_final_dice_rolls();

  public:
  // repeated .dnd5e.api.v1alpha1.RerollEvent rerolls = 4 [json_name = "rerolls"];
  int rerolls_size() const;
  private:
  int _internal_rerolls_size() const;

  public:
  void clear_rerolls() ;
  ::dnd5e::api::v1alpha1::RerollEvent* PROTOBUF_NONNULL mutable_rerolls(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>* PROTOBUF_NONNULL mutable_rerolls();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>& _internal_rerolls() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>* PROTOBUF_NONNULL _internal_mutable_rerolls();
  public:
  const ::dnd5e::api::v1alpha1::RerollEvent& rerolls(int index) const;
  ::dnd5e::api::v1alpha1::RerollEvent* PROTOBUF_NONNULL add_rerolls();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>& rerolls() const;
  // string source = 1 [json_name = "source", deprecated = true];
  [[deprecated]]  void clear_source() ;
  [[deprecated]] const ::std::string& source() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  [[deprecated]] void set_source(Arg_&& arg, Args_... args);
  [[deprecated]] ::std::string* PROTOBUF_NONNULL mutable_source();
  [[deprecated]] [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_source();
  [[deprecated]] void set_allocated_source(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_source() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_source(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_source();

  public:
  // string damage_type = 6 [json_name = "damageType"];
  void clear_damage_type() ;
  const ::std::string& damage_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_damage_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_damage_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_damage_type();
  void set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_damage_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_damage_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_damage_type();

  public:
  // .dnd5e.api.v1alpha1.SourceRef source_ref = 8 [json_name = "sourceRef"];
  bool has_source_ref() const;
  void clear_source_ref() ;
  const ::dnd5e::api::v1alpha1::SourceRef& source_ref() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE release_source_ref();
  ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NONNULL mutable_source_ref();
  void set_allocated_source_ref(::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_source_ref(::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE unsafe_arena_release_source_ref();

  private:
  const ::dnd5e::api::v1alpha1::SourceRef& _internal_source_ref() const;
  ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NONNULL _internal_mutable_source_ref();

  public:
  // int32 flat_bonus = 5 [json_name = "flatBonus"];
  void clear_flat_bonus() ;
  ::int32_t flat_bonus() const;
  void set_flat_bonus(::int32_t value);

  private:
  ::int32_t _internal_flat_bonus() const;
  void _internal_set_flat_bonus(::int32_t value);

  public:
  // bool is_critical = 7 [json_name = "isCritical"];
  void clear_is_critical() ;
  bool is_critical() const;
  void set_is_critical(bool value);

  private:
  bool _internal_is_critical() const;
  void _internal_set_is_critical(bool value);

  public:
  // optional float multiplier = 9 [json_name = "multiplier"];
  bool has_multiplier() const;
  void clear_multiplier() ;
  float multiplier() const;
  void set_multiplier(float value);

  private:
  float _internal_multiplier() const;
  void _internal_set_multiplier(float value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DamageComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   2, 68,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DamageComponent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> original_dice_rolls_;
    ::google::protobuf::internal::CachedSize _original_dice_rolls_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> final_dice_rolls_;
    ::google::protobuf::internal::CachedSize _final_dice_rolls_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::RerollEvent > rerolls_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    ::google::protobuf::internal::ArenaStringPtr damage_type_;
    ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE source_ref_;
    ::int32_t flat_bonus_;
    bool is_critical_;
    float multiplier_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DamageComponent_class_data_;
// -------------------------------------------------------------------

class CombatEndedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CombatEndedEvent) */ {
 public:
  inline CombatEndedEvent() : CombatEndedEvent(nullptr) {}
  ~CombatEndedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CombatEndedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CombatEndedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CombatEndedEvent(::google::protobuf::internal::ConstantInitialized);

  inline CombatEndedEvent(const CombatEndedEvent& from) : CombatEndedEvent(nullptr, from) {}
  inline CombatEndedEvent(CombatEndedEvent&& from) noexcept
      : CombatEndedEvent(nullptr, ::std::move(from)) {}
  inline CombatEndedEvent& operator=(const CombatEndedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombatEndedEvent& operator=(CombatEndedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombatEndedEvent& default_instance() {
    return *reinterpret_cast<const CombatEndedEvent*>(
        &_CombatEndedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 60;
  friend void swap(CombatEndedEvent& a, CombatEndedEvent& b) { a.Swap(&b); }
  inline void Swap(CombatEndedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombatEndedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombatEndedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CombatEndedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CombatEndedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CombatEndedEvent& from) { CombatEndedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CombatEndedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CombatEndedEvent"; }

  explicit CombatEndedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CombatEndedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CombatEndedEvent& from);
  CombatEndedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CombatEndedEvent&& from) noexcept
      : CombatEndedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.EncounterResult result = 1 [json_name = "result"];
  bool has_result() const;
  void clear_result() ;
  const ::dnd5e::api::v1alpha1::EncounterResult& result() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE release_result();
  ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::dnd5e::api::v1alpha1::EncounterResult& _internal_result() const;
  ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CombatEndedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CombatEndedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE result_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CombatEndedEvent_class_data_;
// -------------------------------------------------------------------

class Room_EntitiesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::google::protobuf::Message,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  Room_EntitiesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Room_EntitiesEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit Room_EntitiesEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_Room_EntitiesEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 49,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull Room_EntitiesEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class DamageBreakdown final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DamageBreakdown) */ {
 public:
  inline DamageBreakdown() : DamageBreakdown(nullptr) {}
  ~DamageBreakdown() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DamageBreakdown* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DamageBreakdown));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DamageBreakdown(::google::protobuf::internal::ConstantInitialized);

  inline DamageBreakdown(const DamageBreakdown& from) : DamageBreakdown(nullptr, from) {}
  inline DamageBreakdown(DamageBreakdown&& from) noexcept
      : DamageBreakdown(nullptr, ::std::move(from)) {}
  inline DamageBreakdown& operator=(const DamageBreakdown& from) {
    CopyFrom(from);
    return *this;
  }
  inline DamageBreakdown& operator=(DamageBreakdown&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DamageBreakdown& default_instance() {
    return *reinterpret_cast<const DamageBreakdown*>(
        &_DamageBreakdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(DamageBreakdown& a, DamageBreakdown& b) { a.Swap(&b); }
  inline void Swap(DamageBreakdown* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DamageBreakdown* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DamageBreakdown* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DamageBreakdown>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DamageBreakdown& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DamageBreakdown& from) { DamageBreakdown::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DamageBreakdown* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DamageBreakdown"; }

  explicit DamageBreakdown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DamageBreakdown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DamageBreakdown& from);
  DamageBreakdown(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DamageBreakdown&& from) noexcept
      : DamageBreakdown(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentsFieldNumber = 1,
    kAbilityUsedFieldNumber = 2,
    kTotalDamageFieldNumber = 3,
  };
  // repeated .dnd5e.api.v1alpha1.DamageComponent components = 1 [json_name = "components"];
  int components_size() const;
  private:
  int _internal_components_size() const;

  public:
  void clear_components() ;
  ::dnd5e::api::v1alpha1::DamageComponent* PROTOBUF_NONNULL mutable_components(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>* PROTOBUF_NONNULL mutable_components();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>& _internal_components() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>* PROTOBUF_NONNULL _internal_mutable_components();
  public:
  const ::dnd5e::api::v1alpha1::DamageComponent& components(int index) const;
  ::dnd5e::api::v1alpha1::DamageComponent* PROTOBUF_NONNULL add_components();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>& components() const;
  // string ability_used = 2 [json_name = "abilityUsed"];
  void clear_ability_used() ;
  const ::std::string& ability_used() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_ability_used(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_ability_used();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_ability_used();
  void set_allocated_ability_used(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_ability_used() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_ability_used(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_ability_used();

  public:
  // int32 total_damage = 3 [json_name = "totalDamage"];
  void clear_total_damage() ;
  ::int32_t total_damage() const;
  void set_total_damage(::int32_t value);

  private:
  ::int32_t _internal_total_damage() const;
  void _internal_set_total_damage(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DamageBreakdown)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DamageBreakdown& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::DamageComponent > components_;
    ::google::protobuf::internal::ArenaStringPtr ability_used_;
    ::int32_t total_damage_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DamageBreakdown_class_data_;
// -------------------------------------------------------------------

class CombatState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CombatState) */ {
 public:
  inline CombatState() : CombatState(nullptr) {}
  ~CombatState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CombatState* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CombatState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CombatState(::google::protobuf::internal::ConstantInitialized);

  inline CombatState(const CombatState& from) : CombatState(nullptr, from) {}
  inline CombatState(CombatState&& from) noexcept
      : CombatState(nullptr, ::std::move(from)) {}
  inline CombatState& operator=(const CombatState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombatState& operator=(CombatState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombatState& default_instance() {
    return *reinterpret_cast<const CombatState*>(
        &_CombatState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(CombatState& a, CombatState& b) { a.Swap(&b); }
  inline void Swap(CombatState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombatState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombatState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CombatState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CombatState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CombatState& from) { CombatState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CombatState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CombatState"; }

  explicit CombatState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CombatState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CombatState& from);
  CombatState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CombatState&& from) noexcept
      : CombatState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTurnOrderFieldNumber = 3,
    kEncounterIdFieldNumber = 1,
    kCurrentTurnFieldNumber = 5,
    kRoundFieldNumber = 2,
    kActiveIndexFieldNumber = 4,
    kCombatStartedFieldNumber = 6,
    kCombatEndedFieldNumber = 7,
  };
  // repeated .dnd5e.api.v1alpha1.InitiativeEntry turn_order = 3 [json_name = "turnOrder"];
  int turn_order_size() const;
  private:
  int _internal_turn_order_size() const;

  public:
  void clear_turn_order() ;
  ::dnd5e::api::v1alpha1::InitiativeEntry* PROTOBUF_NONNULL mutable_turn_order(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>* PROTOBUF_NONNULL mutable_turn_order();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>& _internal_turn_order() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>* PROTOBUF_NONNULL _internal_mutable_turn_order();
  public:
  const ::dnd5e::api::v1alpha1::InitiativeEntry& turn_order(int index) const;
  ::dnd5e::api::v1alpha1::InitiativeEntry* PROTOBUF_NONNULL add_turn_order();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>& turn_order() const;
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // .dnd5e.api.v1alpha1.TurnState current_turn = 5 [json_name = "currentTurn"];
  bool has_current_turn() const;
  void clear_current_turn() ;
  const ::dnd5e::api::v1alpha1::TurnState& current_turn() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE release_current_turn();
  ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NONNULL mutable_current_turn();
  void set_allocated_current_turn(::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_current_turn(::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE unsafe_arena_release_current_turn();

  private:
  const ::dnd5e::api::v1alpha1::TurnState& _internal_current_turn() const;
  ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NONNULL _internal_mutable_current_turn();

  public:
  // int32 round = 2 [json_name = "round"];
  void clear_round() ;
  ::int32_t round() const;
  void set_round(::int32_t value);

  private:
  ::int32_t _internal_round() const;
  void _internal_set_round(::int32_t value);

  public:
  // int32 active_index = 4 [json_name = "activeIndex"];
  void clear_active_index() ;
  ::int32_t active_index() const;
  void set_active_index(::int32_t value);

  private:
  ::int32_t _internal_active_index() const;
  void _internal_set_active_index(::int32_t value);

  public:
  // bool combat_started = 6 [json_name = "combatStarted"];
  void clear_combat_started() ;
  bool combat_started() const;
  void set_combat_started(bool value);

  private:
  bool _internal_combat_started() const;
  void _internal_set_combat_started(bool value);

  public:
  // bool combat_ended = 7 [json_name = "combatEnded"];
  void clear_combat_ended() ;
  bool combat_ended() const;
  void set_combat_ended(bool value);

  private:
  bool _internal_combat_ended() const;
  void _internal_set_combat_ended(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CombatState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   2, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CombatState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::InitiativeEntry > turn_order_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE current_turn_;
    ::int32_t round_;
    ::int32_t active_index_;
    bool combat_started_;
    bool combat_ended_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CombatState_class_data_;
// -------------------------------------------------------------------

class Room final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.Room) */ {
 public:
  inline Room() : Room(nullptr) {}
  ~Room() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Room* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Room));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Room(::google::protobuf::internal::ConstantInitialized);

  inline Room(const Room& from) : Room(nullptr, from) {}
  inline Room(Room&& from) noexcept
      : Room(nullptr, ::std::move(from)) {}
  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room& operator=(Room&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Room& default_instance() {
    return *reinterpret_cast<const Room*>(
        &_Room_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Room& a, Room& b) { a.Swap(&b); }
  inline void Swap(Room* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Room>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Room& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Room& from) { Room::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Room* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.Room"; }

  explicit Room(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Room(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Room& from);
  Room(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Room&& from) noexcept
      : Room(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWallsFieldNumber = 8,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kGridTypeFieldNumber = 5,
    kHexOrientationFieldNumber = 6,
    kEntitiesFieldNumber = 7,
  };
  // repeated .api.v1alpha1.Wall walls = 8 [json_name = "walls"];
  int walls_size() const;
  private:
  int _internal_walls_size() const;

  public:
  void clear_walls() ;
  ::api::v1alpha1::Wall* PROTOBUF_NONNULL mutable_walls(int index);
  ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Wall>* PROTOBUF_NONNULL mutable_walls();

  private:
  const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Wall>& _internal_walls() const;
  ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Wall>* PROTOBUF_NONNULL _internal_mutable_walls();
  public:
  const ::api::v1alpha1::Wall& walls(int index) const;
  ::api::v1alpha1::Wall* PROTOBUF_NONNULL add_walls();
  const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Wall>& walls() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const ::std::string& id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string type = 2 [json_name = "type"];
  void clear_type() ;
  const ::std::string& type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_type();
  void set_allocated_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_type();

  public:
  // int32 width = 3 [json_name = "width"];
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // int32 height = 4 [json_name = "height"];
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // .api.v1alpha1.GridType grid_type = 5 [json_name = "gridType"];
  void clear_grid_type() ;
  ::api::v1alpha1::GridType grid_type() const;
  void set_grid_type(::api::v1alpha1::GridType value);

  private:
  ::api::v1alpha1::GridType _internal_grid_type() const;
  void _internal_set_grid_type(::api::v1alpha1::GridType value);

  public:
  // optional bool hex_orientation = 6 [json_name = "hexOrientation"];
  bool has_hex_orientation() const;
  void clear_hex_orientation() ;
  bool hex_orientation() const;
  void set_hex_orientation(bool value);

  private:
  bool _internal_hex_orientation() const;
  void _internal_set_hex_orientation(bool value);

  public:
  // map<string, .dnd5e.api.v1alpha1.EntityPlacement> entities = 7 [json_name = "entities"];
  int entities_size() const;
  private:
  int _internal_entities_size() const;

  public:
  void clear_entities() ;
  const ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>& entities() const;
  ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>* PROTOBUF_NONNULL mutable_entities();

  private:
  const ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>& _internal_entities() const;
  ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>* PROTOBUF_NONNULL _internal_mutable_entities();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.Room)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   3, 54,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Room& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::api::v1alpha1::Wall > walls_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::int32_t width_;
    ::int32_t height_;
    int grid_type_;
    bool hex_orientation_;
    ::google::protobuf::internal::MapField<Room_EntitiesEntry_DoNotUse, ::std::string, ::dnd5e::api::v1alpha1::EntityPlacement,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        entities_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Room_class_data_;
// -------------------------------------------------------------------

class CombatResumedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CombatResumedEvent) */ {
 public:
  inline CombatResumedEvent() : CombatResumedEvent(nullptr) {}
  ~CombatResumedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CombatResumedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CombatResumedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CombatResumedEvent(::google::protobuf::internal::ConstantInitialized);

  inline CombatResumedEvent(const CombatResumedEvent& from) : CombatResumedEvent(nullptr, from) {}
  inline CombatResumedEvent(CombatResumedEvent&& from) noexcept
      : CombatResumedEvent(nullptr, ::std::move(from)) {}
  inline CombatResumedEvent& operator=(const CombatResumedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombatResumedEvent& operator=(CombatResumedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombatResumedEvent& default_instance() {
    return *reinterpret_cast<const CombatResumedEvent*>(
        &_CombatResumedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 64;
  friend void swap(CombatResumedEvent& a, CombatResumedEvent& b) { a.Swap(&b); }
  inline void Swap(CombatResumedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombatResumedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombatResumedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CombatResumedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CombatResumedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CombatResumedEvent& from) { CombatResumedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CombatResumedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CombatResumedEvent"; }

  explicit CombatResumedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CombatResumedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CombatResumedEvent& from);
  CombatResumedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CombatResumedEvent&& from) noexcept
      : CombatResumedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCombatStateFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CombatResumedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CombatResumedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CombatResumedEvent_class_data_;
// -------------------------------------------------------------------

class AttackResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AttackResult) */ {
 public:
  inline AttackResult() : AttackResult(nullptr) {}
  ~AttackResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackResult* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackResult(::google::protobuf::internal::ConstantInitialized);

  inline AttackResult(const AttackResult& from) : AttackResult(nullptr, from) {}
  inline AttackResult(AttackResult&& from) noexcept
      : AttackResult(nullptr, ::std::move(from)) {}
  inline AttackResult& operator=(const AttackResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackResult& operator=(AttackResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackResult& default_instance() {
    return *reinterpret_cast<const AttackResult*>(
        &_AttackResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(AttackResult& a, AttackResult& b) { a.Swap(&b); }
  inline void Swap(AttackResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackResult& from) { AttackResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AttackResult"; }

  explicit AttackResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AttackResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AttackResult& from);
  AttackResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AttackResult&& from) noexcept
      : AttackResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDamageTypeFieldNumber = 6,
    kDamageBreakdownFieldNumber = 8,
    kAttackRollFieldNumber = 2,
    kAttackTotalFieldNumber = 3,
    kTargetAcFieldNumber = 4,
    kHitFieldNumber = 1,
    kCriticalFieldNumber = 7,
    kDamageFieldNumber = 5,
  };
  // string damage_type = 6 [json_name = "damageType"];
  void clear_damage_type() ;
  const ::std::string& damage_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_damage_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_damage_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_damage_type();
  void set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_damage_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_damage_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_damage_type();

  public:
  // .dnd5e.api.v1alpha1.DamageBreakdown damage_breakdown = 8 [json_name = "damageBreakdown"];
  bool has_damage_breakdown() const;
  void clear_damage_breakdown() ;
  const ::dnd5e::api::v1alpha1::DamageBreakdown& damage_breakdown() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE release_damage_breakdown();
  ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NONNULL mutable_damage_breakdown();
  void set_allocated_damage_breakdown(::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_damage_breakdown(::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE unsafe_arena_release_damage_breakdown();

  private:
  const ::dnd5e::api::v1alpha1::DamageBreakdown& _internal_damage_breakdown() const;
  ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NONNULL _internal_mutable_damage_breakdown();

  public:
  // int32 attack_roll = 2 [json_name = "attackRoll"];
  void clear_attack_roll() ;
  ::int32_t attack_roll() const;
  void set_attack_roll(::int32_t value);

  private:
  ::int32_t _internal_attack_roll() const;
  void _internal_set_attack_roll(::int32_t value);

  public:
  // int32 attack_total = 3 [json_name = "attackTotal"];
  void clear_attack_total() ;
  ::int32_t attack_total() const;
  void set_attack_total(::int32_t value);

  private:
  ::int32_t _internal_attack_total() const;
  void _internal_set_attack_total(::int32_t value);

  public:
  // int32 target_ac = 4 [json_name = "targetAc"];
  void clear_target_ac() ;
  ::int32_t target_ac() const;
  void set_target_ac(::int32_t value);

  private:
  ::int32_t _internal_target_ac() const;
  void _internal_set_target_ac(::int32_t value);

  public:
  // bool hit = 1 [json_name = "hit"];
  void clear_hit() ;
  bool hit() const;
  void set_hit(bool value);

  private:
  bool _internal_hit() const;
  void _internal_set_hit(bool value);

  public:
  // bool critical = 7 [json_name = "critical"];
  void clear_critical() ;
  bool critical() const;
  void set_critical(bool value);

  private:
  bool _internal_critical() const;
  void _internal_set_critical(bool value);

  public:
  // int32 damage = 5 [json_name = "damage"];
  void clear_damage() ;
  ::int32_t damage() const;
  void set_damage(::int32_t value);

  private:
  ::int32_t _internal_damage() const;
  void _internal_set_damage(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AttackResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   1, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AttackResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr damage_type_;
    ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE damage_breakdown_;
    ::int32_t attack_roll_;
    ::int32_t attack_total_;
    ::int32_t target_ac_;
    bool hit_;
    bool critical_;
    ::int32_t damage_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AttackResult_class_data_;
// -------------------------------------------------------------------

class TurnEndedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.TurnEndedEvent) */ {
 public:
  inline TurnEndedEvent() : TurnEndedEvent(nullptr) {}
  ~TurnEndedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TurnEndedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TurnEndedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TurnEndedEvent(::google::protobuf::internal::ConstantInitialized);

  inline TurnEndedEvent(const TurnEndedEvent& from) : TurnEndedEvent(nullptr, from) {}
  inline TurnEndedEvent(TurnEndedEvent&& from) noexcept
      : TurnEndedEvent(nullptr, ::std::move(from)) {}
  inline TurnEndedEvent& operator=(const TurnEndedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnEndedEvent& operator=(TurnEndedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnEndedEvent& default_instance() {
    return *reinterpret_cast<const TurnEndedEvent*>(
        &_TurnEndedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 58;
  friend void swap(TurnEndedEvent& a, TurnEndedEvent& b) { a.Swap(&b); }
  inline void Swap(TurnEndedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnEndedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnEndedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TurnEndedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TurnEndedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TurnEndedEvent& from) { TurnEndedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TurnEndedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.TurnEndedEvent"; }

  explicit TurnEndedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TurnEndedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TurnEndedEvent& from);
  TurnEndedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TurnEndedEvent&& from) noexcept
      : TurnEndedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTurnChangeFieldNumber = 1,
    kCombatStateFieldNumber = 2,
    kUpdatedRoomFieldNumber = 3,
  };
  // .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 1 [json_name = "turnChange"];
  bool has_turn_change() const;
  void clear_turn_change() ;
  const ::dnd5e::api::v1alpha1::TurnChangeEvent& turn_change() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE release_turn_change();
  ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL mutable_turn_change();
  void set_allocated_turn_change(::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_turn_change(::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE unsafe_arena_release_turn_change();

  private:
  const ::dnd5e::api::v1alpha1::TurnChangeEvent& _internal_turn_change() const;
  ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL _internal_mutable_turn_change();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // .dnd5e.api.v1alpha1.Room updated_room = 3 [json_name = "updatedRoom"];
  bool has_updated_room() const;
  void clear_updated_room() ;
  const ::dnd5e::api::v1alpha1::Room& updated_room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_updated_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_updated_room();
  void set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_updated_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_updated_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_updated_room();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.TurnEndedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TurnEndedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE turn_change_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE updated_room_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TurnEndedEvent_class_data_;
// -------------------------------------------------------------------

class RoomRevealedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.RoomRevealedEvent) */ {
 public:
  inline RoomRevealedEvent() : RoomRevealedEvent(nullptr) {}
  ~RoomRevealedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoomRevealedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoomRevealedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoomRevealedEvent(::google::protobuf::internal::ConstantInitialized);

  inline RoomRevealedEvent(const RoomRevealedEvent& from) : RoomRevealedEvent(nullptr, from) {}
  inline RoomRevealedEvent(RoomRevealedEvent&& from) noexcept
      : RoomRevealedEvent(nullptr, ::std::move(from)) {}
  inline RoomRevealedEvent& operator=(const RoomRevealedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomRevealedEvent& operator=(RoomRevealedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomRevealedEvent& default_instance() {
    return *reinterpret_cast<const RoomRevealedEvent*>(
        &_RoomRevealedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 65;
  friend void swap(RoomRevealedEvent& a, RoomRevealedEvent& b) { a.Swap(&b); }
  inline void Swap(RoomRevealedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomRevealedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomRevealedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoomRevealedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoomRevealedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoomRevealedEvent& from) { RoomRevealedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoomRevealedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.RoomRevealedEvent"; }

  explicit RoomRevealedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoomRevealedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoomRevealedEvent& from);
  RoomRevealedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoomRevealedEvent&& from) noexcept
      : RoomRevealedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDoorsFieldNumber = 5,
    kDungeonIdFieldNumber = 1,
    kConnectionIdFieldNumber = 2,
    kRoomFieldNumber = 3,
    kCombatStateFieldNumber = 4,
  };
  // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 5 [json_name = "doors"];
  int doors_size() const;
  private:
  int _internal_doors_size() const;

  public:
  void clear_doors() ;
  ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL mutable_doors(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL mutable_doors();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& _internal_doors() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL _internal_mutable_doors();
  public:
  const ::dnd5e::api::v1alpha1::DoorInfo& doors(int index) const;
  ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL add_doors();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& doors() const;
  // string dungeon_id = 1 [json_name = "dungeonId"];
  void clear_dungeon_id() ;
  const ::std::string& dungeon_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dungeon_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dungeon_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dungeon_id();
  void set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dungeon_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dungeon_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dungeon_id();

  public:
  // string connection_id = 2 [json_name = "connectionId"];
  void clear_connection_id() ;
  const ::std::string& connection_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_connection_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_connection_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_connection_id();
  void set_allocated_connection_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_connection_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_connection_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_connection_id();

  public:
  // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.RoomRevealedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   3, 68,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoomRevealedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::DoorInfo > doors_;
    ::google::protobuf::internal::ArenaStringPtr dungeon_id_;
    ::google::protobuf::internal::ArenaStringPtr connection_id_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoomRevealedEvent_class_data_;
// -------------------------------------------------------------------

class MovementCompletedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MovementCompletedEvent) */ {
 public:
  inline MovementCompletedEvent() : MovementCompletedEvent(nullptr) {}
  ~MovementCompletedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MovementCompletedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MovementCompletedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MovementCompletedEvent(::google::protobuf::internal::ConstantInitialized);

  inline MovementCompletedEvent(const MovementCompletedEvent& from) : MovementCompletedEvent(nullptr, from) {}
  inline MovementCompletedEvent(MovementCompletedEvent&& from) noexcept
      : MovementCompletedEvent(nullptr, ::std::move(from)) {}
  inline MovementCompletedEvent& operator=(const MovementCompletedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovementCompletedEvent& operator=(MovementCompletedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovementCompletedEvent& default_instance() {
    return *reinterpret_cast<const MovementCompletedEvent*>(
        &_MovementCompletedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 55;
  friend void swap(MovementCompletedEvent& a, MovementCompletedEvent& b) { a.Swap(&b); }
  inline void Swap(MovementCompletedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovementCompletedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MovementCompletedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MovementCompletedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MovementCompletedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MovementCompletedEvent& from) { MovementCompletedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MovementCompletedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MovementCompletedEvent"; }

  explicit MovementCompletedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MovementCompletedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MovementCompletedEvent& from);
  MovementCompletedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MovementCompletedEvent&& from) noexcept
      : MovementCompletedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 2,
    kEntityIdFieldNumber = 1,
    kStopReasonFieldNumber = 5,
    kFinalPositionFieldNumber = 3,
    kUpdatedRoomFieldNumber = 6,
    kMovementRemainingFieldNumber = 4,
  };
  // repeated .api.v1alpha1.Position path = 2 [json_name = "path"];
  int path_size() const;
  private:
  int _internal_path_size() const;

  public:
  void clear_path() ;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_path(int index);
  ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL mutable_path();

  private:
  const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>& _internal_path() const;
  ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL _internal_mutable_path();
  public:
  const ::api::v1alpha1::Position& path(int index) const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL add_path();
  const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>& path() const;
  // string entity_id = 1 [json_name = "entityId"];
  void clear_entity_id() ;
  const ::std::string& entity_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_entity_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_entity_id();
  void set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_entity_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_entity_id();

  public:
  // string stop_reason = 5 [json_name = "stopReason"];
  void clear_stop_reason() ;
  const ::std::string& stop_reason() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_stop_reason(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_stop_reason();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_stop_reason();
  void set_allocated_stop_reason(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_stop_reason() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_stop_reason(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_stop_reason();

  public:
  // .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
  bool has_final_position() const;
  void clear_final_position() ;
  const ::api::v1alpha1::Position& final_position() const;
  [[nodiscard]] ::api::v1alpha1::Position* PROTOBUF_NULLABLE release_final_position();
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_final_position();
  void set_allocated_final_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_final_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  ::api::v1alpha1::Position* PROTOBUF_NULLABLE unsafe_arena_release_final_position();

  private:
  const ::api::v1alpha1::Position& _internal_final_position() const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL _internal_mutable_final_position();

  public:
  // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
  bool has_updated_room() const;
  void clear_updated_room() ;
  const ::dnd5e::api::v1alpha1::Room& updated_room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_updated_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_updated_room();
  void set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_updated_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_updated_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_updated_room();

  public:
  // int32 movement_remaining = 4 [json_name = "movementRemaining"];
  void clear_movement_remaining() ;
  ::int32_t movement_remaining() const;
  void set_movement_remaining(::int32_t value);

  private:
  ::int32_t _internal_movement_remaining() const;
  void _internal_set_movement_remaining(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MovementCompletedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   3, 70,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MovementCompletedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::api::v1alpha1::Position > path_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr stop_reason_;
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE final_position_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE updated_room_;
    ::int32_t movement_remaining_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MovementCompletedEvent_class_data_;
// -------------------------------------------------------------------

class MoveCharacterResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MoveCharacterResponse) */ {
 public:
  inline MoveCharacterResponse() : MoveCharacterResponse(nullptr) {}
  ~MoveCharacterResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MoveCharacterResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MoveCharacterResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveCharacterResponse(::google::protobuf::internal::ConstantInitialized);

  inline MoveCharacterResponse(const MoveCharacterResponse& from) : MoveCharacterResponse(nullptr, from) {}
  inline MoveCharacterResponse(MoveCharacterResponse&& from) noexcept
      : MoveCharacterResponse(nullptr, ::std::move(from)) {}
  inline MoveCharacterResponse& operator=(const MoveCharacterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveCharacterResponse& operator=(MoveCharacterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveCharacterResponse& default_instance() {
    return *reinterpret_cast<const MoveCharacterResponse*>(
        &_MoveCharacterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(MoveCharacterResponse& a, MoveCharacterResponse& b) { a.Swap(&b); }
  inline void Swap(MoveCharacterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveCharacterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveCharacterResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MoveCharacterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveCharacterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveCharacterResponse& from) { MoveCharacterResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MoveCharacterResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MoveCharacterResponse"; }

  explicit MoveCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MoveCharacterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MoveCharacterResponse& from);
  MoveCharacterResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MoveCharacterResponse&& from) noexcept
      : MoveCharacterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStopReasonFieldNumber = 5,
    kErrorFieldNumber = 2,
    kFinalPositionFieldNumber = 3,
    kUpdatedRoomFieldNumber = 6,
    kSuccessFieldNumber = 1,
    kMovementRemainingFieldNumber = 4,
  };
  // string stop_reason = 5 [json_name = "stopReason"];
  void clear_stop_reason() ;
  const ::std::string& stop_reason() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_stop_reason(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_stop_reason();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_stop_reason();
  void set_allocated_stop_reason(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_stop_reason() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_stop_reason(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_stop_reason();

  public:
  // .dnd5e.api.v1alpha1.MovementError error = 2 [json_name = "error"];
  bool has_error() const;
  void clear_error() ;
  const ::dnd5e::api::v1alpha1::MovementError& error() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE release_error();
  ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NONNULL mutable_error();
  void set_allocated_error(::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_error(::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE unsafe_arena_release_error();

  private:
  const ::dnd5e::api::v1alpha1::MovementError& _internal_error() const;
  ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
  bool has_final_position() const;
  void clear_final_position() ;
  const ::api::v1alpha1::Position& final_position() const;
  [[nodiscard]] ::api::v1alpha1::Position* PROTOBUF_NULLABLE release_final_position();
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_final_position();
  void set_allocated_final_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_final_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  ::api::v1alpha1::Position* PROTOBUF_NULLABLE unsafe_arena_release_final_position();

  private:
  const ::api::v1alpha1::Position& _internal_final_position() const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL _internal_mutable_final_position();

  public:
  // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
  bool has_updated_room() const;
  void clear_updated_room() ;
  const ::dnd5e::api::v1alpha1::Room& updated_room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_updated_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_updated_room();
  void set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_updated_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_updated_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_updated_room();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // int32 movement_remaining = 4 [json_name = "movementRemaining"];
  void clear_movement_remaining() ;
  ::int32_t movement_remaining() const;
  void set_movement_remaining(::int32_t value);

  private:
  ::int32_t _internal_movement_remaining() const;
  void _internal_set_movement_remaining(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MoveCharacterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   3, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MoveCharacterResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr stop_reason_;
    ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE error_;
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE final_position_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE updated_room_;
    bool success_;
    ::int32_t movement_remaining_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MoveCharacterResponse_class_data_;
// -------------------------------------------------------------------

class MonsterExecutedAction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MonsterExecutedAction) */ {
 public:
  inline MonsterExecutedAction() : MonsterExecutedAction(nullptr) {}
  ~MonsterExecutedAction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MonsterExecutedAction* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MonsterExecutedAction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MonsterExecutedAction(::google::protobuf::internal::ConstantInitialized);

  inline MonsterExecutedAction(const MonsterExecutedAction& from) : MonsterExecutedAction(nullptr, from) {}
  inline MonsterExecutedAction(MonsterExecutedAction&& from) noexcept
      : MonsterExecutedAction(nullptr, ::std::move(from)) {}
  inline MonsterExecutedAction& operator=(const MonsterExecutedAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterExecutedAction& operator=(MonsterExecutedAction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterExecutedAction& default_instance() {
    return *reinterpret_cast<const MonsterExecutedAction*>(
        &_MonsterExecutedAction_default_instance_);
  }
  enum DetailsCase {
    kAttackResult = 5,
    kHealResult = 6,
    DETAILS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(MonsterExecutedAction& a, MonsterExecutedAction& b) { a.Swap(&b); }
  inline void Swap(MonsterExecutedAction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterExecutedAction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterExecutedAction* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MonsterExecutedAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MonsterExecutedAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MonsterExecutedAction& from) { MonsterExecutedAction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MonsterExecutedAction* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MonsterExecutedAction"; }

  explicit MonsterExecutedAction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MonsterExecutedAction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MonsterExecutedAction& from);
  MonsterExecutedAction(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MonsterExecutedAction&& from) noexcept
      : MonsterExecutedAction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActionIdFieldNumber = 1,
    kTargetIdFieldNumber = 3,
    kActionTypeFieldNumber = 2,
    kSuccessFieldNumber = 4,
    kAttackResultFieldNumber = 5,
    kHealResultFieldNumber = 6,
  };
  // string action_id = 1 [json_name = "actionId"];
  void clear_action_id() ;
  const ::std::string& action_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_action_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_action_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_action_id();
  void set_allocated_action_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_action_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_action_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_action_id();

  public:
  // string target_id = 3 [json_name = "targetId"];
  void clear_target_id() ;
  const ::std::string& target_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_target_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_target_id();
  void set_allocated_target_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_target_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_target_id();

  public:
  // .dnd5e.api.v1alpha1.MonsterActionType action_type = 2 [json_name = "actionType"];
  void clear_action_type() ;
  ::dnd5e::api::v1alpha1::MonsterActionType action_type() const;
  void set_action_type(::dnd5e::api::v1alpha1::MonsterActionType value);

  private:
  ::dnd5e::api::v1alpha1::MonsterActionType _internal_action_type() const;
  void _internal_set_action_type(::dnd5e::api::v1alpha1::MonsterActionType value);

  public:
  // bool success = 4 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // .dnd5e.api.v1alpha1.AttackResult attack_result = 5 [json_name = "attackResult"];
  bool has_attack_result() const;
  private:
  bool _internal_has_attack_result() const;

  public:
  void clear_attack_result() ;
  const ::dnd5e::api::v1alpha1::AttackResult& attack_result() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE release_attack_result();
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL mutable_attack_result();
  void set_allocated_attack_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_attack_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE unsafe_arena_release_attack_result();

  private:
  const ::dnd5e::api::v1alpha1::AttackResult& _internal_attack_result() const;
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL _internal_mutable_attack_result();

  public:
  // .dnd5e.api.v1alpha1.HealResult heal_result = 6 [json_name = "healResult"];
  bool has_heal_result() const;
  private:
  bool _internal_has_heal_result() const;

  public:
  void clear_heal_result() ;
  const ::dnd5e::api::v1alpha1::HealResult& heal_result() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NULLABLE release_heal_result();
  ::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NONNULL mutable_heal_result();
  void set_allocated_heal_result(::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_heal_result(::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NULLABLE unsafe_arena_release_heal_result();

  private:
  const ::dnd5e::api::v1alpha1::HealResult& _internal_heal_result() const;
  ::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NONNULL _internal_mutable_heal_result();

  public:
  void clear_details();
  DetailsCase details_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MonsterExecutedAction)
 private:
  class _Internal;
  void set_has_attack_result();
  void set_has_heal_result();
  inline bool has_details() const;
  inline void clear_has_details();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 6,
                                   2, 67,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MonsterExecutedAction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr action_id_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    int action_type_;
    bool success_;
    union DetailsUnion {
      constexpr DetailsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE attack_result_;
      ::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NULLABLE heal_result_;
    } details_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MonsterExecutedAction_class_data_;
// -------------------------------------------------------------------

class GetCombatStateResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetCombatStateResponse) */ {
 public:
  inline GetCombatStateResponse() : GetCombatStateResponse(nullptr) {}
  ~GetCombatStateResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetCombatStateResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetCombatStateResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCombatStateResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetCombatStateResponse(const GetCombatStateResponse& from) : GetCombatStateResponse(nullptr, from) {}
  inline GetCombatStateResponse(GetCombatStateResponse&& from) noexcept
      : GetCombatStateResponse(nullptr, ::std::move(from)) {}
  inline GetCombatStateResponse& operator=(const GetCombatStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCombatStateResponse& operator=(GetCombatStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCombatStateResponse& default_instance() {
    return *reinterpret_cast<const GetCombatStateResponse*>(
        &_GetCombatStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(GetCombatStateResponse& a, GetCombatStateResponse& b) { a.Swap(&b); }
  inline void Swap(GetCombatStateResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCombatStateResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCombatStateResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetCombatStateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCombatStateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetCombatStateResponse& from) { GetCombatStateResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetCombatStateResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetCombatStateResponse"; }

  explicit GetCombatStateResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetCombatStateResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetCombatStateResponse& from);
  GetCombatStateResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetCombatStateResponse&& from) noexcept
      : GetCombatStateResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoomFieldNumber = 1,
    kCombatStateFieldNumber = 2,
  };
  // .dnd5e.api.v1alpha1.Room room = 1 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetCombatStateResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetCombatStateResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetCombatStateResponse_class_data_;
// -------------------------------------------------------------------

class CreateEncounterResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CreateEncounterResponse) */ {
 public:
  inline CreateEncounterResponse() : CreateEncounterResponse(nullptr) {}
  ~CreateEncounterResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateEncounterResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateEncounterResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateEncounterResponse(::google::protobuf::internal::ConstantInitialized);

  inline CreateEncounterResponse(const CreateEncounterResponse& from) : CreateEncounterResponse(nullptr, from) {}
  inline CreateEncounterResponse(CreateEncounterResponse&& from) noexcept
      : CreateEncounterResponse(nullptr, ::std::move(from)) {}
  inline CreateEncounterResponse& operator=(const CreateEncounterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEncounterResponse& operator=(CreateEncounterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEncounterResponse& default_instance() {
    return *reinterpret_cast<const CreateEncounterResponse*>(
        &_CreateEncounterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(CreateEncounterResponse& a, CreateEncounterResponse& b) { a.Swap(&b); }
  inline void Swap(CreateEncounterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEncounterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateEncounterResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateEncounterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateEncounterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateEncounterResponse& from) { CreateEncounterResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateEncounterResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CreateEncounterResponse"; }

  explicit CreateEncounterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreateEncounterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreateEncounterResponse& from);
  CreateEncounterResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreateEncounterResponse&& from) noexcept
      : CreateEncounterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncounterIdFieldNumber = 1,
    kJoinCodeFieldNumber = 2,
    kRoomFieldNumber = 3,
  };
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string join_code = 2 [json_name = "joinCode"];
  void clear_join_code() ;
  const ::std::string& join_code() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_join_code(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_join_code();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_join_code();
  void set_allocated_join_code(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_join_code() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_join_code(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_join_code();

  public:
  // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CreateEncounterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 72,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CreateEncounterResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr join_code_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreateEncounterResponse_class_data_;
// -------------------------------------------------------------------

class AttackResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AttackResponse) */ {
 public:
  inline AttackResponse() : AttackResponse(nullptr) {}
  ~AttackResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackResponse(::google::protobuf::internal::ConstantInitialized);

  inline AttackResponse(const AttackResponse& from) : AttackResponse(nullptr, from) {}
  inline AttackResponse(AttackResponse&& from) noexcept
      : AttackResponse(nullptr, ::std::move(from)) {}
  inline AttackResponse& operator=(const AttackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackResponse& operator=(AttackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackResponse& default_instance() {
    return *reinterpret_cast<const AttackResponse*>(
        &_AttackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(AttackResponse& a, AttackResponse& b) { a.Swap(&b); }
  inline void Swap(AttackResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackResponse& from) { AttackResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AttackResponse"; }

  explicit AttackResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AttackResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AttackResponse& from);
  AttackResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AttackResponse&& from) noexcept
      : AttackResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 2,
    kResultFieldNumber = 3,
    kCombatStateFieldNumber = 4,
    kUpdatedRoomFieldNumber = 5,
    kGrantedActionFieldNumber = 6,
    kSuccessFieldNumber = 1,
  };
  // string error = 2 [json_name = "error"];
  void clear_error() ;
  const ::std::string& error() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
  bool has_result() const;
  void clear_result() ;
  const ::dnd5e::api::v1alpha1::AttackResult& result() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE release_result();
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::dnd5e::api::v1alpha1::AttackResult& _internal_result() const;
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // .dnd5e.api.v1alpha1.Room updated_room = 5 [json_name = "updatedRoom"];
  bool has_updated_room() const;
  void clear_updated_room() ;
  const ::dnd5e::api::v1alpha1::Room& updated_room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_updated_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_updated_room();
  void set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_updated_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_updated_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_updated_room();

  public:
  // .dnd5e.api.v1alpha1.GrantedAction granted_action = 6 [json_name = "grantedAction"];
  bool has_granted_action() const;
  void clear_granted_action() ;
  const ::dnd5e::api::v1alpha1::GrantedAction& granted_action() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE release_granted_action();
  ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NONNULL mutable_granted_action();
  void set_allocated_granted_action(::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_granted_action(::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE unsafe_arena_release_granted_action();

  private:
  const ::dnd5e::api::v1alpha1::GrantedAction& _internal_granted_action() const;
  ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NONNULL _internal_mutable_granted_action();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AttackResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   4, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AttackResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE result_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE updated_room_;
    ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE granted_action_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AttackResponse_class_data_;
// -------------------------------------------------------------------

class PartyMember final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.PartyMember) */ {
 public:
  inline PartyMember() : PartyMember(nullptr) {}
  ~PartyMember() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PartyMember* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PartyMember));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PartyMember(::google::protobuf::internal::ConstantInitialized);

  inline PartyMember(const PartyMember& from) : PartyMember(nullptr, from) {}
  inline PartyMember(PartyMember&& from) noexcept
      : PartyMember(nullptr, ::std::move(from)) {}
  inline PartyMember& operator=(const PartyMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyMember& operator=(PartyMember&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartyMember& default_instance() {
    return *reinterpret_cast<const PartyMember*>(
        &_PartyMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(PartyMember& a, PartyMember& b) { a.Swap(&b); }
  inline void Swap(PartyMember* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyMember* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartyMember* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PartyMember>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PartyMember& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PartyMember& from) { PartyMember::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PartyMember* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.PartyMember"; }

  explicit PartyMember(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PartyMember(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PartyMember& from);
  PartyMember(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PartyMember&& from) noexcept
      : PartyMember(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerIdFieldNumber = 1,
    kCharacterFieldNumber = 2,
    kIsHostFieldNumber = 3,
    kIsReadyFieldNumber = 4,
    kIsConnectedFieldNumber = 5,
  };
  // string player_id = 1 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // .dnd5e.api.v1alpha1.Character character = 2 [json_name = "character"];
  bool has_character() const;
  void clear_character() ;
  const ::dnd5e::api::v1alpha1::Character& character() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_character();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_character();
  void set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_character();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_character() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_character();

  public:
  // bool is_host = 3 [json_name = "isHost"];
  void clear_is_host() ;
  bool is_host() const;
  void set_is_host(bool value);

  private:
  bool _internal_is_host() const;
  void _internal_set_is_host(bool value);

  public:
  // bool is_ready = 4 [json_name = "isReady"];
  void clear_is_ready() ;
  bool is_ready() const;
  void set_is_ready(bool value);

  private:
  bool _internal_is_ready() const;
  void _internal_set_is_ready(bool value);

  public:
  // bool is_connected = 5 [json_name = "isConnected"];
  void clear_is_connected() ;
  bool is_connected() const;
  void set_is_connected(bool value);

  private:
  bool _internal_is_connected() const;
  void _internal_set_is_connected(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.PartyMember)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   1, 48,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PartyMember& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE character_;
    bool is_host_;
    bool is_ready_;
    bool is_connected_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PartyMember_class_data_;
// -------------------------------------------------------------------

class MonsterTurnResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MonsterTurnResult) */ {
 public:
  inline MonsterTurnResult() : MonsterTurnResult(nullptr) {}
  ~MonsterTurnResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MonsterTurnResult* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MonsterTurnResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MonsterTurnResult(::google::protobuf::internal::ConstantInitialized);

  inline MonsterTurnResult(const MonsterTurnResult& from) : MonsterTurnResult(nullptr, from) {}
  inline MonsterTurnResult(MonsterTurnResult&& from) noexcept
      : MonsterTurnResult(nullptr, ::std::move(from)) {}
  inline MonsterTurnResult& operator=(const MonsterTurnResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterTurnResult& operator=(MonsterTurnResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterTurnResult& default_instance() {
    return *reinterpret_cast<const MonsterTurnResult*>(
        &_MonsterTurnResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(MonsterTurnResult& a, MonsterTurnResult& b) { a.Swap(&b); }
  inline void Swap(MonsterTurnResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterTurnResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterTurnResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MonsterTurnResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MonsterTurnResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MonsterTurnResult& from) { MonsterTurnResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MonsterTurnResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MonsterTurnResult"; }

  explicit MonsterTurnResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MonsterTurnResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MonsterTurnResult& from);
  MonsterTurnResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MonsterTurnResult&& from) noexcept
      : MonsterTurnResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActionsFieldNumber = 3,
    kMovementPathFieldNumber = 4,
    kMonsterIdFieldNumber = 1,
    kMonsterNameFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.MonsterExecutedAction actions = 3 [json_name = "actions"];
  int actions_size() const;
  private:
  int _internal_actions_size() const;

  public:
  void clear_actions() ;
  ::dnd5e::api::v1alpha1::MonsterExecutedAction* PROTOBUF_NONNULL mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterExecutedAction>* PROTOBUF_NONNULL mutable_actions();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterExecutedAction>& _internal_actions() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterExecutedAction>* PROTOBUF_NONNULL _internal_mutable_actions();
  public:
  const ::dnd5e::api::v1alpha1::MonsterExecutedAction& actions(int index) const;
  ::dnd5e::api::v1alpha1::MonsterExecutedAction* PROTOBUF_NONNULL add_actions();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterExecutedAction>& actions() const;
  // repeated .api.v1alpha1.Position movement_path = 4 [json_name = "movementPath"];
  int movement_path_size() const;
  private:
  int _internal_movement_path_size() const;

  public:
  void clear_movement_path() ;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_movement_path(int index);
  ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL mutable_movement_path();

  private:
  const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>& _internal_movement_path() const;
  ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL _internal_mutable_movement_path();
  public:
  const ::api::v1alpha1::Position& movement_path(int index) const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL add_movement_path();
  const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>& movement_path() const;
  // string monster_id = 1 [json_name = "monsterId"];
  void clear_monster_id() ;
  const ::std::string& monster_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_monster_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_monster_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_monster_id();
  void set_allocated_monster_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_monster_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_monster_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_monster_id();

  public:
  // string monster_name = 2 [json_name = "monsterName"];
  void clear_monster_name() ;
  const ::std::string& monster_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_monster_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_monster_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_monster_name();
  void set_allocated_monster_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_monster_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_monster_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_monster_name();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MonsterTurnResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 67,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MonsterTurnResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::MonsterExecutedAction > actions_;
    ::google::protobuf::RepeatedPtrField< ::api::v1alpha1::Position > movement_path_;
    ::google::protobuf::internal::ArenaStringPtr monster_id_;
    ::google::protobuf::internal::ArenaStringPtr monster_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MonsterTurnResult_class_data_;
// -------------------------------------------------------------------

class FeatureActivatedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.FeatureActivatedEvent) */ {
 public:
  inline FeatureActivatedEvent() : FeatureActivatedEvent(nullptr) {}
  ~FeatureActivatedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FeatureActivatedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FeatureActivatedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FeatureActivatedEvent(::google::protobuf::internal::ConstantInitialized);

  inline FeatureActivatedEvent(const FeatureActivatedEvent& from) : FeatureActivatedEvent(nullptr, from) {}
  inline FeatureActivatedEvent(FeatureActivatedEvent&& from) noexcept
      : FeatureActivatedEvent(nullptr, ::std::move(from)) {}
  inline FeatureActivatedEvent& operator=(const FeatureActivatedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureActivatedEvent& operator=(FeatureActivatedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeatureActivatedEvent& default_instance() {
    return *reinterpret_cast<const FeatureActivatedEvent*>(
        &_FeatureActivatedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 57;
  friend void swap(FeatureActivatedEvent& a, FeatureActivatedEvent& b) { a.Swap(&b); }
  inline void Swap(FeatureActivatedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureActivatedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeatureActivatedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FeatureActivatedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FeatureActivatedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FeatureActivatedEvent& from) { FeatureActivatedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FeatureActivatedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.FeatureActivatedEvent"; }

  explicit FeatureActivatedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FeatureActivatedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FeatureActivatedEvent& from);
  FeatureActivatedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FeatureActivatedEvent&& from) noexcept
      : FeatureActivatedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCharacterIdFieldNumber = 1,
    kFeatureIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kUpdatedCharacterFieldNumber = 4,
  };
  // string character_id = 1 [json_name = "characterId"];
  void clear_character_id() ;
  const ::std::string& character_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_character_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_character_id();
  void set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_character_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_character_id();

  public:
  // string feature_id = 2 [json_name = "featureId"];
  void clear_feature_id() ;
  const ::std::string& feature_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_feature_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_feature_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_feature_id();
  void set_allocated_feature_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_feature_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_feature_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_feature_id();

  public:
  // string message = 3 [json_name = "message"];
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // .dnd5e.api.v1alpha1.Character updated_character = 4 [json_name = "updatedCharacter"];
  bool has_updated_character() const;
  void clear_updated_character() ;
  const ::dnd5e::api::v1alpha1::Character& updated_character() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_updated_character();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_updated_character();
  void set_allocated_updated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_updated_character();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_updated_character() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_updated_character();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.FeatureActivatedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 78,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FeatureActivatedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    ::google::protobuf::internal::ArenaStringPtr feature_id_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE updated_character_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FeatureActivatedEvent_class_data_;
// -------------------------------------------------------------------

class AttackResolvedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.AttackResolvedEvent) */ {
 public:
  inline AttackResolvedEvent() : AttackResolvedEvent(nullptr) {}
  ~AttackResolvedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackResolvedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackResolvedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackResolvedEvent(::google::protobuf::internal::ConstantInitialized);

  inline AttackResolvedEvent(const AttackResolvedEvent& from) : AttackResolvedEvent(nullptr, from) {}
  inline AttackResolvedEvent(AttackResolvedEvent&& from) noexcept
      : AttackResolvedEvent(nullptr, ::std::move(from)) {}
  inline AttackResolvedEvent& operator=(const AttackResolvedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackResolvedEvent& operator=(AttackResolvedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttackResolvedEvent& default_instance() {
    return *reinterpret_cast<const AttackResolvedEvent*>(
        &_AttackResolvedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 56;
  friend void swap(AttackResolvedEvent& a, AttackResolvedEvent& b) { a.Swap(&b); }
  inline void Swap(AttackResolvedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackResolvedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackResolvedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttackResolvedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttackResolvedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttackResolvedEvent& from) { AttackResolvedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackResolvedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.AttackResolvedEvent"; }

  explicit AttackResolvedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AttackResolvedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AttackResolvedEvent& from);
  AttackResolvedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AttackResolvedEvent&& from) noexcept
      : AttackResolvedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAttackerIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kResultFieldNumber = 3,
    kUpdatedAttackerFieldNumber = 4,
    kUpdatedTargetFieldNumber = 5,
    kUpdatedRoomFieldNumber = 6,
    kGrantedActionFieldNumber = 7,
  };
  // string attacker_id = 1 [json_name = "attackerId"];
  void clear_attacker_id() ;
  const ::std::string& attacker_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_attacker_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_attacker_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_attacker_id();
  void set_allocated_attacker_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_attacker_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_attacker_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_attacker_id();

  public:
  // string target_id = 2 [json_name = "targetId"];
  void clear_target_id() ;
  const ::std::string& target_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_target_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_target_id();
  void set_allocated_target_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_target_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_target_id();

  public:
  // .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
  bool has_result() const;
  void clear_result() ;
  const ::dnd5e::api::v1alpha1::AttackResult& result() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE release_result();
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL mutable_result();
  void set_allocated_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE unsafe_arena_release_result();

  private:
  const ::dnd5e::api::v1alpha1::AttackResult& _internal_result() const;
  ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL _internal_mutable_result();

  public:
  // .dnd5e.api.v1alpha1.Character updated_attacker = 4 [json_name = "updatedAttacker"];
  bool has_updated_attacker() const;
  void clear_updated_attacker() ;
  const ::dnd5e::api::v1alpha1::Character& updated_attacker() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_updated_attacker();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_updated_attacker();
  void set_allocated_updated_attacker(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_attacker(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_updated_attacker();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_updated_attacker() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_updated_attacker();

  public:
  // .dnd5e.api.v1alpha1.Character updated_target = 5 [json_name = "updatedTarget"];
  bool has_updated_target() const;
  void clear_updated_target() ;
  const ::dnd5e::api::v1alpha1::Character& updated_target() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_updated_target();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_updated_target();
  void set_allocated_updated_target(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_target(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_updated_target();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_updated_target() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_updated_target();

  public:
  // .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
  bool has_updated_room() const;
  void clear_updated_room() ;
  const ::dnd5e::api::v1alpha1::Room& updated_room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_updated_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_updated_room();
  void set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_updated_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_updated_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_updated_room();

  public:
  // .dnd5e.api.v1alpha1.GrantedAction granted_action = 7 [json_name = "grantedAction"];
  bool has_granted_action() const;
  void clear_granted_action() ;
  const ::dnd5e::api::v1alpha1::GrantedAction& granted_action() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE release_granted_action();
  ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NONNULL mutable_granted_action();
  void set_allocated_granted_action(::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_granted_action(::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE unsafe_arena_release_granted_action();

  private:
  const ::dnd5e::api::v1alpha1::GrantedAction& _internal_granted_action() const;
  ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NONNULL _internal_mutable_granted_action();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.AttackResolvedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   5, 67,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AttackResolvedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr attacker_id_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE result_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE updated_attacker_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE updated_target_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE updated_room_;
    ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE granted_action_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AttackResolvedEvent_class_data_;
// -------------------------------------------------------------------

class ActivateFeatureResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.ActivateFeatureResponse) */ {
 public:
  inline ActivateFeatureResponse() : ActivateFeatureResponse(nullptr) {}
  ~ActivateFeatureResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActivateFeatureResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActivateFeatureResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActivateFeatureResponse(::google::protobuf::internal::ConstantInitialized);

  inline ActivateFeatureResponse(const ActivateFeatureResponse& from) : ActivateFeatureResponse(nullptr, from) {}
  inline ActivateFeatureResponse(ActivateFeatureResponse&& from) noexcept
      : ActivateFeatureResponse(nullptr, ::std::move(from)) {}
  inline ActivateFeatureResponse& operator=(const ActivateFeatureResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivateFeatureResponse& operator=(ActivateFeatureResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivateFeatureResponse& default_instance() {
    return *reinterpret_cast<const ActivateFeatureResponse*>(
        &_ActivateFeatureResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(ActivateFeatureResponse& a, ActivateFeatureResponse& b) { a.Swap(&b); }
  inline void Swap(ActivateFeatureResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivateFeatureResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivateFeatureResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActivateFeatureResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActivateFeatureResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActivateFeatureResponse& from) { ActivateFeatureResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActivateFeatureResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.ActivateFeatureResponse"; }

  explicit ActivateFeatureResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ActivateFeatureResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ActivateFeatureResponse& from);
  ActivateFeatureResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ActivateFeatureResponse&& from) noexcept
      : ActivateFeatureResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kUpdatedCharacterFieldNumber = 3,
    kUpdatedCombatStateFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string message = 2 [json_name = "message"];
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // .dnd5e.api.v1alpha1.Character updated_character = 3 [json_name = "updatedCharacter"];
  bool has_updated_character() const;
  void clear_updated_character() ;
  const ::dnd5e::api::v1alpha1::Character& updated_character() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE release_updated_character();
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_updated_character();
  void set_allocated_updated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE unsafe_arena_release_updated_character();

  private:
  const ::dnd5e::api::v1alpha1::Character& _internal_updated_character() const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL _internal_mutable_updated_character();

  public:
  // .dnd5e.api.v1alpha1.CombatState updated_combat_state = 4 [json_name = "updatedCombatState"];
  bool has_updated_combat_state() const;
  void clear_updated_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& updated_combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_updated_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_updated_combat_state();
  void set_allocated_updated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_updated_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_updated_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_updated_combat_state();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.ActivateFeatureResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 58,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ActivateFeatureResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE updated_character_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE updated_combat_state_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ActivateFeatureResponse_class_data_;
// -------------------------------------------------------------------

class StartCombatResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.StartCombatResponse) */ {
 public:
  inline StartCombatResponse() : StartCombatResponse(nullptr) {}
  ~StartCombatResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StartCombatResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StartCombatResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StartCombatResponse(::google::protobuf::internal::ConstantInitialized);

  inline StartCombatResponse(const StartCombatResponse& from) : StartCombatResponse(nullptr, from) {}
  inline StartCombatResponse(StartCombatResponse&& from) noexcept
      : StartCombatResponse(nullptr, ::std::move(from)) {}
  inline StartCombatResponse& operator=(const StartCombatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartCombatResponse& operator=(StartCombatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartCombatResponse& default_instance() {
    return *reinterpret_cast<const StartCombatResponse*>(
        &_StartCombatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 46;
  friend void swap(StartCombatResponse& a, StartCombatResponse& b) { a.Swap(&b); }
  inline void Swap(StartCombatResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartCombatResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartCombatResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StartCombatResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StartCombatResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StartCombatResponse& from) { StartCombatResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StartCombatResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.StartCombatResponse"; }

  explicit StartCombatResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StartCombatResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StartCombatResponse& from);
  StartCombatResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StartCombatResponse&& from) noexcept
      : StartCombatResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMonsterTurnsFieldNumber = 3,
    kDoorsFieldNumber = 4,
    kDungeonIdFieldNumber = 5,
    kCombatStateFieldNumber = 1,
    kRoomFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 3 [json_name = "monsterTurns"];
  int monster_turns_size() const;
  private:
  int _internal_monster_turns_size() const;

  public:
  void clear_monster_turns() ;
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL mutable_monster_turns(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL mutable_monster_turns();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& _internal_monster_turns() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL _internal_mutable_monster_turns();
  public:
  const ::dnd5e::api::v1alpha1::MonsterTurnResult& monster_turns(int index) const;
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL add_monster_turns();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& monster_turns() const;
  // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 4 [json_name = "doors"];
  int doors_size() const;
  private:
  int _internal_doors_size() const;

  public:
  void clear_doors() ;
  ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL mutable_doors(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL mutable_doors();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& _internal_doors() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL _internal_mutable_doors();
  public:
  const ::dnd5e::api::v1alpha1::DoorInfo& doors(int index) const;
  ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL add_doors();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& doors() const;
  // string dungeon_id = 5 [json_name = "dungeonId"];
  void clear_dungeon_id() ;
  const ::std::string& dungeon_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dungeon_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dungeon_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dungeon_id();
  void set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dungeon_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dungeon_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dungeon_id();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.StartCombatResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   4, 57,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StartCombatResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::MonsterTurnResult > monster_turns_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::DoorInfo > doors_;
    ::google::protobuf::internal::ArenaStringPtr dungeon_id_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StartCombatResponse_class_data_;
// -------------------------------------------------------------------

class PlayerReconnectedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.PlayerReconnectedEvent) */ {
 public:
  inline PlayerReconnectedEvent() : PlayerReconnectedEvent(nullptr) {}
  ~PlayerReconnectedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerReconnectedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerReconnectedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerReconnectedEvent(::google::protobuf::internal::ConstantInitialized);

  inline PlayerReconnectedEvent(const PlayerReconnectedEvent& from) : PlayerReconnectedEvent(nullptr, from) {}
  inline PlayerReconnectedEvent(PlayerReconnectedEvent&& from) noexcept
      : PlayerReconnectedEvent(nullptr, ::std::move(from)) {}
  inline PlayerReconnectedEvent& operator=(const PlayerReconnectedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReconnectedEvent& operator=(PlayerReconnectedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerReconnectedEvent& default_instance() {
    return *reinterpret_cast<const PlayerReconnectedEvent*>(
        &_PlayerReconnectedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 62;
  friend void swap(PlayerReconnectedEvent& a, PlayerReconnectedEvent& b) { a.Swap(&b); }
  inline void Swap(PlayerReconnectedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReconnectedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerReconnectedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerReconnectedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerReconnectedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerReconnectedEvent& from) { PlayerReconnectedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerReconnectedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.PlayerReconnectedEvent"; }

  explicit PlayerReconnectedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerReconnectedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerReconnectedEvent& from);
  PlayerReconnectedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerReconnectedEvent&& from) noexcept
      : PlayerReconnectedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerIdFieldNumber = 1,
    kMemberFieldNumber = 2,
  };
  // string player_id = 1 [json_name = "playerId"];
  void clear_player_id() ;
  const ::std::string& player_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_player_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_player_id();
  void set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_player_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_player_id();

  public:
  // .dnd5e.api.v1alpha1.PartyMember member = 2 [json_name = "member"];
  bool has_member() const;
  void clear_member() ;
  const ::dnd5e::api::v1alpha1::PartyMember& member() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE release_member();
  ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL mutable_member();
  void set_allocated_member(::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_member(::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE unsafe_arena_release_member();

  private:
  const ::dnd5e::api::v1alpha1::PartyMember& _internal_member() const;
  ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL _internal_mutable_member();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.PlayerReconnectedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 59,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerReconnectedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE member_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerReconnectedEvent_class_data_;
// -------------------------------------------------------------------

class PlayerJoinedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.PlayerJoinedEvent) */ {
 public:
  inline PlayerJoinedEvent() : PlayerJoinedEvent(nullptr) {}
  ~PlayerJoinedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerJoinedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerJoinedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerJoinedEvent(::google::protobuf::internal::ConstantInitialized);

  inline PlayerJoinedEvent(const PlayerJoinedEvent& from) : PlayerJoinedEvent(nullptr, from) {}
  inline PlayerJoinedEvent(PlayerJoinedEvent&& from) noexcept
      : PlayerJoinedEvent(nullptr, ::std::move(from)) {}
  inline PlayerJoinedEvent& operator=(const PlayerJoinedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerJoinedEvent& operator=(PlayerJoinedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerJoinedEvent& default_instance() {
    return *reinterpret_cast<const PlayerJoinedEvent*>(
        &_PlayerJoinedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 51;
  friend void swap(PlayerJoinedEvent& a, PlayerJoinedEvent& b) { a.Swap(&b); }
  inline void Swap(PlayerJoinedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerJoinedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerJoinedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerJoinedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerJoinedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerJoinedEvent& from) { PlayerJoinedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerJoinedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.PlayerJoinedEvent"; }

  explicit PlayerJoinedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerJoinedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerJoinedEvent& from);
  PlayerJoinedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerJoinedEvent&& from) noexcept
      : PlayerJoinedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMemberFieldNumber = 1,
  };
  // .dnd5e.api.v1alpha1.PartyMember member = 1 [json_name = "member"];
  bool has_member() const;
  void clear_member() ;
  const ::dnd5e::api::v1alpha1::PartyMember& member() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE release_member();
  ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL mutable_member();
  void set_allocated_member(::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_member(::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE unsafe_arena_release_member();

  private:
  const ::dnd5e::api::v1alpha1::PartyMember& _internal_member() const;
  ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL _internal_mutable_member();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.PlayerJoinedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerJoinedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE member_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerJoinedEvent_class_data_;
// -------------------------------------------------------------------

class OpenDoorResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.OpenDoorResponse) */ {
 public:
  inline OpenDoorResponse() : OpenDoorResponse(nullptr) {}
  ~OpenDoorResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OpenDoorResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OpenDoorResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OpenDoorResponse(::google::protobuf::internal::ConstantInitialized);

  inline OpenDoorResponse(const OpenDoorResponse& from) : OpenDoorResponse(nullptr, from) {}
  inline OpenDoorResponse(OpenDoorResponse&& from) noexcept
      : OpenDoorResponse(nullptr, ::std::move(from)) {}
  inline OpenDoorResponse& operator=(const OpenDoorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenDoorResponse& operator=(OpenDoorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenDoorResponse& default_instance() {
    return *reinterpret_cast<const OpenDoorResponse*>(
        &_OpenDoorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(OpenDoorResponse& a, OpenDoorResponse& b) { a.Swap(&b); }
  inline void Swap(OpenDoorResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenDoorResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenDoorResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OpenDoorResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpenDoorResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OpenDoorResponse& from) { OpenDoorResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OpenDoorResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.OpenDoorResponse"; }

  explicit OpenDoorResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OpenDoorResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OpenDoorResponse& from);
  OpenDoorResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OpenDoorResponse&& from) noexcept
      : OpenDoorResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMonsterTurnsFieldNumber = 6,
    kDoorsFieldNumber = 7,
    kErrorFieldNumber = 2,
    kEncounterIdFieldNumber = 3,
    kRoomFieldNumber = 4,
    kCombatStateFieldNumber = 5,
    kRoomOriginFieldNumber = 9,
    kSuccessFieldNumber = 1,
    kDungeonStateFieldNumber = 8,
  };
  // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 6 [json_name = "monsterTurns"];
  int monster_turns_size() const;
  private:
  int _internal_monster_turns_size() const;

  public:
  void clear_monster_turns() ;
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL mutable_monster_turns(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL mutable_monster_turns();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& _internal_monster_turns() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL _internal_mutable_monster_turns();
  public:
  const ::dnd5e::api::v1alpha1::MonsterTurnResult& monster_turns(int index) const;
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL add_monster_turns();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& monster_turns() const;
  // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 7 [json_name = "doors"];
  int doors_size() const;
  private:
  int _internal_doors_size() const;

  public:
  void clear_doors() ;
  ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL mutable_doors(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL mutable_doors();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& _internal_doors() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL _internal_mutable_doors();
  public:
  const ::dnd5e::api::v1alpha1::DoorInfo& doors(int index) const;
  ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL add_doors();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& doors() const;
  // string error = 2 [json_name = "error"];
  void clear_error() ;
  const ::std::string& error() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // string encounter_id = 3 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // .dnd5e.api.v1alpha1.Room room = 4 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 5 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // .api.v1alpha1.Position room_origin = 9 [json_name = "roomOrigin"];
  bool has_room_origin() const;
  void clear_room_origin() ;
  const ::api::v1alpha1::Position& room_origin() const;
  [[nodiscard]] ::api::v1alpha1::Position* PROTOBUF_NULLABLE release_room_origin();
  ::api::v1alpha1::Position* PROTOBUF_NONNULL mutable_room_origin();
  void set_allocated_room_origin(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room_origin(::api::v1alpha1::Position* PROTOBUF_NULLABLE value);
  ::api::v1alpha1::Position* PROTOBUF_NULLABLE unsafe_arena_release_room_origin();

  private:
  const ::api::v1alpha1::Position& _internal_room_origin() const;
  ::api::v1alpha1::Position* PROTOBUF_NONNULL _internal_mutable_room_origin();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 8 [json_name = "dungeonState"];
  void clear_dungeon_state() ;
  ::dnd5e::api::v1alpha1::DungeonState dungeon_state() const;
  void set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value);

  private:
  ::dnd5e::api::v1alpha1::DungeonState _internal_dungeon_state() const;
  void _internal_set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.OpenDoorResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   5, 69,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OpenDoorResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::MonsterTurnResult > monster_turns_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::DoorInfo > doors_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE room_origin_;
    bool success_;
    int dungeon_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull OpenDoorResponse_class_data_;
// -------------------------------------------------------------------

class MonsterTurnCompletedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent) */ {
 public:
  inline MonsterTurnCompletedEvent() : MonsterTurnCompletedEvent(nullptr) {}
  ~MonsterTurnCompletedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MonsterTurnCompletedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MonsterTurnCompletedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MonsterTurnCompletedEvent(::google::protobuf::internal::ConstantInitialized);

  inline MonsterTurnCompletedEvent(const MonsterTurnCompletedEvent& from) : MonsterTurnCompletedEvent(nullptr, from) {}
  inline MonsterTurnCompletedEvent(MonsterTurnCompletedEvent&& from) noexcept
      : MonsterTurnCompletedEvent(nullptr, ::std::move(from)) {}
  inline MonsterTurnCompletedEvent& operator=(const MonsterTurnCompletedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterTurnCompletedEvent& operator=(MonsterTurnCompletedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterTurnCompletedEvent& default_instance() {
    return *reinterpret_cast<const MonsterTurnCompletedEvent*>(
        &_MonsterTurnCompletedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 59;
  friend void swap(MonsterTurnCompletedEvent& a, MonsterTurnCompletedEvent& b) { a.Swap(&b); }
  inline void Swap(MonsterTurnCompletedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterTurnCompletedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterTurnCompletedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MonsterTurnCompletedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MonsterTurnCompletedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MonsterTurnCompletedEvent& from) { MonsterTurnCompletedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MonsterTurnCompletedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.MonsterTurnCompletedEvent"; }

  explicit MonsterTurnCompletedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MonsterTurnCompletedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MonsterTurnCompletedEvent& from);
  MonsterTurnCompletedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MonsterTurnCompletedEvent&& from) noexcept
      : MonsterTurnCompletedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUpdatedCharactersFieldNumber = 2,
    kMonsterTurnFieldNumber = 1,
    kUpdatedRoomFieldNumber = 3,
  };
  // repeated .dnd5e.api.v1alpha1.Character updated_characters = 2 [json_name = "updatedCharacters"];
  int updated_characters_size() const;
  private:
  int _internal_updated_characters_size() const;

  public:
  void clear_updated_characters() ;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL mutable_updated_characters(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>* PROTOBUF_NONNULL mutable_updated_characters();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>& _internal_updated_characters() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>* PROTOBUF_NONNULL _internal_mutable_updated_characters();
  public:
  const ::dnd5e::api::v1alpha1::Character& updated_characters(int index) const;
  ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL add_updated_characters();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>& updated_characters() const;
  // .dnd5e.api.v1alpha1.MonsterTurnResult monster_turn = 1 [json_name = "monsterTurn"];
  bool has_monster_turn() const;
  void clear_monster_turn() ;
  const ::dnd5e::api::v1alpha1::MonsterTurnResult& monster_turn() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NULLABLE release_monster_turn();
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL mutable_monster_turn();
  void set_allocated_monster_turn(::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_monster_turn(::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NULLABLE unsafe_arena_release_monster_turn();

  private:
  const ::dnd5e::api::v1alpha1::MonsterTurnResult& _internal_monster_turn() const;
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL _internal_mutable_monster_turn();

  public:
  // .dnd5e.api.v1alpha1.Room updated_room = 3 [json_name = "updatedRoom"];
  bool has_updated_room() const;
  void clear_updated_room() ;
  const ::dnd5e::api::v1alpha1::Room& updated_room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_updated_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_updated_room();
  void set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_updated_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_updated_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_updated_room();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MonsterTurnCompletedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::Character > updated_characters_;
    ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NULLABLE monster_turn_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE updated_room_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MonsterTurnCompletedEvent_class_data_;
// -------------------------------------------------------------------

class JoinEncounterResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.JoinEncounterResponse) */ {
 public:
  inline JoinEncounterResponse() : JoinEncounterResponse(nullptr) {}
  ~JoinEncounterResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(JoinEncounterResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(JoinEncounterResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JoinEncounterResponse(::google::protobuf::internal::ConstantInitialized);

  inline JoinEncounterResponse(const JoinEncounterResponse& from) : JoinEncounterResponse(nullptr, from) {}
  inline JoinEncounterResponse(JoinEncounterResponse&& from) noexcept
      : JoinEncounterResponse(nullptr, ::std::move(from)) {}
  inline JoinEncounterResponse& operator=(const JoinEncounterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinEncounterResponse& operator=(JoinEncounterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinEncounterResponse& default_instance() {
    return *reinterpret_cast<const JoinEncounterResponse*>(
        &_JoinEncounterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(JoinEncounterResponse& a, JoinEncounterResponse& b) { a.Swap(&b); }
  inline void Swap(JoinEncounterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinEncounterResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinEncounterResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<JoinEncounterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JoinEncounterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JoinEncounterResponse& from) { JoinEncounterResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(JoinEncounterResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.JoinEncounterResponse"; }

  explicit JoinEncounterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  JoinEncounterResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const JoinEncounterResponse& from);
  JoinEncounterResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, JoinEncounterResponse&& from) noexcept
      : JoinEncounterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPartyFieldNumber = 3,
    kEncounterIdFieldNumber = 1,
    kRoomFieldNumber = 2,
    kStateFieldNumber = 4,
  };
  // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
  int party_size() const;
  private:
  int _internal_party_size() const;

  public:
  void clear_party() ;
  ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL mutable_party(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>* PROTOBUF_NONNULL mutable_party();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>& _internal_party() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>* PROTOBUF_NONNULL _internal_mutable_party();
  public:
  const ::dnd5e::api::v1alpha1::PartyMember& party(int index) const;
  ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL add_party();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>& party() const;
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // .dnd5e.api.v1alpha1.EncounterState state = 4 [json_name = "state"];
  void clear_state() ;
  ::dnd5e::api::v1alpha1::EncounterState state() const;
  void set_state(::dnd5e::api::v1alpha1::EncounterState value);

  private:
  ::dnd5e::api::v1alpha1::EncounterState _internal_state() const;
  void _internal_set_state(::dnd5e::api::v1alpha1::EncounterState value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.JoinEncounterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 61,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const JoinEncounterResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::PartyMember > party_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull JoinEncounterResponse_class_data_;
// -------------------------------------------------------------------

class GetEncounterStateResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetEncounterStateResponse) */ {
 public:
  inline GetEncounterStateResponse() : GetEncounterStateResponse(nullptr) {}
  ~GetEncounterStateResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetEncounterStateResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetEncounterStateResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetEncounterStateResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetEncounterStateResponse(const GetEncounterStateResponse& from) : GetEncounterStateResponse(nullptr, from) {}
  inline GetEncounterStateResponse(GetEncounterStateResponse&& from) noexcept
      : GetEncounterStateResponse(nullptr, ::std::move(from)) {}
  inline GetEncounterStateResponse& operator=(const GetEncounterStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEncounterStateResponse& operator=(GetEncounterStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEncounterStateResponse& default_instance() {
    return *reinterpret_cast<const GetEncounterStateResponse*>(
        &_GetEncounterStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(GetEncounterStateResponse& a, GetEncounterStateResponse& b) { a.Swap(&b); }
  inline void Swap(GetEncounterStateResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEncounterStateResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEncounterStateResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetEncounterStateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetEncounterStateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetEncounterStateResponse& from) { GetEncounterStateResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetEncounterStateResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetEncounterStateResponse"; }

  explicit GetEncounterStateResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetEncounterStateResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetEncounterStateResponse& from);
  GetEncounterStateResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetEncounterStateResponse&& from) noexcept
      : GetEncounterStateResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPartyFieldNumber = 3,
    kMonstersFieldNumber = 8,
    kDoorsFieldNumber = 10,
    kEncounterIdFieldNumber = 1,
    kJoinCodeFieldNumber = 4,
    kHostIdFieldNumber = 5,
    kLastEventIdFieldNumber = 9,
    kDungeonIdFieldNumber = 11,
    kCombatStateFieldNumber = 6,
    kRoomFieldNumber = 7,
    kStateFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
  int party_size() const;
  private:
  int _internal_party_size() const;

  public:
  void clear_party() ;
  ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL mutable_party(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>* PROTOBUF_NONNULL mutable_party();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>& _internal_party() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>* PROTOBUF_NONNULL _internal_mutable_party();
  public:
  const ::dnd5e::api::v1alpha1::PartyMember& party(int index) const;
  ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL add_party();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>& party() const;
  // repeated .dnd5e.api.v1alpha1.MonsterCombatState monsters = 8 [json_name = "monsters"];
  int monsters_size() const;
  private:
  int _internal_monsters_size() const;

  public:
  void clear_monsters() ;
  ::dnd5e::api::v1alpha1::MonsterCombatState* PROTOBUF_NONNULL mutable_monsters(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>* PROTOBUF_NONNULL mutable_monsters();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>& _internal_monsters() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>* PROTOBUF_NONNULL _internal_mutable_monsters();
  public:
  const ::dnd5e::api::v1alpha1::MonsterCombatState& monsters(int index) const;
  ::dnd5e::api::v1alpha1::MonsterCombatState* PROTOBUF_NONNULL add_monsters();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>& monsters() const;
  // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 10 [json_name = "doors"];
  int doors_size() const;
  private:
  int _internal_doors_size() const;

  public:
  void clear_doors() ;
  ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL mutable_doors(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL mutable_doors();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& _internal_doors() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL _internal_mutable_doors();
  public:
  const ::dnd5e::api::v1alpha1::DoorInfo& doors(int index) const;
  ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL add_doors();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& doors() const;
  // string encounter_id = 1 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // string join_code = 4 [json_name = "joinCode"];
  void clear_join_code() ;
  const ::std::string& join_code() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_join_code(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_join_code();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_join_code();
  void set_allocated_join_code(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_join_code() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_join_code(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_join_code();

  public:
  // string host_id = 5 [json_name = "hostId"];
  void clear_host_id() ;
  const ::std::string& host_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_host_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_host_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_host_id();
  void set_allocated_host_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_host_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_host_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_host_id();

  public:
  // string last_event_id = 9 [json_name = "lastEventId"];
  void clear_last_event_id() ;
  const ::std::string& last_event_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_last_event_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_last_event_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_last_event_id();
  void set_allocated_last_event_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_last_event_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_last_event_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_last_event_id();

  public:
  // string dungeon_id = 11 [json_name = "dungeonId"];
  void clear_dungeon_id() ;
  const ::std::string& dungeon_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dungeon_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dungeon_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dungeon_id();
  void set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dungeon_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dungeon_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dungeon_id();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 6 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // .dnd5e.api.v1alpha1.Room room = 7 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // .dnd5e.api.v1alpha1.EncounterState state = 2 [json_name = "state"];
  void clear_state() ;
  ::dnd5e::api::v1alpha1::EncounterState state() const;
  void set_state(::dnd5e::api::v1alpha1::EncounterState value);

  private:
  ::dnd5e::api::v1alpha1::EncounterState _internal_state() const;
  void _internal_set_state(::dnd5e::api::v1alpha1::EncounterState value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetEncounterStateResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11,
                                   5, 112,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetEncounterStateResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::PartyMember > party_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::MonsterCombatState > monsters_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::DoorInfo > doors_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::google::protobuf::internal::ArenaStringPtr join_code_;
    ::google::protobuf::internal::ArenaStringPtr host_id_;
    ::google::protobuf::internal::ArenaStringPtr last_event_id_;
    ::google::protobuf::internal::ArenaStringPtr dungeon_id_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetEncounterStateResponse_class_data_;
// -------------------------------------------------------------------

class EndTurnResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EndTurnResponse) */ {
 public:
  inline EndTurnResponse() : EndTurnResponse(nullptr) {}
  ~EndTurnResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EndTurnResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EndTurnResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EndTurnResponse(::google::protobuf::internal::ConstantInitialized);

  inline EndTurnResponse(const EndTurnResponse& from) : EndTurnResponse(nullptr, from) {}
  inline EndTurnResponse(EndTurnResponse&& from) noexcept
      : EndTurnResponse(nullptr, ::std::move(from)) {}
  inline EndTurnResponse& operator=(const EndTurnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndTurnResponse& operator=(EndTurnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndTurnResponse& default_instance() {
    return *reinterpret_cast<const EndTurnResponse*>(
        &_EndTurnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(EndTurnResponse& a, EndTurnResponse& b) { a.Swap(&b); }
  inline void Swap(EndTurnResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndTurnResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndTurnResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EndTurnResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EndTurnResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EndTurnResponse& from) { EndTurnResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EndTurnResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EndTurnResponse"; }

  explicit EndTurnResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EndTurnResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EndTurnResponse& from);
  EndTurnResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EndTurnResponse&& from) noexcept
      : EndTurnResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMonsterTurnsFieldNumber = 4,
    kCombatStateFieldNumber = 2,
    kTurnChangeFieldNumber = 3,
    kEncounterResultFieldNumber = 5,
    kSuccessFieldNumber = 1,
  };
  // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 4 [json_name = "monsterTurns"];
  int monster_turns_size() const;
  private:
  int _internal_monster_turns_size() const;

  public:
  void clear_monster_turns() ;
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL mutable_monster_turns(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL mutable_monster_turns();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& _internal_monster_turns() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL _internal_mutable_monster_turns();
  public:
  const ::dnd5e::api::v1alpha1::MonsterTurnResult& monster_turns(int index) const;
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL add_monster_turns();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& monster_turns() const;
  // .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 3 [json_name = "turnChange"];
  bool has_turn_change() const;
  void clear_turn_change() ;
  const ::dnd5e::api::v1alpha1::TurnChangeEvent& turn_change() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE release_turn_change();
  ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL mutable_turn_change();
  void set_allocated_turn_change(::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_turn_change(::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE unsafe_arena_release_turn_change();

  private:
  const ::dnd5e::api::v1alpha1::TurnChangeEvent& _internal_turn_change() const;
  ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL _internal_mutable_turn_change();

  public:
  // optional .dnd5e.api.v1alpha1.EncounterResult encounter_result = 5 [json_name = "encounterResult"];
  bool has_encounter_result() const;
  void clear_encounter_result() ;
  const ::dnd5e::api::v1alpha1::EncounterResult& encounter_result() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE release_encounter_result();
  ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NONNULL mutable_encounter_result();
  void set_allocated_encounter_result(::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_encounter_result(::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE unsafe_arena_release_encounter_result();

  private:
  const ::dnd5e::api::v1alpha1::EncounterResult& _internal_encounter_result() const;
  ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NONNULL _internal_mutable_encounter_result();

  public:
  // bool success = 1 [json_name = "success"];
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EndTurnResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EndTurnResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::MonsterTurnResult > monster_turns_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE turn_change_;
    ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE encounter_result_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EndTurnResponse_class_data_;
// -------------------------------------------------------------------

class DungeonStartResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.DungeonStartResponse) */ {
 public:
  inline DungeonStartResponse() : DungeonStartResponse(nullptr) {}
  ~DungeonStartResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DungeonStartResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DungeonStartResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DungeonStartResponse(::google::protobuf::internal::ConstantInitialized);

  inline DungeonStartResponse(const DungeonStartResponse& from) : DungeonStartResponse(nullptr, from) {}
  inline DungeonStartResponse(DungeonStartResponse&& from) noexcept
      : DungeonStartResponse(nullptr, ::std::move(from)) {}
  inline DungeonStartResponse& operator=(const DungeonStartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonStartResponse& operator=(DungeonStartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonStartResponse& default_instance() {
    return *reinterpret_cast<const DungeonStartResponse*>(
        &_DungeonStartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(DungeonStartResponse& a, DungeonStartResponse& b) { a.Swap(&b); }
  inline void Swap(DungeonStartResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonStartResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonStartResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DungeonStartResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DungeonStartResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DungeonStartResponse& from) { DungeonStartResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DungeonStartResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.DungeonStartResponse"; }

  explicit DungeonStartResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DungeonStartResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DungeonStartResponse& from);
  DungeonStartResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DungeonStartResponse&& from) noexcept
      : DungeonStartResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMonsterTurnsFieldNumber = 5,
    kDoorsFieldNumber = 6,
    kDungeonIdFieldNumber = 1,
    kEncounterIdFieldNumber = 2,
    kRoomFieldNumber = 3,
    kCombatStateFieldNumber = 4,
    kDungeonStateFieldNumber = 7,
  };
  // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 5 [json_name = "monsterTurns"];
  int monster_turns_size() const;
  private:
  int _internal_monster_turns_size() const;

  public:
  void clear_monster_turns() ;
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL mutable_monster_turns(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL mutable_monster_turns();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& _internal_monster_turns() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL _internal_mutable_monster_turns();
  public:
  const ::dnd5e::api::v1alpha1::MonsterTurnResult& monster_turns(int index) const;
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL add_monster_turns();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& monster_turns() const;
  // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 6 [json_name = "doors"];
  int doors_size() const;
  private:
  int _internal_doors_size() const;

  public:
  void clear_doors() ;
  ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL mutable_doors(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL mutable_doors();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& _internal_doors() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL _internal_mutable_doors();
  public:
  const ::dnd5e::api::v1alpha1::DoorInfo& doors(int index) const;
  ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL add_doors();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& doors() const;
  // string dungeon_id = 1 [json_name = "dungeonId"];
  void clear_dungeon_id() ;
  const ::std::string& dungeon_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dungeon_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dungeon_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dungeon_id();
  void set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dungeon_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dungeon_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dungeon_id();

  public:
  // string encounter_id = 2 [json_name = "encounterId"];
  void clear_encounter_id() ;
  const ::std::string& encounter_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_encounter_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_encounter_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_encounter_id();
  void set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_encounter_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_encounter_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_encounter_id();

  public:
  // .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // .dnd5e.api.v1alpha1.DungeonState dungeon_state = 7 [json_name = "dungeonState"];
  void clear_dungeon_state() ;
  ::dnd5e::api::v1alpha1::DungeonState dungeon_state() const;
  void set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value);

  private:
  ::dnd5e::api::v1alpha1::DungeonState _internal_dungeon_state() const;
  void _internal_set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.DungeonStartResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   4, 70,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DungeonStartResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::MonsterTurnResult > monster_turns_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::DoorInfo > doors_;
    ::google::protobuf::internal::ArenaStringPtr dungeon_id_;
    ::google::protobuf::internal::ArenaStringPtr encounter_id_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    int dungeon_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DungeonStartResponse_class_data_;
// -------------------------------------------------------------------

class CombatStartedEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.CombatStartedEvent) */ {
 public:
  inline CombatStartedEvent() : CombatStartedEvent(nullptr) {}
  ~CombatStartedEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CombatStartedEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CombatStartedEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CombatStartedEvent(::google::protobuf::internal::ConstantInitialized);

  inline CombatStartedEvent(const CombatStartedEvent& from) : CombatStartedEvent(nullptr, from) {}
  inline CombatStartedEvent(CombatStartedEvent&& from) noexcept
      : CombatStartedEvent(nullptr, ::std::move(from)) {}
  inline CombatStartedEvent& operator=(const CombatStartedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombatStartedEvent& operator=(CombatStartedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombatStartedEvent& default_instance() {
    return *reinterpret_cast<const CombatStartedEvent*>(
        &_CombatStartedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 54;
  friend void swap(CombatStartedEvent& a, CombatStartedEvent& b) { a.Swap(&b); }
  inline void Swap(CombatStartedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombatStartedEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombatStartedEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CombatStartedEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CombatStartedEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CombatStartedEvent& from) { CombatStartedEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CombatStartedEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.CombatStartedEvent"; }

  explicit CombatStartedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CombatStartedEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CombatStartedEvent& from);
  CombatStartedEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CombatStartedEvent&& from) noexcept
      : CombatStartedEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPartyFieldNumber = 3,
    kMonstersFieldNumber = 4,
    kDoorsFieldNumber = 5,
    kMonsterTurnsFieldNumber = 7,
    kDungeonIdFieldNumber = 6,
    kCombatStateFieldNumber = 1,
    kRoomFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
  int party_size() const;
  private:
  int _internal_party_size() const;

  public:
  void clear_party() ;
  ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL mutable_party(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>* PROTOBUF_NONNULL mutable_party();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>& _internal_party() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>* PROTOBUF_NONNULL _internal_mutable_party();
  public:
  const ::dnd5e::api::v1alpha1::PartyMember& party(int index) const;
  ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL add_party();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>& party() const;
  // repeated .dnd5e.api.v1alpha1.MonsterCombatState monsters = 4 [json_name = "monsters"];
  int monsters_size() const;
  private:
  int _internal_monsters_size() const;

  public:
  void clear_monsters() ;
  ::dnd5e::api::v1alpha1::MonsterCombatState* PROTOBUF_NONNULL mutable_monsters(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>* PROTOBUF_NONNULL mutable_monsters();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>& _internal_monsters() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>* PROTOBUF_NONNULL _internal_mutable_monsters();
  public:
  const ::dnd5e::api::v1alpha1::MonsterCombatState& monsters(int index) const;
  ::dnd5e::api::v1alpha1::MonsterCombatState* PROTOBUF_NONNULL add_monsters();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>& monsters() const;
  // repeated .dnd5e.api.v1alpha1.DoorInfo doors = 5 [json_name = "doors"];
  int doors_size() const;
  private:
  int _internal_doors_size() const;

  public:
  void clear_doors() ;
  ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL mutable_doors(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL mutable_doors();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& _internal_doors() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL _internal_mutable_doors();
  public:
  const ::dnd5e::api::v1alpha1::DoorInfo& doors(int index) const;
  ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL add_doors();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& doors() const;
  // repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 7 [json_name = "monsterTurns"];
  int monster_turns_size() const;
  private:
  int _internal_monster_turns_size() const;

  public:
  void clear_monster_turns() ;
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL mutable_monster_turns(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL mutable_monster_turns();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& _internal_monster_turns() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL _internal_mutable_monster_turns();
  public:
  const ::dnd5e::api::v1alpha1::MonsterTurnResult& monster_turns(int index) const;
  ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL add_monster_turns();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& monster_turns() const;
  // string dungeon_id = 6 [json_name = "dungeonId"];
  void clear_dungeon_id() ;
  const ::std::string& dungeon_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dungeon_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dungeon_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dungeon_id();
  void set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dungeon_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dungeon_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dungeon_id();

  public:
  // .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
  bool has_combat_state() const;
  void clear_combat_state() ;
  const ::dnd5e::api::v1alpha1::CombatState& combat_state() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE release_combat_state();
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL mutable_combat_state();
  void set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE unsafe_arena_release_combat_state();

  private:
  const ::dnd5e::api::v1alpha1::CombatState& _internal_combat_state() const;
  ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL _internal_mutable_combat_state();

  public:
  // .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
  bool has_room() const;
  void clear_room() ;
  const ::dnd5e::api::v1alpha1::Room& room() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE release_room();
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::dnd5e::api::v1alpha1::Room& _internal_room() const;
  ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.CombatStartedEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   6, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CombatStartedEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::PartyMember > party_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::MonsterCombatState > monsters_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::DoorInfo > doors_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::MonsterTurnResult > monster_turns_;
    ::google::protobuf::internal::ArenaStringPtr dungeon_id_;
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE combat_state_;
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE room_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CombatStartedEvent_class_data_;
// -------------------------------------------------------------------

class EncounterEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.EncounterEvent) */ {
 public:
  inline EncounterEvent() : EncounterEvent(nullptr) {}
  ~EncounterEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EncounterEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EncounterEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EncounterEvent(::google::protobuf::internal::ConstantInitialized);

  inline EncounterEvent(const EncounterEvent& from) : EncounterEvent(nullptr, from) {}
  inline EncounterEvent(EncounterEvent&& from) noexcept
      : EncounterEvent(nullptr, ::std::move(from)) {}
  inline EncounterEvent& operator=(const EncounterEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncounterEvent& operator=(EncounterEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncounterEvent& default_instance() {
    return *reinterpret_cast<const EncounterEvent*>(
        &_EncounterEvent_default_instance_);
  }
  enum EventCase {
    kPlayerJoined = 10,
    kPlayerLeft = 11,
    kPlayerReady = 12,
    kCombatStarted = 13,
    kMovementCompleted = 20,
    kAttackResolved = 21,
    kFeatureActivated = 22,
    kTurnEnded = 23,
    kMonsterTurnCompleted = 24,
    kCombatEnded = 25,
    kPlayerDisconnected = 30,
    kPlayerReconnected = 31,
    kCombatPaused = 32,
    kCombatResumed = 33,
    kRoomRevealed = 40,
    kDungeonVictory = 41,
    kDungeonFailure = 42,
    EVENT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 50;
  friend void swap(EncounterEvent& a, EncounterEvent& b) { a.Swap(&b); }
  inline void Swap(EncounterEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncounterEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncounterEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EncounterEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EncounterEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EncounterEvent& from) { EncounterEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EncounterEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.EncounterEvent"; }

  explicit EncounterEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EncounterEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EncounterEvent& from);
  EncounterEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EncounterEvent&& from) noexcept
      : EncounterEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kPlayerJoinedFieldNumber = 10,
    kPlayerLeftFieldNumber = 11,
    kPlayerReadyFieldNumber = 12,
    kCombatStartedFieldNumber = 13,
    kMovementCompletedFieldNumber = 20,
    kAttackResolvedFieldNumber = 21,
    kFeatureActivatedFieldNumber = 22,
    kTurnEndedFieldNumber = 23,
    kMonsterTurnCompletedFieldNumber = 24,
    kCombatEndedFieldNumber = 25,
    kPlayerDisconnectedFieldNumber = 30,
    kPlayerReconnectedFieldNumber = 31,
    kCombatPausedFieldNumber = 32,
    kCombatResumedFieldNumber = 33,
    kRoomRevealedFieldNumber = 40,
    kDungeonVictoryFieldNumber = 41,
    kDungeonFailureFieldNumber = 42,
  };
  // string event_id = 1 [json_name = "eventId"];
  void clear_event_id() ;
  const ::std::string& event_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_event_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_event_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_event_id();
  void set_allocated_event_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_event_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_event_id();

  public:
  // int64 timestamp = 2 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // .dnd5e.api.v1alpha1.PlayerJoinedEvent player_joined = 10 [json_name = "playerJoined"];
  bool has_player_joined() const;
  private:
  bool _internal_has_player_joined() const;

  public:
  void clear_player_joined() ;
  const ::dnd5e::api::v1alpha1::PlayerJoinedEvent& player_joined() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::PlayerJoinedEvent* PROTOBUF_NULLABLE release_player_joined();
  ::dnd5e::api::v1alpha1::PlayerJoinedEvent* PROTOBUF_NONNULL mutable_player_joined();
  void set_allocated_player_joined(::dnd5e::api::v1alpha1::PlayerJoinedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_joined(::dnd5e::api::v1alpha1::PlayerJoinedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::PlayerJoinedEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_joined();

  private:
  const ::dnd5e::api::v1alpha1::PlayerJoinedEvent& _internal_player_joined() const;
  ::dnd5e::api::v1alpha1::PlayerJoinedEvent* PROTOBUF_NONNULL _internal_mutable_player_joined();

  public:
  // .dnd5e.api.v1alpha1.PlayerLeftEvent player_left = 11 [json_name = "playerLeft"];
  bool has_player_left() const;
  private:
  bool _internal_has_player_left() const;

  public:
  void clear_player_left() ;
  const ::dnd5e::api::v1alpha1::PlayerLeftEvent& player_left() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::PlayerLeftEvent* PROTOBUF_NULLABLE release_player_left();
  ::dnd5e::api::v1alpha1::PlayerLeftEvent* PROTOBUF_NONNULL mutable_player_left();
  void set_allocated_player_left(::dnd5e::api::v1alpha1::PlayerLeftEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_left(::dnd5e::api::v1alpha1::PlayerLeftEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::PlayerLeftEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_left();

  private:
  const ::dnd5e::api::v1alpha1::PlayerLeftEvent& _internal_player_left() const;
  ::dnd5e::api::v1alpha1::PlayerLeftEvent* PROTOBUF_NONNULL _internal_mutable_player_left();

  public:
  // .dnd5e.api.v1alpha1.PlayerReadyEvent player_ready = 12 [json_name = "playerReady"];
  bool has_player_ready() const;
  private:
  bool _internal_has_player_ready() const;

  public:
  void clear_player_ready() ;
  const ::dnd5e::api::v1alpha1::PlayerReadyEvent& player_ready() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::PlayerReadyEvent* PROTOBUF_NULLABLE release_player_ready();
  ::dnd5e::api::v1alpha1::PlayerReadyEvent* PROTOBUF_NONNULL mutable_player_ready();
  void set_allocated_player_ready(::dnd5e::api::v1alpha1::PlayerReadyEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_ready(::dnd5e::api::v1alpha1::PlayerReadyEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::PlayerReadyEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_ready();

  private:
  const ::dnd5e::api::v1alpha1::PlayerReadyEvent& _internal_player_ready() const;
  ::dnd5e::api::v1alpha1::PlayerReadyEvent* PROTOBUF_NONNULL _internal_mutable_player_ready();

  public:
  // .dnd5e.api.v1alpha1.CombatStartedEvent combat_started = 13 [json_name = "combatStarted"];
  bool has_combat_started() const;
  private:
  bool _internal_has_combat_started() const;

  public:
  void clear_combat_started() ;
  const ::dnd5e::api::v1alpha1::CombatStartedEvent& combat_started() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatStartedEvent* PROTOBUF_NULLABLE release_combat_started();
  ::dnd5e::api::v1alpha1::CombatStartedEvent* PROTOBUF_NONNULL mutable_combat_started();
  void set_allocated_combat_started(::dnd5e::api::v1alpha1::CombatStartedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_started(::dnd5e::api::v1alpha1::CombatStartedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatStartedEvent* PROTOBUF_NULLABLE unsafe_arena_release_combat_started();

  private:
  const ::dnd5e::api::v1alpha1::CombatStartedEvent& _internal_combat_started() const;
  ::dnd5e::api::v1alpha1::CombatStartedEvent* PROTOBUF_NONNULL _internal_mutable_combat_started();

  public:
  // .dnd5e.api.v1alpha1.MovementCompletedEvent movement_completed = 20 [json_name = "movementCompleted"];
  bool has_movement_completed() const;
  private:
  bool _internal_has_movement_completed() const;

  public:
  void clear_movement_completed() ;
  const ::dnd5e::api::v1alpha1::MovementCompletedEvent& movement_completed() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::MovementCompletedEvent* PROTOBUF_NULLABLE release_movement_completed();
  ::dnd5e::api::v1alpha1::MovementCompletedEvent* PROTOBUF_NONNULL mutable_movement_completed();
  void set_allocated_movement_completed(::dnd5e::api::v1alpha1::MovementCompletedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_movement_completed(::dnd5e::api::v1alpha1::MovementCompletedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::MovementCompletedEvent* PROTOBUF_NULLABLE unsafe_arena_release_movement_completed();

  private:
  const ::dnd5e::api::v1alpha1::MovementCompletedEvent& _internal_movement_completed() const;
  ::dnd5e::api::v1alpha1::MovementCompletedEvent* PROTOBUF_NONNULL _internal_mutable_movement_completed();

  public:
  // .dnd5e.api.v1alpha1.AttackResolvedEvent attack_resolved = 21 [json_name = "attackResolved"];
  bool has_attack_resolved() const;
  private:
  bool _internal_has_attack_resolved() const;

  public:
  void clear_attack_resolved() ;
  const ::dnd5e::api::v1alpha1::AttackResolvedEvent& attack_resolved() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::AttackResolvedEvent* PROTOBUF_NULLABLE release_attack_resolved();
  ::dnd5e::api::v1alpha1::AttackResolvedEvent* PROTOBUF_NONNULL mutable_attack_resolved();
  void set_allocated_attack_resolved(::dnd5e::api::v1alpha1::AttackResolvedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_attack_resolved(::dnd5e::api::v1alpha1::AttackResolvedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::AttackResolvedEvent* PROTOBUF_NULLABLE unsafe_arena_release_attack_resolved();

  private:
  const ::dnd5e::api::v1alpha1::AttackResolvedEvent& _internal_attack_resolved() const;
  ::dnd5e::api::v1alpha1::AttackResolvedEvent* PROTOBUF_NONNULL _internal_mutable_attack_resolved();

  public:
  // .dnd5e.api.v1alpha1.FeatureActivatedEvent feature_activated = 22 [json_name = "featureActivated"];
  bool has_feature_activated() const;
  private:
  bool _internal_has_feature_activated() const;

  public:
  void clear_feature_activated() ;
  const ::dnd5e::api::v1alpha1::FeatureActivatedEvent& feature_activated() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::FeatureActivatedEvent* PROTOBUF_NULLABLE release_feature_activated();
  ::dnd5e::api::v1alpha1::FeatureActivatedEvent* PROTOBUF_NONNULL mutable_feature_activated();
  void set_allocated_feature_activated(::dnd5e::api::v1alpha1::FeatureActivatedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_feature_activated(::dnd5e::api::v1alpha1::FeatureActivatedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::FeatureActivatedEvent* PROTOBUF_NULLABLE unsafe_arena_release_feature_activated();

  private:
  const ::dnd5e::api::v1alpha1::FeatureActivatedEvent& _internal_feature_activated() const;
  ::dnd5e::api::v1alpha1::FeatureActivatedEvent* PROTOBUF_NONNULL _internal_mutable_feature_activated();

  public:
  // .dnd5e.api.v1alpha1.TurnEndedEvent turn_ended = 23 [json_name = "turnEnded"];
  bool has_turn_ended() const;
  private:
  bool _internal_has_turn_ended() const;

  public:
  void clear_turn_ended() ;
  const ::dnd5e::api::v1alpha1::TurnEndedEvent& turn_ended() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::TurnEndedEvent* PROTOBUF_NULLABLE release_turn_ended();
  ::dnd5e::api::v1alpha1::TurnEndedEvent* PROTOBUF_NONNULL mutable_turn_ended();
  void set_allocated_turn_ended(::dnd5e::api::v1alpha1::TurnEndedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_turn_ended(::dnd5e::api::v1alpha1::TurnEndedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::TurnEndedEvent* PROTOBUF_NULLABLE unsafe_arena_release_turn_ended();

  private:
  const ::dnd5e::api::v1alpha1::TurnEndedEvent& _internal_turn_ended() const;
  ::dnd5e::api::v1alpha1::TurnEndedEvent* PROTOBUF_NONNULL _internal_mutable_turn_ended();

  public:
  // .dnd5e.api.v1alpha1.MonsterTurnCompletedEvent monster_turn_completed = 24 [json_name = "monsterTurnCompleted"];
  bool has_monster_turn_completed() const;
  private:
  bool _internal_has_monster_turn_completed() const;

  public:
  void clear_monster_turn_completed() ;
  const ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent& monster_turn_completed() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* PROTOBUF_NULLABLE release_monster_turn_completed();
  ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* PROTOBUF_NONNULL mutable_monster_turn_completed();
  void set_allocated_monster_turn_completed(::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_monster_turn_completed(::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* PROTOBUF_NULLABLE unsafe_arena_release_monster_turn_completed();

  private:
  const ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent& _internal_monster_turn_completed() const;
  ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* PROTOBUF_NONNULL _internal_mutable_monster_turn_completed();

  public:
  // .dnd5e.api.v1alpha1.CombatEndedEvent combat_ended = 25 [json_name = "combatEnded"];
  bool has_combat_ended() const;
  private:
  bool _internal_has_combat_ended() const;

  public:
  void clear_combat_ended() ;
  const ::dnd5e::api::v1alpha1::CombatEndedEvent& combat_ended() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatEndedEvent* PROTOBUF_NULLABLE release_combat_ended();
  ::dnd5e::api::v1alpha1::CombatEndedEvent* PROTOBUF_NONNULL mutable_combat_ended();
  void set_allocated_combat_ended(::dnd5e::api::v1alpha1::CombatEndedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_ended(::dnd5e::api::v1alpha1::CombatEndedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatEndedEvent* PROTOBUF_NULLABLE unsafe_arena_release_combat_ended();

  private:
  const ::dnd5e::api::v1alpha1::CombatEndedEvent& _internal_combat_ended() const;
  ::dnd5e::api::v1alpha1::CombatEndedEvent* PROTOBUF_NONNULL _internal_mutable_combat_ended();

  public:
  // .dnd5e.api.v1alpha1.PlayerDisconnectedEvent player_disconnected = 30 [json_name = "playerDisconnected"];
  bool has_player_disconnected() const;
  private:
  bool _internal_has_player_disconnected() const;

  public:
  void clear_player_disconnected() ;
  const ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent& player_disconnected() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* PROTOBUF_NULLABLE release_player_disconnected();
  ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* PROTOBUF_NONNULL mutable_player_disconnected();
  void set_allocated_player_disconnected(::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_disconnected(::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_disconnected();

  private:
  const ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent& _internal_player_disconnected() const;
  ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* PROTOBUF_NONNULL _internal_mutable_player_disconnected();

  public:
  // .dnd5e.api.v1alpha1.PlayerReconnectedEvent player_reconnected = 31 [json_name = "playerReconnected"];
  bool has_player_reconnected() const;
  private:
  bool _internal_has_player_reconnected() const;

  public:
  void clear_player_reconnected() ;
  const ::dnd5e::api::v1alpha1::PlayerReconnectedEvent& player_reconnected() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::PlayerReconnectedEvent* PROTOBUF_NULLABLE release_player_reconnected();
  ::dnd5e::api::v1alpha1::PlayerReconnectedEvent* PROTOBUF_NONNULL mutable_player_reconnected();
  void set_allocated_player_reconnected(::dnd5e::api::v1alpha1::PlayerReconnectedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_reconnected(::dnd5e::api::v1alpha1::PlayerReconnectedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::PlayerReconnectedEvent* PROTOBUF_NULLABLE unsafe_arena_release_player_reconnected();

  private:
  const ::dnd5e::api::v1alpha1::PlayerReconnectedEvent& _internal_player_reconnected() const;
  ::dnd5e::api::v1alpha1::PlayerReconnectedEvent* PROTOBUF_NONNULL _internal_mutable_player_reconnected();

  public:
  // .dnd5e.api.v1alpha1.CombatPausedEvent combat_paused = 32 [json_name = "combatPaused"];
  bool has_combat_paused() const;
  private:
  bool _internal_has_combat_paused() const;

  public:
  void clear_combat_paused() ;
  const ::dnd5e::api::v1alpha1::CombatPausedEvent& combat_paused() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatPausedEvent* PROTOBUF_NULLABLE release_combat_paused();
  ::dnd5e::api::v1alpha1::CombatPausedEvent* PROTOBUF_NONNULL mutable_combat_paused();
  void set_allocated_combat_paused(::dnd5e::api::v1alpha1::CombatPausedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_paused(::dnd5e::api::v1alpha1::CombatPausedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatPausedEvent* PROTOBUF_NULLABLE unsafe_arena_release_combat_paused();

  private:
  const ::dnd5e::api::v1alpha1::CombatPausedEvent& _internal_combat_paused() const;
  ::dnd5e::api::v1alpha1::CombatPausedEvent* PROTOBUF_NONNULL _internal_mutable_combat_paused();

  public:
  // .dnd5e.api.v1alpha1.CombatResumedEvent combat_resumed = 33 [json_name = "combatResumed"];
  bool has_combat_resumed() const;
  private:
  bool _internal_has_combat_resumed() const;

  public:
  void clear_combat_resumed() ;
  const ::dnd5e::api::v1alpha1::CombatResumedEvent& combat_resumed() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::CombatResumedEvent* PROTOBUF_NULLABLE release_combat_resumed();
  ::dnd5e::api::v1alpha1::CombatResumedEvent* PROTOBUF_NONNULL mutable_combat_resumed();
  void set_allocated_combat_resumed(::dnd5e::api::v1alpha1::CombatResumedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combat_resumed(::dnd5e::api::v1alpha1::CombatResumedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::CombatResumedEvent* PROTOBUF_NULLABLE unsafe_arena_release_combat_resumed();

  private:
  const ::dnd5e::api::v1alpha1::CombatResumedEvent& _internal_combat_resumed() const;
  ::dnd5e::api::v1alpha1::CombatResumedEvent* PROTOBUF_NONNULL _internal_mutable_combat_resumed();

  public:
  // .dnd5e.api.v1alpha1.RoomRevealedEvent room_revealed = 40 [json_name = "roomRevealed"];
  bool has_room_revealed() const;
  private:
  bool _internal_has_room_revealed() const;

  public:
  void clear_room_revealed() ;
  const ::dnd5e::api::v1alpha1::RoomRevealedEvent& room_revealed() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::RoomRevealedEvent* PROTOBUF_NULLABLE release_room_revealed();
  ::dnd5e::api::v1alpha1::RoomRevealedEvent* PROTOBUF_NONNULL mutable_room_revealed();
  void set_allocated_room_revealed(::dnd5e::api::v1alpha1::RoomRevealedEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room_revealed(::dnd5e::api::v1alpha1::RoomRevealedEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::RoomRevealedEvent* PROTOBUF_NULLABLE unsafe_arena_release_room_revealed();

  private:
  const ::dnd5e::api::v1alpha1::RoomRevealedEvent& _internal_room_revealed() const;
  ::dnd5e::api::v1alpha1::RoomRevealedEvent* PROTOBUF_NONNULL _internal_mutable_room_revealed();

  public:
  // .dnd5e.api.v1alpha1.DungeonVictoryEvent dungeon_victory = 41 [json_name = "dungeonVictory"];
  bool has_dungeon_victory() const;
  private:
  bool _internal_has_dungeon_victory() const;

  public:
  void clear_dungeon_victory() ;
  const ::dnd5e::api::v1alpha1::DungeonVictoryEvent& dungeon_victory() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::DungeonVictoryEvent* PROTOBUF_NULLABLE release_dungeon_victory();
  ::dnd5e::api::v1alpha1::DungeonVictoryEvent* PROTOBUF_NONNULL mutable_dungeon_victory();
  void set_allocated_dungeon_victory(::dnd5e::api::v1alpha1::DungeonVictoryEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dungeon_victory(::dnd5e::api::v1alpha1::DungeonVictoryEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::DungeonVictoryEvent* PROTOBUF_NULLABLE unsafe_arena_release_dungeon_victory();

  private:
  const ::dnd5e::api::v1alpha1::DungeonVictoryEvent& _internal_dungeon_victory() const;
  ::dnd5e::api::v1alpha1::DungeonVictoryEvent* PROTOBUF_NONNULL _internal_mutable_dungeon_victory();

  public:
  // .dnd5e.api.v1alpha1.DungeonFailureEvent dungeon_failure = 42 [json_name = "dungeonFailure"];
  bool has_dungeon_failure() const;
  private:
  bool _internal_has_dungeon_failure() const;

  public:
  void clear_dungeon_failure() ;
  const ::dnd5e::api::v1alpha1::DungeonFailureEvent& dungeon_failure() const;
  [[nodiscard]] ::dnd5e::api::v1alpha1::DungeonFailureEvent* PROTOBUF_NULLABLE release_dungeon_failure();
  ::dnd5e::api::v1alpha1::DungeonFailureEvent* PROTOBUF_NONNULL mutable_dungeon_failure();
  void set_allocated_dungeon_failure(::dnd5e::api::v1alpha1::DungeonFailureEvent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dungeon_failure(::dnd5e::api::v1alpha1::DungeonFailureEvent* PROTOBUF_NULLABLE value);
  ::dnd5e::api::v1alpha1::DungeonFailureEvent* PROTOBUF_NULLABLE unsafe_arena_release_dungeon_failure();

  private:
  const ::dnd5e::api::v1alpha1::DungeonFailureEvent& _internal_dungeon_failure() const;
  ::dnd5e::api::v1alpha1::DungeonFailureEvent* PROTOBUF_NONNULL _internal_mutable_dungeon_failure();

  public:
  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.EncounterEvent)
 private:
  class _Internal;
  void set_has_player_joined();
  void set_has_player_left();
  void set_has_player_ready();
  void set_has_combat_started();
  void set_has_movement_completed();
  void set_has_attack_resolved();
  void set_has_feature_activated();
  void set_has_turn_ended();
  void set_has_monster_turn_completed();
  void set_has_combat_ended();
  void set_has_player_disconnected();
  void set_has_player_reconnected();
  void set_has_combat_paused();
  void set_has_combat_resumed();
  void set_has_room_revealed();
  void set_has_dungeon_victory();
  void set_has_dungeon_failure();
  inline bool has_event() const;
  inline void clear_has_event();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 19,
                                   17, 66,
                                   7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EncounterEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr event_id_;
    ::int64_t timestamp_;
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_joined_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_left_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_ready_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE combat_started_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE movement_completed_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE attack_resolved_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE feature_activated_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE turn_ended_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE monster_turn_completed_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE combat_ended_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_disconnected_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_reconnected_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE combat_paused_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE combat_resumed_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE room_revealed_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE dungeon_victory_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE dungeon_failure_;
    } event_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EncounterEvent_class_data_;
// -------------------------------------------------------------------

class GetEncounterHistoryResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dnd5e.api.v1alpha1.GetEncounterHistoryResponse) */ {
 public:
  inline GetEncounterHistoryResponse() : GetEncounterHistoryResponse(nullptr) {}
  ~GetEncounterHistoryResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetEncounterHistoryResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetEncounterHistoryResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetEncounterHistoryResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetEncounterHistoryResponse(const GetEncounterHistoryResponse& from) : GetEncounterHistoryResponse(nullptr, from) {}
  inline GetEncounterHistoryResponse(GetEncounterHistoryResponse&& from) noexcept
      : GetEncounterHistoryResponse(nullptr, ::std::move(from)) {}
  inline GetEncounterHistoryResponse& operator=(const GetEncounterHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEncounterHistoryResponse& operator=(GetEncounterHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEncounterHistoryResponse& default_instance() {
    return *reinterpret_cast<const GetEncounterHistoryResponse*>(
        &_GetEncounterHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(GetEncounterHistoryResponse& a, GetEncounterHistoryResponse& b) { a.Swap(&b); }
  inline void Swap(GetEncounterHistoryResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEncounterHistoryResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEncounterHistoryResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetEncounterHistoryResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetEncounterHistoryResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetEncounterHistoryResponse& from) { GetEncounterHistoryResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetEncounterHistoryResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dnd5e.api.v1alpha1.GetEncounterHistoryResponse"; }

  explicit GetEncounterHistoryResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetEncounterHistoryResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetEncounterHistoryResponse& from);
  GetEncounterHistoryResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetEncounterHistoryResponse&& from) noexcept
      : GetEncounterHistoryResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventsFieldNumber = 1,
    kLastEventIdFieldNumber = 3,
    kHasMoreFieldNumber = 2,
  };
  // repeated .dnd5e.api.v1alpha1.EncounterEvent events = 1 [json_name = "events"];
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  ::dnd5e::api::v1alpha1::EncounterEvent* PROTOBUF_NONNULL mutable_events(int index);
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EncounterEvent>* PROTOBUF_NONNULL mutable_events();

  private:
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EncounterEvent>& _internal_events() const;
  ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EncounterEvent>* PROTOBUF_NONNULL _internal_mutable_events();
  public:
  const ::dnd5e::api::v1alpha1::EncounterEvent& events(int index) const;
  ::dnd5e::api::v1alpha1::EncounterEvent* PROTOBUF_NONNULL add_events();
  const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EncounterEvent>& events() const;
  // string last_event_id = 3 [json_name = "lastEventId"];
  void clear_last_event_id() ;
  const ::std::string& last_event_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_last_event_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_last_event_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_last_event_id();
  void set_allocated_last_event_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_last_event_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_last_event_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_last_event_id();

  public:
  // bool has_more = 2 [json_name = "hasMore"];
  void clear_has_more() ;
  bool has_more() const;
  void set_has_more(bool value);

  private:
  bool _internal_has_more() const;
  void _internal_set_has_more(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dnd5e.api.v1alpha1.GetEncounterHistoryResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 68,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetEncounterHistoryResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::dnd5e::api::v1alpha1::EncounterEvent > events_;
    ::google::protobuf::internal::ArenaStringPtr last_event_id_;
    bool has_more_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetEncounterHistoryResponse_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EntityPlacement

// string entity_id = 1 [json_name = "entityId"];
inline void EntityPlacement::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& EntityPlacement::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EntityPlacement::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL EntityPlacement::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
  return _s;
}
inline const ::std::string& EntityPlacement::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void EntityPlacement::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EntityPlacement::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EntityPlacement::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void EntityPlacement::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EntityPlacement.entity_id)
}

// .dnd5e.api.v1alpha1.EntityType entity_type = 2 [json_name = "entityType"];
inline void EntityPlacement::clear_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::EntityType EntityPlacement::entity_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.entity_type)
  return _internal_entity_type();
}
inline void EntityPlacement::set_entity_type(::dnd5e::api::v1alpha1::EntityType value) {
  _internal_set_entity_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.entity_type)
}
inline ::dnd5e::api::v1alpha1::EntityType EntityPlacement::_internal_entity_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::EntityType>(_impl_.entity_type_);
}
inline void EntityPlacement::_internal_set_entity_type(::dnd5e::api::v1alpha1::EntityType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_ = value;
}

// .api.v1alpha1.Position position = 3 [json_name = "position"];
inline bool EntityPlacement::has_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::api::v1alpha1::Position& EntityPlacement::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::api::v1alpha1::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::v1alpha1::Position&>(::api::v1alpha1::_Position_default_instance_);
}
inline const ::api::v1alpha1::Position& EntityPlacement::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.position)
  return _internal_position();
}
inline void EntityPlacement::unsafe_arena_set_allocated_position(
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EntityPlacement.position)
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE EntityPlacement::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::api::v1alpha1::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE EntityPlacement::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EntityPlacement.position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::api::v1alpha1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL EntityPlacement::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::api::v1alpha1::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(p);
  }
  return _impl_.position_;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL EntityPlacement::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::api::v1alpha1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EntityPlacement.position)
  return _msg;
}
inline void EntityPlacement::set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EntityPlacement.position)
}

// .dnd5e.api.v1alpha1.EntitySize size = 4 [json_name = "size"];
inline void EntityPlacement::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::dnd5e::api::v1alpha1::EntitySize EntityPlacement::size() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.size)
  return _internal_size();
}
inline void EntityPlacement::set_size(::dnd5e::api::v1alpha1::EntitySize value) {
  _internal_set_size(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.size)
}
inline ::dnd5e::api::v1alpha1::EntitySize EntityPlacement::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::EntitySize>(_impl_.size_);
}
inline void EntityPlacement::_internal_set_size(::dnd5e::api::v1alpha1::EntitySize value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// bool blocks_movement = 5 [json_name = "blocksMovement"];
inline void EntityPlacement::clear_blocks_movement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_movement_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool EntityPlacement::blocks_movement() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.blocks_movement)
  return _internal_blocks_movement();
}
inline void EntityPlacement::set_blocks_movement(bool value) {
  _internal_set_blocks_movement(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.blocks_movement)
}
inline bool EntityPlacement::_internal_blocks_movement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blocks_movement_;
}
inline void EntityPlacement::_internal_set_blocks_movement(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_movement_ = value;
}

// bool blocks_line_of_sight = 6 [json_name = "blocksLineOfSight"];
inline void EntityPlacement::clear_blocks_line_of_sight() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_line_of_sight_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool EntityPlacement::blocks_line_of_sight() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.blocks_line_of_sight)
  return _internal_blocks_line_of_sight();
}
inline void EntityPlacement::set_blocks_line_of_sight(bool value) {
  _internal_set_blocks_line_of_sight(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.blocks_line_of_sight)
}
inline bool EntityPlacement::_internal_blocks_line_of_sight() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blocks_line_of_sight_;
}
inline void EntityPlacement::_internal_set_blocks_line_of_sight(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_line_of_sight_ = value;
}

// .dnd5e.api.v1alpha1.MonsterType monster_type = 7 [json_name = "monsterType"];
inline bool EntityPlacement::has_monster_type() const {
  return visual_type_case() == kMonsterType;
}
inline void EntityPlacement::set_has_monster_type() {
  _impl_._oneof_case_[0] = kMonsterType;
}
inline void EntityPlacement::clear_monster_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (visual_type_case() == kMonsterType) {
    _impl_.visual_type_.monster_type_ = 0;
    clear_has_visual_type();
  }
}
inline ::dnd5e::api::v1alpha1::MonsterType EntityPlacement::monster_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.monster_type)
  return _internal_monster_type();
}
inline void EntityPlacement::set_monster_type(::dnd5e::api::v1alpha1::MonsterType value) {
  if (visual_type_case() != kMonsterType) {
    clear_visual_type();
    set_has_monster_type();
  }
  _impl_.visual_type_.monster_type_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.monster_type)
}
inline ::dnd5e::api::v1alpha1::MonsterType EntityPlacement::_internal_monster_type() const {
  if (visual_type_case() == kMonsterType) {
    return static_cast<::dnd5e::api::v1alpha1::MonsterType>(_impl_.visual_type_.monster_type_);
  }
  return static_cast<::dnd5e::api::v1alpha1::MonsterType>(0);
}

// .dnd5e.api.v1alpha1.ObstacleType obstacle_type = 8 [json_name = "obstacleType"];
inline bool EntityPlacement::has_obstacle_type() const {
  return visual_type_case() == kObstacleType;
}
inline void EntityPlacement::set_has_obstacle_type() {
  _impl_._oneof_case_[0] = kObstacleType;
}
inline void EntityPlacement::clear_obstacle_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (visual_type_case() == kObstacleType) {
    _impl_.visual_type_.obstacle_type_ = 0;
    clear_has_visual_type();
  }
}
inline ::dnd5e::api::v1alpha1::ObstacleType EntityPlacement::obstacle_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EntityPlacement.obstacle_type)
  return _internal_obstacle_type();
}
inline void EntityPlacement::set_obstacle_type(::dnd5e::api::v1alpha1::ObstacleType value) {
  if (visual_type_case() != kObstacleType) {
    clear_visual_type();
    set_has_obstacle_type();
  }
  _impl_.visual_type_.obstacle_type_ = value;
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EntityPlacement.obstacle_type)
}
inline ::dnd5e::api::v1alpha1::ObstacleType EntityPlacement::_internal_obstacle_type() const {
  if (visual_type_case() == kObstacleType) {
    return static_cast<::dnd5e::api::v1alpha1::ObstacleType>(_impl_.visual_type_.obstacle_type_);
  }
  return static_cast<::dnd5e::api::v1alpha1::ObstacleType>(0);
}

inline bool EntityPlacement::has_visual_type() const {
  return visual_type_case() != VISUAL_TYPE_NOT_SET;
}
inline void EntityPlacement::clear_has_visual_type() {
  _impl_._oneof_case_[0] = VISUAL_TYPE_NOT_SET;
}
inline EntityPlacement::VisualTypeCase EntityPlacement::visual_type_case() const {
  return EntityPlacement::VisualTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Room

// string id = 1 [json_name = "id"];
inline void Room::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& Room::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Room::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.id)
}
inline ::std::string* PROTOBUF_NONNULL Room::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Room.id)
  return _s;
}
inline const ::std::string& Room::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Room::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Room::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Room::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Room.id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void Room::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Room.id)
}

// string type = 2 [json_name = "type"];
inline void Room::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& Room::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Room::set_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.type)
}
inline ::std::string* PROTOBUF_NONNULL Room::mutable_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Room.type)
  return _s;
}
inline const ::std::string& Room::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void Room::_internal_set_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Room::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Room::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.Room.type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.type_.Set("", GetArena());
  }
  return released;
}
inline void Room::set_allocated_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.Room.type)
}

// int32 width = 3 [json_name = "width"];
inline void Room::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t Room::width() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.width)
  return _internal_width();
}
inline void Room::set_width(::int32_t value) {
  _internal_set_width(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.width)
}
inline ::int32_t Room::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void Room::_internal_set_width(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// int32 height = 4 [json_name = "height"];
inline void Room::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int32_t Room::height() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.height)
  return _internal_height();
}
inline void Room::set_height(::int32_t value) {
  _internal_set_height(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.height)
}
inline ::int32_t Room::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void Room::_internal_set_height(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// .api.v1alpha1.GridType grid_type = 5 [json_name = "gridType"];
inline void Room::clear_grid_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::api::v1alpha1::GridType Room::grid_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.grid_type)
  return _internal_grid_type();
}
inline void Room::set_grid_type(::api::v1alpha1::GridType value) {
  _internal_set_grid_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.grid_type)
}
inline ::api::v1alpha1::GridType Room::_internal_grid_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::api::v1alpha1::GridType>(_impl_.grid_type_);
}
inline void Room::_internal_set_grid_type(::api::v1alpha1::GridType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grid_type_ = value;
}

// optional bool hex_orientation = 6 [json_name = "hexOrientation"];
inline bool Room::has_hex_orientation() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  return value;
}
inline void Room::clear_hex_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hex_orientation_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline bool Room::hex_orientation() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.hex_orientation)
  return _internal_hex_orientation();
}
inline void Room::set_hex_orientation(bool value) {
  _internal_set_hex_orientation(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.Room.hex_orientation)
}
inline bool Room::_internal_hex_orientation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hex_orientation_;
}
inline void Room::_internal_set_hex_orientation(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hex_orientation_ = value;
}

// map<string, .dnd5e.api.v1alpha1.EntityPlacement> entities = 7 [json_name = "entities"];
inline int Room::_internal_entities_size() const {
  return _internal_entities().size();
}
inline int Room::entities_size() const {
  return _internal_entities_size();
}
inline void Room::clear_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entities_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>& Room::_internal_entities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entities_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>& Room::entities() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:dnd5e.api.v1alpha1.Room.entities)
  return _internal_entities();
}
inline ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>* PROTOBUF_NONNULL Room::_internal_mutable_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entities_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::dnd5e::api::v1alpha1::EntityPlacement>* PROTOBUF_NONNULL Room::mutable_entities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_mutable_map:dnd5e.api.v1alpha1.Room.entities)
  return _internal_mutable_entities();
}

// repeated .api.v1alpha1.Wall walls = 8 [json_name = "walls"];
inline int Room::_internal_walls_size() const {
  return _internal_walls().size();
}
inline int Room::walls_size() const {
  return _internal_walls_size();
}
inline ::api::v1alpha1::Wall* PROTOBUF_NONNULL Room::mutable_walls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.Room.walls)
  return _internal_mutable_walls()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Wall>* PROTOBUF_NONNULL Room::mutable_walls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.Room.walls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_walls();
}
inline const ::api::v1alpha1::Wall& Room::walls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.Room.walls)
  return _internal_walls().Get(index);
}
inline ::api::v1alpha1::Wall* PROTOBUF_NONNULL Room::add_walls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::api::v1alpha1::Wall* _add =
      _internal_mutable_walls()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.Room.walls)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Wall>& Room::walls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.Room.walls)
  return _internal_walls();
}
inline const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Wall>&
Room::_internal_walls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.walls_;
}
inline ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Wall>* PROTOBUF_NONNULL
Room::_internal_mutable_walls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.walls_;
}

// -------------------------------------------------------------------

// DoorInfo

// string connection_id = 1 [json_name = "connectionId"];
inline void DoorInfo::clear_connection_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& DoorInfo::connection_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DoorInfo.connection_id)
  return _internal_connection_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DoorInfo::set_connection_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.connection_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DoorInfo.connection_id)
}
inline ::std::string* PROTOBUF_NONNULL DoorInfo::mutable_connection_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_connection_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DoorInfo.connection_id)
  return _s;
}
inline const ::std::string& DoorInfo::_internal_connection_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.connection_id_.Get();
}
inline void DoorInfo::_internal_set_connection_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DoorInfo::_internal_mutable_connection_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.connection_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DoorInfo::release_connection_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DoorInfo.connection_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.connection_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.connection_id_.Set("", GetArena());
  }
  return released;
}
inline void DoorInfo::set_allocated_connection_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.connection_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.connection_id_.IsDefault()) {
    _impl_.connection_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DoorInfo.connection_id)
}

// .api.v1alpha1.Position position = 2 [json_name = "position"];
inline bool DoorInfo::has_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::api::v1alpha1::Position& DoorInfo::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::api::v1alpha1::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::v1alpha1::Position&>(::api::v1alpha1::_Position_default_instance_);
}
inline const ::api::v1alpha1::Position& DoorInfo::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DoorInfo.position)
  return _internal_position();
}
inline void DoorInfo::unsafe_arena_set_allocated_position(
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.DoorInfo.position)
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE DoorInfo::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::api::v1alpha1::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE DoorInfo::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DoorInfo.position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::api::v1alpha1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL DoorInfo::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::api::v1alpha1::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(p);
  }
  return _impl_.position_;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL DoorInfo::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::api::v1alpha1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DoorInfo.position)
  return _msg;
}
inline void DoorInfo::set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DoorInfo.position)
}

// string physical_hint = 3 [json_name = "physicalHint"];
inline void DoorInfo::clear_physical_hint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.physical_hint_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& DoorInfo::physical_hint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DoorInfo.physical_hint)
  return _internal_physical_hint();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DoorInfo::set_physical_hint(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.physical_hint_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DoorInfo.physical_hint)
}
inline ::std::string* PROTOBUF_NONNULL DoorInfo::mutable_physical_hint()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_physical_hint();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DoorInfo.physical_hint)
  return _s;
}
inline const ::std::string& DoorInfo::_internal_physical_hint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.physical_hint_.Get();
}
inline void DoorInfo::_internal_set_physical_hint(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.physical_hint_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DoorInfo::_internal_mutable_physical_hint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.physical_hint_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DoorInfo::release_physical_hint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DoorInfo.physical_hint)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.physical_hint_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.physical_hint_.Set("", GetArena());
  }
  return released;
}
inline void DoorInfo::set_allocated_physical_hint(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.physical_hint_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.physical_hint_.IsDefault()) {
    _impl_.physical_hint_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DoorInfo.physical_hint)
}

// bool is_open = 4 [json_name = "isOpen"];
inline void DoorInfo::clear_is_open() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_open_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool DoorInfo::is_open() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DoorInfo.is_open)
  return _internal_is_open();
}
inline void DoorInfo::set_is_open(bool value) {
  _internal_set_is_open(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DoorInfo.is_open)
}
inline bool DoorInfo::_internal_is_open() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_open_;
}
inline void DoorInfo::_internal_set_is_open(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_open_ = value;
}

// string leads_to_room_id = 5 [json_name = "leadsToRoomId"];
inline void DoorInfo::clear_leads_to_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leads_to_room_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& DoorInfo::leads_to_room_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DoorInfo.leads_to_room_id)
  return _internal_leads_to_room_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DoorInfo::set_leads_to_room_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.leads_to_room_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DoorInfo.leads_to_room_id)
}
inline ::std::string* PROTOBUF_NONNULL DoorInfo::mutable_leads_to_room_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_leads_to_room_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DoorInfo.leads_to_room_id)
  return _s;
}
inline const ::std::string& DoorInfo::_internal_leads_to_room_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.leads_to_room_id_.Get();
}
inline void DoorInfo::_internal_set_leads_to_room_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leads_to_room_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DoorInfo::_internal_mutable_leads_to_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.leads_to_room_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DoorInfo::release_leads_to_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DoorInfo.leads_to_room_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.leads_to_room_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.leads_to_room_id_.Set("", GetArena());
  }
  return released;
}
inline void DoorInfo::set_allocated_leads_to_room_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.leads_to_room_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.leads_to_room_id_.IsDefault()) {
    _impl_.leads_to_room_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DoorInfo.leads_to_room_id)
}

// -------------------------------------------------------------------

// DungeonStartRequest

// repeated string character_ids = 1 [json_name = "characterIds"];
inline int DungeonStartRequest::_internal_character_ids_size() const {
  return _internal_character_ids().size();
}
inline int DungeonStartRequest::character_ids_size() const {
  return _internal_character_ids_size();
}
inline void DungeonStartRequest::clear_character_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_ids_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartRequest::add_character_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_character_ids()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  return _s;
}
inline const ::std::string& DungeonStartRequest::character_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  return _internal_character_ids().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartRequest::mutable_character_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  return _internal_mutable_character_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void DungeonStartRequest::set_character_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_character_ids()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
}
template <typename Arg_, typename... Args_>
inline void DungeonStartRequest::add_character_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_character_ids(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& DungeonStartRequest::character_ids()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  return _internal_character_ids();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
DungeonStartRequest::mutable_character_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DungeonStartRequest.character_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_character_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DungeonStartRequest::_internal_character_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
DungeonStartRequest::_internal_mutable_character_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.character_ids_;
}

// .dnd5e.api.v1alpha1.DungeonTheme theme = 2 [json_name = "theme"];
inline void DungeonStartRequest::clear_theme() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.theme_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::DungeonTheme DungeonStartRequest::theme() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartRequest.theme)
  return _internal_theme();
}
inline void DungeonStartRequest::set_theme(::dnd5e::api::v1alpha1::DungeonTheme value) {
  _internal_set_theme(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonStartRequest.theme)
}
inline ::dnd5e::api::v1alpha1::DungeonTheme DungeonStartRequest::_internal_theme() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::DungeonTheme>(_impl_.theme_);
}
inline void DungeonStartRequest::_internal_set_theme(::dnd5e::api::v1alpha1::DungeonTheme value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.theme_ = value;
}

// .dnd5e.api.v1alpha1.DungeonDifficulty difficulty = 3 [json_name = "difficulty"];
inline void DungeonStartRequest::clear_difficulty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.difficulty_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::DungeonDifficulty DungeonStartRequest::difficulty() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartRequest.difficulty)
  return _internal_difficulty();
}
inline void DungeonStartRequest::set_difficulty(::dnd5e::api::v1alpha1::DungeonDifficulty value) {
  _internal_set_difficulty(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonStartRequest.difficulty)
}
inline ::dnd5e::api::v1alpha1::DungeonDifficulty DungeonStartRequest::_internal_difficulty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::DungeonDifficulty>(_impl_.difficulty_);
}
inline void DungeonStartRequest::_internal_set_difficulty(::dnd5e::api::v1alpha1::DungeonDifficulty value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.difficulty_ = value;
}

// .dnd5e.api.v1alpha1.DungeonLength length = 4 [json_name = "length"];
inline void DungeonStartRequest::clear_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::dnd5e::api::v1alpha1::DungeonLength DungeonStartRequest::length() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartRequest.length)
  return _internal_length();
}
inline void DungeonStartRequest::set_length(::dnd5e::api::v1alpha1::DungeonLength value) {
  _internal_set_length(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonStartRequest.length)
}
inline ::dnd5e::api::v1alpha1::DungeonLength DungeonStartRequest::_internal_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::DungeonLength>(_impl_.length_);
}
inline void DungeonStartRequest::_internal_set_length(::dnd5e::api::v1alpha1::DungeonLength value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = value;
}

// -------------------------------------------------------------------

// DungeonStartResponse

// string dungeon_id = 1 [json_name = "dungeonId"];
inline void DungeonStartResponse::clear_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& DungeonStartResponse::dungeon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.dungeon_id)
  return _internal_dungeon_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DungeonStartResponse::set_dungeon_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.dungeon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonStartResponse.dungeon_id)
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartResponse::mutable_dungeon_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_dungeon_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartResponse.dungeon_id)
  return _s;
}
inline const ::std::string& DungeonStartResponse::_internal_dungeon_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dungeon_id_.Get();
}
inline void DungeonStartResponse::_internal_set_dungeon_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartResponse::_internal_mutable_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dungeon_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DungeonStartResponse::release_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonStartResponse.dungeon_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.dungeon_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  return released;
}
inline void DungeonStartResponse::set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.dungeon_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dungeon_id_.IsDefault()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.dungeon_id)
}

// string encounter_id = 2 [json_name = "encounterId"];
inline void DungeonStartResponse::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& DungeonStartResponse::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DungeonStartResponse::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartResponse::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
  return _s;
}
inline const ::std::string& DungeonStartResponse::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void DungeonStartResponse::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DungeonStartResponse::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DungeonStartResponse::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void DungeonStartResponse::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.encounter_id)
}

// .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
inline bool DungeonStartResponse::has_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void DungeonStartResponse::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::dnd5e::api::v1alpha1::Room& DungeonStartResponse::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& DungeonStartResponse::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.room)
  return _internal_room();
}
inline void DungeonStartResponse::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE DungeonStartResponse::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE DungeonStartResponse::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonStartResponse.room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL DungeonStartResponse::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL DungeonStartResponse::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartResponse.room)
  return _msg;
}
inline void DungeonStartResponse::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.room)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
inline bool DungeonStartResponse::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void DungeonStartResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& DungeonStartResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& DungeonStartResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)
  return _internal_combat_state();
}
inline void DungeonStartResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE DungeonStartResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE DungeonStartResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL DungeonStartResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL DungeonStartResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)
  return _msg;
}
inline void DungeonStartResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonStartResponse.combat_state)
}

// repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 5 [json_name = "monsterTurns"];
inline int DungeonStartResponse::_internal_monster_turns_size() const {
  return _internal_monster_turns().size();
}
inline int DungeonStartResponse::monster_turns_size() const {
  return _internal_monster_turns_size();
}
inline void DungeonStartResponse::clear_monster_turns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_turns_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL DungeonStartResponse::mutable_monster_turns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartResponse.monster_turns)
  return _internal_mutable_monster_turns()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL DungeonStartResponse::mutable_monster_turns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DungeonStartResponse.monster_turns)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_monster_turns();
}
inline const ::dnd5e::api::v1alpha1::MonsterTurnResult& DungeonStartResponse::monster_turns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.monster_turns)
  return _internal_monster_turns().Get(index);
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL DungeonStartResponse::add_monster_turns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::MonsterTurnResult* _add =
      _internal_mutable_monster_turns()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DungeonStartResponse.monster_turns)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& DungeonStartResponse::monster_turns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DungeonStartResponse.monster_turns)
  return _internal_monster_turns();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>&
DungeonStartResponse::_internal_monster_turns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monster_turns_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL
DungeonStartResponse::_internal_mutable_monster_turns() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.monster_turns_;
}

// repeated .dnd5e.api.v1alpha1.DoorInfo doors = 6 [json_name = "doors"];
inline int DungeonStartResponse::_internal_doors_size() const {
  return _internal_doors().size();
}
inline int DungeonStartResponse::doors_size() const {
  return _internal_doors_size();
}
inline void DungeonStartResponse::clear_doors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.doors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL DungeonStartResponse::mutable_doors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonStartResponse.doors)
  return _internal_mutable_doors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL DungeonStartResponse::mutable_doors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DungeonStartResponse.doors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_doors();
}
inline const ::dnd5e::api::v1alpha1::DoorInfo& DungeonStartResponse::doors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.doors)
  return _internal_doors().Get(index);
}
inline ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL DungeonStartResponse::add_doors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::DoorInfo* _add =
      _internal_mutable_doors()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DungeonStartResponse.doors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& DungeonStartResponse::doors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DungeonStartResponse.doors)
  return _internal_doors();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>&
DungeonStartResponse::_internal_doors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.doors_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL
DungeonStartResponse::_internal_mutable_doors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.doors_;
}

// .dnd5e.api.v1alpha1.DungeonState dungeon_state = 7 [json_name = "dungeonState"];
inline void DungeonStartResponse::clear_dungeon_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_state_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::dnd5e::api::v1alpha1::DungeonState DungeonStartResponse::dungeon_state() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonStartResponse.dungeon_state)
  return _internal_dungeon_state();
}
inline void DungeonStartResponse::set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value) {
  _internal_set_dungeon_state(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonStartResponse.dungeon_state)
}
inline ::dnd5e::api::v1alpha1::DungeonState DungeonStartResponse::_internal_dungeon_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::DungeonState>(_impl_.dungeon_state_);
}
inline void DungeonStartResponse::_internal_set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_state_ = value;
}

// -------------------------------------------------------------------

// OpenDoorRequest

// string dungeon_id = 1 [json_name = "dungeonId"];
inline void OpenDoorRequest::clear_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& OpenDoorRequest::dungeon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.OpenDoorRequest.dungeon_id)
  return _internal_dungeon_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void OpenDoorRequest::set_dungeon_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.dungeon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.OpenDoorRequest.dungeon_id)
}
inline ::std::string* PROTOBUF_NONNULL OpenDoorRequest::mutable_dungeon_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_dungeon_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.OpenDoorRequest.dungeon_id)
  return _s;
}
inline const ::std::string& OpenDoorRequest::_internal_dungeon_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dungeon_id_.Get();
}
inline void OpenDoorRequest::_internal_set_dungeon_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL OpenDoorRequest::_internal_mutable_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dungeon_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE OpenDoorRequest::release_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.OpenDoorRequest.dungeon_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.dungeon_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  return released;
}
inline void OpenDoorRequest::set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.dungeon_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dungeon_id_.IsDefault()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.OpenDoorRequest.dungeon_id)
}

// string connection_id = 2 [json_name = "connectionId"];
inline void OpenDoorRequest::clear_connection_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& OpenDoorRequest::connection_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.OpenDoorRequest.connection_id)
  return _internal_connection_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void OpenDoorRequest::set_connection_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.connection_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.OpenDoorRequest.connection_id)
}
inline ::std::string* PROTOBUF_NONNULL OpenDoorRequest::mutable_connection_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_connection_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.OpenDoorRequest.connection_id)
  return _s;
}
inline const ::std::string& OpenDoorRequest::_internal_connection_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.connection_id_.Get();
}
inline void OpenDoorRequest::_internal_set_connection_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL OpenDoorRequest::_internal_mutable_connection_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.connection_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE OpenDoorRequest::release_connection_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.OpenDoorRequest.connection_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.connection_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.connection_id_.Set("", GetArena());
  }
  return released;
}
inline void OpenDoorRequest::set_allocated_connection_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.connection_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.connection_id_.IsDefault()) {
    _impl_.connection_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.OpenDoorRequest.connection_id)
}

// -------------------------------------------------------------------

// OpenDoorResponse

// bool success = 1 [json_name = "success"];
inline void OpenDoorResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline bool OpenDoorResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.OpenDoorResponse.success)
  return _internal_success();
}
inline void OpenDoorResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.OpenDoorResponse.success)
}
inline bool OpenDoorResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void OpenDoorResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string error = 2 [json_name = "error"];
inline void OpenDoorResponse::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& OpenDoorResponse::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.OpenDoorResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void OpenDoorResponse::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.OpenDoorResponse.error)
}
inline ::std::string* PROTOBUF_NONNULL OpenDoorResponse::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.OpenDoorResponse.error)
  return _s;
}
inline const ::std::string& OpenDoorResponse::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void OpenDoorResponse::_internal_set_error(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL OpenDoorResponse::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE OpenDoorResponse::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.OpenDoorResponse.error)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void OpenDoorResponse::set_allocated_error(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.OpenDoorResponse.error)
}

// string encounter_id = 3 [json_name = "encounterId"];
inline void OpenDoorResponse::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& OpenDoorResponse::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.OpenDoorResponse.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void OpenDoorResponse::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.OpenDoorResponse.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL OpenDoorResponse::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.OpenDoorResponse.encounter_id)
  return _s;
}
inline const ::std::string& OpenDoorResponse::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void OpenDoorResponse::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL OpenDoorResponse::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE OpenDoorResponse::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.OpenDoorResponse.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void OpenDoorResponse::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.OpenDoorResponse.encounter_id)
}

// .dnd5e.api.v1alpha1.Room room = 4 [json_name = "room"];
inline bool OpenDoorResponse::has_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void OpenDoorResponse::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::dnd5e::api::v1alpha1::Room& OpenDoorResponse::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& OpenDoorResponse::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.OpenDoorResponse.room)
  return _internal_room();
}
inline void OpenDoorResponse::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.OpenDoorResponse.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE OpenDoorResponse::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE OpenDoorResponse::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.OpenDoorResponse.room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL OpenDoorResponse::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL OpenDoorResponse::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.OpenDoorResponse.room)
  return _msg;
}
inline void OpenDoorResponse::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.OpenDoorResponse.room)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 5 [json_name = "combatState"];
inline bool OpenDoorResponse::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void OpenDoorResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& OpenDoorResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& OpenDoorResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.OpenDoorResponse.combat_state)
  return _internal_combat_state();
}
inline void OpenDoorResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.OpenDoorResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE OpenDoorResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE OpenDoorResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.OpenDoorResponse.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL OpenDoorResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL OpenDoorResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.OpenDoorResponse.combat_state)
  return _msg;
}
inline void OpenDoorResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.OpenDoorResponse.combat_state)
}

// repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 6 [json_name = "monsterTurns"];
inline int OpenDoorResponse::_internal_monster_turns_size() const {
  return _internal_monster_turns().size();
}
inline int OpenDoorResponse::monster_turns_size() const {
  return _internal_monster_turns_size();
}
inline void OpenDoorResponse::clear_monster_turns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_turns_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL OpenDoorResponse::mutable_monster_turns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.OpenDoorResponse.monster_turns)
  return _internal_mutable_monster_turns()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL OpenDoorResponse::mutable_monster_turns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.OpenDoorResponse.monster_turns)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_monster_turns();
}
inline const ::dnd5e::api::v1alpha1::MonsterTurnResult& OpenDoorResponse::monster_turns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.OpenDoorResponse.monster_turns)
  return _internal_monster_turns().Get(index);
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL OpenDoorResponse::add_monster_turns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::MonsterTurnResult* _add =
      _internal_mutable_monster_turns()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.OpenDoorResponse.monster_turns)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& OpenDoorResponse::monster_turns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.OpenDoorResponse.monster_turns)
  return _internal_monster_turns();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>&
OpenDoorResponse::_internal_monster_turns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monster_turns_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL
OpenDoorResponse::_internal_mutable_monster_turns() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.monster_turns_;
}

// repeated .dnd5e.api.v1alpha1.DoorInfo doors = 7 [json_name = "doors"];
inline int OpenDoorResponse::_internal_doors_size() const {
  return _internal_doors().size();
}
inline int OpenDoorResponse::doors_size() const {
  return _internal_doors_size();
}
inline void OpenDoorResponse::clear_doors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.doors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL OpenDoorResponse::mutable_doors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.OpenDoorResponse.doors)
  return _internal_mutable_doors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL OpenDoorResponse::mutable_doors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.OpenDoorResponse.doors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_doors();
}
inline const ::dnd5e::api::v1alpha1::DoorInfo& OpenDoorResponse::doors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.OpenDoorResponse.doors)
  return _internal_doors().Get(index);
}
inline ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL OpenDoorResponse::add_doors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::DoorInfo* _add =
      _internal_mutable_doors()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.OpenDoorResponse.doors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& OpenDoorResponse::doors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.OpenDoorResponse.doors)
  return _internal_doors();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>&
OpenDoorResponse::_internal_doors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.doors_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL
OpenDoorResponse::_internal_mutable_doors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.doors_;
}

// .dnd5e.api.v1alpha1.DungeonState dungeon_state = 8 [json_name = "dungeonState"];
inline void OpenDoorResponse::clear_dungeon_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_state_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline ::dnd5e::api::v1alpha1::DungeonState OpenDoorResponse::dungeon_state() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.OpenDoorResponse.dungeon_state)
  return _internal_dungeon_state();
}
inline void OpenDoorResponse::set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value) {
  _internal_set_dungeon_state(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.OpenDoorResponse.dungeon_state)
}
inline ::dnd5e::api::v1alpha1::DungeonState OpenDoorResponse::_internal_dungeon_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::DungeonState>(_impl_.dungeon_state_);
}
inline void OpenDoorResponse::_internal_set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_state_ = value;
}

// .api.v1alpha1.Position room_origin = 9 [json_name = "roomOrigin"];
inline bool OpenDoorResponse::has_room_origin() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.room_origin_ != nullptr);
  return value;
}
inline const ::api::v1alpha1::Position& OpenDoorResponse::_internal_room_origin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::api::v1alpha1::Position* p = _impl_.room_origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::v1alpha1::Position&>(::api::v1alpha1::_Position_default_instance_);
}
inline const ::api::v1alpha1::Position& OpenDoorResponse::room_origin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.OpenDoorResponse.room_origin)
  return _internal_room_origin();
}
inline void OpenDoorResponse::unsafe_arena_set_allocated_room_origin(
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_origin_);
  }
  _impl_.room_origin_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.OpenDoorResponse.room_origin)
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE OpenDoorResponse::release_room_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::api::v1alpha1::Position* released = _impl_.room_origin_;
  _impl_.room_origin_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE OpenDoorResponse::unsafe_arena_release_room_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.OpenDoorResponse.room_origin)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::api::v1alpha1::Position* temp = _impl_.room_origin_;
  _impl_.room_origin_ = nullptr;
  return temp;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL OpenDoorResponse::_internal_mutable_room_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_origin_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::api::v1alpha1::Position>(GetArena());
    _impl_.room_origin_ = reinterpret_cast<::api::v1alpha1::Position*>(p);
  }
  return _impl_.room_origin_;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL OpenDoorResponse::mutable_room_origin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::api::v1alpha1::Position* _msg = _internal_mutable_room_origin();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.OpenDoorResponse.room_origin)
  return _msg;
}
inline void OpenDoorResponse::set_allocated_room_origin(::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_origin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.room_origin_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.OpenDoorResponse.room_origin)
}

// -------------------------------------------------------------------

// InitiativeEntry

// string entity_id = 1 [json_name = "entityId"];
inline void InitiativeEntry::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& InitiativeEntry::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InitiativeEntry::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL InitiativeEntry::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
  return _s;
}
inline const ::std::string& InitiativeEntry::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void InitiativeEntry::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InitiativeEntry::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InitiativeEntry::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void InitiativeEntry::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.InitiativeEntry.entity_id)
}

// string entity_type = 2 [json_name = "entityType"];
inline void InitiativeEntry::clear_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& InitiativeEntry::entity_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
  return _internal_entity_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InitiativeEntry::set_entity_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.entity_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
}
inline ::std::string* PROTOBUF_NONNULL InitiativeEntry::mutable_entity_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_entity_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
  return _s;
}
inline const ::std::string& InitiativeEntry::_internal_entity_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_type_.Get();
}
inline void InitiativeEntry::_internal_set_entity_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InitiativeEntry::_internal_mutable_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InitiativeEntry::release_entity_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.entity_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_type_.Set("", GetArena());
  }
  return released;
}
inline void InitiativeEntry::set_allocated_entity_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.entity_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_type_.IsDefault()) {
    _impl_.entity_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.InitiativeEntry.entity_type)
}

// int32 initiative = 3 [json_name = "initiative"];
inline void InitiativeEntry::clear_initiative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiative_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t InitiativeEntry::initiative() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.initiative)
  return _internal_initiative();
}
inline void InitiativeEntry::set_initiative(::int32_t value) {
  _internal_set_initiative(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.initiative)
}
inline ::int32_t InitiativeEntry::_internal_initiative() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initiative_;
}
inline void InitiativeEntry::_internal_set_initiative(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiative_ = value;
}

// int32 modifier = 4 [json_name = "modifier"];
inline void InitiativeEntry::clear_modifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modifier_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t InitiativeEntry::modifier() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.modifier)
  return _internal_modifier();
}
inline void InitiativeEntry::set_modifier(::int32_t value) {
  _internal_set_modifier(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.modifier)
}
inline ::int32_t InitiativeEntry::_internal_modifier() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.modifier_;
}
inline void InitiativeEntry::_internal_set_modifier(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modifier_ = value;
}

// bool has_acted = 5 [json_name = "hasActed"];
inline void InitiativeEntry::clear_has_acted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_acted_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool InitiativeEntry::has_acted() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.InitiativeEntry.has_acted)
  return _internal_has_acted();
}
inline void InitiativeEntry::set_has_acted(bool value) {
  _internal_set_has_acted(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.InitiativeEntry.has_acted)
}
inline bool InitiativeEntry::_internal_has_acted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_acted_;
}
inline void InitiativeEntry::_internal_set_has_acted(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_acted_ = value;
}

// -------------------------------------------------------------------

// TurnState

// string entity_id = 1 [json_name = "entityId"];
inline void TurnState::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& TurnState::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TurnState::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL TurnState::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnState.entity_id)
  return _s;
}
inline const ::std::string& TurnState::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void TurnState::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TurnState::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TurnState::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnState.entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void TurnState::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnState.entity_id)
}

// int32 movement_used = 2 [json_name = "movementUsed"];
inline void TurnState::clear_movement_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_used_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t TurnState::movement_used() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.movement_used)
  return _internal_movement_used();
}
inline void TurnState::set_movement_used(::int32_t value) {
  _internal_set_movement_used(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.movement_used)
}
inline ::int32_t TurnState::_internal_movement_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movement_used_;
}
inline void TurnState::_internal_set_movement_used(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_used_ = value;
}

// int32 movement_max = 3 [json_name = "movementMax"];
inline void TurnState::clear_movement_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_max_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t TurnState::movement_max() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.movement_max)
  return _internal_movement_max();
}
inline void TurnState::set_movement_max(::int32_t value) {
  _internal_set_movement_max(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.movement_max)
}
inline ::int32_t TurnState::_internal_movement_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movement_max_;
}
inline void TurnState::_internal_set_movement_max(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_max_ = value;
}

// bool action_used = 4 [json_name = "actionUsed"];
inline void TurnState::clear_action_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_used_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool TurnState::action_used() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.action_used)
  return _internal_action_used();
}
inline void TurnState::set_action_used(bool value) {
  _internal_set_action_used(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.action_used)
}
inline bool TurnState::_internal_action_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_used_;
}
inline void TurnState::_internal_set_action_used(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_used_ = value;
}

// bool bonus_action_used = 5 [json_name = "bonusActionUsed"];
inline void TurnState::clear_bonus_action_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonus_action_used_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool TurnState::bonus_action_used() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.bonus_action_used)
  return _internal_bonus_action_used();
}
inline void TurnState::set_bonus_action_used(bool value) {
  _internal_set_bonus_action_used(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.bonus_action_used)
}
inline bool TurnState::_internal_bonus_action_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bonus_action_used_;
}
inline void TurnState::_internal_set_bonus_action_used(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonus_action_used_ = value;
}

// bool reaction_available = 6 [json_name = "reactionAvailable"];
inline void TurnState::clear_reaction_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reaction_available_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline bool TurnState::reaction_available() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.reaction_available)
  return _internal_reaction_available();
}
inline void TurnState::set_reaction_available(bool value) {
  _internal_set_reaction_available(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnState.reaction_available)
}
inline bool TurnState::_internal_reaction_available() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reaction_available_;
}
inline void TurnState::_internal_set_reaction_available(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reaction_available_ = value;
}

// .api.v1alpha1.Position position = 7 [json_name = "position"];
inline bool TurnState::has_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::api::v1alpha1::Position& TurnState::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::api::v1alpha1::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::v1alpha1::Position&>(::api::v1alpha1::_Position_default_instance_);
}
inline const ::api::v1alpha1::Position& TurnState::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnState.position)
  return _internal_position();
}
inline void TurnState::unsafe_arena_set_allocated_position(
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.TurnState.position)
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE TurnState::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::api::v1alpha1::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE TurnState::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnState.position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::api::v1alpha1::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL TurnState::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::api::v1alpha1::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(p);
  }
  return _impl_.position_;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL TurnState::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::api::v1alpha1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnState.position)
  return _msg;
}
inline void TurnState::set_allocated_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnState.position)
}

// -------------------------------------------------------------------

// CombatState

// string encounter_id = 1 [json_name = "encounterId"];
inline void CombatState::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& CombatState::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CombatState::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL CombatState::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatState.encounter_id)
  return _s;
}
inline const ::std::string& CombatState::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void CombatState::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CombatState::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CombatState::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatState.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void CombatState::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatState.encounter_id)
}

// int32 round = 2 [json_name = "round"];
inline void CombatState::clear_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t CombatState::round() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.round)
  return _internal_round();
}
inline void CombatState::set_round(::int32_t value) {
  _internal_set_round(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.round)
}
inline ::int32_t CombatState::_internal_round() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.round_;
}
inline void CombatState::_internal_set_round(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = value;
}

// repeated .dnd5e.api.v1alpha1.InitiativeEntry turn_order = 3 [json_name = "turnOrder"];
inline int CombatState::_internal_turn_order_size() const {
  return _internal_turn_order().size();
}
inline int CombatState::turn_order_size() const {
  return _internal_turn_order_size();
}
inline void CombatState::clear_turn_order() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.turn_order_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::InitiativeEntry* PROTOBUF_NONNULL CombatState::mutable_turn_order(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatState.turn_order)
  return _internal_mutable_turn_order()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>* PROTOBUF_NONNULL CombatState::mutable_turn_order()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.CombatState.turn_order)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_turn_order();
}
inline const ::dnd5e::api::v1alpha1::InitiativeEntry& CombatState::turn_order(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.turn_order)
  return _internal_turn_order().Get(index);
}
inline ::dnd5e::api::v1alpha1::InitiativeEntry* PROTOBUF_NONNULL CombatState::add_turn_order()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::InitiativeEntry* _add =
      _internal_mutable_turn_order()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.CombatState.turn_order)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>& CombatState::turn_order() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.CombatState.turn_order)
  return _internal_turn_order();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>&
CombatState::_internal_turn_order() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.turn_order_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::InitiativeEntry>* PROTOBUF_NONNULL
CombatState::_internal_mutable_turn_order() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.turn_order_;
}

// int32 active_index = 4 [json_name = "activeIndex"];
inline void CombatState::clear_active_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_index_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int32_t CombatState::active_index() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.active_index)
  return _internal_active_index();
}
inline void CombatState::set_active_index(::int32_t value) {
  _internal_set_active_index(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.active_index)
}
inline ::int32_t CombatState::_internal_active_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.active_index_;
}
inline void CombatState::_internal_set_active_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_index_ = value;
}

// .dnd5e.api.v1alpha1.TurnState current_turn = 5 [json_name = "currentTurn"];
inline bool CombatState::has_current_turn() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.current_turn_ != nullptr);
  return value;
}
inline void CombatState::clear_current_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_turn_ != nullptr) _impl_.current_turn_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::TurnState& CombatState::_internal_current_turn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::TurnState* p = _impl_.current_turn_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::TurnState&>(::dnd5e::api::v1alpha1::_TurnState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::TurnState& CombatState::current_turn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.current_turn)
  return _internal_current_turn();
}
inline void CombatState::unsafe_arena_set_allocated_current_turn(
    ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.current_turn_);
  }
  _impl_.current_turn_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CombatState.current_turn)
}
inline ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE CombatState::release_current_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::TurnState* released = _impl_.current_turn_;
  _impl_.current_turn_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE CombatState::unsafe_arena_release_current_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatState.current_turn)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::TurnState* temp = _impl_.current_turn_;
  _impl_.current_turn_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NONNULL CombatState::_internal_mutable_current_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_turn_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::TurnState>(GetArena());
    _impl_.current_turn_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnState*>(p);
  }
  return _impl_.current_turn_;
}
inline ::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NONNULL CombatState::mutable_current_turn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::TurnState* _msg = _internal_mutable_current_turn();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatState.current_turn)
  return _msg;
}
inline void CombatState::set_allocated_current_turn(::dnd5e::api::v1alpha1::TurnState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.current_turn_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.current_turn_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatState.current_turn)
}

// bool combat_started = 6 [json_name = "combatStarted"];
inline void CombatState::clear_combat_started() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combat_started_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool CombatState::combat_started() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.combat_started)
  return _internal_combat_started();
}
inline void CombatState::set_combat_started(bool value) {
  _internal_set_combat_started(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.combat_started)
}
inline bool CombatState::_internal_combat_started() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.combat_started_;
}
inline void CombatState::_internal_set_combat_started(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combat_started_ = value;
}

// bool combat_ended = 7 [json_name = "combatEnded"];
inline void CombatState::clear_combat_ended() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combat_ended_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline bool CombatState::combat_ended() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatState.combat_ended)
  return _internal_combat_ended();
}
inline void CombatState::set_combat_ended(bool value) {
  _internal_set_combat_ended(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatState.combat_ended)
}
inline bool CombatState::_internal_combat_ended() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.combat_ended_;
}
inline void CombatState::_internal_set_combat_ended(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combat_ended_ = value;
}

// -------------------------------------------------------------------

// GetCombatStateRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void GetCombatStateRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& GetCombatStateRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetCombatStateRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL GetCombatStateRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
  return _s;
}
inline const ::std::string& GetCombatStateRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void GetCombatStateRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetCombatStateRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetCombatStateRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void GetCombatStateRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCombatStateRequest.encounter_id)
}

// -------------------------------------------------------------------

// GetCombatStateResponse

// .dnd5e.api.v1alpha1.Room room = 1 [json_name = "room"];
inline bool GetCombatStateResponse::has_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void GetCombatStateResponse::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::dnd5e::api::v1alpha1::Room& GetCombatStateResponse::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& GetCombatStateResponse::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCombatStateResponse.room)
  return _internal_room();
}
inline void GetCombatStateResponse::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetCombatStateResponse.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE GetCombatStateResponse::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE GetCombatStateResponse::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCombatStateResponse.room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL GetCombatStateResponse::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL GetCombatStateResponse::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCombatStateResponse.room)
  return _msg;
}
inline void GetCombatStateResponse::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCombatStateResponse.room)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
inline bool GetCombatStateResponse::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void GetCombatStateResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& GetCombatStateResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& GetCombatStateResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)
  return _internal_combat_state();
}
inline void GetCombatStateResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE GetCombatStateResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE GetCombatStateResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL GetCombatStateResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL GetCombatStateResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)
  return _msg;
}
inline void GetCombatStateResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetCombatStateResponse.combat_state)
}

// -------------------------------------------------------------------

// GetEncounterStateRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void GetEncounterStateRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& GetEncounterStateRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetEncounterStateRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterStateRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterStateRequest.encounter_id)
  return _s;
}
inline const ::std::string& GetEncounterStateRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void GetEncounterStateRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetEncounterStateRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetEncounterStateRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void GetEncounterStateRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetEncounterStateRequest.encounter_id)
}

// string player_id = 2 [json_name = "playerId"];
inline void GetEncounterStateRequest::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& GetEncounterStateRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetEncounterStateRequest::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterStateRequest.player_id)
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateRequest::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterStateRequest.player_id)
  return _s;
}
inline const ::std::string& GetEncounterStateRequest::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void GetEncounterStateRequest::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateRequest::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetEncounterStateRequest::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetEncounterStateRequest.player_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void GetEncounterStateRequest::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetEncounterStateRequest.player_id)
}

// -------------------------------------------------------------------

// MonsterCombatState

// string monster_id = 1 [json_name = "monsterId"];
inline void MonsterCombatState::clear_monster_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& MonsterCombatState::monster_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterCombatState.monster_id)
  return _internal_monster_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MonsterCombatState::set_monster_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.monster_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MonsterCombatState.monster_id)
}
inline ::std::string* PROTOBUF_NONNULL MonsterCombatState::mutable_monster_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_monster_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterCombatState.monster_id)
  return _s;
}
inline const ::std::string& MonsterCombatState::_internal_monster_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monster_id_.Get();
}
inline void MonsterCombatState::_internal_set_monster_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MonsterCombatState::_internal_mutable_monster_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.monster_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MonsterCombatState::release_monster_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MonsterCombatState.monster_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.monster_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.monster_id_.Set("", GetArena());
  }
  return released;
}
inline void MonsterCombatState::set_allocated_monster_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.monster_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.monster_id_.IsDefault()) {
    _impl_.monster_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MonsterCombatState.monster_id)
}

// string monster_name = 2 [json_name = "monsterName"];
inline void MonsterCombatState::clear_monster_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& MonsterCombatState::monster_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterCombatState.monster_name)
  return _internal_monster_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MonsterCombatState::set_monster_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.monster_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MonsterCombatState.monster_name)
}
inline ::std::string* PROTOBUF_NONNULL MonsterCombatState::mutable_monster_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_monster_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterCombatState.monster_name)
  return _s;
}
inline const ::std::string& MonsterCombatState::_internal_monster_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monster_name_.Get();
}
inline void MonsterCombatState::_internal_set_monster_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MonsterCombatState::_internal_mutable_monster_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.monster_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MonsterCombatState::release_monster_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MonsterCombatState.monster_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.monster_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.monster_name_.Set("", GetArena());
  }
  return released;
}
inline void MonsterCombatState::set_allocated_monster_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.monster_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.monster_name_.IsDefault()) {
    _impl_.monster_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MonsterCombatState.monster_name)
}

// int32 current_hit_points = 3 [json_name = "currentHitPoints"];
inline void MonsterCombatState::clear_current_hit_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_hit_points_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t MonsterCombatState::current_hit_points() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterCombatState.current_hit_points)
  return _internal_current_hit_points();
}
inline void MonsterCombatState::set_current_hit_points(::int32_t value) {
  _internal_set_current_hit_points(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MonsterCombatState.current_hit_points)
}
inline ::int32_t MonsterCombatState::_internal_current_hit_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_hit_points_;
}
inline void MonsterCombatState::_internal_set_current_hit_points(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_hit_points_ = value;
}

// int32 max_hit_points = 4 [json_name = "maxHitPoints"];
inline void MonsterCombatState::clear_max_hit_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_hit_points_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t MonsterCombatState::max_hit_points() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterCombatState.max_hit_points)
  return _internal_max_hit_points();
}
inline void MonsterCombatState::set_max_hit_points(::int32_t value) {
  _internal_set_max_hit_points(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MonsterCombatState.max_hit_points)
}
inline ::int32_t MonsterCombatState::_internal_max_hit_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_hit_points_;
}
inline void MonsterCombatState::_internal_set_max_hit_points(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_hit_points_ = value;
}

// .dnd5e.api.v1alpha1.MonsterType monster_type = 5 [json_name = "monsterType"];
inline void MonsterCombatState::clear_monster_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::dnd5e::api::v1alpha1::MonsterType MonsterCombatState::monster_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterCombatState.monster_type)
  return _internal_monster_type();
}
inline void MonsterCombatState::set_monster_type(::dnd5e::api::v1alpha1::MonsterType value) {
  _internal_set_monster_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MonsterCombatState.monster_type)
}
inline ::dnd5e::api::v1alpha1::MonsterType MonsterCombatState::_internal_monster_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::MonsterType>(_impl_.monster_type_);
}
inline void MonsterCombatState::_internal_set_monster_type(::dnd5e::api::v1alpha1::MonsterType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_type_ = value;
}

// -------------------------------------------------------------------

// GetEncounterStateResponse

// string encounter_id = 1 [json_name = "encounterId"];
inline void GetEncounterStateResponse::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& GetEncounterStateResponse::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateResponse.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetEncounterStateResponse::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterStateResponse.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterStateResponse.encounter_id)
  return _s;
}
inline const ::std::string& GetEncounterStateResponse::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void GetEncounterStateResponse::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateResponse::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetEncounterStateResponse::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetEncounterStateResponse.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void GetEncounterStateResponse::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetEncounterStateResponse.encounter_id)
}

// .dnd5e.api.v1alpha1.EncounterState state = 2 [json_name = "state"];
inline void GetEncounterStateResponse::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000400U);
}
inline ::dnd5e::api::v1alpha1::EncounterState GetEncounterStateResponse::state() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateResponse.state)
  return _internal_state();
}
inline void GetEncounterStateResponse::set_state(::dnd5e::api::v1alpha1::EncounterState value) {
  _internal_set_state(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterStateResponse.state)
}
inline ::dnd5e::api::v1alpha1::EncounterState GetEncounterStateResponse::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::EncounterState>(_impl_.state_);
}
inline void GetEncounterStateResponse::_internal_set_state(::dnd5e::api::v1alpha1::EncounterState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
inline int GetEncounterStateResponse::_internal_party_size() const {
  return _internal_party().size();
}
inline int GetEncounterStateResponse::party_size() const {
  return _internal_party_size();
}
inline void GetEncounterStateResponse::clear_party() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.party_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_party(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterStateResponse.party)
  return _internal_mutable_party()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_party()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.GetEncounterStateResponse.party)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_party();
}
inline const ::dnd5e::api::v1alpha1::PartyMember& GetEncounterStateResponse::party(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateResponse.party)
  return _internal_party().Get(index);
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL GetEncounterStateResponse::add_party()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::PartyMember* _add =
      _internal_mutable_party()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.GetEncounterStateResponse.party)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>& GetEncounterStateResponse::party() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.GetEncounterStateResponse.party)
  return _internal_party();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>&
GetEncounterStateResponse::_internal_party() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.party_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>* PROTOBUF_NONNULL
GetEncounterStateResponse::_internal_mutable_party() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.party_;
}

// string join_code = 4 [json_name = "joinCode"];
inline void GetEncounterStateResponse::clear_join_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.join_code_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::std::string& GetEncounterStateResponse::join_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateResponse.join_code)
  return _internal_join_code();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetEncounterStateResponse::set_join_code(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  _impl_.join_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterStateResponse.join_code)
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_join_code()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::std::string* _s = _internal_mutable_join_code();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterStateResponse.join_code)
  return _s;
}
inline const ::std::string& GetEncounterStateResponse::_internal_join_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.join_code_.Get();
}
inline void GetEncounterStateResponse::_internal_set_join_code(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.join_code_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateResponse::_internal_mutable_join_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.join_code_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetEncounterStateResponse::release_join_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetEncounterStateResponse.join_code)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000010U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  auto* released = _impl_.join_code_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.join_code_.Set("", GetArena());
  }
  return released;
}
inline void GetEncounterStateResponse::set_allocated_join_code(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  _impl_.join_code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.join_code_.IsDefault()) {
    _impl_.join_code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetEncounterStateResponse.join_code)
}

// string host_id = 5 [json_name = "hostId"];
inline void GetEncounterStateResponse::clear_host_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::std::string& GetEncounterStateResponse::host_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateResponse.host_id)
  return _internal_host_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetEncounterStateResponse::set_host_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  _impl_.host_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterStateResponse.host_id)
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_host_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::std::string* _s = _internal_mutable_host_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterStateResponse.host_id)
  return _s;
}
inline const ::std::string& GetEncounterStateResponse::_internal_host_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.host_id_.Get();
}
inline void GetEncounterStateResponse::_internal_set_host_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateResponse::_internal_mutable_host_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.host_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetEncounterStateResponse::release_host_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetEncounterStateResponse.host_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000020U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  auto* released = _impl_.host_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.host_id_.Set("", GetArena());
  }
  return released;
}
inline void GetEncounterStateResponse::set_allocated_host_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  _impl_.host_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.host_id_.IsDefault()) {
    _impl_.host_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetEncounterStateResponse.host_id)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 6 [json_name = "combatState"];
inline bool GetEncounterStateResponse::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void GetEncounterStateResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& GetEncounterStateResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& GetEncounterStateResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateResponse.combat_state)
  return _internal_combat_state();
}
inline void GetEncounterStateResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetEncounterStateResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE GetEncounterStateResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE GetEncounterStateResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetEncounterStateResponse.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL GetEncounterStateResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterStateResponse.combat_state)
  return _msg;
}
inline void GetEncounterStateResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetEncounterStateResponse.combat_state)
}

// .dnd5e.api.v1alpha1.Room room = 7 [json_name = "room"];
inline bool GetEncounterStateResponse::has_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000200U);
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void GetEncounterStateResponse::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline const ::dnd5e::api::v1alpha1::Room& GetEncounterStateResponse::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& GetEncounterStateResponse::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateResponse.room)
  return _internal_room();
}
inline void GetEncounterStateResponse::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.GetEncounterStateResponse.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE GetEncounterStateResponse::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE GetEncounterStateResponse::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetEncounterStateResponse.room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL GetEncounterStateResponse::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterStateResponse.room)
  return _msg;
}
inline void GetEncounterStateResponse::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000200U);
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetEncounterStateResponse.room)
}

// repeated .dnd5e.api.v1alpha1.MonsterCombatState monsters = 8 [json_name = "monsters"];
inline int GetEncounterStateResponse::_internal_monsters_size() const {
  return _internal_monsters().size();
}
inline int GetEncounterStateResponse::monsters_size() const {
  return _internal_monsters_size();
}
inline void GetEncounterStateResponse::clear_monsters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monsters_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::MonsterCombatState* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_monsters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterStateResponse.monsters)
  return _internal_mutable_monsters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_monsters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.GetEncounterStateResponse.monsters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_monsters();
}
inline const ::dnd5e::api::v1alpha1::MonsterCombatState& GetEncounterStateResponse::monsters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateResponse.monsters)
  return _internal_monsters().Get(index);
}
inline ::dnd5e::api::v1alpha1::MonsterCombatState* PROTOBUF_NONNULL GetEncounterStateResponse::add_monsters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::MonsterCombatState* _add =
      _internal_mutable_monsters()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.GetEncounterStateResponse.monsters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>& GetEncounterStateResponse::monsters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.GetEncounterStateResponse.monsters)
  return _internal_monsters();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>&
GetEncounterStateResponse::_internal_monsters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monsters_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>* PROTOBUF_NONNULL
GetEncounterStateResponse::_internal_mutable_monsters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.monsters_;
}

// string last_event_id = 9 [json_name = "lastEventId"];
inline void GetEncounterStateResponse::clear_last_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_event_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::std::string& GetEncounterStateResponse::last_event_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateResponse.last_event_id)
  return _internal_last_event_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetEncounterStateResponse::set_last_event_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  _impl_.last_event_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterStateResponse.last_event_id)
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_last_event_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::std::string* _s = _internal_mutable_last_event_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterStateResponse.last_event_id)
  return _s;
}
inline const ::std::string& GetEncounterStateResponse::_internal_last_event_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_event_id_.Get();
}
inline void GetEncounterStateResponse::_internal_set_last_event_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_event_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateResponse::_internal_mutable_last_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_event_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetEncounterStateResponse::release_last_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetEncounterStateResponse.last_event_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000040U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  auto* released = _impl_.last_event_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.last_event_id_.Set("", GetArena());
  }
  return released;
}
inline void GetEncounterStateResponse::set_allocated_last_event_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  _impl_.last_event_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_event_id_.IsDefault()) {
    _impl_.last_event_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetEncounterStateResponse.last_event_id)
}

// repeated .dnd5e.api.v1alpha1.DoorInfo doors = 10 [json_name = "doors"];
inline int GetEncounterStateResponse::_internal_doors_size() const {
  return _internal_doors().size();
}
inline int GetEncounterStateResponse::doors_size() const {
  return _internal_doors_size();
}
inline void GetEncounterStateResponse::clear_doors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.doors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_doors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterStateResponse.doors)
  return _internal_mutable_doors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_doors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.GetEncounterStateResponse.doors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_doors();
}
inline const ::dnd5e::api::v1alpha1::DoorInfo& GetEncounterStateResponse::doors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateResponse.doors)
  return _internal_doors().Get(index);
}
inline ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL GetEncounterStateResponse::add_doors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::DoorInfo* _add =
      _internal_mutable_doors()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.GetEncounterStateResponse.doors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& GetEncounterStateResponse::doors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.GetEncounterStateResponse.doors)
  return _internal_doors();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>&
GetEncounterStateResponse::_internal_doors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.doors_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL
GetEncounterStateResponse::_internal_mutable_doors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.doors_;
}

// string dungeon_id = 11 [json_name = "dungeonId"];
inline void GetEncounterStateResponse::clear_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::std::string& GetEncounterStateResponse::dungeon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterStateResponse.dungeon_id)
  return _internal_dungeon_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetEncounterStateResponse::set_dungeon_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  _impl_.dungeon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterStateResponse.dungeon_id)
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateResponse::mutable_dungeon_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::std::string* _s = _internal_mutable_dungeon_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterStateResponse.dungeon_id)
  return _s;
}
inline const ::std::string& GetEncounterStateResponse::_internal_dungeon_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dungeon_id_.Get();
}
inline void GetEncounterStateResponse::_internal_set_dungeon_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterStateResponse::_internal_mutable_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dungeon_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetEncounterStateResponse::release_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetEncounterStateResponse.dungeon_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000080U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  auto* released = _impl_.dungeon_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  return released;
}
inline void GetEncounterStateResponse::set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  _impl_.dungeon_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dungeon_id_.IsDefault()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetEncounterStateResponse.dungeon_id)
}

// -------------------------------------------------------------------

// GetEncounterHistoryRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void GetEncounterHistoryRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& GetEncounterHistoryRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterHistoryRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetEncounterHistoryRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterHistoryRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterHistoryRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterHistoryRequest.encounter_id)
  return _s;
}
inline const ::std::string& GetEncounterHistoryRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void GetEncounterHistoryRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterHistoryRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetEncounterHistoryRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetEncounterHistoryRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void GetEncounterHistoryRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetEncounterHistoryRequest.encounter_id)
}

// string up_to_event_id = 2 [json_name = "upToEventId"];
inline void GetEncounterHistoryRequest::clear_up_to_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.up_to_event_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& GetEncounterHistoryRequest::up_to_event_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterHistoryRequest.up_to_event_id)
  return _internal_up_to_event_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetEncounterHistoryRequest::set_up_to_event_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.up_to_event_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterHistoryRequest.up_to_event_id)
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterHistoryRequest::mutable_up_to_event_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_up_to_event_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterHistoryRequest.up_to_event_id)
  return _s;
}
inline const ::std::string& GetEncounterHistoryRequest::_internal_up_to_event_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.up_to_event_id_.Get();
}
inline void GetEncounterHistoryRequest::_internal_set_up_to_event_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.up_to_event_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterHistoryRequest::_internal_mutable_up_to_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.up_to_event_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetEncounterHistoryRequest::release_up_to_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetEncounterHistoryRequest.up_to_event_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.up_to_event_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.up_to_event_id_.Set("", GetArena());
  }
  return released;
}
inline void GetEncounterHistoryRequest::set_allocated_up_to_event_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.up_to_event_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.up_to_event_id_.IsDefault()) {
    _impl_.up_to_event_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetEncounterHistoryRequest.up_to_event_id)
}

// int32 limit = 3 [json_name = "limit"];
inline void GetEncounterHistoryRequest::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t GetEncounterHistoryRequest::limit() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterHistoryRequest.limit)
  return _internal_limit();
}
inline void GetEncounterHistoryRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterHistoryRequest.limit)
}
inline ::int32_t GetEncounterHistoryRequest::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void GetEncounterHistoryRequest::_internal_set_limit(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// -------------------------------------------------------------------

// GetEncounterHistoryResponse

// repeated .dnd5e.api.v1alpha1.EncounterEvent events = 1 [json_name = "events"];
inline int GetEncounterHistoryResponse::_internal_events_size() const {
  return _internal_events().size();
}
inline int GetEncounterHistoryResponse::events_size() const {
  return _internal_events_size();
}
inline void GetEncounterHistoryResponse::clear_events() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.events_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::EncounterEvent* PROTOBUF_NONNULL GetEncounterHistoryResponse::mutable_events(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterHistoryResponse.events)
  return _internal_mutable_events()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EncounterEvent>* PROTOBUF_NONNULL GetEncounterHistoryResponse::mutable_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.GetEncounterHistoryResponse.events)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_events();
}
inline const ::dnd5e::api::v1alpha1::EncounterEvent& GetEncounterHistoryResponse::events(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterHistoryResponse.events)
  return _internal_events().Get(index);
}
inline ::dnd5e::api::v1alpha1::EncounterEvent* PROTOBUF_NONNULL GetEncounterHistoryResponse::add_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::EncounterEvent* _add =
      _internal_mutable_events()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.GetEncounterHistoryResponse.events)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EncounterEvent>& GetEncounterHistoryResponse::events() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.GetEncounterHistoryResponse.events)
  return _internal_events();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EncounterEvent>&
GetEncounterHistoryResponse::_internal_events() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.events_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::EncounterEvent>* PROTOBUF_NONNULL
GetEncounterHistoryResponse::_internal_mutable_events() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.events_;
}

// bool has_more = 2 [json_name = "hasMore"];
inline void GetEncounterHistoryResponse::clear_has_more() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_more_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool GetEncounterHistoryResponse::has_more() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterHistoryResponse.has_more)
  return _internal_has_more();
}
inline void GetEncounterHistoryResponse::set_has_more(bool value) {
  _internal_set_has_more(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterHistoryResponse.has_more)
}
inline bool GetEncounterHistoryResponse::_internal_has_more() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_more_;
}
inline void GetEncounterHistoryResponse::_internal_set_has_more(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_more_ = value;
}

// string last_event_id = 3 [json_name = "lastEventId"];
inline void GetEncounterHistoryResponse::clear_last_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_event_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& GetEncounterHistoryResponse::last_event_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GetEncounterHistoryResponse.last_event_id)
  return _internal_last_event_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GetEncounterHistoryResponse::set_last_event_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.last_event_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GetEncounterHistoryResponse.last_event_id)
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterHistoryResponse::mutable_last_event_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_last_event_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GetEncounterHistoryResponse.last_event_id)
  return _s;
}
inline const ::std::string& GetEncounterHistoryResponse::_internal_last_event_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_event_id_.Get();
}
inline void GetEncounterHistoryResponse::_internal_set_last_event_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_event_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GetEncounterHistoryResponse::_internal_mutable_last_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_event_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GetEncounterHistoryResponse::release_last_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GetEncounterHistoryResponse.last_event_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.last_event_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.last_event_id_.Set("", GetArena());
  }
  return released;
}
inline void GetEncounterHistoryResponse::set_allocated_last_event_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.last_event_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_event_id_.IsDefault()) {
    _impl_.last_event_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GetEncounterHistoryResponse.last_event_id)
}

// -------------------------------------------------------------------

// MoveCharacterRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void MoveCharacterRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& MoveCharacterRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MoveCharacterRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
  return _s;
}
inline const ::std::string& MoveCharacterRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void MoveCharacterRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MoveCharacterRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void MoveCharacterRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterRequest.encounter_id)
}

// string entity_id = 2 [json_name = "entityId"];
inline void MoveCharacterRequest::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& MoveCharacterRequest::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MoveCharacterRequest::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterRequest::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
  return _s;
}
inline const ::std::string& MoveCharacterRequest::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void MoveCharacterRequest::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterRequest::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MoveCharacterRequest::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void MoveCharacterRequest::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterRequest.entity_id)
}

// repeated .api.v1alpha1.Position path = 3 [json_name = "path"];
inline int MoveCharacterRequest::_internal_path_size() const {
  return _internal_path().size();
}
inline int MoveCharacterRequest::path_size() const {
  return _internal_path_size();
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MoveCharacterRequest::mutable_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterRequest.path)
  return _internal_mutable_path()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL MoveCharacterRequest::mutable_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.MoveCharacterRequest.path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_path();
}
inline const ::api::v1alpha1::Position& MoveCharacterRequest::path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterRequest.path)
  return _internal_path().Get(index);
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MoveCharacterRequest::add_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::api::v1alpha1::Position* _add =
      _internal_mutable_path()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.MoveCharacterRequest.path)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>& MoveCharacterRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.MoveCharacterRequest.path)
  return _internal_path();
}
inline const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>&
MoveCharacterRequest::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_;
}
inline ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL
MoveCharacterRequest::_internal_mutable_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.path_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MovementError

// .dnd5e.api.v1alpha1.MovementError.ErrorCode code = 1 [json_name = "code"];
inline void MovementError::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::MovementError_ErrorCode MovementError::code() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MovementError.code)
  return _internal_code();
}
inline void MovementError::set_code(::dnd5e::api::v1alpha1::MovementError_ErrorCode value) {
  _internal_set_code(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MovementError.code)
}
inline ::dnd5e::api::v1alpha1::MovementError_ErrorCode MovementError::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::MovementError_ErrorCode>(_impl_.code_);
}
inline void MovementError::_internal_set_code(::dnd5e::api::v1alpha1::MovementError_ErrorCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = value;
}

// string message = 2 [json_name = "message"];
inline void MovementError::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& MovementError::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MovementError.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MovementError::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MovementError.message)
}
inline ::std::string* PROTOBUF_NONNULL MovementError::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MovementError.message)
  return _s;
}
inline const ::std::string& MovementError::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void MovementError::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MovementError::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MovementError::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MovementError.message)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void MovementError::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MovementError.message)
}

// map<string, string> details = 3 [json_name = "details"];
inline int MovementError::_internal_details_size() const {
  return _internal_details().size();
}
inline int MovementError::details_size() const {
  return _internal_details_size();
}
inline void MovementError::clear_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::google::protobuf::Map<::std::string, ::std::string>& MovementError::_internal_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.details_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::std::string>& MovementError::details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:dnd5e.api.v1alpha1.MovementError.details)
  return _internal_details();
}
inline ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL MovementError::_internal_mutable_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.details_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL MovementError::mutable_details()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_map:dnd5e.api.v1alpha1.MovementError.details)
  return _internal_mutable_details();
}

// -------------------------------------------------------------------

// MoveCharacterResponse

// bool success = 1 [json_name = "success"];
inline void MoveCharacterResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool MoveCharacterResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.success)
  return _internal_success();
}
inline void MoveCharacterResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterResponse.success)
}
inline bool MoveCharacterResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void MoveCharacterResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// .dnd5e.api.v1alpha1.MovementError error = 2 [json_name = "error"];
inline bool MoveCharacterResponse::has_error() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline void MoveCharacterResponse::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::MovementError& MoveCharacterResponse::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::MovementError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::MovementError&>(::dnd5e::api::v1alpha1::_MovementError_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::MovementError& MoveCharacterResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.error)
  return _internal_error();
}
inline void MoveCharacterResponse::unsafe_arena_set_allocated_error(
    ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::dnd5e::api::v1alpha1::MovementError*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.error)
}
inline ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE MoveCharacterResponse::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::MovementError* released = _impl_.error_;
  _impl_.error_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE MoveCharacterResponse::unsafe_arena_release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterResponse.error)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::MovementError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NONNULL MoveCharacterResponse::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.error_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::MovementError>(GetArena());
    _impl_.error_ = reinterpret_cast<::dnd5e::api::v1alpha1::MovementError*>(p);
  }
  return _impl_.error_;
}
inline ::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NONNULL MoveCharacterResponse::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::MovementError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterResponse.error)
  return _msg;
}
inline void MoveCharacterResponse::set_allocated_error(::dnd5e::api::v1alpha1::MovementError* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.error_ = reinterpret_cast<::dnd5e::api::v1alpha1::MovementError*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.error)
}

// .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
inline bool MoveCharacterResponse::has_final_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.final_position_ != nullptr);
  return value;
}
inline const ::api::v1alpha1::Position& MoveCharacterResponse::_internal_final_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::api::v1alpha1::Position* p = _impl_.final_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::v1alpha1::Position&>(::api::v1alpha1::_Position_default_instance_);
}
inline const ::api::v1alpha1::Position& MoveCharacterResponse::final_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.final_position)
  return _internal_final_position();
}
inline void MoveCharacterResponse::unsafe_arena_set_allocated_final_position(
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.final_position_);
  }
  _impl_.final_position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.final_position)
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE MoveCharacterResponse::release_final_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::api::v1alpha1::Position* released = _impl_.final_position_;
  _impl_.final_position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE MoveCharacterResponse::unsafe_arena_release_final_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterResponse.final_position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::api::v1alpha1::Position* temp = _impl_.final_position_;
  _impl_.final_position_ = nullptr;
  return temp;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MoveCharacterResponse::_internal_mutable_final_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.final_position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::api::v1alpha1::Position>(GetArena());
    _impl_.final_position_ = reinterpret_cast<::api::v1alpha1::Position*>(p);
  }
  return _impl_.final_position_;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MoveCharacterResponse::mutable_final_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::api::v1alpha1::Position* _msg = _internal_mutable_final_position();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterResponse.final_position)
  return _msg;
}
inline void MoveCharacterResponse::set_allocated_final_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.final_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.final_position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.final_position)
}

// int32 movement_remaining = 4 [json_name = "movementRemaining"];
inline void MoveCharacterResponse::clear_movement_remaining() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_remaining_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::int32_t MoveCharacterResponse::movement_remaining() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.movement_remaining)
  return _internal_movement_remaining();
}
inline void MoveCharacterResponse::set_movement_remaining(::int32_t value) {
  _internal_set_movement_remaining(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterResponse.movement_remaining)
}
inline ::int32_t MoveCharacterResponse::_internal_movement_remaining() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movement_remaining_;
}
inline void MoveCharacterResponse::_internal_set_movement_remaining(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_remaining_ = value;
}

// string stop_reason = 5 [json_name = "stopReason"];
inline void MoveCharacterResponse::clear_stop_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_reason_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& MoveCharacterResponse::stop_reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.stop_reason)
  return _internal_stop_reason();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MoveCharacterResponse::set_stop_reason(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.stop_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MoveCharacterResponse.stop_reason)
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterResponse::mutable_stop_reason()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_stop_reason();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterResponse.stop_reason)
  return _s;
}
inline const ::std::string& MoveCharacterResponse::_internal_stop_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_reason_.Get();
}
inline void MoveCharacterResponse::_internal_set_stop_reason(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_reason_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MoveCharacterResponse::_internal_mutable_stop_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.stop_reason_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MoveCharacterResponse::release_stop_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterResponse.stop_reason)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.stop_reason_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stop_reason_.Set("", GetArena());
  }
  return released;
}
inline void MoveCharacterResponse::set_allocated_stop_reason(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.stop_reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stop_reason_.IsDefault()) {
    _impl_.stop_reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.stop_reason)
}

// .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
inline bool MoveCharacterResponse::has_updated_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.updated_room_ != nullptr);
  return value;
}
inline void MoveCharacterResponse::clear_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ != nullptr) _impl_.updated_room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::dnd5e::api::v1alpha1::Room& MoveCharacterResponse::_internal_updated_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.updated_room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& MoveCharacterResponse::updated_room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)
  return _internal_updated_room();
}
inline void MoveCharacterResponse::unsafe_arena_set_allocated_updated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }
  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE MoveCharacterResponse::release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE MoveCharacterResponse::unsafe_arena_release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL MoveCharacterResponse::_internal_mutable_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.updated_room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL MoveCharacterResponse::mutable_updated_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_updated_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)
  return _msg;
}
inline void MoveCharacterResponse::set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MoveCharacterResponse.updated_room)
}

// -------------------------------------------------------------------

// EndTurnRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void EndTurnRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& EndTurnRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EndTurnRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL EndTurnRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
  return _s;
}
inline const ::std::string& EndTurnRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void EndTurnRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EndTurnRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EndTurnRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void EndTurnRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnRequest.encounter_id)
}

// string entity_id = 2 [json_name = "entityId"];
inline void EndTurnRequest::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& EndTurnRequest::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EndTurnRequest::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL EndTurnRequest::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
  return _s;
}
inline const ::std::string& EndTurnRequest::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void EndTurnRequest::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EndTurnRequest::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EndTurnRequest::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void EndTurnRequest::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnRequest.entity_id)
}

// -------------------------------------------------------------------

// TurnChangeEvent

// string previous_entity_id = 1 [json_name = "previousEntityId"];
inline void TurnChangeEvent::clear_previous_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.previous_entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& TurnChangeEvent::previous_entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
  return _internal_previous_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TurnChangeEvent::set_previous_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.previous_entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
}
inline ::std::string* PROTOBUF_NONNULL TurnChangeEvent::mutable_previous_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_previous_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
  return _s;
}
inline const ::std::string& TurnChangeEvent::_internal_previous_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.previous_entity_id_.Get();
}
inline void TurnChangeEvent::_internal_set_previous_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.previous_entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TurnChangeEvent::_internal_mutable_previous_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.previous_entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TurnChangeEvent::release_previous_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.previous_entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.previous_entity_id_.Set("", GetArena());
  }
  return released;
}
inline void TurnChangeEvent::set_allocated_previous_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.previous_entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.previous_entity_id_.IsDefault()) {
    _impl_.previous_entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnChangeEvent.previous_entity_id)
}

// string next_entity_id = 2 [json_name = "nextEntityId"];
inline void TurnChangeEvent::clear_next_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& TurnChangeEvent::next_entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
  return _internal_next_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TurnChangeEvent::set_next_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.next_entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
}
inline ::std::string* PROTOBUF_NONNULL TurnChangeEvent::mutable_next_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_next_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
  return _s;
}
inline const ::std::string& TurnChangeEvent::_internal_next_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_entity_id_.Get();
}
inline void TurnChangeEvent::_internal_set_next_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TurnChangeEvent::_internal_mutable_next_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TurnChangeEvent::release_next_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.next_entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.next_entity_id_.Set("", GetArena());
  }
  return released;
}
inline void TurnChangeEvent::set_allocated_next_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.next_entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_entity_id_.IsDefault()) {
    _impl_.next_entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnChangeEvent.next_entity_id)
}

// int32 round = 3 [json_name = "round"];
inline void TurnChangeEvent::clear_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t TurnChangeEvent::round() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnChangeEvent.round)
  return _internal_round();
}
inline void TurnChangeEvent::set_round(::int32_t value) {
  _internal_set_round(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnChangeEvent.round)
}
inline ::int32_t TurnChangeEvent::_internal_round() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.round_;
}
inline void TurnChangeEvent::_internal_set_round(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = value;
}

// bool new_round = 4 [json_name = "newRound"];
inline void TurnChangeEvent::clear_new_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_round_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool TurnChangeEvent::new_round() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnChangeEvent.new_round)
  return _internal_new_round();
}
inline void TurnChangeEvent::set_new_round(bool value) {
  _internal_set_new_round(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.TurnChangeEvent.new_round)
}
inline bool TurnChangeEvent::_internal_new_round() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_round_;
}
inline void TurnChangeEvent::_internal_set_new_round(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_round_ = value;
}

// -------------------------------------------------------------------

// EndTurnResponse

// bool success = 1 [json_name = "success"];
inline void EndTurnResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool EndTurnResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnResponse.success)
  return _internal_success();
}
inline void EndTurnResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EndTurnResponse.success)
}
inline bool EndTurnResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void EndTurnResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
inline bool EndTurnResponse::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void EndTurnResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& EndTurnResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& EndTurnResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)
  return _internal_combat_state();
}
inline void EndTurnResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE EndTurnResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE EndTurnResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL EndTurnResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL EndTurnResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)
  return _msg;
}
inline void EndTurnResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.combat_state)
}

// .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 3 [json_name = "turnChange"];
inline bool EndTurnResponse::has_turn_change() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.turn_change_ != nullptr);
  return value;
}
inline void EndTurnResponse::clear_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.turn_change_ != nullptr) _impl_.turn_change_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::TurnChangeEvent& EndTurnResponse::_internal_turn_change() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::TurnChangeEvent* p = _impl_.turn_change_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::TurnChangeEvent&>(::dnd5e::api::v1alpha1::_TurnChangeEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::TurnChangeEvent& EndTurnResponse::turn_change() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)
  return _internal_turn_change();
}
inline void EndTurnResponse::unsafe_arena_set_allocated_turn_change(
    ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.turn_change_);
  }
  _impl_.turn_change_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnChangeEvent*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE EndTurnResponse::release_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* released = _impl_.turn_change_;
  _impl_.turn_change_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE EndTurnResponse::unsafe_arena_release_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* temp = _impl_.turn_change_;
  _impl_.turn_change_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL EndTurnResponse::_internal_mutable_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.turn_change_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::TurnChangeEvent>(GetArena());
    _impl_.turn_change_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnChangeEvent*>(p);
  }
  return _impl_.turn_change_;
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL EndTurnResponse::mutable_turn_change()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* _msg = _internal_mutable_turn_change();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)
  return _msg;
}
inline void EndTurnResponse::set_allocated_turn_change(::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.turn_change_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.turn_change_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnChangeEvent*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.turn_change)
}

// repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 4 [json_name = "monsterTurns"];
inline int EndTurnResponse::_internal_monster_turns_size() const {
  return _internal_monster_turns().size();
}
inline int EndTurnResponse::monster_turns_size() const {
  return _internal_monster_turns_size();
}
inline void EndTurnResponse::clear_monster_turns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_turns_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL EndTurnResponse::mutable_monster_turns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnResponse.monster_turns)
  return _internal_mutable_monster_turns()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL EndTurnResponse::mutable_monster_turns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.EndTurnResponse.monster_turns)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_monster_turns();
}
inline const ::dnd5e::api::v1alpha1::MonsterTurnResult& EndTurnResponse::monster_turns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnResponse.monster_turns)
  return _internal_monster_turns().Get(index);
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL EndTurnResponse::add_monster_turns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::MonsterTurnResult* _add =
      _internal_mutable_monster_turns()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.EndTurnResponse.monster_turns)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& EndTurnResponse::monster_turns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.EndTurnResponse.monster_turns)
  return _internal_monster_turns();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>&
EndTurnResponse::_internal_monster_turns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monster_turns_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL
EndTurnResponse::_internal_mutable_monster_turns() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.monster_turns_;
}

// optional .dnd5e.api.v1alpha1.EncounterResult encounter_result = 5 [json_name = "encounterResult"];
inline bool EndTurnResponse::has_encounter_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.encounter_result_ != nullptr);
  return value;
}
inline void EndTurnResponse::clear_encounter_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.encounter_result_ != nullptr) _impl_.encounter_result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::dnd5e::api::v1alpha1::EncounterResult& EndTurnResponse::_internal_encounter_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::EncounterResult* p = _impl_.encounter_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::EncounterResult&>(::dnd5e::api::v1alpha1::_EncounterResult_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::EncounterResult& EndTurnResponse::encounter_result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EndTurnResponse.encounter_result)
  return _internal_encounter_result();
}
inline void EndTurnResponse::unsafe_arena_set_allocated_encounter_result(
    ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.encounter_result_);
  }
  _impl_.encounter_result_ = reinterpret_cast<::dnd5e::api::v1alpha1::EncounterResult*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.encounter_result)
}
inline ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE EndTurnResponse::release_encounter_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::EncounterResult* released = _impl_.encounter_result_;
  _impl_.encounter_result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE EndTurnResponse::unsafe_arena_release_encounter_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EndTurnResponse.encounter_result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::EncounterResult* temp = _impl_.encounter_result_;
  _impl_.encounter_result_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NONNULL EndTurnResponse::_internal_mutable_encounter_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.encounter_result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::EncounterResult>(GetArena());
    _impl_.encounter_result_ = reinterpret_cast<::dnd5e::api::v1alpha1::EncounterResult*>(p);
  }
  return _impl_.encounter_result_;
}
inline ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NONNULL EndTurnResponse::mutable_encounter_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::EncounterResult* _msg = _internal_mutable_encounter_result();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EndTurnResponse.encounter_result)
  return _msg;
}
inline void EndTurnResponse::set_allocated_encounter_result(::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.encounter_result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.encounter_result_ = reinterpret_cast<::dnd5e::api::v1alpha1::EncounterResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EndTurnResponse.encounter_result)
}

// -------------------------------------------------------------------

// AttackRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void AttackRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& AttackRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
  return _s;
}
inline const ::std::string& AttackRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void AttackRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackRequest.encounter_id)
}

// string attacker_id = 2 [json_name = "attackerId"];
inline void AttackRequest::clear_attacker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attacker_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& AttackRequest::attacker_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
  return _internal_attacker_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackRequest::set_attacker_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.attacker_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::mutable_attacker_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_attacker_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
  return _s;
}
inline const ::std::string& AttackRequest::_internal_attacker_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attacker_id_.Get();
}
inline void AttackRequest::_internal_set_attacker_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attacker_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::_internal_mutable_attacker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.attacker_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackRequest::release_attacker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.attacker_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.attacker_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackRequest::set_allocated_attacker_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.attacker_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.attacker_id_.IsDefault()) {
    _impl_.attacker_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackRequest.attacker_id)
}

// string target_id = 3 [json_name = "targetId"];
inline void AttackRequest::clear_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& AttackRequest::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackRequest::set_target_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.target_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::mutable_target_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackRequest.target_id)
  return _s;
}
inline const ::std::string& AttackRequest::_internal_target_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_id_.Get();
}
inline void AttackRequest::_internal_set_target_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::_internal_mutable_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackRequest::release_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackRequest.target_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.target_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.target_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackRequest::set_allocated_target_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.target_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_id_.IsDefault()) {
    _impl_.target_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackRequest.target_id)
}

// string weapon_id = 4 [json_name = "weaponId"];
inline void AttackRequest::clear_weapon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapon_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& AttackRequest::weapon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
  return _internal_weapon_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackRequest::set_weapon_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.weapon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::mutable_weapon_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_weapon_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
  return _s;
}
inline const ::std::string& AttackRequest::_internal_weapon_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.weapon_id_.Get();
}
inline void AttackRequest::_internal_set_weapon_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapon_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackRequest::_internal_mutable_weapon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.weapon_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackRequest::release_weapon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.weapon_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.weapon_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackRequest::set_allocated_weapon_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.weapon_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.weapon_id_.IsDefault()) {
    _impl_.weapon_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackRequest.weapon_id)
}

// .dnd5e.api.v1alpha1.AttackHand attack_hand = 5 [json_name = "attackHand"];
inline void AttackRequest::clear_attack_hand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_hand_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::dnd5e::api::v1alpha1::AttackHand AttackRequest::attack_hand() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackRequest.attack_hand)
  return _internal_attack_hand();
}
inline void AttackRequest::set_attack_hand(::dnd5e::api::v1alpha1::AttackHand value) {
  _internal_set_attack_hand(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackRequest.attack_hand)
}
inline ::dnd5e::api::v1alpha1::AttackHand AttackRequest::_internal_attack_hand() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::AttackHand>(_impl_.attack_hand_);
}
inline void AttackRequest::_internal_set_attack_hand(::dnd5e::api::v1alpha1::AttackHand value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_hand_ = value;
}

// -------------------------------------------------------------------

// RerollEvent

// int32 die_index = 1 [json_name = "dieIndex"];
inline void RerollEvent::clear_die_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.die_index_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t RerollEvent::die_index() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RerollEvent.die_index)
  return _internal_die_index();
}
inline void RerollEvent::set_die_index(::int32_t value) {
  _internal_set_die_index(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RerollEvent.die_index)
}
inline ::int32_t RerollEvent::_internal_die_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.die_index_;
}
inline void RerollEvent::_internal_set_die_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.die_index_ = value;
}

// int32 before = 2 [json_name = "before"];
inline void RerollEvent::clear_before() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.before_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t RerollEvent::before() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RerollEvent.before)
  return _internal_before();
}
inline void RerollEvent::set_before(::int32_t value) {
  _internal_set_before(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RerollEvent.before)
}
inline ::int32_t RerollEvent::_internal_before() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.before_;
}
inline void RerollEvent::_internal_set_before(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.before_ = value;
}

// int32 after = 3 [json_name = "after"];
inline void RerollEvent::clear_after() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.after_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t RerollEvent::after() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RerollEvent.after)
  return _internal_after();
}
inline void RerollEvent::set_after(::int32_t value) {
  _internal_set_after(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RerollEvent.after)
}
inline ::int32_t RerollEvent::_internal_after() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.after_;
}
inline void RerollEvent::_internal_set_after(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.after_ = value;
}

// string reason = 4 [json_name = "reason"];
inline void RerollEvent::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& RerollEvent::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RerollEvent.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RerollEvent::set_reason(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RerollEvent.reason)
}
inline ::std::string* PROTOBUF_NONNULL RerollEvent::mutable_reason()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RerollEvent.reason)
  return _s;
}
inline const ::std::string& RerollEvent::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void RerollEvent::_internal_set_reason(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RerollEvent::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RerollEvent::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RerollEvent.reason)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.reason_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reason_.Set("", GetArena());
  }
  return released;
}
inline void RerollEvent::set_allocated_reason(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RerollEvent.reason)
}

// -------------------------------------------------------------------

// DamageComponent

// string source = 1 [json_name = "source", deprecated = true];
inline void DamageComponent::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& DamageComponent::source() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DamageComponent::set_source(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.source)
}
inline ::std::string* PROTOBUF_NONNULL DamageComponent::mutable_source()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageComponent.source)
  return _s;
}
inline const ::std::string& DamageComponent::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_.Get();
}
inline void DamageComponent::_internal_set_source(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DamageComponent::_internal_mutable_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.source_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DamageComponent::release_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DamageComponent.source)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.source_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.source_.Set("", GetArena());
  }
  return released;
}
inline void DamageComponent::set_allocated_source(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.source_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DamageComponent.source)
}

// repeated int32 original_dice_rolls = 2 [json_name = "originalDiceRolls"];
inline int DamageComponent::_internal_original_dice_rolls_size() const {
  return _internal_original_dice_rolls().size();
}
inline int DamageComponent::original_dice_rolls_size() const {
  return _internal_original_dice_rolls_size();
}
inline void DamageComponent::clear_original_dice_rolls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.original_dice_rolls_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t DamageComponent::original_dice_rolls(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.original_dice_rolls)
  return _internal_original_dice_rolls().Get(index);
}
inline void DamageComponent::set_original_dice_rolls(int index, ::int32_t value) {
  _internal_mutable_original_dice_rolls()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.original_dice_rolls)
}
inline void DamageComponent::add_original_dice_rolls(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_original_dice_rolls()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DamageComponent.original_dice_rolls)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& DamageComponent::original_dice_rolls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DamageComponent.original_dice_rolls)
  return _internal_original_dice_rolls();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL DamageComponent::mutable_original_dice_rolls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DamageComponent.original_dice_rolls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_original_dice_rolls();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
DamageComponent::_internal_original_dice_rolls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.original_dice_rolls_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
DamageComponent::_internal_mutable_original_dice_rolls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.original_dice_rolls_;
}

// repeated int32 final_dice_rolls = 3 [json_name = "finalDiceRolls"];
inline int DamageComponent::_internal_final_dice_rolls_size() const {
  return _internal_final_dice_rolls().size();
}
inline int DamageComponent::final_dice_rolls_size() const {
  return _internal_final_dice_rolls_size();
}
inline void DamageComponent::clear_final_dice_rolls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_dice_rolls_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t DamageComponent::final_dice_rolls(int index) const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.final_dice_rolls)
  return _internal_final_dice_rolls().Get(index);
}
inline void DamageComponent::set_final_dice_rolls(int index, ::int32_t value) {
  _internal_mutable_final_dice_rolls()->Set(index, value);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.final_dice_rolls)
}
inline void DamageComponent::add_final_dice_rolls(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_final_dice_rolls()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DamageComponent.final_dice_rolls)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& DamageComponent::final_dice_rolls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DamageComponent.final_dice_rolls)
  return _internal_final_dice_rolls();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL DamageComponent::mutable_final_dice_rolls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DamageComponent.final_dice_rolls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_final_dice_rolls();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
DamageComponent::_internal_final_dice_rolls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.final_dice_rolls_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
DamageComponent::_internal_mutable_final_dice_rolls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.final_dice_rolls_;
}

// repeated .dnd5e.api.v1alpha1.RerollEvent rerolls = 4 [json_name = "rerolls"];
inline int DamageComponent::_internal_rerolls_size() const {
  return _internal_rerolls().size();
}
inline int DamageComponent::rerolls_size() const {
  return _internal_rerolls_size();
}
inline void DamageComponent::clear_rerolls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rerolls_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::RerollEvent* PROTOBUF_NONNULL DamageComponent::mutable_rerolls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageComponent.rerolls)
  return _internal_mutable_rerolls()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>* PROTOBUF_NONNULL DamageComponent::mutable_rerolls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DamageComponent.rerolls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_rerolls();
}
inline const ::dnd5e::api::v1alpha1::RerollEvent& DamageComponent::rerolls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.rerolls)
  return _internal_rerolls().Get(index);
}
inline ::dnd5e::api::v1alpha1::RerollEvent* PROTOBUF_NONNULL DamageComponent::add_rerolls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::RerollEvent* _add =
      _internal_mutable_rerolls()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DamageComponent.rerolls)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>& DamageComponent::rerolls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DamageComponent.rerolls)
  return _internal_rerolls();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>&
DamageComponent::_internal_rerolls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rerolls_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::RerollEvent>* PROTOBUF_NONNULL
DamageComponent::_internal_mutable_rerolls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.rerolls_;
}

// int32 flat_bonus = 5 [json_name = "flatBonus"];
inline void DamageComponent::clear_flat_bonus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flat_bonus_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::int32_t DamageComponent::flat_bonus() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.flat_bonus)
  return _internal_flat_bonus();
}
inline void DamageComponent::set_flat_bonus(::int32_t value) {
  _internal_set_flat_bonus(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.flat_bonus)
}
inline ::int32_t DamageComponent::_internal_flat_bonus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.flat_bonus_;
}
inline void DamageComponent::_internal_set_flat_bonus(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flat_bonus_ = value;
}

// string damage_type = 6 [json_name = "damageType"];
inline void DamageComponent::clear_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::std::string& DamageComponent::damage_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.damage_type)
  return _internal_damage_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DamageComponent::set_damage_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  _impl_.damage_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.damage_type)
}
inline ::std::string* PROTOBUF_NONNULL DamageComponent::mutable_damage_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::std::string* _s = _internal_mutable_damage_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageComponent.damage_type)
  return _s;
}
inline const ::std::string& DamageComponent::_internal_damage_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_type_.Get();
}
inline void DamageComponent::_internal_set_damage_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DamageComponent::_internal_mutable_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.damage_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DamageComponent::release_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DamageComponent.damage_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000010U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  auto* released = _impl_.damage_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  return released;
}
inline void DamageComponent::set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  _impl_.damage_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.damage_type_.IsDefault()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DamageComponent.damage_type)
}

// bool is_critical = 7 [json_name = "isCritical"];
inline void DamageComponent::clear_is_critical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_critical_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline bool DamageComponent::is_critical() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.is_critical)
  return _internal_is_critical();
}
inline void DamageComponent::set_is_critical(bool value) {
  _internal_set_is_critical(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.is_critical)
}
inline bool DamageComponent::_internal_is_critical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_critical_;
}
inline void DamageComponent::_internal_set_is_critical(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_critical_ = value;
}

// .dnd5e.api.v1alpha1.SourceRef source_ref = 8 [json_name = "sourceRef"];
inline bool DamageComponent::has_source_ref() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.source_ref_ != nullptr);
  return value;
}
inline const ::dnd5e::api::v1alpha1::SourceRef& DamageComponent::_internal_source_ref() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::SourceRef* p = _impl_.source_ref_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::SourceRef&>(::dnd5e::api::v1alpha1::_SourceRef_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::SourceRef& DamageComponent::source_ref() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.source_ref)
  return _internal_source_ref();
}
inline void DamageComponent::unsafe_arena_set_allocated_source_ref(
    ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_ref_);
  }
  _impl_.source_ref_ = reinterpret_cast<::dnd5e::api::v1alpha1::SourceRef*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.DamageComponent.source_ref)
}
inline ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE DamageComponent::release_source_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::SourceRef* released = _impl_.source_ref_;
  _impl_.source_ref_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE DamageComponent::unsafe_arena_release_source_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DamageComponent.source_ref)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::SourceRef* temp = _impl_.source_ref_;
  _impl_.source_ref_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NONNULL DamageComponent::_internal_mutable_source_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.source_ref_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::SourceRef>(GetArena());
    _impl_.source_ref_ = reinterpret_cast<::dnd5e::api::v1alpha1::SourceRef*>(p);
  }
  return _impl_.source_ref_;
}
inline ::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NONNULL DamageComponent::mutable_source_ref()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::SourceRef* _msg = _internal_mutable_source_ref();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageComponent.source_ref)
  return _msg;
}
inline void DamageComponent::set_allocated_source_ref(::dnd5e::api::v1alpha1::SourceRef* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_ref_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.source_ref_ = reinterpret_cast<::dnd5e::api::v1alpha1::SourceRef*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DamageComponent.source_ref)
}

// optional float multiplier = 9 [json_name = "multiplier"];
inline bool DamageComponent::has_multiplier() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  return value;
}
inline void DamageComponent::clear_multiplier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.multiplier_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline float DamageComponent::multiplier() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageComponent.multiplier)
  return _internal_multiplier();
}
inline void DamageComponent::set_multiplier(float value) {
  _internal_set_multiplier(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageComponent.multiplier)
}
inline float DamageComponent::_internal_multiplier() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.multiplier_;
}
inline void DamageComponent::_internal_set_multiplier(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.multiplier_ = value;
}

// -------------------------------------------------------------------

// DamageBreakdown

// repeated .dnd5e.api.v1alpha1.DamageComponent components = 1 [json_name = "components"];
inline int DamageBreakdown::_internal_components_size() const {
  return _internal_components().size();
}
inline int DamageBreakdown::components_size() const {
  return _internal_components_size();
}
inline void DamageBreakdown::clear_components() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.components_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::DamageComponent* PROTOBUF_NONNULL DamageBreakdown::mutable_components(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageBreakdown.components)
  return _internal_mutable_components()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>* PROTOBUF_NONNULL DamageBreakdown::mutable_components()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.DamageBreakdown.components)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_components();
}
inline const ::dnd5e::api::v1alpha1::DamageComponent& DamageBreakdown::components(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageBreakdown.components)
  return _internal_components().Get(index);
}
inline ::dnd5e::api::v1alpha1::DamageComponent* PROTOBUF_NONNULL DamageBreakdown::add_components()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::DamageComponent* _add =
      _internal_mutable_components()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.DamageBreakdown.components)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>& DamageBreakdown::components() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.DamageBreakdown.components)
  return _internal_components();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>&
DamageBreakdown::_internal_components() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.components_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DamageComponent>* PROTOBUF_NONNULL
DamageBreakdown::_internal_mutable_components() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.components_;
}

// string ability_used = 2 [json_name = "abilityUsed"];
inline void DamageBreakdown::clear_ability_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ability_used_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& DamageBreakdown::ability_used() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageBreakdown.ability_used)
  return _internal_ability_used();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DamageBreakdown::set_ability_used(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.ability_used_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageBreakdown.ability_used)
}
inline ::std::string* PROTOBUF_NONNULL DamageBreakdown::mutable_ability_used()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_ability_used();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DamageBreakdown.ability_used)
  return _s;
}
inline const ::std::string& DamageBreakdown::_internal_ability_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ability_used_.Get();
}
inline void DamageBreakdown::_internal_set_ability_used(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ability_used_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DamageBreakdown::_internal_mutable_ability_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ability_used_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DamageBreakdown::release_ability_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DamageBreakdown.ability_used)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.ability_used_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.ability_used_.Set("", GetArena());
  }
  return released;
}
inline void DamageBreakdown::set_allocated_ability_used(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.ability_used_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ability_used_.IsDefault()) {
    _impl_.ability_used_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DamageBreakdown.ability_used)
}

// int32 total_damage = 3 [json_name = "totalDamage"];
inline void DamageBreakdown::clear_total_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_damage_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t DamageBreakdown::total_damage() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DamageBreakdown.total_damage)
  return _internal_total_damage();
}
inline void DamageBreakdown::set_total_damage(::int32_t value) {
  _internal_set_total_damage(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DamageBreakdown.total_damage)
}
inline ::int32_t DamageBreakdown::_internal_total_damage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_damage_;
}
inline void DamageBreakdown::_internal_set_total_damage(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_damage_ = value;
}

// -------------------------------------------------------------------

// AttackResult

// bool hit = 1 [json_name = "hit"];
inline void AttackResult::clear_hit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hit_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool AttackResult::hit() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.hit)
  return _internal_hit();
}
inline void AttackResult::set_hit(bool value) {
  _internal_set_hit(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.hit)
}
inline bool AttackResult::_internal_hit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hit_;
}
inline void AttackResult::_internal_set_hit(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hit_ = value;
}

// int32 attack_roll = 2 [json_name = "attackRoll"];
inline void AttackResult::clear_attack_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_roll_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t AttackResult::attack_roll() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.attack_roll)
  return _internal_attack_roll();
}
inline void AttackResult::set_attack_roll(::int32_t value) {
  _internal_set_attack_roll(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.attack_roll)
}
inline ::int32_t AttackResult::_internal_attack_roll() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attack_roll_;
}
inline void AttackResult::_internal_set_attack_roll(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_roll_ = value;
}

// int32 attack_total = 3 [json_name = "attackTotal"];
inline void AttackResult::clear_attack_total() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_total_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t AttackResult::attack_total() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.attack_total)
  return _internal_attack_total();
}
inline void AttackResult::set_attack_total(::int32_t value) {
  _internal_set_attack_total(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.attack_total)
}
inline ::int32_t AttackResult::_internal_attack_total() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attack_total_;
}
inline void AttackResult::_internal_set_attack_total(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attack_total_ = value;
}

// int32 target_ac = 4 [json_name = "targetAc"];
inline void AttackResult::clear_target_ac() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ac_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int32_t AttackResult::target_ac() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.target_ac)
  return _internal_target_ac();
}
inline void AttackResult::set_target_ac(::int32_t value) {
  _internal_set_target_ac(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.target_ac)
}
inline ::int32_t AttackResult::_internal_target_ac() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_ac_;
}
inline void AttackResult::_internal_set_target_ac(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ac_ = value;
}

// int32 damage = 5 [json_name = "damage"];
inline void AttackResult::clear_damage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline ::int32_t AttackResult::damage() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.damage)
  return _internal_damage();
}
inline void AttackResult::set_damage(::int32_t value) {
  _internal_set_damage(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.damage)
}
inline ::int32_t AttackResult::_internal_damage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_;
}
inline void AttackResult::_internal_set_damage(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_ = value;
}

// string damage_type = 6 [json_name = "damageType"];
inline void AttackResult::clear_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& AttackResult::damage_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.damage_type)
  return _internal_damage_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackResult::set_damage_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.damage_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.damage_type)
}
inline ::std::string* PROTOBUF_NONNULL AttackResult::mutable_damage_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_damage_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResult.damage_type)
  return _s;
}
inline const ::std::string& AttackResult::_internal_damage_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.damage_type_.Get();
}
inline void AttackResult::_internal_set_damage_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.damage_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackResult::_internal_mutable_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.damage_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackResult::release_damage_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResult.damage_type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.damage_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  return released;
}
inline void AttackResult::set_allocated_damage_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.damage_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.damage_type_.IsDefault()) {
    _impl_.damage_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResult.damage_type)
}

// bool critical = 7 [json_name = "critical"];
inline void AttackResult::clear_critical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline bool AttackResult::critical() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.critical)
  return _internal_critical();
}
inline void AttackResult::set_critical(bool value) {
  _internal_set_critical(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResult.critical)
}
inline bool AttackResult::_internal_critical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.critical_;
}
inline void AttackResult::_internal_set_critical(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_ = value;
}

// .dnd5e.api.v1alpha1.DamageBreakdown damage_breakdown = 8 [json_name = "damageBreakdown"];
inline bool AttackResult::has_damage_breakdown() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.damage_breakdown_ != nullptr);
  return value;
}
inline void AttackResult::clear_damage_breakdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.damage_breakdown_ != nullptr) _impl_.damage_breakdown_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::DamageBreakdown& AttackResult::_internal_damage_breakdown() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::DamageBreakdown* p = _impl_.damage_breakdown_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::DamageBreakdown&>(::dnd5e::api::v1alpha1::_DamageBreakdown_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::DamageBreakdown& AttackResult::damage_breakdown() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResult.damage_breakdown)
  return _internal_damage_breakdown();
}
inline void AttackResult::unsafe_arena_set_allocated_damage_breakdown(
    ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.damage_breakdown_);
  }
  _impl_.damage_breakdown_ = reinterpret_cast<::dnd5e::api::v1alpha1::DamageBreakdown*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResult.damage_breakdown)
}
inline ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE AttackResult::release_damage_breakdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::DamageBreakdown* released = _impl_.damage_breakdown_;
  _impl_.damage_breakdown_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE AttackResult::unsafe_arena_release_damage_breakdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResult.damage_breakdown)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::DamageBreakdown* temp = _impl_.damage_breakdown_;
  _impl_.damage_breakdown_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NONNULL AttackResult::_internal_mutable_damage_breakdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.damage_breakdown_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::DamageBreakdown>(GetArena());
    _impl_.damage_breakdown_ = reinterpret_cast<::dnd5e::api::v1alpha1::DamageBreakdown*>(p);
  }
  return _impl_.damage_breakdown_;
}
inline ::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NONNULL AttackResult::mutable_damage_breakdown()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::DamageBreakdown* _msg = _internal_mutable_damage_breakdown();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResult.damage_breakdown)
  return _msg;
}
inline void AttackResult::set_allocated_damage_breakdown(::dnd5e::api::v1alpha1::DamageBreakdown* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.damage_breakdown_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.damage_breakdown_ = reinterpret_cast<::dnd5e::api::v1alpha1::DamageBreakdown*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResult.damage_breakdown)
}

// -------------------------------------------------------------------

// GrantedAction

// string id = 1 [json_name = "id"];
inline void GrantedAction::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& GrantedAction::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GrantedAction.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GrantedAction::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GrantedAction.id)
}
inline ::std::string* PROTOBUF_NONNULL GrantedAction::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GrantedAction.id)
  return _s;
}
inline const ::std::string& GrantedAction::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void GrantedAction::_internal_set_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GrantedAction::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GrantedAction::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GrantedAction.id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void GrantedAction::set_allocated_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GrantedAction.id)
}

// string type = 2 [json_name = "type"];
inline void GrantedAction::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& GrantedAction::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GrantedAction.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GrantedAction::set_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GrantedAction.type)
}
inline ::std::string* PROTOBUF_NONNULL GrantedAction::mutable_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GrantedAction.type)
  return _s;
}
inline const ::std::string& GrantedAction::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void GrantedAction::_internal_set_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GrantedAction::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GrantedAction::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GrantedAction.type)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.type_.Set("", GetArena());
  }
  return released;
}
inline void GrantedAction::set_allocated_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GrantedAction.type)
}

// string name = 3 [json_name = "name"];
inline void GrantedAction::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& GrantedAction::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GrantedAction.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GrantedAction::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GrantedAction.name)
}
inline ::std::string* PROTOBUF_NONNULL GrantedAction::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GrantedAction.name)
  return _s;
}
inline const ::std::string& GrantedAction::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void GrantedAction::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GrantedAction::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GrantedAction::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GrantedAction.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void GrantedAction::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GrantedAction.name)
}

// string reason = 4 [json_name = "reason"];
inline void GrantedAction::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& GrantedAction::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GrantedAction.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GrantedAction::set_reason(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GrantedAction.reason)
}
inline ::std::string* PROTOBUF_NONNULL GrantedAction::mutable_reason()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GrantedAction.reason)
  return _s;
}
inline const ::std::string& GrantedAction::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void GrantedAction::_internal_set_reason(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GrantedAction::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GrantedAction::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GrantedAction.reason)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.reason_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reason_.Set("", GetArena());
  }
  return released;
}
inline void GrantedAction::set_allocated_reason(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GrantedAction.reason)
}

// string weapon_id = 5 [json_name = "weaponId"];
inline void GrantedAction::clear_weapon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapon_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::std::string& GrantedAction::weapon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.GrantedAction.weapon_id)
  return _internal_weapon_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GrantedAction::set_weapon_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  _impl_.weapon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.GrantedAction.weapon_id)
}
inline ::std::string* PROTOBUF_NONNULL GrantedAction::mutable_weapon_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::std::string* _s = _internal_mutable_weapon_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.GrantedAction.weapon_id)
  return _s;
}
inline const ::std::string& GrantedAction::_internal_weapon_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.weapon_id_.Get();
}
inline void GrantedAction::_internal_set_weapon_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapon_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL GrantedAction::_internal_mutable_weapon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.weapon_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE GrantedAction::release_weapon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.GrantedAction.weapon_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000010U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  auto* released = _impl_.weapon_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.weapon_id_.Set("", GetArena());
  }
  return released;
}
inline void GrantedAction::set_allocated_weapon_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  _impl_.weapon_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.weapon_id_.IsDefault()) {
    _impl_.weapon_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.GrantedAction.weapon_id)
}

// -------------------------------------------------------------------

// AttackResponse

// bool success = 1 [json_name = "success"];
inline void AttackResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline bool AttackResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.success)
  return _internal_success();
}
inline void AttackResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResponse.success)
}
inline bool AttackResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void AttackResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string error = 2 [json_name = "error"];
inline void AttackResponse::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& AttackResponse::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackResponse::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResponse.error)
}
inline ::std::string* PROTOBUF_NONNULL AttackResponse::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.error)
  return _s;
}
inline const ::std::string& AttackResponse::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void AttackResponse::_internal_set_error(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackResponse::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackResponse::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.error)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void AttackResponse::set_allocated_error(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.error)
}

// .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
inline bool AttackResponse::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void AttackResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::AttackResult& AttackResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::AttackResult* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::AttackResult&>(::dnd5e::api::v1alpha1::_AttackResult_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AttackResult& AttackResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.result)
  return _internal_result();
}
inline void AttackResponse::unsafe_arena_set_allocated_result(
    ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResult*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResponse.result)
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE AttackResponse::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::AttackResult* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE AttackResponse::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::AttackResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL AttackResponse::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AttackResult>(GetArena());
    _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResult*>(p);
  }
  return _impl_.result_;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL AttackResponse::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::AttackResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.result)
  return _msg;
}
inline void AttackResponse::set_allocated_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.result)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
inline bool AttackResponse::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void AttackResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& AttackResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& AttackResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.combat_state)
  return _internal_combat_state();
}
inline void AttackResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE AttackResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE AttackResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL AttackResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL AttackResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.combat_state)
  return _msg;
}
inline void AttackResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.combat_state)
}

// .dnd5e.api.v1alpha1.Room updated_room = 5 [json_name = "updatedRoom"];
inline bool AttackResponse::has_updated_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.updated_room_ != nullptr);
  return value;
}
inline void AttackResponse::clear_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ != nullptr) _impl_.updated_room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::dnd5e::api::v1alpha1::Room& AttackResponse::_internal_updated_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.updated_room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& AttackResponse::updated_room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.updated_room)
  return _internal_updated_room();
}
inline void AttackResponse::unsafe_arena_set_allocated_updated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }
  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResponse.updated_room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE AttackResponse::release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE AttackResponse::unsafe_arena_release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.updated_room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL AttackResponse::_internal_mutable_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.updated_room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL AttackResponse::mutable_updated_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_updated_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.updated_room)
  return _msg;
}
inline void AttackResponse::set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.updated_room)
}

// .dnd5e.api.v1alpha1.GrantedAction granted_action = 6 [json_name = "grantedAction"];
inline bool AttackResponse::has_granted_action() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.granted_action_ != nullptr);
  return value;
}
inline void AttackResponse::clear_granted_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.granted_action_ != nullptr) _impl_.granted_action_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::dnd5e::api::v1alpha1::GrantedAction& AttackResponse::_internal_granted_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::GrantedAction* p = _impl_.granted_action_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::GrantedAction&>(::dnd5e::api::v1alpha1::_GrantedAction_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::GrantedAction& AttackResponse::granted_action() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResponse.granted_action)
  return _internal_granted_action();
}
inline void AttackResponse::unsafe_arena_set_allocated_granted_action(
    ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.granted_action_);
  }
  _impl_.granted_action_ = reinterpret_cast<::dnd5e::api::v1alpha1::GrantedAction*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResponse.granted_action)
}
inline ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE AttackResponse::release_granted_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::GrantedAction* released = _impl_.granted_action_;
  _impl_.granted_action_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE AttackResponse::unsafe_arena_release_granted_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResponse.granted_action)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::GrantedAction* temp = _impl_.granted_action_;
  _impl_.granted_action_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NONNULL AttackResponse::_internal_mutable_granted_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.granted_action_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::GrantedAction>(GetArena());
    _impl_.granted_action_ = reinterpret_cast<::dnd5e::api::v1alpha1::GrantedAction*>(p);
  }
  return _impl_.granted_action_;
}
inline ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NONNULL AttackResponse::mutable_granted_action()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::GrantedAction* _msg = _internal_mutable_granted_action();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResponse.granted_action)
  return _msg;
}
inline void AttackResponse::set_allocated_granted_action(::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.granted_action_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.granted_action_ = reinterpret_cast<::dnd5e::api::v1alpha1::GrantedAction*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResponse.granted_action)
}

// -------------------------------------------------------------------

// EncounterResult

// .dnd5e.api.v1alpha1.EncounterEndReason reason = 1 [json_name = "reason"];
inline void EncounterResult::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::EncounterEndReason EncounterResult::reason() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterResult.reason)
  return _internal_reason();
}
inline void EncounterResult::set_reason(::dnd5e::api::v1alpha1::EncounterEndReason value) {
  _internal_set_reason(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EncounterResult.reason)
}
inline ::dnd5e::api::v1alpha1::EncounterEndReason EncounterResult::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::EncounterEndReason>(_impl_.reason_);
}
inline void EncounterResult::_internal_set_reason(::dnd5e::api::v1alpha1::EncounterEndReason value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_ = value;
}

// -------------------------------------------------------------------

// HealResult

// int32 amount_healed = 1 [json_name = "amountHealed"];
inline void HealResult::clear_amount_healed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.amount_healed_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t HealResult::amount_healed() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.HealResult.amount_healed)
  return _internal_amount_healed();
}
inline void HealResult::set_amount_healed(::int32_t value) {
  _internal_set_amount_healed(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.HealResult.amount_healed)
}
inline ::int32_t HealResult::_internal_amount_healed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.amount_healed_;
}
inline void HealResult::_internal_set_amount_healed(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.amount_healed_ = value;
}

// int32 new_hp = 2 [json_name = "newHp"];
inline void HealResult::clear_new_hp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_hp_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t HealResult::new_hp() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.HealResult.new_hp)
  return _internal_new_hp();
}
inline void HealResult::set_new_hp(::int32_t value) {
  _internal_set_new_hp(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.HealResult.new_hp)
}
inline ::int32_t HealResult::_internal_new_hp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_hp_;
}
inline void HealResult::_internal_set_new_hp(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_hp_ = value;
}

// int32 max_hp = 3 [json_name = "maxHp"];
inline void HealResult::clear_max_hp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_hp_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t HealResult::max_hp() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.HealResult.max_hp)
  return _internal_max_hp();
}
inline void HealResult::set_max_hp(::int32_t value) {
  _internal_set_max_hp(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.HealResult.max_hp)
}
inline ::int32_t HealResult::_internal_max_hp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_hp_;
}
inline void HealResult::_internal_set_max_hp(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_hp_ = value;
}

// -------------------------------------------------------------------

// MonsterExecutedAction

// string action_id = 1 [json_name = "actionId"];
inline void MonsterExecutedAction::clear_action_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& MonsterExecutedAction::action_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterExecutedAction.action_id)
  return _internal_action_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MonsterExecutedAction::set_action_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.action_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MonsterExecutedAction.action_id)
}
inline ::std::string* PROTOBUF_NONNULL MonsterExecutedAction::mutable_action_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_action_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterExecutedAction.action_id)
  return _s;
}
inline const ::std::string& MonsterExecutedAction::_internal_action_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_id_.Get();
}
inline void MonsterExecutedAction::_internal_set_action_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MonsterExecutedAction::_internal_mutable_action_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.action_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MonsterExecutedAction::release_action_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MonsterExecutedAction.action_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.action_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.action_id_.Set("", GetArena());
  }
  return released;
}
inline void MonsterExecutedAction::set_allocated_action_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.action_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.action_id_.IsDefault()) {
    _impl_.action_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MonsterExecutedAction.action_id)
}

// .dnd5e.api.v1alpha1.MonsterActionType action_type = 2 [json_name = "actionType"];
inline void MonsterExecutedAction::clear_action_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::MonsterActionType MonsterExecutedAction::action_type() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterExecutedAction.action_type)
  return _internal_action_type();
}
inline void MonsterExecutedAction::set_action_type(::dnd5e::api::v1alpha1::MonsterActionType value) {
  _internal_set_action_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MonsterExecutedAction.action_type)
}
inline ::dnd5e::api::v1alpha1::MonsterActionType MonsterExecutedAction::_internal_action_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::MonsterActionType>(_impl_.action_type_);
}
inline void MonsterExecutedAction::_internal_set_action_type(::dnd5e::api::v1alpha1::MonsterActionType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_type_ = value;
}

// string target_id = 3 [json_name = "targetId"];
inline void MonsterExecutedAction::clear_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& MonsterExecutedAction::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterExecutedAction.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MonsterExecutedAction::set_target_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MonsterExecutedAction.target_id)
}
inline ::std::string* PROTOBUF_NONNULL MonsterExecutedAction::mutable_target_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterExecutedAction.target_id)
  return _s;
}
inline const ::std::string& MonsterExecutedAction::_internal_target_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_id_.Get();
}
inline void MonsterExecutedAction::_internal_set_target_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MonsterExecutedAction::_internal_mutable_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MonsterExecutedAction::release_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MonsterExecutedAction.target_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.target_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.target_id_.Set("", GetArena());
  }
  return released;
}
inline void MonsterExecutedAction::set_allocated_target_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.target_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_id_.IsDefault()) {
    _impl_.target_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MonsterExecutedAction.target_id)
}

// bool success = 4 [json_name = "success"];
inline void MonsterExecutedAction::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool MonsterExecutedAction::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterExecutedAction.success)
  return _internal_success();
}
inline void MonsterExecutedAction::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MonsterExecutedAction.success)
}
inline bool MonsterExecutedAction::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void MonsterExecutedAction::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// .dnd5e.api.v1alpha1.AttackResult attack_result = 5 [json_name = "attackResult"];
inline bool MonsterExecutedAction::has_attack_result() const {
  return details_case() == kAttackResult;
}
inline bool MonsterExecutedAction::_internal_has_attack_result() const {
  return details_case() == kAttackResult;
}
inline void MonsterExecutedAction::set_has_attack_result() {
  _impl_._oneof_case_[0] = kAttackResult;
}
inline void MonsterExecutedAction::clear_attack_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (details_case() == kAttackResult) {
    if (GetArena() == nullptr) {
      delete _impl_.details_.attack_result_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.details_.attack_result_);
    }
    clear_has_details();
  }
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE MonsterExecutedAction::release_attack_result() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MonsterExecutedAction.attack_result)
  if (details_case() == kAttackResult) {
    clear_has_details();
    auto* temp = _impl_.details_.attack_result_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.details_.attack_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::AttackResult& MonsterExecutedAction::_internal_attack_result() const {
  return details_case() == kAttackResult ? static_cast<const ::dnd5e::api::v1alpha1::AttackResult&>(*_impl_.details_.attack_result_)
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::AttackResult&>(::dnd5e::api::v1alpha1::_AttackResult_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AttackResult& MonsterExecutedAction::attack_result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterExecutedAction.attack_result)
  return _internal_attack_result();
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE MonsterExecutedAction::unsafe_arena_release_attack_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.MonsterExecutedAction.attack_result)
  if (details_case() == kAttackResult) {
    clear_has_details();
    auto* temp = _impl_.details_.attack_result_;
    _impl_.details_.attack_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MonsterExecutedAction::unsafe_arena_set_allocated_attack_result(
    ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_details();
  if (value) {
    set_has_attack_result();
    _impl_.details_.attack_result_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MonsterExecutedAction.attack_result)
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL MonsterExecutedAction::_internal_mutable_attack_result() {
  if (details_case() != kAttackResult) {
    clear_details();
    set_has_attack_result();
    _impl_.details_.attack_result_ = 
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AttackResult>(GetArena());
  }
  return _impl_.details_.attack_result_;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL MonsterExecutedAction::mutable_attack_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::AttackResult* _msg = _internal_mutable_attack_result();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterExecutedAction.attack_result)
  return _msg;
}

// .dnd5e.api.v1alpha1.HealResult heal_result = 6 [json_name = "healResult"];
inline bool MonsterExecutedAction::has_heal_result() const {
  return details_case() == kHealResult;
}
inline bool MonsterExecutedAction::_internal_has_heal_result() const {
  return details_case() == kHealResult;
}
inline void MonsterExecutedAction::set_has_heal_result() {
  _impl_._oneof_case_[0] = kHealResult;
}
inline void MonsterExecutedAction::clear_heal_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (details_case() == kHealResult) {
    if (GetArena() == nullptr) {
      delete _impl_.details_.heal_result_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.details_.heal_result_);
    }
    clear_has_details();
  }
}
inline ::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NULLABLE MonsterExecutedAction::release_heal_result() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MonsterExecutedAction.heal_result)
  if (details_case() == kHealResult) {
    clear_has_details();
    auto* temp = _impl_.details_.heal_result_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.details_.heal_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::HealResult& MonsterExecutedAction::_internal_heal_result() const {
  return details_case() == kHealResult ? static_cast<const ::dnd5e::api::v1alpha1::HealResult&>(*_impl_.details_.heal_result_)
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::HealResult&>(::dnd5e::api::v1alpha1::_HealResult_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::HealResult& MonsterExecutedAction::heal_result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterExecutedAction.heal_result)
  return _internal_heal_result();
}
inline ::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NULLABLE MonsterExecutedAction::unsafe_arena_release_heal_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.MonsterExecutedAction.heal_result)
  if (details_case() == kHealResult) {
    clear_has_details();
    auto* temp = _impl_.details_.heal_result_;
    _impl_.details_.heal_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MonsterExecutedAction::unsafe_arena_set_allocated_heal_result(
    ::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_details();
  if (value) {
    set_has_heal_result();
    _impl_.details_.heal_result_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MonsterExecutedAction.heal_result)
}
inline ::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NONNULL MonsterExecutedAction::_internal_mutable_heal_result() {
  if (details_case() != kHealResult) {
    clear_details();
    set_has_heal_result();
    _impl_.details_.heal_result_ = 
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::HealResult>(GetArena());
  }
  return _impl_.details_.heal_result_;
}
inline ::dnd5e::api::v1alpha1::HealResult* PROTOBUF_NONNULL MonsterExecutedAction::mutable_heal_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::HealResult* _msg = _internal_mutable_heal_result();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterExecutedAction.heal_result)
  return _msg;
}

inline bool MonsterExecutedAction::has_details() const {
  return details_case() != DETAILS_NOT_SET;
}
inline void MonsterExecutedAction::clear_has_details() {
  _impl_._oneof_case_[0] = DETAILS_NOT_SET;
}
inline MonsterExecutedAction::DetailsCase MonsterExecutedAction::details_case() const {
  return MonsterExecutedAction::DetailsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MonsterTurnResult

// string monster_id = 1 [json_name = "monsterId"];
inline void MonsterTurnResult::clear_monster_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& MonsterTurnResult::monster_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterTurnResult.monster_id)
  return _internal_monster_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MonsterTurnResult::set_monster_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.monster_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MonsterTurnResult.monster_id)
}
inline ::std::string* PROTOBUF_NONNULL MonsterTurnResult::mutable_monster_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_monster_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterTurnResult.monster_id)
  return _s;
}
inline const ::std::string& MonsterTurnResult::_internal_monster_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monster_id_.Get();
}
inline void MonsterTurnResult::_internal_set_monster_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MonsterTurnResult::_internal_mutable_monster_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.monster_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MonsterTurnResult::release_monster_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MonsterTurnResult.monster_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.monster_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.monster_id_.Set("", GetArena());
  }
  return released;
}
inline void MonsterTurnResult::set_allocated_monster_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.monster_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.monster_id_.IsDefault()) {
    _impl_.monster_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MonsterTurnResult.monster_id)
}

// string monster_name = 2 [json_name = "monsterName"];
inline void MonsterTurnResult::clear_monster_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::std::string& MonsterTurnResult::monster_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterTurnResult.monster_name)
  return _internal_monster_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MonsterTurnResult::set_monster_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  _impl_.monster_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MonsterTurnResult.monster_name)
}
inline ::std::string* PROTOBUF_NONNULL MonsterTurnResult::mutable_monster_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::std::string* _s = _internal_mutable_monster_name();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterTurnResult.monster_name)
  return _s;
}
inline const ::std::string& MonsterTurnResult::_internal_monster_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monster_name_.Get();
}
inline void MonsterTurnResult::_internal_set_monster_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MonsterTurnResult::_internal_mutable_monster_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.monster_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MonsterTurnResult::release_monster_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MonsterTurnResult.monster_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000008U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  auto* released = _impl_.monster_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.monster_name_.Set("", GetArena());
  }
  return released;
}
inline void MonsterTurnResult::set_allocated_monster_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  _impl_.monster_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.monster_name_.IsDefault()) {
    _impl_.monster_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MonsterTurnResult.monster_name)
}

// repeated .dnd5e.api.v1alpha1.MonsterExecutedAction actions = 3 [json_name = "actions"];
inline int MonsterTurnResult::_internal_actions_size() const {
  return _internal_actions().size();
}
inline int MonsterTurnResult::actions_size() const {
  return _internal_actions_size();
}
inline void MonsterTurnResult::clear_actions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actions_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::MonsterExecutedAction* PROTOBUF_NONNULL MonsterTurnResult::mutable_actions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterTurnResult.actions)
  return _internal_mutable_actions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterExecutedAction>* PROTOBUF_NONNULL MonsterTurnResult::mutable_actions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.MonsterTurnResult.actions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_actions();
}
inline const ::dnd5e::api::v1alpha1::MonsterExecutedAction& MonsterTurnResult::actions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterTurnResult.actions)
  return _internal_actions().Get(index);
}
inline ::dnd5e::api::v1alpha1::MonsterExecutedAction* PROTOBUF_NONNULL MonsterTurnResult::add_actions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::MonsterExecutedAction* _add =
      _internal_mutable_actions()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.MonsterTurnResult.actions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterExecutedAction>& MonsterTurnResult::actions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.MonsterTurnResult.actions)
  return _internal_actions();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterExecutedAction>&
MonsterTurnResult::_internal_actions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actions_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterExecutedAction>* PROTOBUF_NONNULL
MonsterTurnResult::_internal_mutable_actions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.actions_;
}

// repeated .api.v1alpha1.Position movement_path = 4 [json_name = "movementPath"];
inline int MonsterTurnResult::_internal_movement_path_size() const {
  return _internal_movement_path().size();
}
inline int MonsterTurnResult::movement_path_size() const {
  return _internal_movement_path_size();
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MonsterTurnResult::mutable_movement_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterTurnResult.movement_path)
  return _internal_mutable_movement_path()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL MonsterTurnResult::mutable_movement_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.MonsterTurnResult.movement_path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_movement_path();
}
inline const ::api::v1alpha1::Position& MonsterTurnResult::movement_path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterTurnResult.movement_path)
  return _internal_movement_path().Get(index);
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MonsterTurnResult::add_movement_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::api::v1alpha1::Position* _add =
      _internal_mutable_movement_path()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.MonsterTurnResult.movement_path)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>& MonsterTurnResult::movement_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.MonsterTurnResult.movement_path)
  return _internal_movement_path();
}
inline const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>&
MonsterTurnResult::_internal_movement_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movement_path_;
}
inline ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL
MonsterTurnResult::_internal_mutable_movement_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.movement_path_;
}

// -------------------------------------------------------------------

// ActivateFeatureRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void ActivateFeatureRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ActivateFeatureRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActivateFeatureRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ActivateFeatureRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ActivateFeatureRequest.encounter_id)
  return _s;
}
inline const ::std::string& ActivateFeatureRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void ActivateFeatureRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ActivateFeatureRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ActivateFeatureRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void ActivateFeatureRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureRequest.encounter_id)
}

// string character_id = 2 [json_name = "characterId"];
inline void ActivateFeatureRequest::clear_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& ActivateFeatureRequest::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActivateFeatureRequest::set_character_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ActivateFeatureRequest.character_id)
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureRequest::mutable_character_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ActivateFeatureRequest.character_id)
  return _s;
}
inline const ::std::string& ActivateFeatureRequest::_internal_character_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_id_.Get();
}
inline void ActivateFeatureRequest::_internal_set_character_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureRequest::_internal_mutable_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.character_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ActivateFeatureRequest::release_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ActivateFeatureRequest.character_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.character_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.character_id_.Set("", GetArena());
  }
  return released;
}
inline void ActivateFeatureRequest::set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.character_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureRequest.character_id)
}

// .dnd5e.api.v1alpha1.FeatureId feature_id = 3 [json_name = "featureId"];
inline void ActivateFeatureRequest::clear_feature_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_id_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::FeatureId ActivateFeatureRequest::feature_id() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureRequest.feature_id)
  return _internal_feature_id();
}
inline void ActivateFeatureRequest::set_feature_id(::dnd5e::api::v1alpha1::FeatureId value) {
  _internal_set_feature_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ActivateFeatureRequest.feature_id)
}
inline ::dnd5e::api::v1alpha1::FeatureId ActivateFeatureRequest::_internal_feature_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::FeatureId>(_impl_.feature_id_);
}
inline void ActivateFeatureRequest::_internal_set_feature_id(::dnd5e::api::v1alpha1::FeatureId value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_id_ = value;
}

// -------------------------------------------------------------------

// ActivateFeatureResponse

// bool success = 1 [json_name = "success"];
inline void ActivateFeatureResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool ActivateFeatureResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureResponse.success)
  return _internal_success();
}
inline void ActivateFeatureResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ActivateFeatureResponse.success)
}
inline bool ActivateFeatureResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ActivateFeatureResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string message = 2 [json_name = "message"];
inline void ActivateFeatureResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ActivateFeatureResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActivateFeatureResponse::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.ActivateFeatureResponse.message)
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureResponse::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ActivateFeatureResponse.message)
  return _s;
}
inline const ::std::string& ActivateFeatureResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void ActivateFeatureResponse::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ActivateFeatureResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ActivateFeatureResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ActivateFeatureResponse.message)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void ActivateFeatureResponse::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureResponse.message)
}

// .dnd5e.api.v1alpha1.Character updated_character = 3 [json_name = "updatedCharacter"];
inline bool ActivateFeatureResponse::has_updated_character() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.updated_character_ != nullptr);
  return value;
}
inline const ::dnd5e::api::v1alpha1::Character& ActivateFeatureResponse::_internal_updated_character() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.updated_character_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& ActivateFeatureResponse::updated_character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_character)
  return _internal_updated_character();
}
inline void ActivateFeatureResponse::unsafe_arena_set_allocated_updated_character(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_character_);
  }
  _impl_.updated_character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_character)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE ActivateFeatureResponse::release_updated_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::Character* released = _impl_.updated_character_;
  _impl_.updated_character_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE ActivateFeatureResponse::unsafe_arena_release_updated_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_character)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.updated_character_;
  _impl_.updated_character_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL ActivateFeatureResponse::_internal_mutable_updated_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_character_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.updated_character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.updated_character_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL ActivateFeatureResponse::mutable_updated_character()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_updated_character();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_character)
  return _msg;
}
inline void ActivateFeatureResponse::set_allocated_updated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.updated_character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_character)
}

// .dnd5e.api.v1alpha1.CombatState updated_combat_state = 4 [json_name = "updatedCombatState"];
inline bool ActivateFeatureResponse::has_updated_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.updated_combat_state_ != nullptr);
  return value;
}
inline void ActivateFeatureResponse::clear_updated_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_combat_state_ != nullptr) _impl_.updated_combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& ActivateFeatureResponse::_internal_updated_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.updated_combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& ActivateFeatureResponse::updated_combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_combat_state)
  return _internal_updated_combat_state();
}
inline void ActivateFeatureResponse::unsafe_arena_set_allocated_updated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_combat_state_);
  }
  _impl_.updated_combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE ActivateFeatureResponse::release_updated_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.updated_combat_state_;
  _impl_.updated_combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE ActivateFeatureResponse::unsafe_arena_release_updated_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.updated_combat_state_;
  _impl_.updated_combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL ActivateFeatureResponse::_internal_mutable_updated_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.updated_combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.updated_combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL ActivateFeatureResponse::mutable_updated_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_updated_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_combat_state)
  return _msg;
}
inline void ActivateFeatureResponse::set_allocated_updated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.updated_combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.ActivateFeatureResponse.updated_combat_state)
}

// -------------------------------------------------------------------

// PartyMember

// string player_id = 1 [json_name = "playerId"];
inline void PartyMember::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PartyMember::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PartyMember.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PartyMember::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.PartyMember.player_id)
}
inline ::std::string* PROTOBUF_NONNULL PartyMember::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.PartyMember.player_id)
  return _s;
}
inline const ::std::string& PartyMember::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void PartyMember::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PartyMember::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PartyMember::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.PartyMember.player_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void PartyMember::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.PartyMember.player_id)
}

// .dnd5e.api.v1alpha1.Character character = 2 [json_name = "character"];
inline bool PartyMember::has_character() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.character_ != nullptr);
  return value;
}
inline const ::dnd5e::api::v1alpha1::Character& PartyMember::_internal_character() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.character_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& PartyMember::character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PartyMember.character)
  return _internal_character();
}
inline void PartyMember::unsafe_arena_set_allocated_character(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }
  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.PartyMember.character)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE PartyMember::release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::Character* released = _impl_.character_;
  _impl_.character_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE PartyMember::unsafe_arena_release_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.PartyMember.character)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.character_;
  _impl_.character_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL PartyMember::_internal_mutable_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.character_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.character_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL PartyMember::mutable_character()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.PartyMember.character)
  return _msg;
}
inline void PartyMember::set_allocated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.PartyMember.character)
}

// bool is_host = 3 [json_name = "isHost"];
inline void PartyMember::clear_is_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_host_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool PartyMember::is_host() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PartyMember.is_host)
  return _internal_is_host();
}
inline void PartyMember::set_is_host(bool value) {
  _internal_set_is_host(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.PartyMember.is_host)
}
inline bool PartyMember::_internal_is_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_host_;
}
inline void PartyMember::_internal_set_is_host(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_host_ = value;
}

// bool is_ready = 4 [json_name = "isReady"];
inline void PartyMember::clear_is_ready() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ready_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool PartyMember::is_ready() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PartyMember.is_ready)
  return _internal_is_ready();
}
inline void PartyMember::set_is_ready(bool value) {
  _internal_set_is_ready(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.PartyMember.is_ready)
}
inline bool PartyMember::_internal_is_ready() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_ready_;
}
inline void PartyMember::_internal_set_is_ready(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ready_ = value;
}

// bool is_connected = 5 [json_name = "isConnected"];
inline void PartyMember::clear_is_connected() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_connected_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline bool PartyMember::is_connected() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PartyMember.is_connected)
  return _internal_is_connected();
}
inline void PartyMember::set_is_connected(bool value) {
  _internal_set_is_connected(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.PartyMember.is_connected)
}
inline bool PartyMember::_internal_is_connected() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_connected_;
}
inline void PartyMember::_internal_set_is_connected(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_connected_ = value;
}

// -------------------------------------------------------------------

// CreateEncounterRequest

// repeated string character_ids = 1 [json_name = "characterIds"];
inline int CreateEncounterRequest::_internal_character_ids_size() const {
  return _internal_character_ids().size();
}
inline int CreateEncounterRequest::character_ids_size() const {
  return _internal_character_ids_size();
}
inline void CreateEncounterRequest::clear_character_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_ids_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL CreateEncounterRequest::add_character_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_character_ids()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.CreateEncounterRequest.character_ids)
  return _s;
}
inline const ::std::string& CreateEncounterRequest::character_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreateEncounterRequest.character_ids)
  return _internal_character_ids().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL CreateEncounterRequest::mutable_character_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CreateEncounterRequest.character_ids)
  return _internal_mutable_character_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void CreateEncounterRequest::set_character_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_character_ids()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreateEncounterRequest.character_ids)
}
template <typename Arg_, typename... Args_>
inline void CreateEncounterRequest::add_character_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_character_ids(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.CreateEncounterRequest.character_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& CreateEncounterRequest::character_ids()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.CreateEncounterRequest.character_ids)
  return _internal_character_ids();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
CreateEncounterRequest::mutable_character_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.CreateEncounterRequest.character_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_character_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
CreateEncounterRequest::_internal_character_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
CreateEncounterRequest::_internal_mutable_character_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.character_ids_;
}

// -------------------------------------------------------------------

// CreateEncounterResponse

// string encounter_id = 1 [json_name = "encounterId"];
inline void CreateEncounterResponse::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CreateEncounterResponse::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreateEncounterResponse.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateEncounterResponse::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreateEncounterResponse.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL CreateEncounterResponse::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CreateEncounterResponse.encounter_id)
  return _s;
}
inline const ::std::string& CreateEncounterResponse::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void CreateEncounterResponse::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CreateEncounterResponse::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CreateEncounterResponse::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CreateEncounterResponse.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void CreateEncounterResponse::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CreateEncounterResponse.encounter_id)
}

// string join_code = 2 [json_name = "joinCode"];
inline void CreateEncounterResponse::clear_join_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.join_code_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& CreateEncounterResponse::join_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreateEncounterResponse.join_code)
  return _internal_join_code();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateEncounterResponse::set_join_code(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.join_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CreateEncounterResponse.join_code)
}
inline ::std::string* PROTOBUF_NONNULL CreateEncounterResponse::mutable_join_code()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_join_code();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CreateEncounterResponse.join_code)
  return _s;
}
inline const ::std::string& CreateEncounterResponse::_internal_join_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.join_code_.Get();
}
inline void CreateEncounterResponse::_internal_set_join_code(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.join_code_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CreateEncounterResponse::_internal_mutable_join_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.join_code_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CreateEncounterResponse::release_join_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CreateEncounterResponse.join_code)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.join_code_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.join_code_.Set("", GetArena());
  }
  return released;
}
inline void CreateEncounterResponse::set_allocated_join_code(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.join_code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.join_code_.IsDefault()) {
    _impl_.join_code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CreateEncounterResponse.join_code)
}

// .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
inline bool CreateEncounterResponse::has_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void CreateEncounterResponse::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::Room& CreateEncounterResponse::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& CreateEncounterResponse::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CreateEncounterResponse.room)
  return _internal_room();
}
inline void CreateEncounterResponse::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CreateEncounterResponse.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE CreateEncounterResponse::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE CreateEncounterResponse::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CreateEncounterResponse.room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL CreateEncounterResponse::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL CreateEncounterResponse::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CreateEncounterResponse.room)
  return _msg;
}
inline void CreateEncounterResponse::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CreateEncounterResponse.room)
}

// -------------------------------------------------------------------

// JoinEncounterRequest

// string join_code = 1 [json_name = "joinCode"];
inline void JoinEncounterRequest::clear_join_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.join_code_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& JoinEncounterRequest::join_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.JoinEncounterRequest.join_code)
  return _internal_join_code();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void JoinEncounterRequest::set_join_code(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.join_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.JoinEncounterRequest.join_code)
}
inline ::std::string* PROTOBUF_NONNULL JoinEncounterRequest::mutable_join_code()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_join_code();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.JoinEncounterRequest.join_code)
  return _s;
}
inline const ::std::string& JoinEncounterRequest::_internal_join_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.join_code_.Get();
}
inline void JoinEncounterRequest::_internal_set_join_code(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.join_code_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL JoinEncounterRequest::_internal_mutable_join_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.join_code_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE JoinEncounterRequest::release_join_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.JoinEncounterRequest.join_code)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.join_code_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.join_code_.Set("", GetArena());
  }
  return released;
}
inline void JoinEncounterRequest::set_allocated_join_code(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.join_code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.join_code_.IsDefault()) {
    _impl_.join_code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.JoinEncounterRequest.join_code)
}

// repeated string character_ids = 2 [json_name = "characterIds"];
inline int JoinEncounterRequest::_internal_character_ids_size() const {
  return _internal_character_ids().size();
}
inline int JoinEncounterRequest::character_ids_size() const {
  return _internal_character_ids_size();
}
inline void JoinEncounterRequest::clear_character_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_ids_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::std::string* PROTOBUF_NONNULL JoinEncounterRequest::add_character_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s =
      _internal_mutable_character_ids()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add_mutable:dnd5e.api.v1alpha1.JoinEncounterRequest.character_ids)
  return _s;
}
inline const ::std::string& JoinEncounterRequest::character_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.JoinEncounterRequest.character_ids)
  return _internal_character_ids().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL JoinEncounterRequest::mutable_character_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.JoinEncounterRequest.character_ids)
  return _internal_mutable_character_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void JoinEncounterRequest::set_character_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_character_ids()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.JoinEncounterRequest.character_ids)
}
template <typename Arg_, typename... Args_>
inline void JoinEncounterRequest::add_character_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(
      ::google::protobuf::MessageLite::internal_visibility(), GetArena(),
      *_internal_mutable_character_ids(), ::std::forward<Arg_>(value),
      args... );
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.JoinEncounterRequest.character_ids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& JoinEncounterRequest::character_ids()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.JoinEncounterRequest.character_ids)
  return _internal_character_ids();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
JoinEncounterRequest::mutable_character_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.JoinEncounterRequest.character_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_character_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
JoinEncounterRequest::_internal_character_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
JoinEncounterRequest::_internal_mutable_character_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.character_ids_;
}

// -------------------------------------------------------------------

// JoinEncounterResponse

// string encounter_id = 1 [json_name = "encounterId"];
inline void JoinEncounterResponse::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& JoinEncounterResponse::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.JoinEncounterResponse.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void JoinEncounterResponse::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.JoinEncounterResponse.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL JoinEncounterResponse::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.JoinEncounterResponse.encounter_id)
  return _s;
}
inline const ::std::string& JoinEncounterResponse::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void JoinEncounterResponse::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL JoinEncounterResponse::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE JoinEncounterResponse::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.JoinEncounterResponse.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void JoinEncounterResponse::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.JoinEncounterResponse.encounter_id)
}

// .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
inline bool JoinEncounterResponse::has_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void JoinEncounterResponse::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::Room& JoinEncounterResponse::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& JoinEncounterResponse::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.JoinEncounterResponse.room)
  return _internal_room();
}
inline void JoinEncounterResponse::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.JoinEncounterResponse.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE JoinEncounterResponse::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE JoinEncounterResponse::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.JoinEncounterResponse.room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL JoinEncounterResponse::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL JoinEncounterResponse::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.JoinEncounterResponse.room)
  return _msg;
}
inline void JoinEncounterResponse::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.JoinEncounterResponse.room)
}

// repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
inline int JoinEncounterResponse::_internal_party_size() const {
  return _internal_party().size();
}
inline int JoinEncounterResponse::party_size() const {
  return _internal_party_size();
}
inline void JoinEncounterResponse::clear_party() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.party_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL JoinEncounterResponse::mutable_party(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.JoinEncounterResponse.party)
  return _internal_mutable_party()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>* PROTOBUF_NONNULL JoinEncounterResponse::mutable_party()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.JoinEncounterResponse.party)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_party();
}
inline const ::dnd5e::api::v1alpha1::PartyMember& JoinEncounterResponse::party(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.JoinEncounterResponse.party)
  return _internal_party().Get(index);
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL JoinEncounterResponse::add_party()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::PartyMember* _add =
      _internal_mutable_party()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.JoinEncounterResponse.party)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>& JoinEncounterResponse::party() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.JoinEncounterResponse.party)
  return _internal_party();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>&
JoinEncounterResponse::_internal_party() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.party_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>* PROTOBUF_NONNULL
JoinEncounterResponse::_internal_mutable_party() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.party_;
}

// .dnd5e.api.v1alpha1.EncounterState state = 4 [json_name = "state"];
inline void JoinEncounterResponse::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::dnd5e::api::v1alpha1::EncounterState JoinEncounterResponse::state() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.JoinEncounterResponse.state)
  return _internal_state();
}
inline void JoinEncounterResponse::set_state(::dnd5e::api::v1alpha1::EncounterState value) {
  _internal_set_state(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.JoinEncounterResponse.state)
}
inline ::dnd5e::api::v1alpha1::EncounterState JoinEncounterResponse::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::EncounterState>(_impl_.state_);
}
inline void JoinEncounterResponse::_internal_set_state(::dnd5e::api::v1alpha1::EncounterState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// SetReadyRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void SetReadyRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& SetReadyRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SetReadyRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SetReadyRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SetReadyRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL SetReadyRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SetReadyRequest.encounter_id)
  return _s;
}
inline const ::std::string& SetReadyRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void SetReadyRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SetReadyRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SetReadyRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.SetReadyRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void SetReadyRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.SetReadyRequest.encounter_id)
}

// string player_id = 2 [json_name = "playerId"];
inline void SetReadyRequest::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& SetReadyRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SetReadyRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SetReadyRequest::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SetReadyRequest.player_id)
}
inline ::std::string* PROTOBUF_NONNULL SetReadyRequest::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.SetReadyRequest.player_id)
  return _s;
}
inline const ::std::string& SetReadyRequest::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void SetReadyRequest::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SetReadyRequest::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SetReadyRequest::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.SetReadyRequest.player_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void SetReadyRequest::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.SetReadyRequest.player_id)
}

// bool is_ready = 3 [json_name = "isReady"];
inline void SetReadyRequest::clear_is_ready() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ready_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool SetReadyRequest::is_ready() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SetReadyRequest.is_ready)
  return _internal_is_ready();
}
inline void SetReadyRequest::set_is_ready(bool value) {
  _internal_set_is_ready(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SetReadyRequest.is_ready)
}
inline bool SetReadyRequest::_internal_is_ready() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_ready_;
}
inline void SetReadyRequest::_internal_set_is_ready(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ready_ = value;
}

// -------------------------------------------------------------------

// SetReadyResponse

// bool success = 1 [json_name = "success"];
inline void SetReadyResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool SetReadyResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.SetReadyResponse.success)
  return _internal_success();
}
inline void SetReadyResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.SetReadyResponse.success)
}
inline bool SetReadyResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void SetReadyResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// StartCombatRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void StartCombatRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& StartCombatRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.StartCombatRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StartCombatRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.StartCombatRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL StartCombatRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.StartCombatRequest.encounter_id)
  return _s;
}
inline const ::std::string& StartCombatRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void StartCombatRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StartCombatRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StartCombatRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.StartCombatRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void StartCombatRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.StartCombatRequest.encounter_id)
}

// .dnd5e.api.v1alpha1.DungeonTheme theme = 2 [json_name = "theme"];
inline void StartCombatRequest::clear_theme() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.theme_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::DungeonTheme StartCombatRequest::theme() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.StartCombatRequest.theme)
  return _internal_theme();
}
inline void StartCombatRequest::set_theme(::dnd5e::api::v1alpha1::DungeonTheme value) {
  _internal_set_theme(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.StartCombatRequest.theme)
}
inline ::dnd5e::api::v1alpha1::DungeonTheme StartCombatRequest::_internal_theme() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::DungeonTheme>(_impl_.theme_);
}
inline void StartCombatRequest::_internal_set_theme(::dnd5e::api::v1alpha1::DungeonTheme value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.theme_ = value;
}

// .dnd5e.api.v1alpha1.DungeonDifficulty difficulty = 3 [json_name = "difficulty"];
inline void StartCombatRequest::clear_difficulty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.difficulty_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::DungeonDifficulty StartCombatRequest::difficulty() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.StartCombatRequest.difficulty)
  return _internal_difficulty();
}
inline void StartCombatRequest::set_difficulty(::dnd5e::api::v1alpha1::DungeonDifficulty value) {
  _internal_set_difficulty(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.StartCombatRequest.difficulty)
}
inline ::dnd5e::api::v1alpha1::DungeonDifficulty StartCombatRequest::_internal_difficulty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::DungeonDifficulty>(_impl_.difficulty_);
}
inline void StartCombatRequest::_internal_set_difficulty(::dnd5e::api::v1alpha1::DungeonDifficulty value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.difficulty_ = value;
}

// .dnd5e.api.v1alpha1.DungeonLength length = 4 [json_name = "length"];
inline void StartCombatRequest::clear_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::dnd5e::api::v1alpha1::DungeonLength StartCombatRequest::length() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.StartCombatRequest.length)
  return _internal_length();
}
inline void StartCombatRequest::set_length(::dnd5e::api::v1alpha1::DungeonLength value) {
  _internal_set_length(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.StartCombatRequest.length)
}
inline ::dnd5e::api::v1alpha1::DungeonLength StartCombatRequest::_internal_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::DungeonLength>(_impl_.length_);
}
inline void StartCombatRequest::_internal_set_length(::dnd5e::api::v1alpha1::DungeonLength value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = value;
}

// -------------------------------------------------------------------

// StartCombatResponse

// .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
inline bool StartCombatResponse::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void StartCombatResponse::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& StartCombatResponse::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& StartCombatResponse::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.StartCombatResponse.combat_state)
  return _internal_combat_state();
}
inline void StartCombatResponse::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.StartCombatResponse.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE StartCombatResponse::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE StartCombatResponse::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.StartCombatResponse.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL StartCombatResponse::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL StartCombatResponse::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.StartCombatResponse.combat_state)
  return _msg;
}
inline void StartCombatResponse::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.StartCombatResponse.combat_state)
}

// .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
inline bool StartCombatResponse::has_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void StartCombatResponse::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::dnd5e::api::v1alpha1::Room& StartCombatResponse::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& StartCombatResponse::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.StartCombatResponse.room)
  return _internal_room();
}
inline void StartCombatResponse::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.StartCombatResponse.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE StartCombatResponse::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE StartCombatResponse::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.StartCombatResponse.room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL StartCombatResponse::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL StartCombatResponse::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.StartCombatResponse.room)
  return _msg;
}
inline void StartCombatResponse::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.StartCombatResponse.room)
}

// repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 3 [json_name = "monsterTurns"];
inline int StartCombatResponse::_internal_monster_turns_size() const {
  return _internal_monster_turns().size();
}
inline int StartCombatResponse::monster_turns_size() const {
  return _internal_monster_turns_size();
}
inline void StartCombatResponse::clear_monster_turns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_turns_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL StartCombatResponse::mutable_monster_turns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.StartCombatResponse.monster_turns)
  return _internal_mutable_monster_turns()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL StartCombatResponse::mutable_monster_turns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.StartCombatResponse.monster_turns)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_monster_turns();
}
inline const ::dnd5e::api::v1alpha1::MonsterTurnResult& StartCombatResponse::monster_turns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.StartCombatResponse.monster_turns)
  return _internal_monster_turns().Get(index);
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL StartCombatResponse::add_monster_turns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::MonsterTurnResult* _add =
      _internal_mutable_monster_turns()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.StartCombatResponse.monster_turns)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& StartCombatResponse::monster_turns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.StartCombatResponse.monster_turns)
  return _internal_monster_turns();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>&
StartCombatResponse::_internal_monster_turns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monster_turns_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL
StartCombatResponse::_internal_mutable_monster_turns() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.monster_turns_;
}

// repeated .dnd5e.api.v1alpha1.DoorInfo doors = 4 [json_name = "doors"];
inline int StartCombatResponse::_internal_doors_size() const {
  return _internal_doors().size();
}
inline int StartCombatResponse::doors_size() const {
  return _internal_doors_size();
}
inline void StartCombatResponse::clear_doors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.doors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL StartCombatResponse::mutable_doors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.StartCombatResponse.doors)
  return _internal_mutable_doors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL StartCombatResponse::mutable_doors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.StartCombatResponse.doors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_doors();
}
inline const ::dnd5e::api::v1alpha1::DoorInfo& StartCombatResponse::doors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.StartCombatResponse.doors)
  return _internal_doors().Get(index);
}
inline ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL StartCombatResponse::add_doors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::DoorInfo* _add =
      _internal_mutable_doors()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.StartCombatResponse.doors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& StartCombatResponse::doors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.StartCombatResponse.doors)
  return _internal_doors();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>&
StartCombatResponse::_internal_doors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.doors_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL
StartCombatResponse::_internal_mutable_doors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.doors_;
}

// string dungeon_id = 5 [json_name = "dungeonId"];
inline void StartCombatResponse::clear_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& StartCombatResponse::dungeon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.StartCombatResponse.dungeon_id)
  return _internal_dungeon_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StartCombatResponse::set_dungeon_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.dungeon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.StartCombatResponse.dungeon_id)
}
inline ::std::string* PROTOBUF_NONNULL StartCombatResponse::mutable_dungeon_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_dungeon_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.StartCombatResponse.dungeon_id)
  return _s;
}
inline const ::std::string& StartCombatResponse::_internal_dungeon_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dungeon_id_.Get();
}
inline void StartCombatResponse::_internal_set_dungeon_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StartCombatResponse::_internal_mutable_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dungeon_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StartCombatResponse::release_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.StartCombatResponse.dungeon_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.dungeon_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  return released;
}
inline void StartCombatResponse::set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.dungeon_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dungeon_id_.IsDefault()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.StartCombatResponse.dungeon_id)
}

// -------------------------------------------------------------------

// LeaveEncounterRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void LeaveEncounterRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& LeaveEncounterRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.LeaveEncounterRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void LeaveEncounterRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.LeaveEncounterRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL LeaveEncounterRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.LeaveEncounterRequest.encounter_id)
  return _s;
}
inline const ::std::string& LeaveEncounterRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void LeaveEncounterRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL LeaveEncounterRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE LeaveEncounterRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.LeaveEncounterRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void LeaveEncounterRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.LeaveEncounterRequest.encounter_id)
}

// string player_id = 2 [json_name = "playerId"];
inline void LeaveEncounterRequest::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& LeaveEncounterRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.LeaveEncounterRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void LeaveEncounterRequest::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.LeaveEncounterRequest.player_id)
}
inline ::std::string* PROTOBUF_NONNULL LeaveEncounterRequest::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.LeaveEncounterRequest.player_id)
  return _s;
}
inline const ::std::string& LeaveEncounterRequest::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void LeaveEncounterRequest::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL LeaveEncounterRequest::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE LeaveEncounterRequest::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.LeaveEncounterRequest.player_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void LeaveEncounterRequest::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.LeaveEncounterRequest.player_id)
}

// -------------------------------------------------------------------

// LeaveEncounterResponse

// bool success = 1 [json_name = "success"];
inline void LeaveEncounterResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool LeaveEncounterResponse::success() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.LeaveEncounterResponse.success)
  return _internal_success();
}
inline void LeaveEncounterResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.LeaveEncounterResponse.success)
}
inline bool LeaveEncounterResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void LeaveEncounterResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// StreamEncounterEventsRequest

// string encounter_id = 1 [json_name = "encounterId"];
inline void StreamEncounterEventsRequest::clear_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& StreamEncounterEventsRequest::encounter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.StreamEncounterEventsRequest.encounter_id)
  return _internal_encounter_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StreamEncounterEventsRequest::set_encounter_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.encounter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.StreamEncounterEventsRequest.encounter_id)
}
inline ::std::string* PROTOBUF_NONNULL StreamEncounterEventsRequest::mutable_encounter_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_encounter_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.StreamEncounterEventsRequest.encounter_id)
  return _s;
}
inline const ::std::string& StreamEncounterEventsRequest::_internal_encounter_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encounter_id_.Get();
}
inline void StreamEncounterEventsRequest::_internal_set_encounter_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encounter_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StreamEncounterEventsRequest::_internal_mutable_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encounter_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StreamEncounterEventsRequest::release_encounter_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.StreamEncounterEventsRequest.encounter_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.encounter_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  return released;
}
inline void StreamEncounterEventsRequest::set_allocated_encounter_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.encounter_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encounter_id_.IsDefault()) {
    _impl_.encounter_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.StreamEncounterEventsRequest.encounter_id)
}

// string player_id = 2 [json_name = "playerId"];
inline void StreamEncounterEventsRequest::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& StreamEncounterEventsRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.StreamEncounterEventsRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StreamEncounterEventsRequest::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.StreamEncounterEventsRequest.player_id)
}
inline ::std::string* PROTOBUF_NONNULL StreamEncounterEventsRequest::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.StreamEncounterEventsRequest.player_id)
  return _s;
}
inline const ::std::string& StreamEncounterEventsRequest::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void StreamEncounterEventsRequest::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StreamEncounterEventsRequest::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StreamEncounterEventsRequest::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.StreamEncounterEventsRequest.player_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void StreamEncounterEventsRequest::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.StreamEncounterEventsRequest.player_id)
}

// -------------------------------------------------------------------

// EncounterEvent

// string event_id = 1 [json_name = "eventId"];
inline void EncounterEvent::clear_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& EncounterEvent::event_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.event_id)
  return _internal_event_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EncounterEvent::set_event_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.event_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EncounterEvent.event_id)
}
inline ::std::string* PROTOBUF_NONNULL EncounterEvent::mutable_event_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.event_id)
  return _s;
}
inline const ::std::string& EncounterEvent::_internal_event_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.event_id_.Get();
}
inline void EncounterEvent::_internal_set_event_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.event_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE EncounterEvent::release_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.event_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.event_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.event_id_.Set("", GetArena());
  }
  return released;
}
inline void EncounterEvent::set_allocated_event_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.event_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.event_id)
}

// int64 timestamp = 2 [json_name = "timestamp"];
inline void EncounterEvent::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int64_t EncounterEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.timestamp)
  return _internal_timestamp();
}
inline void EncounterEvent::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.EncounterEvent.timestamp)
}
inline ::int64_t EncounterEvent::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void EncounterEvent::_internal_set_timestamp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// .dnd5e.api.v1alpha1.PlayerJoinedEvent player_joined = 10 [json_name = "playerJoined"];
inline bool EncounterEvent::has_player_joined() const {
  return event_case() == kPlayerJoined;
}
inline bool EncounterEvent::_internal_has_player_joined() const {
  return event_case() == kPlayerJoined;
}
inline void EncounterEvent::set_has_player_joined() {
  _impl_._oneof_case_[0] = kPlayerJoined;
}
inline void EncounterEvent::clear_player_joined() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerJoined) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_joined_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_joined_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::PlayerJoinedEvent* PROTOBUF_NULLABLE EncounterEvent::release_player_joined() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.player_joined)
  if (event_case() == kPlayerJoined) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::PlayerJoinedEvent*>(_impl_.event_.player_joined_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_joined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::PlayerJoinedEvent& EncounterEvent::_internal_player_joined() const {
  return event_case() == kPlayerJoined ? static_cast<const ::dnd5e::api::v1alpha1::PlayerJoinedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::PlayerJoinedEvent*>(_impl_.event_.player_joined_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::PlayerJoinedEvent&>(::dnd5e::api::v1alpha1::_PlayerJoinedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::PlayerJoinedEvent& EncounterEvent::player_joined() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.player_joined)
  return _internal_player_joined();
}
inline ::dnd5e::api::v1alpha1::PlayerJoinedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_player_joined() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.player_joined)
  if (event_case() == kPlayerJoined) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::PlayerJoinedEvent*>(_impl_.event_.player_joined_);
    _impl_.event_.player_joined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_player_joined(
    ::dnd5e::api::v1alpha1::PlayerJoinedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_joined();
    _impl_.event_.player_joined_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.player_joined)
}
inline ::dnd5e::api::v1alpha1::PlayerJoinedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_player_joined() {
  if (event_case() != kPlayerJoined) {
    clear_event();
    set_has_player_joined();
    _impl_.event_.player_joined_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::PlayerJoinedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::PlayerJoinedEvent*>(_impl_.event_.player_joined_);
}
inline ::dnd5e::api::v1alpha1::PlayerJoinedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_player_joined()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::PlayerJoinedEvent* _msg = _internal_mutable_player_joined();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.player_joined)
  return _msg;
}

// .dnd5e.api.v1alpha1.PlayerLeftEvent player_left = 11 [json_name = "playerLeft"];
inline bool EncounterEvent::has_player_left() const {
  return event_case() == kPlayerLeft;
}
inline bool EncounterEvent::_internal_has_player_left() const {
  return event_case() == kPlayerLeft;
}
inline void EncounterEvent::set_has_player_left() {
  _impl_._oneof_case_[0] = kPlayerLeft;
}
inline void EncounterEvent::clear_player_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerLeft) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_left_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_left_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::PlayerLeftEvent* PROTOBUF_NULLABLE EncounterEvent::release_player_left() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.player_left)
  if (event_case() == kPlayerLeft) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::PlayerLeftEvent*>(_impl_.event_.player_left_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_left_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::PlayerLeftEvent& EncounterEvent::_internal_player_left() const {
  return event_case() == kPlayerLeft ? static_cast<const ::dnd5e::api::v1alpha1::PlayerLeftEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::PlayerLeftEvent*>(_impl_.event_.player_left_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::PlayerLeftEvent&>(::dnd5e::api::v1alpha1::_PlayerLeftEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::PlayerLeftEvent& EncounterEvent::player_left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.player_left)
  return _internal_player_left();
}
inline ::dnd5e::api::v1alpha1::PlayerLeftEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_player_left() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.player_left)
  if (event_case() == kPlayerLeft) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::PlayerLeftEvent*>(_impl_.event_.player_left_);
    _impl_.event_.player_left_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_player_left(
    ::dnd5e::api::v1alpha1::PlayerLeftEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_left();
    _impl_.event_.player_left_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.player_left)
}
inline ::dnd5e::api::v1alpha1::PlayerLeftEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_player_left() {
  if (event_case() != kPlayerLeft) {
    clear_event();
    set_has_player_left();
    _impl_.event_.player_left_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::PlayerLeftEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::PlayerLeftEvent*>(_impl_.event_.player_left_);
}
inline ::dnd5e::api::v1alpha1::PlayerLeftEvent* PROTOBUF_NONNULL EncounterEvent::mutable_player_left()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::PlayerLeftEvent* _msg = _internal_mutable_player_left();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.player_left)
  return _msg;
}

// .dnd5e.api.v1alpha1.PlayerReadyEvent player_ready = 12 [json_name = "playerReady"];
inline bool EncounterEvent::has_player_ready() const {
  return event_case() == kPlayerReady;
}
inline bool EncounterEvent::_internal_has_player_ready() const {
  return event_case() == kPlayerReady;
}
inline void EncounterEvent::set_has_player_ready() {
  _impl_._oneof_case_[0] = kPlayerReady;
}
inline void EncounterEvent::clear_player_ready() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerReady) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_ready_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_ready_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::PlayerReadyEvent* PROTOBUF_NULLABLE EncounterEvent::release_player_ready() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.player_ready)
  if (event_case() == kPlayerReady) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::PlayerReadyEvent*>(_impl_.event_.player_ready_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_ready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::PlayerReadyEvent& EncounterEvent::_internal_player_ready() const {
  return event_case() == kPlayerReady ? static_cast<const ::dnd5e::api::v1alpha1::PlayerReadyEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::PlayerReadyEvent*>(_impl_.event_.player_ready_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::PlayerReadyEvent&>(::dnd5e::api::v1alpha1::_PlayerReadyEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::PlayerReadyEvent& EncounterEvent::player_ready() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.player_ready)
  return _internal_player_ready();
}
inline ::dnd5e::api::v1alpha1::PlayerReadyEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_player_ready() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.player_ready)
  if (event_case() == kPlayerReady) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::PlayerReadyEvent*>(_impl_.event_.player_ready_);
    _impl_.event_.player_ready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_player_ready(
    ::dnd5e::api::v1alpha1::PlayerReadyEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_ready();
    _impl_.event_.player_ready_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.player_ready)
}
inline ::dnd5e::api::v1alpha1::PlayerReadyEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_player_ready() {
  if (event_case() != kPlayerReady) {
    clear_event();
    set_has_player_ready();
    _impl_.event_.player_ready_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::PlayerReadyEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::PlayerReadyEvent*>(_impl_.event_.player_ready_);
}
inline ::dnd5e::api::v1alpha1::PlayerReadyEvent* PROTOBUF_NONNULL EncounterEvent::mutable_player_ready()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::PlayerReadyEvent* _msg = _internal_mutable_player_ready();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.player_ready)
  return _msg;
}

// .dnd5e.api.v1alpha1.CombatStartedEvent combat_started = 13 [json_name = "combatStarted"];
inline bool EncounterEvent::has_combat_started() const {
  return event_case() == kCombatStarted;
}
inline bool EncounterEvent::_internal_has_combat_started() const {
  return event_case() == kCombatStarted;
}
inline void EncounterEvent::set_has_combat_started() {
  _impl_._oneof_case_[0] = kCombatStarted;
}
inline void EncounterEvent::clear_combat_started() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kCombatStarted) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.combat_started_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.combat_started_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::CombatStartedEvent* PROTOBUF_NULLABLE EncounterEvent::release_combat_started() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.combat_started)
  if (event_case() == kCombatStarted) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::CombatStartedEvent*>(_impl_.event_.combat_started_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.combat_started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::CombatStartedEvent& EncounterEvent::_internal_combat_started() const {
  return event_case() == kCombatStarted ? static_cast<const ::dnd5e::api::v1alpha1::CombatStartedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::CombatStartedEvent*>(_impl_.event_.combat_started_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatStartedEvent&>(::dnd5e::api::v1alpha1::_CombatStartedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatStartedEvent& EncounterEvent::combat_started() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.combat_started)
  return _internal_combat_started();
}
inline ::dnd5e::api::v1alpha1::CombatStartedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_combat_started() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.combat_started)
  if (event_case() == kCombatStarted) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::CombatStartedEvent*>(_impl_.event_.combat_started_);
    _impl_.event_.combat_started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_combat_started(
    ::dnd5e::api::v1alpha1::CombatStartedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_combat_started();
    _impl_.event_.combat_started_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.combat_started)
}
inline ::dnd5e::api::v1alpha1::CombatStartedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_combat_started() {
  if (event_case() != kCombatStarted) {
    clear_event();
    set_has_combat_started();
    _impl_.event_.combat_started_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatStartedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::CombatStartedEvent*>(_impl_.event_.combat_started_);
}
inline ::dnd5e::api::v1alpha1::CombatStartedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_combat_started()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::CombatStartedEvent* _msg = _internal_mutable_combat_started();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.combat_started)
  return _msg;
}

// .dnd5e.api.v1alpha1.MovementCompletedEvent movement_completed = 20 [json_name = "movementCompleted"];
inline bool EncounterEvent::has_movement_completed() const {
  return event_case() == kMovementCompleted;
}
inline bool EncounterEvent::_internal_has_movement_completed() const {
  return event_case() == kMovementCompleted;
}
inline void EncounterEvent::set_has_movement_completed() {
  _impl_._oneof_case_[0] = kMovementCompleted;
}
inline void EncounterEvent::clear_movement_completed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kMovementCompleted) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.movement_completed_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.movement_completed_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::MovementCompletedEvent* PROTOBUF_NULLABLE EncounterEvent::release_movement_completed() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.movement_completed)
  if (event_case() == kMovementCompleted) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::MovementCompletedEvent*>(_impl_.event_.movement_completed_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.movement_completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::MovementCompletedEvent& EncounterEvent::_internal_movement_completed() const {
  return event_case() == kMovementCompleted ? static_cast<const ::dnd5e::api::v1alpha1::MovementCompletedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::MovementCompletedEvent*>(_impl_.event_.movement_completed_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::MovementCompletedEvent&>(::dnd5e::api::v1alpha1::_MovementCompletedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::MovementCompletedEvent& EncounterEvent::movement_completed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.movement_completed)
  return _internal_movement_completed();
}
inline ::dnd5e::api::v1alpha1::MovementCompletedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_movement_completed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.movement_completed)
  if (event_case() == kMovementCompleted) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::MovementCompletedEvent*>(_impl_.event_.movement_completed_);
    _impl_.event_.movement_completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_movement_completed(
    ::dnd5e::api::v1alpha1::MovementCompletedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_movement_completed();
    _impl_.event_.movement_completed_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.movement_completed)
}
inline ::dnd5e::api::v1alpha1::MovementCompletedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_movement_completed() {
  if (event_case() != kMovementCompleted) {
    clear_event();
    set_has_movement_completed();
    _impl_.event_.movement_completed_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::MovementCompletedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::MovementCompletedEvent*>(_impl_.event_.movement_completed_);
}
inline ::dnd5e::api::v1alpha1::MovementCompletedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_movement_completed()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::MovementCompletedEvent* _msg = _internal_mutable_movement_completed();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.movement_completed)
  return _msg;
}

// .dnd5e.api.v1alpha1.AttackResolvedEvent attack_resolved = 21 [json_name = "attackResolved"];
inline bool EncounterEvent::has_attack_resolved() const {
  return event_case() == kAttackResolved;
}
inline bool EncounterEvent::_internal_has_attack_resolved() const {
  return event_case() == kAttackResolved;
}
inline void EncounterEvent::set_has_attack_resolved() {
  _impl_._oneof_case_[0] = kAttackResolved;
}
inline void EncounterEvent::clear_attack_resolved() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kAttackResolved) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.attack_resolved_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.attack_resolved_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::AttackResolvedEvent* PROTOBUF_NULLABLE EncounterEvent::release_attack_resolved() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.attack_resolved)
  if (event_case() == kAttackResolved) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResolvedEvent*>(_impl_.event_.attack_resolved_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.attack_resolved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::AttackResolvedEvent& EncounterEvent::_internal_attack_resolved() const {
  return event_case() == kAttackResolved ? static_cast<const ::dnd5e::api::v1alpha1::AttackResolvedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::AttackResolvedEvent*>(_impl_.event_.attack_resolved_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::AttackResolvedEvent&>(::dnd5e::api::v1alpha1::_AttackResolvedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AttackResolvedEvent& EncounterEvent::attack_resolved() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.attack_resolved)
  return _internal_attack_resolved();
}
inline ::dnd5e::api::v1alpha1::AttackResolvedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_attack_resolved() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.attack_resolved)
  if (event_case() == kAttackResolved) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResolvedEvent*>(_impl_.event_.attack_resolved_);
    _impl_.event_.attack_resolved_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_attack_resolved(
    ::dnd5e::api::v1alpha1::AttackResolvedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_attack_resolved();
    _impl_.event_.attack_resolved_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.attack_resolved)
}
inline ::dnd5e::api::v1alpha1::AttackResolvedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_attack_resolved() {
  if (event_case() != kAttackResolved) {
    clear_event();
    set_has_attack_resolved();
    _impl_.event_.attack_resolved_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AttackResolvedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::AttackResolvedEvent*>(_impl_.event_.attack_resolved_);
}
inline ::dnd5e::api::v1alpha1::AttackResolvedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_attack_resolved()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::AttackResolvedEvent* _msg = _internal_mutable_attack_resolved();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.attack_resolved)
  return _msg;
}

// .dnd5e.api.v1alpha1.FeatureActivatedEvent feature_activated = 22 [json_name = "featureActivated"];
inline bool EncounterEvent::has_feature_activated() const {
  return event_case() == kFeatureActivated;
}
inline bool EncounterEvent::_internal_has_feature_activated() const {
  return event_case() == kFeatureActivated;
}
inline void EncounterEvent::set_has_feature_activated() {
  _impl_._oneof_case_[0] = kFeatureActivated;
}
inline void EncounterEvent::clear_feature_activated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kFeatureActivated) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.feature_activated_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.feature_activated_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::FeatureActivatedEvent* PROTOBUF_NULLABLE EncounterEvent::release_feature_activated() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.feature_activated)
  if (event_case() == kFeatureActivated) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::FeatureActivatedEvent*>(_impl_.event_.feature_activated_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.feature_activated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::FeatureActivatedEvent& EncounterEvent::_internal_feature_activated() const {
  return event_case() == kFeatureActivated ? static_cast<const ::dnd5e::api::v1alpha1::FeatureActivatedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::FeatureActivatedEvent*>(_impl_.event_.feature_activated_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::FeatureActivatedEvent&>(::dnd5e::api::v1alpha1::_FeatureActivatedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::FeatureActivatedEvent& EncounterEvent::feature_activated() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.feature_activated)
  return _internal_feature_activated();
}
inline ::dnd5e::api::v1alpha1::FeatureActivatedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_feature_activated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.feature_activated)
  if (event_case() == kFeatureActivated) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::FeatureActivatedEvent*>(_impl_.event_.feature_activated_);
    _impl_.event_.feature_activated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_feature_activated(
    ::dnd5e::api::v1alpha1::FeatureActivatedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_feature_activated();
    _impl_.event_.feature_activated_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.feature_activated)
}
inline ::dnd5e::api::v1alpha1::FeatureActivatedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_feature_activated() {
  if (event_case() != kFeatureActivated) {
    clear_event();
    set_has_feature_activated();
    _impl_.event_.feature_activated_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::FeatureActivatedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::FeatureActivatedEvent*>(_impl_.event_.feature_activated_);
}
inline ::dnd5e::api::v1alpha1::FeatureActivatedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_feature_activated()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::FeatureActivatedEvent* _msg = _internal_mutable_feature_activated();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.feature_activated)
  return _msg;
}

// .dnd5e.api.v1alpha1.TurnEndedEvent turn_ended = 23 [json_name = "turnEnded"];
inline bool EncounterEvent::has_turn_ended() const {
  return event_case() == kTurnEnded;
}
inline bool EncounterEvent::_internal_has_turn_ended() const {
  return event_case() == kTurnEnded;
}
inline void EncounterEvent::set_has_turn_ended() {
  _impl_._oneof_case_[0] = kTurnEnded;
}
inline void EncounterEvent::clear_turn_ended() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kTurnEnded) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.turn_ended_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.turn_ended_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::TurnEndedEvent* PROTOBUF_NULLABLE EncounterEvent::release_turn_ended() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.turn_ended)
  if (event_case() == kTurnEnded) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::TurnEndedEvent*>(_impl_.event_.turn_ended_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.turn_ended_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::TurnEndedEvent& EncounterEvent::_internal_turn_ended() const {
  return event_case() == kTurnEnded ? static_cast<const ::dnd5e::api::v1alpha1::TurnEndedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::TurnEndedEvent*>(_impl_.event_.turn_ended_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::TurnEndedEvent&>(::dnd5e::api::v1alpha1::_TurnEndedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::TurnEndedEvent& EncounterEvent::turn_ended() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.turn_ended)
  return _internal_turn_ended();
}
inline ::dnd5e::api::v1alpha1::TurnEndedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_turn_ended() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.turn_ended)
  if (event_case() == kTurnEnded) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::TurnEndedEvent*>(_impl_.event_.turn_ended_);
    _impl_.event_.turn_ended_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_turn_ended(
    ::dnd5e::api::v1alpha1::TurnEndedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_turn_ended();
    _impl_.event_.turn_ended_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.turn_ended)
}
inline ::dnd5e::api::v1alpha1::TurnEndedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_turn_ended() {
  if (event_case() != kTurnEnded) {
    clear_event();
    set_has_turn_ended();
    _impl_.event_.turn_ended_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::TurnEndedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::TurnEndedEvent*>(_impl_.event_.turn_ended_);
}
inline ::dnd5e::api::v1alpha1::TurnEndedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_turn_ended()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::TurnEndedEvent* _msg = _internal_mutable_turn_ended();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.turn_ended)
  return _msg;
}

// .dnd5e.api.v1alpha1.MonsterTurnCompletedEvent monster_turn_completed = 24 [json_name = "monsterTurnCompleted"];
inline bool EncounterEvent::has_monster_turn_completed() const {
  return event_case() == kMonsterTurnCompleted;
}
inline bool EncounterEvent::_internal_has_monster_turn_completed() const {
  return event_case() == kMonsterTurnCompleted;
}
inline void EncounterEvent::set_has_monster_turn_completed() {
  _impl_._oneof_case_[0] = kMonsterTurnCompleted;
}
inline void EncounterEvent::clear_monster_turn_completed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kMonsterTurnCompleted) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.monster_turn_completed_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.monster_turn_completed_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* PROTOBUF_NULLABLE EncounterEvent::release_monster_turn_completed() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.monster_turn_completed)
  if (event_case() == kMonsterTurnCompleted) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent*>(_impl_.event_.monster_turn_completed_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.monster_turn_completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent& EncounterEvent::_internal_monster_turn_completed() const {
  return event_case() == kMonsterTurnCompleted ? static_cast<const ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent*>(_impl_.event_.monster_turn_completed_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent&>(::dnd5e::api::v1alpha1::_MonsterTurnCompletedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent& EncounterEvent::monster_turn_completed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.monster_turn_completed)
  return _internal_monster_turn_completed();
}
inline ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_monster_turn_completed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.monster_turn_completed)
  if (event_case() == kMonsterTurnCompleted) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent*>(_impl_.event_.monster_turn_completed_);
    _impl_.event_.monster_turn_completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_monster_turn_completed(
    ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_monster_turn_completed();
    _impl_.event_.monster_turn_completed_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.monster_turn_completed)
}
inline ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_monster_turn_completed() {
  if (event_case() != kMonsterTurnCompleted) {
    clear_event();
    set_has_monster_turn_completed();
    _impl_.event_.monster_turn_completed_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent*>(_impl_.event_.monster_turn_completed_);
}
inline ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_monster_turn_completed()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::MonsterTurnCompletedEvent* _msg = _internal_mutable_monster_turn_completed();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.monster_turn_completed)
  return _msg;
}

// .dnd5e.api.v1alpha1.CombatEndedEvent combat_ended = 25 [json_name = "combatEnded"];
inline bool EncounterEvent::has_combat_ended() const {
  return event_case() == kCombatEnded;
}
inline bool EncounterEvent::_internal_has_combat_ended() const {
  return event_case() == kCombatEnded;
}
inline void EncounterEvent::set_has_combat_ended() {
  _impl_._oneof_case_[0] = kCombatEnded;
}
inline void EncounterEvent::clear_combat_ended() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kCombatEnded) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.combat_ended_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.combat_ended_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::CombatEndedEvent* PROTOBUF_NULLABLE EncounterEvent::release_combat_ended() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.combat_ended)
  if (event_case() == kCombatEnded) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::CombatEndedEvent*>(_impl_.event_.combat_ended_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.combat_ended_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::CombatEndedEvent& EncounterEvent::_internal_combat_ended() const {
  return event_case() == kCombatEnded ? static_cast<const ::dnd5e::api::v1alpha1::CombatEndedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::CombatEndedEvent*>(_impl_.event_.combat_ended_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatEndedEvent&>(::dnd5e::api::v1alpha1::_CombatEndedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatEndedEvent& EncounterEvent::combat_ended() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.combat_ended)
  return _internal_combat_ended();
}
inline ::dnd5e::api::v1alpha1::CombatEndedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_combat_ended() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.combat_ended)
  if (event_case() == kCombatEnded) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::CombatEndedEvent*>(_impl_.event_.combat_ended_);
    _impl_.event_.combat_ended_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_combat_ended(
    ::dnd5e::api::v1alpha1::CombatEndedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_combat_ended();
    _impl_.event_.combat_ended_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.combat_ended)
}
inline ::dnd5e::api::v1alpha1::CombatEndedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_combat_ended() {
  if (event_case() != kCombatEnded) {
    clear_event();
    set_has_combat_ended();
    _impl_.event_.combat_ended_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatEndedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::CombatEndedEvent*>(_impl_.event_.combat_ended_);
}
inline ::dnd5e::api::v1alpha1::CombatEndedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_combat_ended()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::CombatEndedEvent* _msg = _internal_mutable_combat_ended();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.combat_ended)
  return _msg;
}

// .dnd5e.api.v1alpha1.PlayerDisconnectedEvent player_disconnected = 30 [json_name = "playerDisconnected"];
inline bool EncounterEvent::has_player_disconnected() const {
  return event_case() == kPlayerDisconnected;
}
inline bool EncounterEvent::_internal_has_player_disconnected() const {
  return event_case() == kPlayerDisconnected;
}
inline void EncounterEvent::set_has_player_disconnected() {
  _impl_._oneof_case_[0] = kPlayerDisconnected;
}
inline void EncounterEvent::clear_player_disconnected() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerDisconnected) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_disconnected_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_disconnected_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* PROTOBUF_NULLABLE EncounterEvent::release_player_disconnected() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.player_disconnected)
  if (event_case() == kPlayerDisconnected) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::PlayerDisconnectedEvent*>(_impl_.event_.player_disconnected_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_disconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent& EncounterEvent::_internal_player_disconnected() const {
  return event_case() == kPlayerDisconnected ? static_cast<const ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::PlayerDisconnectedEvent*>(_impl_.event_.player_disconnected_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent&>(::dnd5e::api::v1alpha1::_PlayerDisconnectedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent& EncounterEvent::player_disconnected() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.player_disconnected)
  return _internal_player_disconnected();
}
inline ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_player_disconnected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.player_disconnected)
  if (event_case() == kPlayerDisconnected) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::PlayerDisconnectedEvent*>(_impl_.event_.player_disconnected_);
    _impl_.event_.player_disconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_player_disconnected(
    ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_disconnected();
    _impl_.event_.player_disconnected_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.player_disconnected)
}
inline ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_player_disconnected() {
  if (event_case() != kPlayerDisconnected) {
    clear_event();
    set_has_player_disconnected();
    _impl_.event_.player_disconnected_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::PlayerDisconnectedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::PlayerDisconnectedEvent*>(_impl_.event_.player_disconnected_);
}
inline ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_player_disconnected()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::PlayerDisconnectedEvent* _msg = _internal_mutable_player_disconnected();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.player_disconnected)
  return _msg;
}

// .dnd5e.api.v1alpha1.PlayerReconnectedEvent player_reconnected = 31 [json_name = "playerReconnected"];
inline bool EncounterEvent::has_player_reconnected() const {
  return event_case() == kPlayerReconnected;
}
inline bool EncounterEvent::_internal_has_player_reconnected() const {
  return event_case() == kPlayerReconnected;
}
inline void EncounterEvent::set_has_player_reconnected() {
  _impl_._oneof_case_[0] = kPlayerReconnected;
}
inline void EncounterEvent::clear_player_reconnected() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerReconnected) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_reconnected_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_reconnected_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::PlayerReconnectedEvent* PROTOBUF_NULLABLE EncounterEvent::release_player_reconnected() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.player_reconnected)
  if (event_case() == kPlayerReconnected) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::PlayerReconnectedEvent*>(_impl_.event_.player_reconnected_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_reconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::PlayerReconnectedEvent& EncounterEvent::_internal_player_reconnected() const {
  return event_case() == kPlayerReconnected ? static_cast<const ::dnd5e::api::v1alpha1::PlayerReconnectedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::PlayerReconnectedEvent*>(_impl_.event_.player_reconnected_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::PlayerReconnectedEvent&>(::dnd5e::api::v1alpha1::_PlayerReconnectedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::PlayerReconnectedEvent& EncounterEvent::player_reconnected() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.player_reconnected)
  return _internal_player_reconnected();
}
inline ::dnd5e::api::v1alpha1::PlayerReconnectedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_player_reconnected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.player_reconnected)
  if (event_case() == kPlayerReconnected) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::PlayerReconnectedEvent*>(_impl_.event_.player_reconnected_);
    _impl_.event_.player_reconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_player_reconnected(
    ::dnd5e::api::v1alpha1::PlayerReconnectedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_reconnected();
    _impl_.event_.player_reconnected_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.player_reconnected)
}
inline ::dnd5e::api::v1alpha1::PlayerReconnectedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_player_reconnected() {
  if (event_case() != kPlayerReconnected) {
    clear_event();
    set_has_player_reconnected();
    _impl_.event_.player_reconnected_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::PlayerReconnectedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::PlayerReconnectedEvent*>(_impl_.event_.player_reconnected_);
}
inline ::dnd5e::api::v1alpha1::PlayerReconnectedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_player_reconnected()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::PlayerReconnectedEvent* _msg = _internal_mutable_player_reconnected();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.player_reconnected)
  return _msg;
}

// .dnd5e.api.v1alpha1.CombatPausedEvent combat_paused = 32 [json_name = "combatPaused"];
inline bool EncounterEvent::has_combat_paused() const {
  return event_case() == kCombatPaused;
}
inline bool EncounterEvent::_internal_has_combat_paused() const {
  return event_case() == kCombatPaused;
}
inline void EncounterEvent::set_has_combat_paused() {
  _impl_._oneof_case_[0] = kCombatPaused;
}
inline void EncounterEvent::clear_combat_paused() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kCombatPaused) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.combat_paused_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.combat_paused_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::CombatPausedEvent* PROTOBUF_NULLABLE EncounterEvent::release_combat_paused() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.combat_paused)
  if (event_case() == kCombatPaused) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::CombatPausedEvent*>(_impl_.event_.combat_paused_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.combat_paused_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::CombatPausedEvent& EncounterEvent::_internal_combat_paused() const {
  return event_case() == kCombatPaused ? static_cast<const ::dnd5e::api::v1alpha1::CombatPausedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::CombatPausedEvent*>(_impl_.event_.combat_paused_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatPausedEvent&>(::dnd5e::api::v1alpha1::_CombatPausedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatPausedEvent& EncounterEvent::combat_paused() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.combat_paused)
  return _internal_combat_paused();
}
inline ::dnd5e::api::v1alpha1::CombatPausedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_combat_paused() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.combat_paused)
  if (event_case() == kCombatPaused) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::CombatPausedEvent*>(_impl_.event_.combat_paused_);
    _impl_.event_.combat_paused_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_combat_paused(
    ::dnd5e::api::v1alpha1::CombatPausedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_combat_paused();
    _impl_.event_.combat_paused_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.combat_paused)
}
inline ::dnd5e::api::v1alpha1::CombatPausedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_combat_paused() {
  if (event_case() != kCombatPaused) {
    clear_event();
    set_has_combat_paused();
    _impl_.event_.combat_paused_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatPausedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::CombatPausedEvent*>(_impl_.event_.combat_paused_);
}
inline ::dnd5e::api::v1alpha1::CombatPausedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_combat_paused()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::CombatPausedEvent* _msg = _internal_mutable_combat_paused();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.combat_paused)
  return _msg;
}

// .dnd5e.api.v1alpha1.CombatResumedEvent combat_resumed = 33 [json_name = "combatResumed"];
inline bool EncounterEvent::has_combat_resumed() const {
  return event_case() == kCombatResumed;
}
inline bool EncounterEvent::_internal_has_combat_resumed() const {
  return event_case() == kCombatResumed;
}
inline void EncounterEvent::set_has_combat_resumed() {
  _impl_._oneof_case_[0] = kCombatResumed;
}
inline void EncounterEvent::clear_combat_resumed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kCombatResumed) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.combat_resumed_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.combat_resumed_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::CombatResumedEvent* PROTOBUF_NULLABLE EncounterEvent::release_combat_resumed() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.combat_resumed)
  if (event_case() == kCombatResumed) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::CombatResumedEvent*>(_impl_.event_.combat_resumed_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.combat_resumed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::CombatResumedEvent& EncounterEvent::_internal_combat_resumed() const {
  return event_case() == kCombatResumed ? static_cast<const ::dnd5e::api::v1alpha1::CombatResumedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::CombatResumedEvent*>(_impl_.event_.combat_resumed_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatResumedEvent&>(::dnd5e::api::v1alpha1::_CombatResumedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatResumedEvent& EncounterEvent::combat_resumed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.combat_resumed)
  return _internal_combat_resumed();
}
inline ::dnd5e::api::v1alpha1::CombatResumedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_combat_resumed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.combat_resumed)
  if (event_case() == kCombatResumed) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::CombatResumedEvent*>(_impl_.event_.combat_resumed_);
    _impl_.event_.combat_resumed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_combat_resumed(
    ::dnd5e::api::v1alpha1::CombatResumedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_combat_resumed();
    _impl_.event_.combat_resumed_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.combat_resumed)
}
inline ::dnd5e::api::v1alpha1::CombatResumedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_combat_resumed() {
  if (event_case() != kCombatResumed) {
    clear_event();
    set_has_combat_resumed();
    _impl_.event_.combat_resumed_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatResumedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::CombatResumedEvent*>(_impl_.event_.combat_resumed_);
}
inline ::dnd5e::api::v1alpha1::CombatResumedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_combat_resumed()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::CombatResumedEvent* _msg = _internal_mutable_combat_resumed();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.combat_resumed)
  return _msg;
}

// .dnd5e.api.v1alpha1.RoomRevealedEvent room_revealed = 40 [json_name = "roomRevealed"];
inline bool EncounterEvent::has_room_revealed() const {
  return event_case() == kRoomRevealed;
}
inline bool EncounterEvent::_internal_has_room_revealed() const {
  return event_case() == kRoomRevealed;
}
inline void EncounterEvent::set_has_room_revealed() {
  _impl_._oneof_case_[0] = kRoomRevealed;
}
inline void EncounterEvent::clear_room_revealed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kRoomRevealed) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.room_revealed_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.room_revealed_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::RoomRevealedEvent* PROTOBUF_NULLABLE EncounterEvent::release_room_revealed() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.room_revealed)
  if (event_case() == kRoomRevealed) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::RoomRevealedEvent*>(_impl_.event_.room_revealed_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.room_revealed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::RoomRevealedEvent& EncounterEvent::_internal_room_revealed() const {
  return event_case() == kRoomRevealed ? static_cast<const ::dnd5e::api::v1alpha1::RoomRevealedEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::RoomRevealedEvent*>(_impl_.event_.room_revealed_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::RoomRevealedEvent&>(::dnd5e::api::v1alpha1::_RoomRevealedEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::RoomRevealedEvent& EncounterEvent::room_revealed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.room_revealed)
  return _internal_room_revealed();
}
inline ::dnd5e::api::v1alpha1::RoomRevealedEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_room_revealed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.room_revealed)
  if (event_case() == kRoomRevealed) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::RoomRevealedEvent*>(_impl_.event_.room_revealed_);
    _impl_.event_.room_revealed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_room_revealed(
    ::dnd5e::api::v1alpha1::RoomRevealedEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_room_revealed();
    _impl_.event_.room_revealed_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.room_revealed)
}
inline ::dnd5e::api::v1alpha1::RoomRevealedEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_room_revealed() {
  if (event_case() != kRoomRevealed) {
    clear_event();
    set_has_room_revealed();
    _impl_.event_.room_revealed_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::RoomRevealedEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::RoomRevealedEvent*>(_impl_.event_.room_revealed_);
}
inline ::dnd5e::api::v1alpha1::RoomRevealedEvent* PROTOBUF_NONNULL EncounterEvent::mutable_room_revealed()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::RoomRevealedEvent* _msg = _internal_mutable_room_revealed();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.room_revealed)
  return _msg;
}

// .dnd5e.api.v1alpha1.DungeonVictoryEvent dungeon_victory = 41 [json_name = "dungeonVictory"];
inline bool EncounterEvent::has_dungeon_victory() const {
  return event_case() == kDungeonVictory;
}
inline bool EncounterEvent::_internal_has_dungeon_victory() const {
  return event_case() == kDungeonVictory;
}
inline void EncounterEvent::set_has_dungeon_victory() {
  _impl_._oneof_case_[0] = kDungeonVictory;
}
inline void EncounterEvent::clear_dungeon_victory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kDungeonVictory) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.dungeon_victory_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.dungeon_victory_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::DungeonVictoryEvent* PROTOBUF_NULLABLE EncounterEvent::release_dungeon_victory() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.dungeon_victory)
  if (event_case() == kDungeonVictory) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::DungeonVictoryEvent*>(_impl_.event_.dungeon_victory_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.dungeon_victory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::DungeonVictoryEvent& EncounterEvent::_internal_dungeon_victory() const {
  return event_case() == kDungeonVictory ? static_cast<const ::dnd5e::api::v1alpha1::DungeonVictoryEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::DungeonVictoryEvent*>(_impl_.event_.dungeon_victory_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::DungeonVictoryEvent&>(::dnd5e::api::v1alpha1::_DungeonVictoryEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::DungeonVictoryEvent& EncounterEvent::dungeon_victory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.dungeon_victory)
  return _internal_dungeon_victory();
}
inline ::dnd5e::api::v1alpha1::DungeonVictoryEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_dungeon_victory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.dungeon_victory)
  if (event_case() == kDungeonVictory) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::DungeonVictoryEvent*>(_impl_.event_.dungeon_victory_);
    _impl_.event_.dungeon_victory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_dungeon_victory(
    ::dnd5e::api::v1alpha1::DungeonVictoryEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_dungeon_victory();
    _impl_.event_.dungeon_victory_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.dungeon_victory)
}
inline ::dnd5e::api::v1alpha1::DungeonVictoryEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_dungeon_victory() {
  if (event_case() != kDungeonVictory) {
    clear_event();
    set_has_dungeon_victory();
    _impl_.event_.dungeon_victory_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::DungeonVictoryEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::DungeonVictoryEvent*>(_impl_.event_.dungeon_victory_);
}
inline ::dnd5e::api::v1alpha1::DungeonVictoryEvent* PROTOBUF_NONNULL EncounterEvent::mutable_dungeon_victory()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::DungeonVictoryEvent* _msg = _internal_mutable_dungeon_victory();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.dungeon_victory)
  return _msg;
}

// .dnd5e.api.v1alpha1.DungeonFailureEvent dungeon_failure = 42 [json_name = "dungeonFailure"];
inline bool EncounterEvent::has_dungeon_failure() const {
  return event_case() == kDungeonFailure;
}
inline bool EncounterEvent::_internal_has_dungeon_failure() const {
  return event_case() == kDungeonFailure;
}
inline void EncounterEvent::set_has_dungeon_failure() {
  _impl_._oneof_case_[0] = kDungeonFailure;
}
inline void EncounterEvent::clear_dungeon_failure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kDungeonFailure) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.dungeon_failure_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.dungeon_failure_);
    }
    clear_has_event();
  }
}
inline ::dnd5e::api::v1alpha1::DungeonFailureEvent* PROTOBUF_NULLABLE EncounterEvent::release_dungeon_failure() {
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.EncounterEvent.dungeon_failure)
  if (event_case() == kDungeonFailure) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::DungeonFailureEvent*>(_impl_.event_.dungeon_failure_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.dungeon_failure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dnd5e::api::v1alpha1::DungeonFailureEvent& EncounterEvent::_internal_dungeon_failure() const {
  return event_case() == kDungeonFailure ? static_cast<const ::dnd5e::api::v1alpha1::DungeonFailureEvent&>(*reinterpret_cast<::dnd5e::api::v1alpha1::DungeonFailureEvent*>(_impl_.event_.dungeon_failure_))
                     : reinterpret_cast<const ::dnd5e::api::v1alpha1::DungeonFailureEvent&>(::dnd5e::api::v1alpha1::_DungeonFailureEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::DungeonFailureEvent& EncounterEvent::dungeon_failure() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.EncounterEvent.dungeon_failure)
  return _internal_dungeon_failure();
}
inline ::dnd5e::api::v1alpha1::DungeonFailureEvent* PROTOBUF_NULLABLE EncounterEvent::unsafe_arena_release_dungeon_failure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dnd5e.api.v1alpha1.EncounterEvent.dungeon_failure)
  if (event_case() == kDungeonFailure) {
    clear_has_event();
    auto* temp = reinterpret_cast<::dnd5e::api::v1alpha1::DungeonFailureEvent*>(_impl_.event_.dungeon_failure_);
    _impl_.event_.dungeon_failure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncounterEvent::unsafe_arena_set_allocated_dungeon_failure(
    ::dnd5e::api::v1alpha1::DungeonFailureEvent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_dungeon_failure();
    _impl_.event_.dungeon_failure_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.EncounterEvent.dungeon_failure)
}
inline ::dnd5e::api::v1alpha1::DungeonFailureEvent* PROTOBUF_NONNULL EncounterEvent::_internal_mutable_dungeon_failure() {
  if (event_case() != kDungeonFailure) {
    clear_event();
    set_has_dungeon_failure();
    _impl_.event_.dungeon_failure_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::DungeonFailureEvent>(GetArena()));
  }
  return reinterpret_cast<::dnd5e::api::v1alpha1::DungeonFailureEvent*>(_impl_.event_.dungeon_failure_);
}
inline ::dnd5e::api::v1alpha1::DungeonFailureEvent* PROTOBUF_NONNULL EncounterEvent::mutable_dungeon_failure()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dnd5e::api::v1alpha1::DungeonFailureEvent* _msg = _internal_mutable_dungeon_failure();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.EncounterEvent.dungeon_failure)
  return _msg;
}

inline bool EncounterEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void EncounterEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline EncounterEvent::EventCase EncounterEvent::event_case() const {
  return EncounterEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlayerJoinedEvent

// .dnd5e.api.v1alpha1.PartyMember member = 1 [json_name = "member"];
inline bool PlayerJoinedEvent::has_member() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.member_ != nullptr);
  return value;
}
inline void PlayerJoinedEvent::clear_member() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.member_ != nullptr) _impl_.member_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::dnd5e::api::v1alpha1::PartyMember& PlayerJoinedEvent::_internal_member() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::PartyMember* p = _impl_.member_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::PartyMember&>(::dnd5e::api::v1alpha1::_PartyMember_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::PartyMember& PlayerJoinedEvent::member() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PlayerJoinedEvent.member)
  return _internal_member();
}
inline void PlayerJoinedEvent::unsafe_arena_set_allocated_member(
    ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.member_);
  }
  _impl_.member_ = reinterpret_cast<::dnd5e::api::v1alpha1::PartyMember*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.PlayerJoinedEvent.member)
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE PlayerJoinedEvent::release_member() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::PartyMember* released = _impl_.member_;
  _impl_.member_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE PlayerJoinedEvent::unsafe_arena_release_member() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.PlayerJoinedEvent.member)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::PartyMember* temp = _impl_.member_;
  _impl_.member_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL PlayerJoinedEvent::_internal_mutable_member() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.member_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::PartyMember>(GetArena());
    _impl_.member_ = reinterpret_cast<::dnd5e::api::v1alpha1::PartyMember*>(p);
  }
  return _impl_.member_;
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL PlayerJoinedEvent::mutable_member()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::PartyMember* _msg = _internal_mutable_member();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.PlayerJoinedEvent.member)
  return _msg;
}
inline void PlayerJoinedEvent::set_allocated_member(::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.member_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.member_ = reinterpret_cast<::dnd5e::api::v1alpha1::PartyMember*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.PlayerJoinedEvent.member)
}

// -------------------------------------------------------------------

// PlayerLeftEvent

// string player_id = 1 [json_name = "playerId"];
inline void PlayerLeftEvent::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PlayerLeftEvent::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PlayerLeftEvent.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PlayerLeftEvent::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.PlayerLeftEvent.player_id)
}
inline ::std::string* PROTOBUF_NONNULL PlayerLeftEvent::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.PlayerLeftEvent.player_id)
  return _s;
}
inline const ::std::string& PlayerLeftEvent::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void PlayerLeftEvent::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PlayerLeftEvent::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PlayerLeftEvent::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.PlayerLeftEvent.player_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void PlayerLeftEvent::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.PlayerLeftEvent.player_id)
}

// string character_id = 2 [json_name = "characterId"];
inline void PlayerLeftEvent::clear_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& PlayerLeftEvent::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PlayerLeftEvent.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PlayerLeftEvent::set_character_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.PlayerLeftEvent.character_id)
}
inline ::std::string* PROTOBUF_NONNULL PlayerLeftEvent::mutable_character_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.PlayerLeftEvent.character_id)
  return _s;
}
inline const ::std::string& PlayerLeftEvent::_internal_character_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_id_.Get();
}
inline void PlayerLeftEvent::_internal_set_character_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PlayerLeftEvent::_internal_mutable_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.character_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PlayerLeftEvent::release_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.PlayerLeftEvent.character_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.character_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.character_id_.Set("", GetArena());
  }
  return released;
}
inline void PlayerLeftEvent::set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.character_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.PlayerLeftEvent.character_id)
}

// -------------------------------------------------------------------

// PlayerReadyEvent

// string player_id = 1 [json_name = "playerId"];
inline void PlayerReadyEvent::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PlayerReadyEvent::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PlayerReadyEvent.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PlayerReadyEvent::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.PlayerReadyEvent.player_id)
}
inline ::std::string* PROTOBUF_NONNULL PlayerReadyEvent::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.PlayerReadyEvent.player_id)
  return _s;
}
inline const ::std::string& PlayerReadyEvent::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void PlayerReadyEvent::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PlayerReadyEvent::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PlayerReadyEvent::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.PlayerReadyEvent.player_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void PlayerReadyEvent::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.PlayerReadyEvent.player_id)
}

// bool is_ready = 2 [json_name = "isReady"];
inline void PlayerReadyEvent::clear_is_ready() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ready_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool PlayerReadyEvent::is_ready() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PlayerReadyEvent.is_ready)
  return _internal_is_ready();
}
inline void PlayerReadyEvent::set_is_ready(bool value) {
  _internal_set_is_ready(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.PlayerReadyEvent.is_ready)
}
inline bool PlayerReadyEvent::_internal_is_ready() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_ready_;
}
inline void PlayerReadyEvent::_internal_set_is_ready(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ready_ = value;
}

// -------------------------------------------------------------------

// CombatStartedEvent

// .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
inline bool CombatStartedEvent::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void CombatStartedEvent::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& CombatStartedEvent::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& CombatStartedEvent::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStartedEvent.combat_state)
  return _internal_combat_state();
}
inline void CombatStartedEvent::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CombatStartedEvent.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE CombatStartedEvent::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE CombatStartedEvent::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatStartedEvent.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL CombatStartedEvent::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL CombatStartedEvent::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatStartedEvent.combat_state)
  return _msg;
}
inline void CombatStartedEvent::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatStartedEvent.combat_state)
}

// .dnd5e.api.v1alpha1.Room room = 2 [json_name = "room"];
inline bool CombatStartedEvent::has_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void CombatStartedEvent::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::dnd5e::api::v1alpha1::Room& CombatStartedEvent::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& CombatStartedEvent::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStartedEvent.room)
  return _internal_room();
}
inline void CombatStartedEvent::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CombatStartedEvent.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE CombatStartedEvent::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE CombatStartedEvent::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatStartedEvent.room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL CombatStartedEvent::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL CombatStartedEvent::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatStartedEvent.room)
  return _msg;
}
inline void CombatStartedEvent::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatStartedEvent.room)
}

// repeated .dnd5e.api.v1alpha1.PartyMember party = 3 [json_name = "party"];
inline int CombatStartedEvent::_internal_party_size() const {
  return _internal_party().size();
}
inline int CombatStartedEvent::party_size() const {
  return _internal_party_size();
}
inline void CombatStartedEvent::clear_party() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.party_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL CombatStartedEvent::mutable_party(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatStartedEvent.party)
  return _internal_mutable_party()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>* PROTOBUF_NONNULL CombatStartedEvent::mutable_party()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.CombatStartedEvent.party)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_party();
}
inline const ::dnd5e::api::v1alpha1::PartyMember& CombatStartedEvent::party(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStartedEvent.party)
  return _internal_party().Get(index);
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL CombatStartedEvent::add_party()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::PartyMember* _add =
      _internal_mutable_party()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.CombatStartedEvent.party)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>& CombatStartedEvent::party() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.CombatStartedEvent.party)
  return _internal_party();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>&
CombatStartedEvent::_internal_party() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.party_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::PartyMember>* PROTOBUF_NONNULL
CombatStartedEvent::_internal_mutable_party() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.party_;
}

// repeated .dnd5e.api.v1alpha1.MonsterCombatState monsters = 4 [json_name = "monsters"];
inline int CombatStartedEvent::_internal_monsters_size() const {
  return _internal_monsters().size();
}
inline int CombatStartedEvent::monsters_size() const {
  return _internal_monsters_size();
}
inline void CombatStartedEvent::clear_monsters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monsters_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::dnd5e::api::v1alpha1::MonsterCombatState* PROTOBUF_NONNULL CombatStartedEvent::mutable_monsters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatStartedEvent.monsters)
  return _internal_mutable_monsters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>* PROTOBUF_NONNULL CombatStartedEvent::mutable_monsters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.CombatStartedEvent.monsters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_monsters();
}
inline const ::dnd5e::api::v1alpha1::MonsterCombatState& CombatStartedEvent::monsters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStartedEvent.monsters)
  return _internal_monsters().Get(index);
}
inline ::dnd5e::api::v1alpha1::MonsterCombatState* PROTOBUF_NONNULL CombatStartedEvent::add_monsters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::MonsterCombatState* _add =
      _internal_mutable_monsters()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.CombatStartedEvent.monsters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>& CombatStartedEvent::monsters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.CombatStartedEvent.monsters)
  return _internal_monsters();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>&
CombatStartedEvent::_internal_monsters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monsters_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterCombatState>* PROTOBUF_NONNULL
CombatStartedEvent::_internal_mutable_monsters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.monsters_;
}

// repeated .dnd5e.api.v1alpha1.DoorInfo doors = 5 [json_name = "doors"];
inline int CombatStartedEvent::_internal_doors_size() const {
  return _internal_doors().size();
}
inline int CombatStartedEvent::doors_size() const {
  return _internal_doors_size();
}
inline void CombatStartedEvent::clear_doors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.doors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL CombatStartedEvent::mutable_doors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatStartedEvent.doors)
  return _internal_mutable_doors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL CombatStartedEvent::mutable_doors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.CombatStartedEvent.doors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_doors();
}
inline const ::dnd5e::api::v1alpha1::DoorInfo& CombatStartedEvent::doors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStartedEvent.doors)
  return _internal_doors().Get(index);
}
inline ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL CombatStartedEvent::add_doors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::DoorInfo* _add =
      _internal_mutable_doors()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.CombatStartedEvent.doors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& CombatStartedEvent::doors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.CombatStartedEvent.doors)
  return _internal_doors();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>&
CombatStartedEvent::_internal_doors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.doors_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL
CombatStartedEvent::_internal_mutable_doors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.doors_;
}

// string dungeon_id = 6 [json_name = "dungeonId"];
inline void CombatStartedEvent::clear_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::std::string& CombatStartedEvent::dungeon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStartedEvent.dungeon_id)
  return _internal_dungeon_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CombatStartedEvent::set_dungeon_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  _impl_.dungeon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatStartedEvent.dungeon_id)
}
inline ::std::string* PROTOBUF_NONNULL CombatStartedEvent::mutable_dungeon_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::std::string* _s = _internal_mutable_dungeon_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatStartedEvent.dungeon_id)
  return _s;
}
inline const ::std::string& CombatStartedEvent::_internal_dungeon_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dungeon_id_.Get();
}
inline void CombatStartedEvent::_internal_set_dungeon_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CombatStartedEvent::_internal_mutable_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dungeon_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CombatStartedEvent::release_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatStartedEvent.dungeon_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000010U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  auto* released = _impl_.dungeon_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  return released;
}
inline void CombatStartedEvent::set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  _impl_.dungeon_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dungeon_id_.IsDefault()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatStartedEvent.dungeon_id)
}

// repeated .dnd5e.api.v1alpha1.MonsterTurnResult monster_turns = 7 [json_name = "monsterTurns"];
inline int CombatStartedEvent::_internal_monster_turns_size() const {
  return _internal_monster_turns().size();
}
inline int CombatStartedEvent::monster_turns_size() const {
  return _internal_monster_turns_size();
}
inline void CombatStartedEvent::clear_monster_turns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monster_turns_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL CombatStartedEvent::mutable_monster_turns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatStartedEvent.monster_turns)
  return _internal_mutable_monster_turns()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL CombatStartedEvent::mutable_monster_turns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.CombatStartedEvent.monster_turns)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_monster_turns();
}
inline const ::dnd5e::api::v1alpha1::MonsterTurnResult& CombatStartedEvent::monster_turns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatStartedEvent.monster_turns)
  return _internal_monster_turns().Get(index);
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL CombatStartedEvent::add_monster_turns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::MonsterTurnResult* _add =
      _internal_mutable_monster_turns()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.CombatStartedEvent.monster_turns)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>& CombatStartedEvent::monster_turns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.CombatStartedEvent.monster_turns)
  return _internal_monster_turns();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>&
CombatStartedEvent::_internal_monster_turns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monster_turns_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::MonsterTurnResult>* PROTOBUF_NONNULL
CombatStartedEvent::_internal_mutable_monster_turns() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.monster_turns_;
}

// -------------------------------------------------------------------

// MovementCompletedEvent

// string entity_id = 1 [json_name = "entityId"];
inline void MovementCompletedEvent::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& MovementCompletedEvent::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MovementCompletedEvent.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MovementCompletedEvent::set_entity_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MovementCompletedEvent.entity_id)
}
inline ::std::string* PROTOBUF_NONNULL MovementCompletedEvent::mutable_entity_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MovementCompletedEvent.entity_id)
  return _s;
}
inline const ::std::string& MovementCompletedEvent::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void MovementCompletedEvent::_internal_set_entity_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MovementCompletedEvent::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MovementCompletedEvent::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MovementCompletedEvent.entity_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.entity_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  return released;
}
inline void MovementCompletedEvent::set_allocated_entity_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MovementCompletedEvent.entity_id)
}

// repeated .api.v1alpha1.Position path = 2 [json_name = "path"];
inline int MovementCompletedEvent::_internal_path_size() const {
  return _internal_path().size();
}
inline int MovementCompletedEvent::path_size() const {
  return _internal_path_size();
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MovementCompletedEvent::mutable_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MovementCompletedEvent.path)
  return _internal_mutable_path()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL MovementCompletedEvent::mutable_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.MovementCompletedEvent.path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_path();
}
inline const ::api::v1alpha1::Position& MovementCompletedEvent::path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MovementCompletedEvent.path)
  return _internal_path().Get(index);
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MovementCompletedEvent::add_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::api::v1alpha1::Position* _add =
      _internal_mutable_path()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.MovementCompletedEvent.path)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>& MovementCompletedEvent::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.MovementCompletedEvent.path)
  return _internal_path();
}
inline const ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>&
MovementCompletedEvent::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_;
}
inline ::google::protobuf::RepeatedPtrField<::api::v1alpha1::Position>* PROTOBUF_NONNULL
MovementCompletedEvent::_internal_mutable_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.path_;
}

// .api.v1alpha1.Position final_position = 3 [json_name = "finalPosition"];
inline bool MovementCompletedEvent::has_final_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.final_position_ != nullptr);
  return value;
}
inline const ::api::v1alpha1::Position& MovementCompletedEvent::_internal_final_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::api::v1alpha1::Position* p = _impl_.final_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::api::v1alpha1::Position&>(::api::v1alpha1::_Position_default_instance_);
}
inline const ::api::v1alpha1::Position& MovementCompletedEvent::final_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MovementCompletedEvent.final_position)
  return _internal_final_position();
}
inline void MovementCompletedEvent::unsafe_arena_set_allocated_final_position(
    ::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.final_position_);
  }
  _impl_.final_position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MovementCompletedEvent.final_position)
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE MovementCompletedEvent::release_final_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::api::v1alpha1::Position* released = _impl_.final_position_;
  _impl_.final_position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::api::v1alpha1::Position* PROTOBUF_NULLABLE MovementCompletedEvent::unsafe_arena_release_final_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MovementCompletedEvent.final_position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::api::v1alpha1::Position* temp = _impl_.final_position_;
  _impl_.final_position_ = nullptr;
  return temp;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MovementCompletedEvent::_internal_mutable_final_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.final_position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::api::v1alpha1::Position>(GetArena());
    _impl_.final_position_ = reinterpret_cast<::api::v1alpha1::Position*>(p);
  }
  return _impl_.final_position_;
}
inline ::api::v1alpha1::Position* PROTOBUF_NONNULL MovementCompletedEvent::mutable_final_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::api::v1alpha1::Position* _msg = _internal_mutable_final_position();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MovementCompletedEvent.final_position)
  return _msg;
}
inline void MovementCompletedEvent::set_allocated_final_position(::api::v1alpha1::Position* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.final_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.final_position_ = reinterpret_cast<::api::v1alpha1::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MovementCompletedEvent.final_position)
}

// int32 movement_remaining = 4 [json_name = "movementRemaining"];
inline void MovementCompletedEvent::clear_movement_remaining() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_remaining_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::int32_t MovementCompletedEvent::movement_remaining() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MovementCompletedEvent.movement_remaining)
  return _internal_movement_remaining();
}
inline void MovementCompletedEvent::set_movement_remaining(::int32_t value) {
  _internal_set_movement_remaining(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MovementCompletedEvent.movement_remaining)
}
inline ::int32_t MovementCompletedEvent::_internal_movement_remaining() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.movement_remaining_;
}
inline void MovementCompletedEvent::_internal_set_movement_remaining(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.movement_remaining_ = value;
}

// string stop_reason = 5 [json_name = "stopReason"];
inline void MovementCompletedEvent::clear_stop_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_reason_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& MovementCompletedEvent::stop_reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MovementCompletedEvent.stop_reason)
  return _internal_stop_reason();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MovementCompletedEvent::set_stop_reason(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.stop_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.MovementCompletedEvent.stop_reason)
}
inline ::std::string* PROTOBUF_NONNULL MovementCompletedEvent::mutable_stop_reason()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_stop_reason();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MovementCompletedEvent.stop_reason)
  return _s;
}
inline const ::std::string& MovementCompletedEvent::_internal_stop_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_reason_.Get();
}
inline void MovementCompletedEvent::_internal_set_stop_reason(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_reason_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL MovementCompletedEvent::_internal_mutable_stop_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.stop_reason_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE MovementCompletedEvent::release_stop_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MovementCompletedEvent.stop_reason)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.stop_reason_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stop_reason_.Set("", GetArena());
  }
  return released;
}
inline void MovementCompletedEvent::set_allocated_stop_reason(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.stop_reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stop_reason_.IsDefault()) {
    _impl_.stop_reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MovementCompletedEvent.stop_reason)
}

// .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
inline bool MovementCompletedEvent::has_updated_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.updated_room_ != nullptr);
  return value;
}
inline void MovementCompletedEvent::clear_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ != nullptr) _impl_.updated_room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::dnd5e::api::v1alpha1::Room& MovementCompletedEvent::_internal_updated_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.updated_room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& MovementCompletedEvent::updated_room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MovementCompletedEvent.updated_room)
  return _internal_updated_room();
}
inline void MovementCompletedEvent::unsafe_arena_set_allocated_updated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }
  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MovementCompletedEvent.updated_room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE MovementCompletedEvent::release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE MovementCompletedEvent::unsafe_arena_release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MovementCompletedEvent.updated_room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL MovementCompletedEvent::_internal_mutable_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.updated_room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL MovementCompletedEvent::mutable_updated_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_updated_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MovementCompletedEvent.updated_room)
  return _msg;
}
inline void MovementCompletedEvent::set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MovementCompletedEvent.updated_room)
}

// -------------------------------------------------------------------

// AttackResolvedEvent

// string attacker_id = 1 [json_name = "attackerId"];
inline void AttackResolvedEvent::clear_attacker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attacker_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& AttackResolvedEvent::attacker_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResolvedEvent.attacker_id)
  return _internal_attacker_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackResolvedEvent::set_attacker_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.attacker_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResolvedEvent.attacker_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackResolvedEvent::mutable_attacker_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_attacker_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResolvedEvent.attacker_id)
  return _s;
}
inline const ::std::string& AttackResolvedEvent::_internal_attacker_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attacker_id_.Get();
}
inline void AttackResolvedEvent::_internal_set_attacker_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attacker_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackResolvedEvent::_internal_mutable_attacker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.attacker_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackResolvedEvent::release_attacker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResolvedEvent.attacker_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.attacker_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.attacker_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackResolvedEvent::set_allocated_attacker_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.attacker_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.attacker_id_.IsDefault()) {
    _impl_.attacker_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResolvedEvent.attacker_id)
}

// string target_id = 2 [json_name = "targetId"];
inline void AttackResolvedEvent::clear_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& AttackResolvedEvent::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResolvedEvent.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AttackResolvedEvent::set_target_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.AttackResolvedEvent.target_id)
}
inline ::std::string* PROTOBUF_NONNULL AttackResolvedEvent::mutable_target_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResolvedEvent.target_id)
  return _s;
}
inline const ::std::string& AttackResolvedEvent::_internal_target_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_id_.Get();
}
inline void AttackResolvedEvent::_internal_set_target_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AttackResolvedEvent::_internal_mutable_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AttackResolvedEvent::release_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResolvedEvent.target_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.target_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.target_id_.Set("", GetArena());
  }
  return released;
}
inline void AttackResolvedEvent::set_allocated_target_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.target_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_id_.IsDefault()) {
    _impl_.target_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResolvedEvent.target_id)
}

// .dnd5e.api.v1alpha1.AttackResult result = 3 [json_name = "result"];
inline bool AttackResolvedEvent::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void AttackResolvedEvent::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::AttackResult& AttackResolvedEvent::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::AttackResult* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::AttackResult&>(::dnd5e::api::v1alpha1::_AttackResult_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::AttackResult& AttackResolvedEvent::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResolvedEvent.result)
  return _internal_result();
}
inline void AttackResolvedEvent::unsafe_arena_set_allocated_result(
    ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResult*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResolvedEvent.result)
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE AttackResolvedEvent::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::AttackResult* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE AttackResolvedEvent::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResolvedEvent.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::AttackResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL AttackResolvedEvent::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::AttackResult>(GetArena());
    _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResult*>(p);
  }
  return _impl_.result_;
}
inline ::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NONNULL AttackResolvedEvent::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::AttackResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResolvedEvent.result)
  return _msg;
}
inline void AttackResolvedEvent::set_allocated_result(::dnd5e::api::v1alpha1::AttackResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::AttackResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResolvedEvent.result)
}

// .dnd5e.api.v1alpha1.Character updated_attacker = 4 [json_name = "updatedAttacker"];
inline bool AttackResolvedEvent::has_updated_attacker() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.updated_attacker_ != nullptr);
  return value;
}
inline const ::dnd5e::api::v1alpha1::Character& AttackResolvedEvent::_internal_updated_attacker() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.updated_attacker_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& AttackResolvedEvent::updated_attacker() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_attacker)
  return _internal_updated_attacker();
}
inline void AttackResolvedEvent::unsafe_arena_set_allocated_updated_attacker(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_attacker_);
  }
  _impl_.updated_attacker_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_attacker)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE AttackResolvedEvent::release_updated_attacker() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Character* released = _impl_.updated_attacker_;
  _impl_.updated_attacker_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE AttackResolvedEvent::unsafe_arena_release_updated_attacker() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_attacker)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.updated_attacker_;
  _impl_.updated_attacker_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL AttackResolvedEvent::_internal_mutable_updated_attacker() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_attacker_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.updated_attacker_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.updated_attacker_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL AttackResolvedEvent::mutable_updated_attacker()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_updated_attacker();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_attacker)
  return _msg;
}
inline void AttackResolvedEvent::set_allocated_updated_attacker(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_attacker_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.updated_attacker_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_attacker)
}

// .dnd5e.api.v1alpha1.Character updated_target = 5 [json_name = "updatedTarget"];
inline bool AttackResolvedEvent::has_updated_target() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.updated_target_ != nullptr);
  return value;
}
inline const ::dnd5e::api::v1alpha1::Character& AttackResolvedEvent::_internal_updated_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.updated_target_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& AttackResolvedEvent::updated_target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_target)
  return _internal_updated_target();
}
inline void AttackResolvedEvent::unsafe_arena_set_allocated_updated_target(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_target_);
  }
  _impl_.updated_target_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_target)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE AttackResolvedEvent::release_updated_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Character* released = _impl_.updated_target_;
  _impl_.updated_target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE AttackResolvedEvent::unsafe_arena_release_updated_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_target)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.updated_target_;
  _impl_.updated_target_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL AttackResolvedEvent::_internal_mutable_updated_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.updated_target_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.updated_target_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL AttackResolvedEvent::mutable_updated_target()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_updated_target();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_target)
  return _msg;
}
inline void AttackResolvedEvent::set_allocated_updated_target(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.updated_target_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_target)
}

// .dnd5e.api.v1alpha1.Room updated_room = 6 [json_name = "updatedRoom"];
inline bool AttackResolvedEvent::has_updated_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.updated_room_ != nullptr);
  return value;
}
inline void AttackResolvedEvent::clear_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ != nullptr) _impl_.updated_room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::dnd5e::api::v1alpha1::Room& AttackResolvedEvent::_internal_updated_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.updated_room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& AttackResolvedEvent::updated_room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_room)
  return _internal_updated_room();
}
inline void AttackResolvedEvent::unsafe_arena_set_allocated_updated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }
  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE AttackResolvedEvent::release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE AttackResolvedEvent::unsafe_arena_release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL AttackResolvedEvent::_internal_mutable_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.updated_room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL AttackResolvedEvent::mutable_updated_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_updated_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_room)
  return _msg;
}
inline void AttackResolvedEvent::set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResolvedEvent.updated_room)
}

// .dnd5e.api.v1alpha1.GrantedAction granted_action = 7 [json_name = "grantedAction"];
inline bool AttackResolvedEvent::has_granted_action() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.granted_action_ != nullptr);
  return value;
}
inline void AttackResolvedEvent::clear_granted_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.granted_action_ != nullptr) _impl_.granted_action_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::dnd5e::api::v1alpha1::GrantedAction& AttackResolvedEvent::_internal_granted_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::GrantedAction* p = _impl_.granted_action_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::GrantedAction&>(::dnd5e::api::v1alpha1::_GrantedAction_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::GrantedAction& AttackResolvedEvent::granted_action() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.AttackResolvedEvent.granted_action)
  return _internal_granted_action();
}
inline void AttackResolvedEvent::unsafe_arena_set_allocated_granted_action(
    ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.granted_action_);
  }
  _impl_.granted_action_ = reinterpret_cast<::dnd5e::api::v1alpha1::GrantedAction*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.AttackResolvedEvent.granted_action)
}
inline ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE AttackResolvedEvent::release_granted_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::dnd5e::api::v1alpha1::GrantedAction* released = _impl_.granted_action_;
  _impl_.granted_action_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE AttackResolvedEvent::unsafe_arena_release_granted_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.AttackResolvedEvent.granted_action)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::dnd5e::api::v1alpha1::GrantedAction* temp = _impl_.granted_action_;
  _impl_.granted_action_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NONNULL AttackResolvedEvent::_internal_mutable_granted_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.granted_action_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::GrantedAction>(GetArena());
    _impl_.granted_action_ = reinterpret_cast<::dnd5e::api::v1alpha1::GrantedAction*>(p);
  }
  return _impl_.granted_action_;
}
inline ::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NONNULL AttackResolvedEvent::mutable_granted_action()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::dnd5e::api::v1alpha1::GrantedAction* _msg = _internal_mutable_granted_action();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.AttackResolvedEvent.granted_action)
  return _msg;
}
inline void AttackResolvedEvent::set_allocated_granted_action(::dnd5e::api::v1alpha1::GrantedAction* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.granted_action_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.granted_action_ = reinterpret_cast<::dnd5e::api::v1alpha1::GrantedAction*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.AttackResolvedEvent.granted_action)
}

// -------------------------------------------------------------------

// FeatureActivatedEvent

// string character_id = 1 [json_name = "characterId"];
inline void FeatureActivatedEvent::clear_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& FeatureActivatedEvent::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FeatureActivatedEvent.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FeatureActivatedEvent::set_character_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FeatureActivatedEvent.character_id)
}
inline ::std::string* PROTOBUF_NONNULL FeatureActivatedEvent::mutable_character_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.FeatureActivatedEvent.character_id)
  return _s;
}
inline const ::std::string& FeatureActivatedEvent::_internal_character_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_id_.Get();
}
inline void FeatureActivatedEvent::_internal_set_character_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FeatureActivatedEvent::_internal_mutable_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.character_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FeatureActivatedEvent::release_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.FeatureActivatedEvent.character_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.character_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.character_id_.Set("", GetArena());
  }
  return released;
}
inline void FeatureActivatedEvent::set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.character_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.FeatureActivatedEvent.character_id)
}

// string feature_id = 2 [json_name = "featureId"];
inline void FeatureActivatedEvent::clear_feature_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& FeatureActivatedEvent::feature_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FeatureActivatedEvent.feature_id)
  return _internal_feature_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FeatureActivatedEvent::set_feature_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.feature_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FeatureActivatedEvent.feature_id)
}
inline ::std::string* PROTOBUF_NONNULL FeatureActivatedEvent::mutable_feature_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_feature_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.FeatureActivatedEvent.feature_id)
  return _s;
}
inline const ::std::string& FeatureActivatedEvent::_internal_feature_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.feature_id_.Get();
}
inline void FeatureActivatedEvent::_internal_set_feature_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feature_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FeatureActivatedEvent::_internal_mutable_feature_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.feature_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FeatureActivatedEvent::release_feature_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.FeatureActivatedEvent.feature_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.feature_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.feature_id_.Set("", GetArena());
  }
  return released;
}
inline void FeatureActivatedEvent::set_allocated_feature_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.feature_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.feature_id_.IsDefault()) {
    _impl_.feature_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.FeatureActivatedEvent.feature_id)
}

// string message = 3 [json_name = "message"];
inline void FeatureActivatedEvent::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& FeatureActivatedEvent::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FeatureActivatedEvent.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FeatureActivatedEvent::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.FeatureActivatedEvent.message)
}
inline ::std::string* PROTOBUF_NONNULL FeatureActivatedEvent::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.FeatureActivatedEvent.message)
  return _s;
}
inline const ::std::string& FeatureActivatedEvent::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void FeatureActivatedEvent::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FeatureActivatedEvent::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FeatureActivatedEvent::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.FeatureActivatedEvent.message)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void FeatureActivatedEvent::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.FeatureActivatedEvent.message)
}

// .dnd5e.api.v1alpha1.Character updated_character = 4 [json_name = "updatedCharacter"];
inline bool FeatureActivatedEvent::has_updated_character() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.updated_character_ != nullptr);
  return value;
}
inline const ::dnd5e::api::v1alpha1::Character& FeatureActivatedEvent::_internal_updated_character() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Character* p = _impl_.updated_character_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Character&>(::dnd5e::api::v1alpha1::_Character_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Character& FeatureActivatedEvent::updated_character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.FeatureActivatedEvent.updated_character)
  return _internal_updated_character();
}
inline void FeatureActivatedEvent::unsafe_arena_set_allocated_updated_character(
    ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_character_);
  }
  _impl_.updated_character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.FeatureActivatedEvent.updated_character)
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE FeatureActivatedEvent::release_updated_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Character* released = _impl_.updated_character_;
  _impl_.updated_character_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE FeatureActivatedEvent::unsafe_arena_release_updated_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.FeatureActivatedEvent.updated_character)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Character* temp = _impl_.updated_character_;
  _impl_.updated_character_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL FeatureActivatedEvent::_internal_mutable_updated_character() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_character_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Character>(GetArena());
    _impl_.updated_character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(p);
  }
  return _impl_.updated_character_;
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL FeatureActivatedEvent::mutable_updated_character()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Character* _msg = _internal_mutable_updated_character();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.FeatureActivatedEvent.updated_character)
  return _msg;
}
inline void FeatureActivatedEvent::set_allocated_updated_character(::dnd5e::api::v1alpha1::Character* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.updated_character_ = reinterpret_cast<::dnd5e::api::v1alpha1::Character*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.FeatureActivatedEvent.updated_character)
}

// -------------------------------------------------------------------

// TurnEndedEvent

// .dnd5e.api.v1alpha1.TurnChangeEvent turn_change = 1 [json_name = "turnChange"];
inline bool TurnEndedEvent::has_turn_change() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.turn_change_ != nullptr);
  return value;
}
inline void TurnEndedEvent::clear_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.turn_change_ != nullptr) _impl_.turn_change_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::dnd5e::api::v1alpha1::TurnChangeEvent& TurnEndedEvent::_internal_turn_change() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::TurnChangeEvent* p = _impl_.turn_change_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::TurnChangeEvent&>(::dnd5e::api::v1alpha1::_TurnChangeEvent_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::TurnChangeEvent& TurnEndedEvent::turn_change() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnEndedEvent.turn_change)
  return _internal_turn_change();
}
inline void TurnEndedEvent::unsafe_arena_set_allocated_turn_change(
    ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.turn_change_);
  }
  _impl_.turn_change_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnChangeEvent*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.TurnEndedEvent.turn_change)
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE TurnEndedEvent::release_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* released = _impl_.turn_change_;
  _impl_.turn_change_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE TurnEndedEvent::unsafe_arena_release_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnEndedEvent.turn_change)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* temp = _impl_.turn_change_;
  _impl_.turn_change_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL TurnEndedEvent::_internal_mutable_turn_change() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.turn_change_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::TurnChangeEvent>(GetArena());
    _impl_.turn_change_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnChangeEvent*>(p);
  }
  return _impl_.turn_change_;
}
inline ::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NONNULL TurnEndedEvent::mutable_turn_change()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::TurnChangeEvent* _msg = _internal_mutable_turn_change();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnEndedEvent.turn_change)
  return _msg;
}
inline void TurnEndedEvent::set_allocated_turn_change(::dnd5e::api::v1alpha1::TurnChangeEvent* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.turn_change_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.turn_change_ = reinterpret_cast<::dnd5e::api::v1alpha1::TurnChangeEvent*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnEndedEvent.turn_change)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 2 [json_name = "combatState"];
inline bool TurnEndedEvent::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void TurnEndedEvent::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& TurnEndedEvent::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& TurnEndedEvent::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnEndedEvent.combat_state)
  return _internal_combat_state();
}
inline void TurnEndedEvent::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.TurnEndedEvent.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE TurnEndedEvent::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE TurnEndedEvent::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnEndedEvent.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL TurnEndedEvent::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL TurnEndedEvent::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnEndedEvent.combat_state)
  return _msg;
}
inline void TurnEndedEvent::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnEndedEvent.combat_state)
}

// .dnd5e.api.v1alpha1.Room updated_room = 3 [json_name = "updatedRoom"];
inline bool TurnEndedEvent::has_updated_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.updated_room_ != nullptr);
  return value;
}
inline void TurnEndedEvent::clear_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ != nullptr) _impl_.updated_room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::Room& TurnEndedEvent::_internal_updated_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.updated_room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& TurnEndedEvent::updated_room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.TurnEndedEvent.updated_room)
  return _internal_updated_room();
}
inline void TurnEndedEvent::unsafe_arena_set_allocated_updated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }
  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.TurnEndedEvent.updated_room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE TurnEndedEvent::release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE TurnEndedEvent::unsafe_arena_release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.TurnEndedEvent.updated_room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL TurnEndedEvent::_internal_mutable_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.updated_room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL TurnEndedEvent::mutable_updated_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_updated_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.TurnEndedEvent.updated_room)
  return _msg;
}
inline void TurnEndedEvent::set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.TurnEndedEvent.updated_room)
}

// -------------------------------------------------------------------

// MonsterTurnCompletedEvent

// .dnd5e.api.v1alpha1.MonsterTurnResult monster_turn = 1 [json_name = "monsterTurn"];
inline bool MonsterTurnCompletedEvent::has_monster_turn() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.monster_turn_ != nullptr);
  return value;
}
inline void MonsterTurnCompletedEvent::clear_monster_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.monster_turn_ != nullptr) _impl_.monster_turn_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::MonsterTurnResult& MonsterTurnCompletedEvent::_internal_monster_turn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::MonsterTurnResult* p = _impl_.monster_turn_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::MonsterTurnResult&>(::dnd5e::api::v1alpha1::_MonsterTurnResult_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::MonsterTurnResult& MonsterTurnCompletedEvent::monster_turn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.monster_turn)
  return _internal_monster_turn();
}
inline void MonsterTurnCompletedEvent::unsafe_arena_set_allocated_monster_turn(
    ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.monster_turn_);
  }
  _impl_.monster_turn_ = reinterpret_cast<::dnd5e::api::v1alpha1::MonsterTurnResult*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.monster_turn)
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NULLABLE MonsterTurnCompletedEvent::release_monster_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::MonsterTurnResult* released = _impl_.monster_turn_;
  _impl_.monster_turn_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NULLABLE MonsterTurnCompletedEvent::unsafe_arena_release_monster_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.monster_turn)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::MonsterTurnResult* temp = _impl_.monster_turn_;
  _impl_.monster_turn_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL MonsterTurnCompletedEvent::_internal_mutable_monster_turn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.monster_turn_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::MonsterTurnResult>(GetArena());
    _impl_.monster_turn_ = reinterpret_cast<::dnd5e::api::v1alpha1::MonsterTurnResult*>(p);
  }
  return _impl_.monster_turn_;
}
inline ::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NONNULL MonsterTurnCompletedEvent::mutable_monster_turn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::MonsterTurnResult* _msg = _internal_mutable_monster_turn();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.monster_turn)
  return _msg;
}
inline void MonsterTurnCompletedEvent::set_allocated_monster_turn(::dnd5e::api::v1alpha1::MonsterTurnResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.monster_turn_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.monster_turn_ = reinterpret_cast<::dnd5e::api::v1alpha1::MonsterTurnResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.monster_turn)
}

// repeated .dnd5e.api.v1alpha1.Character updated_characters = 2 [json_name = "updatedCharacters"];
inline int MonsterTurnCompletedEvent::_internal_updated_characters_size() const {
  return _internal_updated_characters().size();
}
inline int MonsterTurnCompletedEvent::updated_characters_size() const {
  return _internal_updated_characters_size();
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL MonsterTurnCompletedEvent::mutable_updated_characters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.updated_characters)
  return _internal_mutable_updated_characters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>* PROTOBUF_NONNULL MonsterTurnCompletedEvent::mutable_updated_characters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.updated_characters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_updated_characters();
}
inline const ::dnd5e::api::v1alpha1::Character& MonsterTurnCompletedEvent::updated_characters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.updated_characters)
  return _internal_updated_characters().Get(index);
}
inline ::dnd5e::api::v1alpha1::Character* PROTOBUF_NONNULL MonsterTurnCompletedEvent::add_updated_characters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::Character* _add =
      _internal_mutable_updated_characters()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.updated_characters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>& MonsterTurnCompletedEvent::updated_characters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.updated_characters)
  return _internal_updated_characters();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>&
MonsterTurnCompletedEvent::_internal_updated_characters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_characters_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::Character>* PROTOBUF_NONNULL
MonsterTurnCompletedEvent::_internal_mutable_updated_characters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.updated_characters_;
}

// .dnd5e.api.v1alpha1.Room updated_room = 3 [json_name = "updatedRoom"];
inline bool MonsterTurnCompletedEvent::has_updated_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.updated_room_ != nullptr);
  return value;
}
inline void MonsterTurnCompletedEvent::clear_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ != nullptr) _impl_.updated_room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::dnd5e::api::v1alpha1::Room& MonsterTurnCompletedEvent::_internal_updated_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.updated_room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& MonsterTurnCompletedEvent::updated_room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.updated_room)
  return _internal_updated_room();
}
inline void MonsterTurnCompletedEvent::unsafe_arena_set_allocated_updated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }
  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.updated_room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE MonsterTurnCompletedEvent::release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE MonsterTurnCompletedEvent::unsafe_arena_release_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.updated_room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.updated_room_;
  _impl_.updated_room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL MonsterTurnCompletedEvent::_internal_mutable_updated_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.updated_room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL MonsterTurnCompletedEvent::mutable_updated_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_updated_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.updated_room)
  return _msg;
}
inline void MonsterTurnCompletedEvent::set_allocated_updated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.updated_room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.MonsterTurnCompletedEvent.updated_room)
}

// -------------------------------------------------------------------

// CombatEndedEvent

// .dnd5e.api.v1alpha1.EncounterResult result = 1 [json_name = "result"];
inline bool CombatEndedEvent::has_result() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void CombatEndedEvent::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::dnd5e::api::v1alpha1::EncounterResult& CombatEndedEvent::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::EncounterResult* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::EncounterResult&>(::dnd5e::api::v1alpha1::_EncounterResult_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::EncounterResult& CombatEndedEvent::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatEndedEvent.result)
  return _internal_result();
}
inline void CombatEndedEvent::unsafe_arena_set_allocated_result(
    ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::EncounterResult*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CombatEndedEvent.result)
}
inline ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE CombatEndedEvent::release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::EncounterResult* released = _impl_.result_;
  _impl_.result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE CombatEndedEvent::unsafe_arena_release_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatEndedEvent.result)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::EncounterResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NONNULL CombatEndedEvent::_internal_mutable_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::EncounterResult>(GetArena());
    _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::EncounterResult*>(p);
  }
  return _impl_.result_;
}
inline ::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NONNULL CombatEndedEvent::mutable_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::EncounterResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatEndedEvent.result)
  return _msg;
}
inline void CombatEndedEvent::set_allocated_result(::dnd5e::api::v1alpha1::EncounterResult* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.result_ = reinterpret_cast<::dnd5e::api::v1alpha1::EncounterResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatEndedEvent.result)
}

// -------------------------------------------------------------------

// PlayerDisconnectedEvent

// string player_id = 1 [json_name = "playerId"];
inline void PlayerDisconnectedEvent::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PlayerDisconnectedEvent::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PlayerDisconnectedEvent.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PlayerDisconnectedEvent::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.PlayerDisconnectedEvent.player_id)
}
inline ::std::string* PROTOBUF_NONNULL PlayerDisconnectedEvent::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.PlayerDisconnectedEvent.player_id)
  return _s;
}
inline const ::std::string& PlayerDisconnectedEvent::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void PlayerDisconnectedEvent::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PlayerDisconnectedEvent::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PlayerDisconnectedEvent::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.PlayerDisconnectedEvent.player_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void PlayerDisconnectedEvent::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.PlayerDisconnectedEvent.player_id)
}

// string character_id = 2 [json_name = "characterId"];
inline void PlayerDisconnectedEvent::clear_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& PlayerDisconnectedEvent::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PlayerDisconnectedEvent.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PlayerDisconnectedEvent::set_character_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.PlayerDisconnectedEvent.character_id)
}
inline ::std::string* PROTOBUF_NONNULL PlayerDisconnectedEvent::mutable_character_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.PlayerDisconnectedEvent.character_id)
  return _s;
}
inline const ::std::string& PlayerDisconnectedEvent::_internal_character_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.character_id_.Get();
}
inline void PlayerDisconnectedEvent::_internal_set_character_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.character_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PlayerDisconnectedEvent::_internal_mutable_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.character_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PlayerDisconnectedEvent::release_character_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.PlayerDisconnectedEvent.character_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.character_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.character_id_.Set("", GetArena());
  }
  return released;
}
inline void PlayerDisconnectedEvent::set_allocated_character_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.character_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.PlayerDisconnectedEvent.character_id)
}

// -------------------------------------------------------------------

// PlayerReconnectedEvent

// string player_id = 1 [json_name = "playerId"];
inline void PlayerReconnectedEvent::clear_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PlayerReconnectedEvent::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PlayerReconnectedEvent.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PlayerReconnectedEvent::set_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.PlayerReconnectedEvent.player_id)
}
inline ::std::string* PROTOBUF_NONNULL PlayerReconnectedEvent::mutable_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.PlayerReconnectedEvent.player_id)
  return _s;
}
inline const ::std::string& PlayerReconnectedEvent::_internal_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_id_.Get();
}
inline void PlayerReconnectedEvent::_internal_set_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PlayerReconnectedEvent::_internal_mutable_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PlayerReconnectedEvent::release_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.PlayerReconnectedEvent.player_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.player_id_.Set("", GetArena());
  }
  return released;
}
inline void PlayerReconnectedEvent::set_allocated_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.PlayerReconnectedEvent.player_id)
}

// .dnd5e.api.v1alpha1.PartyMember member = 2 [json_name = "member"];
inline bool PlayerReconnectedEvent::has_member() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.member_ != nullptr);
  return value;
}
inline void PlayerReconnectedEvent::clear_member() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.member_ != nullptr) _impl_.member_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::dnd5e::api::v1alpha1::PartyMember& PlayerReconnectedEvent::_internal_member() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::PartyMember* p = _impl_.member_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::PartyMember&>(::dnd5e::api::v1alpha1::_PartyMember_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::PartyMember& PlayerReconnectedEvent::member() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.PlayerReconnectedEvent.member)
  return _internal_member();
}
inline void PlayerReconnectedEvent::unsafe_arena_set_allocated_member(
    ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.member_);
  }
  _impl_.member_ = reinterpret_cast<::dnd5e::api::v1alpha1::PartyMember*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.PlayerReconnectedEvent.member)
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE PlayerReconnectedEvent::release_member() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::PartyMember* released = _impl_.member_;
  _impl_.member_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE PlayerReconnectedEvent::unsafe_arena_release_member() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.PlayerReconnectedEvent.member)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::PartyMember* temp = _impl_.member_;
  _impl_.member_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL PlayerReconnectedEvent::_internal_mutable_member() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.member_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::PartyMember>(GetArena());
    _impl_.member_ = reinterpret_cast<::dnd5e::api::v1alpha1::PartyMember*>(p);
  }
  return _impl_.member_;
}
inline ::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NONNULL PlayerReconnectedEvent::mutable_member()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::dnd5e::api::v1alpha1::PartyMember* _msg = _internal_mutable_member();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.PlayerReconnectedEvent.member)
  return _msg;
}
inline void PlayerReconnectedEvent::set_allocated_member(::dnd5e::api::v1alpha1::PartyMember* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.member_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.member_ = reinterpret_cast<::dnd5e::api::v1alpha1::PartyMember*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.PlayerReconnectedEvent.member)
}

// -------------------------------------------------------------------

// CombatPausedEvent

// string reason = 1 [json_name = "reason"];
inline void CombatPausedEvent::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& CombatPausedEvent::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatPausedEvent.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CombatPausedEvent::set_reason(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatPausedEvent.reason)
}
inline ::std::string* PROTOBUF_NONNULL CombatPausedEvent::mutable_reason()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatPausedEvent.reason)
  return _s;
}
inline const ::std::string& CombatPausedEvent::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void CombatPausedEvent::_internal_set_reason(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CombatPausedEvent::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CombatPausedEvent::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatPausedEvent.reason)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.reason_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reason_.Set("", GetArena());
  }
  return released;
}
inline void CombatPausedEvent::set_allocated_reason(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatPausedEvent.reason)
}

// string disconnected_player_id = 2 [json_name = "disconnectedPlayerId"];
inline void CombatPausedEvent::clear_disconnected_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disconnected_player_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& CombatPausedEvent::disconnected_player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatPausedEvent.disconnected_player_id)
  return _internal_disconnected_player_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CombatPausedEvent::set_disconnected_player_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.disconnected_player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.CombatPausedEvent.disconnected_player_id)
}
inline ::std::string* PROTOBUF_NONNULL CombatPausedEvent::mutable_disconnected_player_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_disconnected_player_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatPausedEvent.disconnected_player_id)
  return _s;
}
inline const ::std::string& CombatPausedEvent::_internal_disconnected_player_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disconnected_player_id_.Get();
}
inline void CombatPausedEvent::_internal_set_disconnected_player_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disconnected_player_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CombatPausedEvent::_internal_mutable_disconnected_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.disconnected_player_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CombatPausedEvent::release_disconnected_player_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatPausedEvent.disconnected_player_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.disconnected_player_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.disconnected_player_id_.Set("", GetArena());
  }
  return released;
}
inline void CombatPausedEvent::set_allocated_disconnected_player_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.disconnected_player_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.disconnected_player_id_.IsDefault()) {
    _impl_.disconnected_player_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatPausedEvent.disconnected_player_id)
}

// -------------------------------------------------------------------

// CombatResumedEvent

// .dnd5e.api.v1alpha1.CombatState combat_state = 1 [json_name = "combatState"];
inline bool CombatResumedEvent::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void CombatResumedEvent::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& CombatResumedEvent::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& CombatResumedEvent::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.CombatResumedEvent.combat_state)
  return _internal_combat_state();
}
inline void CombatResumedEvent::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.CombatResumedEvent.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE CombatResumedEvent::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE CombatResumedEvent::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.CombatResumedEvent.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL CombatResumedEvent::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL CombatResumedEvent::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.CombatResumedEvent.combat_state)
  return _msg;
}
inline void CombatResumedEvent::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.CombatResumedEvent.combat_state)
}

// -------------------------------------------------------------------

// RoomRevealedEvent

// string dungeon_id = 1 [json_name = "dungeonId"];
inline void RoomRevealedEvent::clear_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& RoomRevealedEvent::dungeon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RoomRevealedEvent.dungeon_id)
  return _internal_dungeon_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RoomRevealedEvent::set_dungeon_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.dungeon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RoomRevealedEvent.dungeon_id)
}
inline ::std::string* PROTOBUF_NONNULL RoomRevealedEvent::mutable_dungeon_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_dungeon_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RoomRevealedEvent.dungeon_id)
  return _s;
}
inline const ::std::string& RoomRevealedEvent::_internal_dungeon_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dungeon_id_.Get();
}
inline void RoomRevealedEvent::_internal_set_dungeon_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RoomRevealedEvent::_internal_mutable_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dungeon_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RoomRevealedEvent::release_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RoomRevealedEvent.dungeon_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.dungeon_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  return released;
}
inline void RoomRevealedEvent::set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.dungeon_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dungeon_id_.IsDefault()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RoomRevealedEvent.dungeon_id)
}

// string connection_id = 2 [json_name = "connectionId"];
inline void RoomRevealedEvent::clear_connection_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::std::string& RoomRevealedEvent::connection_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RoomRevealedEvent.connection_id)
  return _internal_connection_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RoomRevealedEvent::set_connection_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  _impl_.connection_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.RoomRevealedEvent.connection_id)
}
inline ::std::string* PROTOBUF_NONNULL RoomRevealedEvent::mutable_connection_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::std::string* _s = _internal_mutable_connection_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RoomRevealedEvent.connection_id)
  return _s;
}
inline const ::std::string& RoomRevealedEvent::_internal_connection_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.connection_id_.Get();
}
inline void RoomRevealedEvent::_internal_set_connection_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RoomRevealedEvent::_internal_mutable_connection_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.connection_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RoomRevealedEvent::release_connection_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RoomRevealedEvent.connection_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000004U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  auto* released = _impl_.connection_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.connection_id_.Set("", GetArena());
  }
  return released;
}
inline void RoomRevealedEvent::set_allocated_connection_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  _impl_.connection_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.connection_id_.IsDefault()) {
    _impl_.connection_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RoomRevealedEvent.connection_id)
}

// .dnd5e.api.v1alpha1.Room room = 3 [json_name = "room"];
inline bool RoomRevealedEvent::has_room() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline void RoomRevealedEvent::clear_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::dnd5e::api::v1alpha1::Room& RoomRevealedEvent::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::Room&>(::dnd5e::api::v1alpha1::_Room_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::Room& RoomRevealedEvent::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RoomRevealedEvent.room)
  return _internal_room();
}
inline void RoomRevealedEvent::unsafe_arena_set_allocated_room(
    ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.RoomRevealedEvent.room)
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE RoomRevealedEvent::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE RoomRevealedEvent::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RoomRevealedEvent.room)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL RoomRevealedEvent::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(p);
  }
  return _impl_.room_;
}
inline ::dnd5e::api::v1alpha1::Room* PROTOBUF_NONNULL RoomRevealedEvent::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::dnd5e::api::v1alpha1::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RoomRevealedEvent.room)
  return _msg;
}
inline void RoomRevealedEvent::set_allocated_room(::dnd5e::api::v1alpha1::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.room_ = reinterpret_cast<::dnd5e::api::v1alpha1::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RoomRevealedEvent.room)
}

// .dnd5e.api.v1alpha1.CombatState combat_state = 4 [json_name = "combatState"];
inline bool RoomRevealedEvent::has_combat_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000010U);
  PROTOBUF_ASSUME(!value || _impl_.combat_state_ != nullptr);
  return value;
}
inline void RoomRevealedEvent::clear_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ != nullptr) _impl_.combat_state_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::dnd5e::api::v1alpha1::CombatState& RoomRevealedEvent::_internal_combat_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dnd5e::api::v1alpha1::CombatState* p = _impl_.combat_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::dnd5e::api::v1alpha1::CombatState&>(::dnd5e::api::v1alpha1::_CombatState_default_instance_);
}
inline const ::dnd5e::api::v1alpha1::CombatState& RoomRevealedEvent::combat_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RoomRevealedEvent.combat_state)
  return _internal_combat_state();
}
inline void RoomRevealedEvent::unsafe_arena_set_allocated_combat_state(
    ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }
  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dnd5e.api.v1alpha1.RoomRevealedEvent.combat_state)
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE RoomRevealedEvent::release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::CombatState* released = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE RoomRevealedEvent::unsafe_arena_release_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.RoomRevealedEvent.combat_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::CombatState* temp = _impl_.combat_state_;
  _impl_.combat_state_ = nullptr;
  return temp;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL RoomRevealedEvent::_internal_mutable_combat_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.combat_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dnd5e::api::v1alpha1::CombatState>(GetArena());
    _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(p);
  }
  return _impl_.combat_state_;
}
inline ::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NONNULL RoomRevealedEvent::mutable_combat_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::dnd5e::api::v1alpha1::CombatState* _msg = _internal_mutable_combat_state();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RoomRevealedEvent.combat_state)
  return _msg;
}
inline void RoomRevealedEvent::set_allocated_combat_state(::dnd5e::api::v1alpha1::CombatState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.combat_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }

  _impl_.combat_state_ = reinterpret_cast<::dnd5e::api::v1alpha1::CombatState*>(value);
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.RoomRevealedEvent.combat_state)
}

// repeated .dnd5e.api.v1alpha1.DoorInfo doors = 5 [json_name = "doors"];
inline int RoomRevealedEvent::_internal_doors_size() const {
  return _internal_doors().size();
}
inline int RoomRevealedEvent::doors_size() const {
  return _internal_doors_size();
}
inline void RoomRevealedEvent::clear_doors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.doors_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL RoomRevealedEvent::mutable_doors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.RoomRevealedEvent.doors)
  return _internal_mutable_doors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL RoomRevealedEvent::mutable_doors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:dnd5e.api.v1alpha1.RoomRevealedEvent.doors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_doors();
}
inline const ::dnd5e::api::v1alpha1::DoorInfo& RoomRevealedEvent::doors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.RoomRevealedEvent.doors)
  return _internal_doors().Get(index);
}
inline ::dnd5e::api::v1alpha1::DoorInfo* PROTOBUF_NONNULL RoomRevealedEvent::add_doors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dnd5e::api::v1alpha1::DoorInfo* _add =
      _internal_mutable_doors()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:dnd5e.api.v1alpha1.RoomRevealedEvent.doors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>& RoomRevealedEvent::doors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dnd5e.api.v1alpha1.RoomRevealedEvent.doors)
  return _internal_doors();
}
inline const ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>&
RoomRevealedEvent::_internal_doors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.doors_;
}
inline ::google::protobuf::RepeatedPtrField<::dnd5e::api::v1alpha1::DoorInfo>* PROTOBUF_NONNULL
RoomRevealedEvent::_internal_mutable_doors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.doors_;
}

// -------------------------------------------------------------------

// DungeonVictoryEvent

// string dungeon_id = 1 [json_name = "dungeonId"];
inline void DungeonVictoryEvent::clear_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& DungeonVictoryEvent::dungeon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonVictoryEvent.dungeon_id)
  return _internal_dungeon_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DungeonVictoryEvent::set_dungeon_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.dungeon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonVictoryEvent.dungeon_id)
}
inline ::std::string* PROTOBUF_NONNULL DungeonVictoryEvent::mutable_dungeon_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_dungeon_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonVictoryEvent.dungeon_id)
  return _s;
}
inline const ::std::string& DungeonVictoryEvent::_internal_dungeon_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dungeon_id_.Get();
}
inline void DungeonVictoryEvent::_internal_set_dungeon_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DungeonVictoryEvent::_internal_mutable_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dungeon_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DungeonVictoryEvent::release_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonVictoryEvent.dungeon_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.dungeon_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  return released;
}
inline void DungeonVictoryEvent::set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.dungeon_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dungeon_id_.IsDefault()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonVictoryEvent.dungeon_id)
}

// int32 rooms_cleared = 2 [json_name = "roomsCleared"];
inline void DungeonVictoryEvent::clear_rooms_cleared() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rooms_cleared_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t DungeonVictoryEvent::rooms_cleared() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonVictoryEvent.rooms_cleared)
  return _internal_rooms_cleared();
}
inline void DungeonVictoryEvent::set_rooms_cleared(::int32_t value) {
  _internal_set_rooms_cleared(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonVictoryEvent.rooms_cleared)
}
inline ::int32_t DungeonVictoryEvent::_internal_rooms_cleared() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rooms_cleared_;
}
inline void DungeonVictoryEvent::_internal_set_rooms_cleared(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rooms_cleared_ = value;
}

// .dnd5e.api.v1alpha1.DungeonState dungeon_state = 3 [json_name = "dungeonState"];
inline void DungeonVictoryEvent::clear_dungeon_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_state_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::DungeonState DungeonVictoryEvent::dungeon_state() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonVictoryEvent.dungeon_state)
  return _internal_dungeon_state();
}
inline void DungeonVictoryEvent::set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value) {
  _internal_set_dungeon_state(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonVictoryEvent.dungeon_state)
}
inline ::dnd5e::api::v1alpha1::DungeonState DungeonVictoryEvent::_internal_dungeon_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::DungeonState>(_impl_.dungeon_state_);
}
inline void DungeonVictoryEvent::_internal_set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_state_ = value;
}

// -------------------------------------------------------------------

// DungeonFailureEvent

// string dungeon_id = 1 [json_name = "dungeonId"];
inline void DungeonFailureEvent::clear_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& DungeonFailureEvent::dungeon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonFailureEvent.dungeon_id)
  return _internal_dungeon_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DungeonFailureEvent::set_dungeon_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.dungeon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonFailureEvent.dungeon_id)
}
inline ::std::string* PROTOBUF_NONNULL DungeonFailureEvent::mutable_dungeon_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_dungeon_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonFailureEvent.dungeon_id)
  return _s;
}
inline const ::std::string& DungeonFailureEvent::_internal_dungeon_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dungeon_id_.Get();
}
inline void DungeonFailureEvent::_internal_set_dungeon_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DungeonFailureEvent::_internal_mutable_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dungeon_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DungeonFailureEvent::release_dungeon_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonFailureEvent.dungeon_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.dungeon_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  return released;
}
inline void DungeonFailureEvent::set_allocated_dungeon_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.dungeon_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dungeon_id_.IsDefault()) {
    _impl_.dungeon_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonFailureEvent.dungeon_id)
}

// string final_room_id = 2 [json_name = "finalRoomId"];
inline void DungeonFailureEvent::clear_final_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_room_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& DungeonFailureEvent::final_room_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonFailureEvent.final_room_id)
  return _internal_final_room_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DungeonFailureEvent::set_final_room_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.final_room_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonFailureEvent.final_room_id)
}
inline ::std::string* PROTOBUF_NONNULL DungeonFailureEvent::mutable_final_room_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_final_room_id();
  // @@protoc_insertion_point(field_mutable:dnd5e.api.v1alpha1.DungeonFailureEvent.final_room_id)
  return _s;
}
inline const ::std::string& DungeonFailureEvent::_internal_final_room_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.final_room_id_.Get();
}
inline void DungeonFailureEvent::_internal_set_final_room_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_room_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DungeonFailureEvent::_internal_mutable_final_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.final_room_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DungeonFailureEvent::release_final_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dnd5e.api.v1alpha1.DungeonFailureEvent.final_room_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.final_room_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.final_room_id_.Set("", GetArena());
  }
  return released;
}
inline void DungeonFailureEvent::set_allocated_final_room_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.final_room_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.final_room_id_.IsDefault()) {
    _impl_.final_room_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dnd5e.api.v1alpha1.DungeonFailureEvent.final_room_id)
}

// .dnd5e.api.v1alpha1.DungeonState dungeon_state = 3 [json_name = "dungeonState"];
inline void DungeonFailureEvent::clear_dungeon_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_state_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::dnd5e::api::v1alpha1::DungeonState DungeonFailureEvent::dungeon_state() const {
  // @@protoc_insertion_point(field_get:dnd5e.api.v1alpha1.DungeonFailureEvent.dungeon_state)
  return _internal_dungeon_state();
}
inline void DungeonFailureEvent::set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value) {
  _internal_set_dungeon_state(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:dnd5e.api.v1alpha1.DungeonFailureEvent.dungeon_state)
}
inline ::dnd5e::api::v1alpha1::DungeonState DungeonFailureEvent::_internal_dungeon_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dnd5e::api::v1alpha1::DungeonState>(_impl_.dungeon_state_);
}
inline void DungeonFailureEvent::_internal_set_dungeon_state(::dnd5e::api::v1alpha1::DungeonState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dungeon_state_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace api
}  // namespace dnd5e


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::MovementError_ErrorCode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::MovementError_ErrorCode>() {
  return ::dnd5e::api::v1alpha1::MovementError_ErrorCode_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::EncounterEndReason> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::EncounterEndReason>() {
  return ::dnd5e::api::v1alpha1::EncounterEndReason_descriptor();
}
template <>
struct is_proto_enum<::dnd5e::api::v1alpha1::EncounterState> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::dnd5e::api::v1alpha1::EncounterState>() {
  return ::dnd5e::api::v1alpha1::EncounterState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // dnd5e_2fapi_2fv1alpha1_2fencounter_2eproto_2epb_2eh
