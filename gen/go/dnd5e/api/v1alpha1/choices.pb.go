// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        (unknown)
// source: dnd5e/api/v1alpha1/choices.proto

package apiv1alpha1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Types of spell selection systems
type SpellSelectionType int32

const (
	SpellSelectionType_SPELL_SELECTION_TYPE_UNSPECIFIED SpellSelectionType = 0
	SpellSelectionType_SPELL_SELECTION_TYPE_SPELLBOOK   SpellSelectionType = 1 // Wizard spellbook system
	SpellSelectionType_SPELL_SELECTION_TYPE_KNOWN       SpellSelectionType = 2 // Fixed known spells (sorcerer, warlock)
	SpellSelectionType_SPELL_SELECTION_TYPE_PREPARED    SpellSelectionType = 3 // Prepared spells (cleric, druid)
)

// Enum value maps for SpellSelectionType.
var (
	SpellSelectionType_name = map[int32]string{
		0: "SPELL_SELECTION_TYPE_UNSPECIFIED",
		1: "SPELL_SELECTION_TYPE_SPELLBOOK",
		2: "SPELL_SELECTION_TYPE_KNOWN",
		3: "SPELL_SELECTION_TYPE_PREPARED",
	}
	SpellSelectionType_value = map[string]int32{
		"SPELL_SELECTION_TYPE_UNSPECIFIED": 0,
		"SPELL_SELECTION_TYPE_SPELLBOOK":   1,
		"SPELL_SELECTION_TYPE_KNOWN":       2,
		"SPELL_SELECTION_TYPE_PREPARED":    3,
	}
)

func (x SpellSelectionType) Enum() *SpellSelectionType {
	p := new(SpellSelectionType)
	*p = x
	return p
}

func (x SpellSelectionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SpellSelectionType) Descriptor() protoreflect.EnumDescriptor {
	return file_dnd5e_api_v1alpha1_choices_proto_enumTypes[0].Descriptor()
}

func (SpellSelectionType) Type() protoreflect.EnumType {
	return &file_dnd5e_api_v1alpha1_choices_proto_enumTypes[0]
}

func (x SpellSelectionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SpellSelectionType.Descriptor instead.
func (SpellSelectionType) EnumDescriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{0}
}

// Source of a choice during character creation
type ChoiceSource int32

const (
	ChoiceSource_CHOICE_SOURCE_UNSPECIFIED ChoiceSource = 0
	ChoiceSource_CHOICE_SOURCE_PLAYER      ChoiceSource = 1 // Direct player choice
	ChoiceSource_CHOICE_SOURCE_RACE        ChoiceSource = 2
	ChoiceSource_CHOICE_SOURCE_SUBRACE     ChoiceSource = 3
	ChoiceSource_CHOICE_SOURCE_CLASS       ChoiceSource = 4
	ChoiceSource_CHOICE_SOURCE_BACKGROUND  ChoiceSource = 5
	ChoiceSource_CHOICE_SOURCE_LEVEL_UP    ChoiceSource = 6 // Choices made during level progression
)

// Enum value maps for ChoiceSource.
var (
	ChoiceSource_name = map[int32]string{
		0: "CHOICE_SOURCE_UNSPECIFIED",
		1: "CHOICE_SOURCE_PLAYER",
		2: "CHOICE_SOURCE_RACE",
		3: "CHOICE_SOURCE_SUBRACE",
		4: "CHOICE_SOURCE_CLASS",
		5: "CHOICE_SOURCE_BACKGROUND",
		6: "CHOICE_SOURCE_LEVEL_UP",
	}
	ChoiceSource_value = map[string]int32{
		"CHOICE_SOURCE_UNSPECIFIED": 0,
		"CHOICE_SOURCE_PLAYER":      1,
		"CHOICE_SOURCE_RACE":        2,
		"CHOICE_SOURCE_SUBRACE":     3,
		"CHOICE_SOURCE_CLASS":       4,
		"CHOICE_SOURCE_BACKGROUND":  5,
		"CHOICE_SOURCE_LEVEL_UP":    6,
	}
)

func (x ChoiceSource) Enum() *ChoiceSource {
	p := new(ChoiceSource)
	*p = x
	return p
}

func (x ChoiceSource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ChoiceSource) Descriptor() protoreflect.EnumDescriptor {
	return file_dnd5e_api_v1alpha1_choices_proto_enumTypes[1].Descriptor()
}

func (ChoiceSource) Type() protoreflect.EnumType {
	return &file_dnd5e_api_v1alpha1_choices_proto_enumTypes[1]
}

func (x ChoiceSource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ChoiceSource.Descriptor instead.
func (ChoiceSource) EnumDescriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{1}
}

// Category of choice being made
type ChoiceCategory int32

const (
	ChoiceCategory_CHOICE_CATEGORY_UNSPECIFIED          ChoiceCategory = 0
	ChoiceCategory_CHOICE_CATEGORY_EQUIPMENT            ChoiceCategory = 1
	ChoiceCategory_CHOICE_CATEGORY_SKILLS               ChoiceCategory = 2  // Skill proficiencies
	ChoiceCategory_CHOICE_CATEGORY_TOOLS                ChoiceCategory = 3  // Tool proficiencies
	ChoiceCategory_CHOICE_CATEGORY_LANGUAGES            ChoiceCategory = 4  // Languages
	ChoiceCategory_CHOICE_CATEGORY_WEAPON_PROFICIENCIES ChoiceCategory = 5  // Weapon proficiencies
	ChoiceCategory_CHOICE_CATEGORY_ARMOR_PROFICIENCIES  ChoiceCategory = 6  // Armor proficiencies
	ChoiceCategory_CHOICE_CATEGORY_SPELLS               ChoiceCategory = 7  // Spells known/prepared
	ChoiceCategory_CHOICE_CATEGORY_FEATS                ChoiceCategory = 8  // Feats
	ChoiceCategory_CHOICE_CATEGORY_ABILITY_SCORES       ChoiceCategory = 9  // Ability score improvements
	ChoiceCategory_CHOICE_CATEGORY_NAME                 ChoiceCategory = 10 // Character name
	ChoiceCategory_CHOICE_CATEGORY_FIGHTING_STYLE       ChoiceCategory = 11 // Fighting style selection
	ChoiceCategory_CHOICE_CATEGORY_RACE                 ChoiceCategory = 12 // Race selection
	ChoiceCategory_CHOICE_CATEGORY_CLASS                ChoiceCategory = 13 // Class selection
	ChoiceCategory_CHOICE_CATEGORY_BACKGROUND           ChoiceCategory = 14 // Background selection
	ChoiceCategory_CHOICE_CATEGORY_CANTRIPS             ChoiceCategory = 15 // Cantrips known
	ChoiceCategory_CHOICE_CATEGORY_EXPERTISE            ChoiceCategory = 16 // Expertise (double proficiency) choices
	ChoiceCategory_CHOICE_CATEGORY_SUBRACE              ChoiceCategory = 17 // Subrace selection (e.g., High Elf, Mountain Dwarf)
	ChoiceCategory_CHOICE_CATEGORY_TRAITS               ChoiceCategory = 18 // Racial or class traits (e.g., Draconic Ancestry)
)

// Enum value maps for ChoiceCategory.
var (
	ChoiceCategory_name = map[int32]string{
		0:  "CHOICE_CATEGORY_UNSPECIFIED",
		1:  "CHOICE_CATEGORY_EQUIPMENT",
		2:  "CHOICE_CATEGORY_SKILLS",
		3:  "CHOICE_CATEGORY_TOOLS",
		4:  "CHOICE_CATEGORY_LANGUAGES",
		5:  "CHOICE_CATEGORY_WEAPON_PROFICIENCIES",
		6:  "CHOICE_CATEGORY_ARMOR_PROFICIENCIES",
		7:  "CHOICE_CATEGORY_SPELLS",
		8:  "CHOICE_CATEGORY_FEATS",
		9:  "CHOICE_CATEGORY_ABILITY_SCORES",
		10: "CHOICE_CATEGORY_NAME",
		11: "CHOICE_CATEGORY_FIGHTING_STYLE",
		12: "CHOICE_CATEGORY_RACE",
		13: "CHOICE_CATEGORY_CLASS",
		14: "CHOICE_CATEGORY_BACKGROUND",
		15: "CHOICE_CATEGORY_CANTRIPS",
		16: "CHOICE_CATEGORY_EXPERTISE",
		17: "CHOICE_CATEGORY_SUBRACE",
		18: "CHOICE_CATEGORY_TRAITS",
	}
	ChoiceCategory_value = map[string]int32{
		"CHOICE_CATEGORY_UNSPECIFIED":          0,
		"CHOICE_CATEGORY_EQUIPMENT":            1,
		"CHOICE_CATEGORY_SKILLS":               2,
		"CHOICE_CATEGORY_TOOLS":                3,
		"CHOICE_CATEGORY_LANGUAGES":            4,
		"CHOICE_CATEGORY_WEAPON_PROFICIENCIES": 5,
		"CHOICE_CATEGORY_ARMOR_PROFICIENCIES":  6,
		"CHOICE_CATEGORY_SPELLS":               7,
		"CHOICE_CATEGORY_FEATS":                8,
		"CHOICE_CATEGORY_ABILITY_SCORES":       9,
		"CHOICE_CATEGORY_NAME":                 10,
		"CHOICE_CATEGORY_FIGHTING_STYLE":       11,
		"CHOICE_CATEGORY_RACE":                 12,
		"CHOICE_CATEGORY_CLASS":                13,
		"CHOICE_CATEGORY_BACKGROUND":           14,
		"CHOICE_CATEGORY_CANTRIPS":             15,
		"CHOICE_CATEGORY_EXPERTISE":            16,
		"CHOICE_CATEGORY_SUBRACE":              17,
		"CHOICE_CATEGORY_TRAITS":               18,
	}
)

func (x ChoiceCategory) Enum() *ChoiceCategory {
	p := new(ChoiceCategory)
	*p = x
	return p
}

func (x ChoiceCategory) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ChoiceCategory) Descriptor() protoreflect.EnumDescriptor {
	return file_dnd5e_api_v1alpha1_choices_proto_enumTypes[2].Descriptor()
}

func (ChoiceCategory) Type() protoreflect.EnumType {
	return &file_dnd5e_api_v1alpha1_choices_proto_enumTypes[2]
}

func (x ChoiceCategory) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ChoiceCategory.Descriptor instead.
func (ChoiceCategory) EnumDescriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{2}
}

// Choice represents any decision point in character creation
// This is the ONE way to represent all choices - maps to toolkit's Requirements
type Choice struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Id          string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`                                                                           // Unique identifier (e.g., "fighter-skills", "fighter-armor")
	Description string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`                                                         // Human-readable description
	ChooseCount int32                  `protobuf:"varint,3,opt,name=choose_count,json=chooseCount,proto3" json:"choose_count,omitempty"`                                     // How many to choose
	ChoiceType  ChoiceCategory         `protobuf:"varint,4,opt,name=choice_type,json=choiceType,proto3,enum=dnd5e.api.v1alpha1.ChoiceCategory" json:"choice_type,omitempty"` // Category for validation
	// Category-specific options - only one will be set based on choice_type
	//
	// Types that are valid to be assigned to Options:
	//
	//	*Choice_SkillOptions
	//	*Choice_EquipmentOptions
	//	*Choice_LanguageOptions
	//	*Choice_ToolOptions
	//	*Choice_FightingStyleOptions
	//	*Choice_SpellOptions
	//	*Choice_ExpertiseOptions
	Options       isChoice_Options `protobuf_oneof:"options"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Choice) Reset() {
	*x = Choice{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Choice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Choice) ProtoMessage() {}

func (x *Choice) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Choice.ProtoReflect.Descriptor instead.
func (*Choice) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{0}
}

func (x *Choice) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Choice) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Choice) GetChooseCount() int32 {
	if x != nil {
		return x.ChooseCount
	}
	return 0
}

func (x *Choice) GetChoiceType() ChoiceCategory {
	if x != nil {
		return x.ChoiceType
	}
	return ChoiceCategory_CHOICE_CATEGORY_UNSPECIFIED
}

func (x *Choice) GetOptions() isChoice_Options {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *Choice) GetSkillOptions() *SkillOptions {
	if x != nil {
		if x, ok := x.Options.(*Choice_SkillOptions); ok {
			return x.SkillOptions
		}
	}
	return nil
}

func (x *Choice) GetEquipmentOptions() *EquipmentOptions {
	if x != nil {
		if x, ok := x.Options.(*Choice_EquipmentOptions); ok {
			return x.EquipmentOptions
		}
	}
	return nil
}

func (x *Choice) GetLanguageOptions() *LanguageOptions {
	if x != nil {
		if x, ok := x.Options.(*Choice_LanguageOptions); ok {
			return x.LanguageOptions
		}
	}
	return nil
}

func (x *Choice) GetToolOptions() *ToolOptions {
	if x != nil {
		if x, ok := x.Options.(*Choice_ToolOptions); ok {
			return x.ToolOptions
		}
	}
	return nil
}

func (x *Choice) GetFightingStyleOptions() *FightingStyleOptions {
	if x != nil {
		if x, ok := x.Options.(*Choice_FightingStyleOptions); ok {
			return x.FightingStyleOptions
		}
	}
	return nil
}

func (x *Choice) GetSpellOptions() *SpellOptions {
	if x != nil {
		if x, ok := x.Options.(*Choice_SpellOptions); ok {
			return x.SpellOptions
		}
	}
	return nil
}

func (x *Choice) GetExpertiseOptions() *ExpertiseOptions {
	if x != nil {
		if x, ok := x.Options.(*Choice_ExpertiseOptions); ok {
			return x.ExpertiseOptions
		}
	}
	return nil
}

type isChoice_Options interface {
	isChoice_Options()
}

type Choice_SkillOptions struct {
	SkillOptions *SkillOptions `protobuf:"bytes,5,opt,name=skill_options,json=skillOptions,proto3,oneof"`
}

type Choice_EquipmentOptions struct {
	EquipmentOptions *EquipmentOptions `protobuf:"bytes,6,opt,name=equipment_options,json=equipmentOptions,proto3,oneof"`
}

type Choice_LanguageOptions struct {
	LanguageOptions *LanguageOptions `protobuf:"bytes,7,opt,name=language_options,json=languageOptions,proto3,oneof"`
}

type Choice_ToolOptions struct {
	ToolOptions *ToolOptions `protobuf:"bytes,8,opt,name=tool_options,json=toolOptions,proto3,oneof"`
}

type Choice_FightingStyleOptions struct {
	FightingStyleOptions *FightingStyleOptions `protobuf:"bytes,9,opt,name=fighting_style_options,json=fightingStyleOptions,proto3,oneof"`
}

type Choice_SpellOptions struct {
	SpellOptions *SpellOptions `protobuf:"bytes,10,opt,name=spell_options,json=spellOptions,proto3,oneof"`
}

type Choice_ExpertiseOptions struct {
	ExpertiseOptions *ExpertiseOptions `protobuf:"bytes,11,opt,name=expertise_options,json=expertiseOptions,proto3,oneof"` // Add more as needed for other choice types
}

func (*Choice_SkillOptions) isChoice_Options() {}

func (*Choice_EquipmentOptions) isChoice_Options() {}

func (*Choice_LanguageOptions) isChoice_Options() {}

func (*Choice_ToolOptions) isChoice_Options() {}

func (*Choice_FightingStyleOptions) isChoice_Options() {}

func (*Choice_SpellOptions) isChoice_Options() {}

func (*Choice_ExpertiseOptions) isChoice_Options() {}

// Skills that can be chosen
type SkillOptions struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Available     []Skill                `protobuf:"varint,1,rep,packed,name=available,proto3,enum=dnd5e.api.v1alpha1.Skill" json:"available,omitempty"` // Available skills to choose from
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SkillOptions) Reset() {
	*x = SkillOptions{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SkillOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SkillOptions) ProtoMessage() {}

func (x *SkillOptions) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SkillOptions.ProtoReflect.Descriptor instead.
func (*SkillOptions) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{1}
}

func (x *SkillOptions) GetAvailable() []Skill {
	if x != nil {
		return x.Available
	}
	return nil
}

// Equipment bundles (e.g., "chain mail" OR "leather + longbow + arrows")
type EquipmentOptions struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Bundles       []*EquipmentBundle     `protobuf:"bytes,1,rep,name=bundles,proto3" json:"bundles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EquipmentOptions) Reset() {
	*x = EquipmentOptions{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EquipmentOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EquipmentOptions) ProtoMessage() {}

func (x *EquipmentOptions) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EquipmentOptions.ProtoReflect.Descriptor instead.
func (*EquipmentOptions) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{2}
}

func (x *EquipmentOptions) GetBundles() []*EquipmentBundle {
	if x != nil {
		return x.Bundles
	}
	return nil
}

// Single equipment bundle option
type EquipmentBundle struct {
	state           protoimpl.MessageState     `protogen:"open.v1"`
	Id              string                     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`                                                  // Bundle identifier (e.g., "fighter-armor-a")
	Label           string                     `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`                                            // Display name (e.g., "Chain mail")
	Items           []*EquipmentItem           `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty"`                                            // Concrete items in this bundle
	CategoryChoices []*EquipmentCategoryChoice `protobuf:"bytes,4,rep,name=category_choices,json=categoryChoices,proto3" json:"category_choices,omitempty"` // Category-based selections
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *EquipmentBundle) Reset() {
	*x = EquipmentBundle{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EquipmentBundle) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EquipmentBundle) ProtoMessage() {}

func (x *EquipmentBundle) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EquipmentBundle.ProtoReflect.Descriptor instead.
func (*EquipmentBundle) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{3}
}

func (x *EquipmentBundle) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *EquipmentBundle) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *EquipmentBundle) GetItems() []*EquipmentItem {
	if x != nil {
		return x.Items
	}
	return nil
}

func (x *EquipmentBundle) GetCategoryChoices() []*EquipmentCategoryChoice {
	if x != nil {
		return x.CategoryChoices
	}
	return nil
}

// Concrete equipment item
type EquipmentItem struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	SelectionId string                 `protobuf:"bytes,1,opt,name=selection_id,json=selectionId,proto3" json:"selection_id,omitempty"` // Maps to toolkit's SelectionID (e.g., "chain-mail", "shield")
	Quantity    int32                  `protobuf:"varint,2,opt,name=quantity,proto3" json:"quantity,omitempty"`                         // How many (default 1)
	// Optional type hint for client convenience (can help with icon display, etc.)
	//
	// Types that are valid to be assigned to TypeHint:
	//
	//	*EquipmentItem_Weapon
	//	*EquipmentItem_Armor
	//	*EquipmentItem_Tool
	//	*EquipmentItem_Pack
	//	*EquipmentItem_Ammunition
	TypeHint      isEquipmentItem_TypeHint `protobuf_oneof:"type_hint"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EquipmentItem) Reset() {
	*x = EquipmentItem{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EquipmentItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EquipmentItem) ProtoMessage() {}

func (x *EquipmentItem) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EquipmentItem.ProtoReflect.Descriptor instead.
func (*EquipmentItem) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{4}
}

func (x *EquipmentItem) GetSelectionId() string {
	if x != nil {
		return x.SelectionId
	}
	return ""
}

func (x *EquipmentItem) GetQuantity() int32 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

func (x *EquipmentItem) GetTypeHint() isEquipmentItem_TypeHint {
	if x != nil {
		return x.TypeHint
	}
	return nil
}

func (x *EquipmentItem) GetWeapon() Weapon {
	if x != nil {
		if x, ok := x.TypeHint.(*EquipmentItem_Weapon); ok {
			return x.Weapon
		}
	}
	return Weapon_WEAPON_UNSPECIFIED
}

func (x *EquipmentItem) GetArmor() Armor {
	if x != nil {
		if x, ok := x.TypeHint.(*EquipmentItem_Armor); ok {
			return x.Armor
		}
	}
	return Armor_ARMOR_UNSPECIFIED
}

func (x *EquipmentItem) GetTool() Tool {
	if x != nil {
		if x, ok := x.TypeHint.(*EquipmentItem_Tool); ok {
			return x.Tool
		}
	}
	return Tool_TOOL_UNSPECIFIED
}

func (x *EquipmentItem) GetPack() Pack {
	if x != nil {
		if x, ok := x.TypeHint.(*EquipmentItem_Pack); ok {
			return x.Pack
		}
	}
	return Pack_PACK_UNSPECIFIED
}

func (x *EquipmentItem) GetAmmunition() Ammunition {
	if x != nil {
		if x, ok := x.TypeHint.(*EquipmentItem_Ammunition); ok {
			return x.Ammunition
		}
	}
	return Ammunition_AMMUNITION_UNSPECIFIED
}

type isEquipmentItem_TypeHint interface {
	isEquipmentItem_TypeHint()
}

type EquipmentItem_Weapon struct {
	Weapon Weapon `protobuf:"varint,3,opt,name=weapon,proto3,enum=dnd5e.api.v1alpha1.Weapon,oneof"`
}

type EquipmentItem_Armor struct {
	Armor Armor `protobuf:"varint,4,opt,name=armor,proto3,enum=dnd5e.api.v1alpha1.Armor,oneof"`
}

type EquipmentItem_Tool struct {
	Tool Tool `protobuf:"varint,5,opt,name=tool,proto3,enum=dnd5e.api.v1alpha1.Tool,oneof"`
}

type EquipmentItem_Pack struct {
	Pack Pack `protobuf:"varint,6,opt,name=pack,proto3,enum=dnd5e.api.v1alpha1.Pack,oneof"`
}

type EquipmentItem_Ammunition struct {
	Ammunition Ammunition `protobuf:"varint,7,opt,name=ammunition,proto3,enum=dnd5e.api.v1alpha1.Ammunition,oneof"`
}

func (*EquipmentItem_Weapon) isEquipmentItem_TypeHint() {}

func (*EquipmentItem_Armor) isEquipmentItem_TypeHint() {}

func (*EquipmentItem_Tool) isEquipmentItem_TypeHint() {}

func (*EquipmentItem_Pack) isEquipmentItem_TypeHint() {}

func (*EquipmentItem_Ammunition) isEquipmentItem_TypeHint() {}

// Category-based equipment selection (e.g., "choose 2 martial weapons")
type EquipmentCategoryChoice struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Choose           int32                  `protobuf:"varint,1,opt,name=choose,proto3" json:"choose,omitempty"`                                                                                           // How many to choose (e.g., 1 or 2)
	WeaponCategories []WeaponCategory       `protobuf:"varint,2,rep,packed,name=weapon_categories,json=weaponCategories,proto3,enum=dnd5e.api.v1alpha1.WeaponCategory" json:"weapon_categories,omitempty"` // Weapon categories to choose from
	ArmorCategories  []ArmorCategory        `protobuf:"varint,3,rep,packed,name=armor_categories,json=armorCategories,proto3,enum=dnd5e.api.v1alpha1.ArmorCategory" json:"armor_categories,omitempty"`     // Armor categories to choose from
	ToolCategories   []ToolCategory         `protobuf:"varint,4,rep,packed,name=tool_categories,json=toolCategories,proto3,enum=dnd5e.api.v1alpha1.ToolCategory" json:"tool_categories,omitempty"`         // Tool categories to choose from
	Label            string                 `protobuf:"bytes,5,opt,name=label,proto3" json:"label,omitempty"`                                                                                              // Description (e.g., "Choose two martial weapons")
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *EquipmentCategoryChoice) Reset() {
	*x = EquipmentCategoryChoice{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EquipmentCategoryChoice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EquipmentCategoryChoice) ProtoMessage() {}

func (x *EquipmentCategoryChoice) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EquipmentCategoryChoice.ProtoReflect.Descriptor instead.
func (*EquipmentCategoryChoice) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{5}
}

func (x *EquipmentCategoryChoice) GetChoose() int32 {
	if x != nil {
		return x.Choose
	}
	return 0
}

func (x *EquipmentCategoryChoice) GetWeaponCategories() []WeaponCategory {
	if x != nil {
		return x.WeaponCategories
	}
	return nil
}

func (x *EquipmentCategoryChoice) GetArmorCategories() []ArmorCategory {
	if x != nil {
		return x.ArmorCategories
	}
	return nil
}

func (x *EquipmentCategoryChoice) GetToolCategories() []ToolCategory {
	if x != nil {
		return x.ToolCategories
	}
	return nil
}

func (x *EquipmentCategoryChoice) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

// Languages that can be chosen
type LanguageOptions struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Available     []Language             `protobuf:"varint,1,rep,packed,name=available,proto3,enum=dnd5e.api.v1alpha1.Language" json:"available,omitempty"` // nil in toolkit means "any language"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LanguageOptions) Reset() {
	*x = LanguageOptions{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LanguageOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LanguageOptions) ProtoMessage() {}

func (x *LanguageOptions) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LanguageOptions.ProtoReflect.Descriptor instead.
func (*LanguageOptions) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{6}
}

func (x *LanguageOptions) GetAvailable() []Language {
	if x != nil {
		return x.Available
	}
	return nil
}

// Tools that can be chosen
type ToolOptions struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Available     []Tool                 `protobuf:"varint,1,rep,packed,name=available,proto3,enum=dnd5e.api.v1alpha1.Tool" json:"available,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToolOptions) Reset() {
	*x = ToolOptions{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolOptions) ProtoMessage() {}

func (x *ToolOptions) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolOptions.ProtoReflect.Descriptor instead.
func (*ToolOptions) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{7}
}

func (x *ToolOptions) GetAvailable() []Tool {
	if x != nil {
		return x.Available
	}
	return nil
}

// Fighting styles that can be chosen
type FightingStyleOptions struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Available     []FightingStyle        `protobuf:"varint,1,rep,packed,name=available,proto3,enum=dnd5e.api.v1alpha1.FightingStyle" json:"available,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FightingStyleOptions) Reset() {
	*x = FightingStyleOptions{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FightingStyleOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FightingStyleOptions) ProtoMessage() {}

func (x *FightingStyleOptions) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FightingStyleOptions.ProtoReflect.Descriptor instead.
func (*FightingStyleOptions) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{8}
}

func (x *FightingStyleOptions) GetAvailable() []FightingStyle {
	if x != nil {
		return x.Available
	}
	return nil
}

// Spells that can be chosen
type SpellOptions struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Available     []Spell                `protobuf:"varint,1,rep,packed,name=available,proto3,enum=dnd5e.api.v1alpha1.Spell" json:"available,omitempty"`
	SpellLevel    int32                  `protobuf:"varint,2,opt,name=spell_level,json=spellLevel,proto3" json:"spell_level,omitempty"`                                                     // Optional: level of spells being chosen
	SelectionType SpellSelectionType     `protobuf:"varint,3,opt,name=selection_type,json=selectionType,proto3,enum=dnd5e.api.v1alpha1.SpellSelectionType" json:"selection_type,omitempty"` // How spells are selected (learned, prepared, etc.)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SpellOptions) Reset() {
	*x = SpellOptions{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpellOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpellOptions) ProtoMessage() {}

func (x *SpellOptions) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpellOptions.ProtoReflect.Descriptor instead.
func (*SpellOptions) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{9}
}

func (x *SpellOptions) GetAvailable() []Spell {
	if x != nil {
		return x.Available
	}
	return nil
}

func (x *SpellOptions) GetSpellLevel() int32 {
	if x != nil {
		return x.SpellLevel
	}
	return 0
}

func (x *SpellOptions) GetSelectionType() SpellSelectionType {
	if x != nil {
		return x.SelectionType
	}
	return SpellSelectionType_SPELL_SELECTION_TYPE_UNSPECIFIED
}

// Skills/tools that can gain expertise
type ExpertiseOptions struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	AvailableSkills []Skill                `protobuf:"varint,1,rep,packed,name=available_skills,json=availableSkills,proto3,enum=dnd5e.api.v1alpha1.Skill" json:"available_skills,omitempty"`
	AvailableTools  []Tool                 `protobuf:"varint,2,rep,packed,name=available_tools,json=availableTools,proto3,enum=dnd5e.api.v1alpha1.Tool" json:"available_tools,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ExpertiseOptions) Reset() {
	*x = ExpertiseOptions{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExpertiseOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExpertiseOptions) ProtoMessage() {}

func (x *ExpertiseOptions) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExpertiseOptions.ProtoReflect.Descriptor instead.
func (*ExpertiseOptions) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{10}
}

func (x *ExpertiseOptions) GetAvailableSkills() []Skill {
	if x != nil {
		return x.AvailableSkills
	}
	return nil
}

func (x *ExpertiseOptions) GetAvailableTools() []Tool {
	if x != nil {
		return x.AvailableTools
	}
	return nil
}

// Represents a submitted choice (what the player actually selected)
// Maps closely to toolkit's Submission struct
type ChoiceSubmission struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	ChoiceId string                 `protobuf:"bytes,1,opt,name=choice_id,json=choiceId,proto3" json:"choice_id,omitempty"`                         // Which choice this is for (matches Choice.id)
	Category ChoiceCategory         `protobuf:"varint,2,opt,name=category,proto3,enum=dnd5e.api.v1alpha1.ChoiceCategory" json:"category,omitempty"` // Category of the choice
	Source   ChoiceSource           `protobuf:"varint,3,opt,name=source,proto3,enum=dnd5e.api.v1alpha1.ChoiceSource" json:"source,omitempty"`       // Where this choice came from
	OptionId string                 `protobuf:"bytes,4,opt,name=option_id,json=optionId,proto3" json:"option_id,omitempty"`                         // For equipment bundles, which bundle was selected
	// The actual selection IDs - mirrors toolkit's Values []shared.SelectionID
	// For equipment category choices like "choose 2 martial weapons", this would contain
	// the IDs of the selected weapons (e.g., ["longsword", "battleaxe"])
	SelectionIds []string `protobuf:"bytes,5,rep,name=selection_ids,json=selectionIds,proto3" json:"selection_ids,omitempty"` // Generic selection IDs (can be equipment, spells, skills, etc.)
	// DEPRECATED: Category-specific selections (maintained for backward compatibility)
	// The actual selection - only one will be set based on category
	//
	// Types that are valid to be assigned to Selection:
	//
	//	*ChoiceSubmission_Skills
	//	*ChoiceSubmission_Equipment
	//	*ChoiceSubmission_Languages
	//	*ChoiceSubmission_Tools
	//	*ChoiceSubmission_FightingStyle
	//	*ChoiceSubmission_Spells
	//	*ChoiceSubmission_Expertise
	Selection     isChoiceSubmission_Selection `protobuf_oneof:"selection"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChoiceSubmission) Reset() {
	*x = ChoiceSubmission{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChoiceSubmission) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChoiceSubmission) ProtoMessage() {}

func (x *ChoiceSubmission) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChoiceSubmission.ProtoReflect.Descriptor instead.
func (*ChoiceSubmission) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{11}
}

func (x *ChoiceSubmission) GetChoiceId() string {
	if x != nil {
		return x.ChoiceId
	}
	return ""
}

func (x *ChoiceSubmission) GetCategory() ChoiceCategory {
	if x != nil {
		return x.Category
	}
	return ChoiceCategory_CHOICE_CATEGORY_UNSPECIFIED
}

func (x *ChoiceSubmission) GetSource() ChoiceSource {
	if x != nil {
		return x.Source
	}
	return ChoiceSource_CHOICE_SOURCE_UNSPECIFIED
}

func (x *ChoiceSubmission) GetOptionId() string {
	if x != nil {
		return x.OptionId
	}
	return ""
}

func (x *ChoiceSubmission) GetSelectionIds() []string {
	if x != nil {
		return x.SelectionIds
	}
	return nil
}

func (x *ChoiceSubmission) GetSelection() isChoiceSubmission_Selection {
	if x != nil {
		return x.Selection
	}
	return nil
}

func (x *ChoiceSubmission) GetSkills() *SkillSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceSubmission_Skills); ok {
			return x.Skills
		}
	}
	return nil
}

func (x *ChoiceSubmission) GetEquipment() *EquipmentSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceSubmission_Equipment); ok {
			return x.Equipment
		}
	}
	return nil
}

func (x *ChoiceSubmission) GetLanguages() *LanguageSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceSubmission_Languages); ok {
			return x.Languages
		}
	}
	return nil
}

func (x *ChoiceSubmission) GetTools() *ToolSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceSubmission_Tools); ok {
			return x.Tools
		}
	}
	return nil
}

func (x *ChoiceSubmission) GetFightingStyle() *FightingStyleSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceSubmission_FightingStyle); ok {
			return x.FightingStyle
		}
	}
	return nil
}

func (x *ChoiceSubmission) GetSpells() *SpellSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceSubmission_Spells); ok {
			return x.Spells
		}
	}
	return nil
}

func (x *ChoiceSubmission) GetExpertise() *ExpertiseSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceSubmission_Expertise); ok {
			return x.Expertise
		}
	}
	return nil
}

type isChoiceSubmission_Selection interface {
	isChoiceSubmission_Selection()
}

type ChoiceSubmission_Skills struct {
	Skills *SkillSelection `protobuf:"bytes,6,opt,name=skills,proto3,oneof"`
}

type ChoiceSubmission_Equipment struct {
	Equipment *EquipmentSelection `protobuf:"bytes,7,opt,name=equipment,proto3,oneof"`
}

type ChoiceSubmission_Languages struct {
	Languages *LanguageSelection `protobuf:"bytes,8,opt,name=languages,proto3,oneof"`
}

type ChoiceSubmission_Tools struct {
	Tools *ToolSelection `protobuf:"bytes,9,opt,name=tools,proto3,oneof"`
}

type ChoiceSubmission_FightingStyle struct {
	FightingStyle *FightingStyleSelection `protobuf:"bytes,10,opt,name=fighting_style,json=fightingStyle,proto3,oneof"`
}

type ChoiceSubmission_Spells struct {
	Spells *SpellSelection `protobuf:"bytes,11,opt,name=spells,proto3,oneof"`
}

type ChoiceSubmission_Expertise struct {
	Expertise *ExpertiseSelection `protobuf:"bytes,12,opt,name=expertise,proto3,oneof"`
}

func (*ChoiceSubmission_Skills) isChoiceSubmission_Selection() {}

func (*ChoiceSubmission_Equipment) isChoiceSubmission_Selection() {}

func (*ChoiceSubmission_Languages) isChoiceSubmission_Selection() {}

func (*ChoiceSubmission_Tools) isChoiceSubmission_Selection() {}

func (*ChoiceSubmission_FightingStyle) isChoiceSubmission_Selection() {}

func (*ChoiceSubmission_Spells) isChoiceSubmission_Selection() {}

func (*ChoiceSubmission_Expertise) isChoiceSubmission_Selection() {}

// Selected skills
type SkillSelection struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Skills        []Skill                `protobuf:"varint,1,rep,packed,name=skills,proto3,enum=dnd5e.api.v1alpha1.Skill" json:"skills,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SkillSelection) Reset() {
	*x = SkillSelection{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SkillSelection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SkillSelection) ProtoMessage() {}

func (x *SkillSelection) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SkillSelection.ProtoReflect.Descriptor instead.
func (*SkillSelection) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{12}
}

func (x *SkillSelection) GetSkills() []Skill {
	if x != nil {
		return x.Skills
	}
	return nil
}

// Selected equipment - supports multiple items from category choices
type EquipmentSelection struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Items         []*EquipmentSelectionItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"` // Multiple items can be selected
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EquipmentSelection) Reset() {
	*x = EquipmentSelection{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EquipmentSelection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EquipmentSelection) ProtoMessage() {}

func (x *EquipmentSelection) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EquipmentSelection.ProtoReflect.Descriptor instead.
func (*EquipmentSelection) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{13}
}

func (x *EquipmentSelection) GetItems() []*EquipmentSelectionItem {
	if x != nil {
		return x.Items
	}
	return nil
}

// A specific equipment item with quantity
type EquipmentSelectionItem struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Equipment:
	//
	//	*EquipmentSelectionItem_Weapon
	//	*EquipmentSelectionItem_Armor
	//	*EquipmentSelectionItem_Tool
	//	*EquipmentSelectionItem_Pack
	//	*EquipmentSelectionItem_Ammunition
	//	*EquipmentSelectionItem_OtherEquipmentId
	Equipment     isEquipmentSelectionItem_Equipment `protobuf_oneof:"equipment"`
	Quantity      int32                              `protobuf:"varint,7,opt,name=quantity,proto3" json:"quantity,omitempty"` // Default 1
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EquipmentSelectionItem) Reset() {
	*x = EquipmentSelectionItem{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EquipmentSelectionItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EquipmentSelectionItem) ProtoMessage() {}

func (x *EquipmentSelectionItem) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EquipmentSelectionItem.ProtoReflect.Descriptor instead.
func (*EquipmentSelectionItem) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{14}
}

func (x *EquipmentSelectionItem) GetEquipment() isEquipmentSelectionItem_Equipment {
	if x != nil {
		return x.Equipment
	}
	return nil
}

func (x *EquipmentSelectionItem) GetWeapon() Weapon {
	if x != nil {
		if x, ok := x.Equipment.(*EquipmentSelectionItem_Weapon); ok {
			return x.Weapon
		}
	}
	return Weapon_WEAPON_UNSPECIFIED
}

func (x *EquipmentSelectionItem) GetArmor() Armor {
	if x != nil {
		if x, ok := x.Equipment.(*EquipmentSelectionItem_Armor); ok {
			return x.Armor
		}
	}
	return Armor_ARMOR_UNSPECIFIED
}

func (x *EquipmentSelectionItem) GetTool() Tool {
	if x != nil {
		if x, ok := x.Equipment.(*EquipmentSelectionItem_Tool); ok {
			return x.Tool
		}
	}
	return Tool_TOOL_UNSPECIFIED
}

func (x *EquipmentSelectionItem) GetPack() Pack {
	if x != nil {
		if x, ok := x.Equipment.(*EquipmentSelectionItem_Pack); ok {
			return x.Pack
		}
	}
	return Pack_PACK_UNSPECIFIED
}

func (x *EquipmentSelectionItem) GetAmmunition() Ammunition {
	if x != nil {
		if x, ok := x.Equipment.(*EquipmentSelectionItem_Ammunition); ok {
			return x.Ammunition
		}
	}
	return Ammunition_AMMUNITION_UNSPECIFIED
}

func (x *EquipmentSelectionItem) GetOtherEquipmentId() string {
	if x != nil {
		if x, ok := x.Equipment.(*EquipmentSelectionItem_OtherEquipmentId); ok {
			return x.OtherEquipmentId
		}
	}
	return ""
}

func (x *EquipmentSelectionItem) GetQuantity() int32 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

type isEquipmentSelectionItem_Equipment interface {
	isEquipmentSelectionItem_Equipment()
}

type EquipmentSelectionItem_Weapon struct {
	Weapon Weapon `protobuf:"varint,1,opt,name=weapon,proto3,enum=dnd5e.api.v1alpha1.Weapon,oneof"`
}

type EquipmentSelectionItem_Armor struct {
	Armor Armor `protobuf:"varint,2,opt,name=armor,proto3,enum=dnd5e.api.v1alpha1.Armor,oneof"`
}

type EquipmentSelectionItem_Tool struct {
	Tool Tool `protobuf:"varint,3,opt,name=tool,proto3,enum=dnd5e.api.v1alpha1.Tool,oneof"`
}

type EquipmentSelectionItem_Pack struct {
	Pack Pack `protobuf:"varint,4,opt,name=pack,proto3,enum=dnd5e.api.v1alpha1.Pack,oneof"`
}

type EquipmentSelectionItem_Ammunition struct {
	Ammunition Ammunition `protobuf:"varint,5,opt,name=ammunition,proto3,enum=dnd5e.api.v1alpha1.Ammunition,oneof"`
}

type EquipmentSelectionItem_OtherEquipmentId struct {
	OtherEquipmentId string `protobuf:"bytes,6,opt,name=other_equipment_id,json=otherEquipmentId,proto3,oneof"` // For items not yet enumerated
}

func (*EquipmentSelectionItem_Weapon) isEquipmentSelectionItem_Equipment() {}

func (*EquipmentSelectionItem_Armor) isEquipmentSelectionItem_Equipment() {}

func (*EquipmentSelectionItem_Tool) isEquipmentSelectionItem_Equipment() {}

func (*EquipmentSelectionItem_Pack) isEquipmentSelectionItem_Equipment() {}

func (*EquipmentSelectionItem_Ammunition) isEquipmentSelectionItem_Equipment() {}

func (*EquipmentSelectionItem_OtherEquipmentId) isEquipmentSelectionItem_Equipment() {}

// Selected languages
type LanguageSelection struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Languages     []Language             `protobuf:"varint,1,rep,packed,name=languages,proto3,enum=dnd5e.api.v1alpha1.Language" json:"languages,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LanguageSelection) Reset() {
	*x = LanguageSelection{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LanguageSelection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LanguageSelection) ProtoMessage() {}

func (x *LanguageSelection) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LanguageSelection.ProtoReflect.Descriptor instead.
func (*LanguageSelection) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{15}
}

func (x *LanguageSelection) GetLanguages() []Language {
	if x != nil {
		return x.Languages
	}
	return nil
}

// Selected tools
type ToolSelection struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tools         []Tool                 `protobuf:"varint,1,rep,packed,name=tools,proto3,enum=dnd5e.api.v1alpha1.Tool" json:"tools,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToolSelection) Reset() {
	*x = ToolSelection{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolSelection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolSelection) ProtoMessage() {}

func (x *ToolSelection) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolSelection.ProtoReflect.Descriptor instead.
func (*ToolSelection) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{16}
}

func (x *ToolSelection) GetTools() []Tool {
	if x != nil {
		return x.Tools
	}
	return nil
}

// Selected fighting style
type FightingStyleSelection struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Style         FightingStyle          `protobuf:"varint,1,opt,name=style,proto3,enum=dnd5e.api.v1alpha1.FightingStyle" json:"style,omitempty"` // Usually just one
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FightingStyleSelection) Reset() {
	*x = FightingStyleSelection{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FightingStyleSelection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FightingStyleSelection) ProtoMessage() {}

func (x *FightingStyleSelection) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FightingStyleSelection.ProtoReflect.Descriptor instead.
func (*FightingStyleSelection) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{17}
}

func (x *FightingStyleSelection) GetStyle() FightingStyle {
	if x != nil {
		return x.Style
	}
	return FightingStyle_FIGHTING_STYLE_UNSPECIFIED
}

// Selected spells
type SpellSelection struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Spells        []Spell                `protobuf:"varint,1,rep,packed,name=spells,proto3,enum=dnd5e.api.v1alpha1.Spell" json:"spells,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SpellSelection) Reset() {
	*x = SpellSelection{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpellSelection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpellSelection) ProtoMessage() {}

func (x *SpellSelection) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpellSelection.ProtoReflect.Descriptor instead.
func (*SpellSelection) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{18}
}

func (x *SpellSelection) GetSpells() []Spell {
	if x != nil {
		return x.Spells
	}
	return nil
}

// Selected expertise
type ExpertiseSelection struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Skills        []Skill                `protobuf:"varint,1,rep,packed,name=skills,proto3,enum=dnd5e.api.v1alpha1.Skill" json:"skills,omitempty"`
	Tools         []Tool                 `protobuf:"varint,2,rep,packed,name=tools,proto3,enum=dnd5e.api.v1alpha1.Tool" json:"tools,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExpertiseSelection) Reset() {
	*x = ExpertiseSelection{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExpertiseSelection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExpertiseSelection) ProtoMessage() {}

func (x *ExpertiseSelection) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExpertiseSelection.ProtoReflect.Descriptor instead.
func (*ExpertiseSelection) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{19}
}

func (x *ExpertiseSelection) GetSkills() []Skill {
	if x != nil {
		return x.Skills
	}
	return nil
}

func (x *ExpertiseSelection) GetTools() []Tool {
	if x != nil {
		return x.Tools
	}
	return nil
}

// Tracks a choice that was made during character creation
// Stored with the character to remember what choices were made
type ChoiceData struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Category ChoiceCategory         `protobuf:"varint,1,opt,name=category,proto3,enum=dnd5e.api.v1alpha1.ChoiceCategory" json:"category,omitempty"`
	Source   ChoiceSource           `protobuf:"varint,2,opt,name=source,proto3,enum=dnd5e.api.v1alpha1.ChoiceSource" json:"source,omitempty"`
	ChoiceId string                 `protobuf:"bytes,3,opt,name=choice_id,json=choiceId,proto3" json:"choice_id,omitempty"` // The Choice.id this relates to
	OptionId string                 `protobuf:"bytes,4,opt,name=option_id,json=optionId,proto3" json:"option_id,omitempty"` // For equipment bundles, which bundle was selected
	// Generic selection IDs - preferred approach, mirrors toolkit's Submission.Values
	SelectionIds []string `protobuf:"bytes,5,rep,name=selection_ids,json=selectionIds,proto3" json:"selection_ids,omitempty"` // The IDs that were selected
	// DEPRECATED: Category-specific selection data (maintained for backward compatibility)
	//
	// Types that are valid to be assigned to Selection:
	//
	//	*ChoiceData_Name
	//	*ChoiceData_Skills
	//	*ChoiceData_Languages
	//	*ChoiceData_AbilityScores
	//	*ChoiceData_FightingStyle
	//	*ChoiceData_Equipment
	//	*ChoiceData_Background
	//	*ChoiceData_Spells
	//	*ChoiceData_Tools
	//	*ChoiceData_Expertise
	Selection     isChoiceData_Selection `protobuf_oneof:"selection"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChoiceData) Reset() {
	*x = ChoiceData{}
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChoiceData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChoiceData) ProtoMessage() {}

func (x *ChoiceData) ProtoReflect() protoreflect.Message {
	mi := &file_dnd5e_api_v1alpha1_choices_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChoiceData.ProtoReflect.Descriptor instead.
func (*ChoiceData) Descriptor() ([]byte, []int) {
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP(), []int{20}
}

func (x *ChoiceData) GetCategory() ChoiceCategory {
	if x != nil {
		return x.Category
	}
	return ChoiceCategory_CHOICE_CATEGORY_UNSPECIFIED
}

func (x *ChoiceData) GetSource() ChoiceSource {
	if x != nil {
		return x.Source
	}
	return ChoiceSource_CHOICE_SOURCE_UNSPECIFIED
}

func (x *ChoiceData) GetChoiceId() string {
	if x != nil {
		return x.ChoiceId
	}
	return ""
}

func (x *ChoiceData) GetOptionId() string {
	if x != nil {
		return x.OptionId
	}
	return ""
}

func (x *ChoiceData) GetSelectionIds() []string {
	if x != nil {
		return x.SelectionIds
	}
	return nil
}

func (x *ChoiceData) GetSelection() isChoiceData_Selection {
	if x != nil {
		return x.Selection
	}
	return nil
}

func (x *ChoiceData) GetName() string {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceData_Name); ok {
			return x.Name
		}
	}
	return ""
}

func (x *ChoiceData) GetSkills() *SkillSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceData_Skills); ok {
			return x.Skills
		}
	}
	return nil
}

func (x *ChoiceData) GetLanguages() *LanguageSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceData_Languages); ok {
			return x.Languages
		}
	}
	return nil
}

func (x *ChoiceData) GetAbilityScores() *AbilityScores {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceData_AbilityScores); ok {
			return x.AbilityScores
		}
	}
	return nil
}

func (x *ChoiceData) GetFightingStyle() *FightingStyleSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceData_FightingStyle); ok {
			return x.FightingStyle
		}
	}
	return nil
}

func (x *ChoiceData) GetEquipment() *EquipmentSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceData_Equipment); ok {
			return x.Equipment
		}
	}
	return nil
}

func (x *ChoiceData) GetBackground() Background {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceData_Background); ok {
			return x.Background
		}
	}
	return Background_BACKGROUND_UNSPECIFIED
}

func (x *ChoiceData) GetSpells() *SpellSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceData_Spells); ok {
			return x.Spells
		}
	}
	return nil
}

func (x *ChoiceData) GetTools() *ToolSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceData_Tools); ok {
			return x.Tools
		}
	}
	return nil
}

func (x *ChoiceData) GetExpertise() *ExpertiseSelection {
	if x != nil {
		if x, ok := x.Selection.(*ChoiceData_Expertise); ok {
			return x.Expertise
		}
	}
	return nil
}

type isChoiceData_Selection interface {
	isChoiceData_Selection()
}

type ChoiceData_Name struct {
	Name string `protobuf:"bytes,6,opt,name=name,proto3,oneof"` // For character name
}

type ChoiceData_Skills struct {
	Skills *SkillSelection `protobuf:"bytes,7,opt,name=skills,proto3,oneof"`
}

type ChoiceData_Languages struct {
	Languages *LanguageSelection `protobuf:"bytes,8,opt,name=languages,proto3,oneof"`
}

type ChoiceData_AbilityScores struct {
	AbilityScores *AbilityScores `protobuf:"bytes,9,opt,name=ability_scores,json=abilityScores,proto3,oneof"`
}

type ChoiceData_FightingStyle struct {
	FightingStyle *FightingStyleSelection `protobuf:"bytes,10,opt,name=fighting_style,json=fightingStyle,proto3,oneof"`
}

type ChoiceData_Equipment struct {
	Equipment *EquipmentSelection `protobuf:"bytes,11,opt,name=equipment,proto3,oneof"`
}

type ChoiceData_Background struct {
	Background Background `protobuf:"varint,12,opt,name=background,proto3,enum=dnd5e.api.v1alpha1.Background,oneof"`
}

type ChoiceData_Spells struct {
	Spells *SpellSelection `protobuf:"bytes,13,opt,name=spells,proto3,oneof"`
}

type ChoiceData_Tools struct {
	Tools *ToolSelection `protobuf:"bytes,14,opt,name=tools,proto3,oneof"`
}

type ChoiceData_Expertise struct {
	Expertise *ExpertiseSelection `protobuf:"bytes,15,opt,name=expertise,proto3,oneof"`
}

func (*ChoiceData_Name) isChoiceData_Selection() {}

func (*ChoiceData_Skills) isChoiceData_Selection() {}

func (*ChoiceData_Languages) isChoiceData_Selection() {}

func (*ChoiceData_AbilityScores) isChoiceData_Selection() {}

func (*ChoiceData_FightingStyle) isChoiceData_Selection() {}

func (*ChoiceData_Equipment) isChoiceData_Selection() {}

func (*ChoiceData_Background) isChoiceData_Selection() {}

func (*ChoiceData_Spells) isChoiceData_Selection() {}

func (*ChoiceData_Tools) isChoiceData_Selection() {}

func (*ChoiceData_Expertise) isChoiceData_Selection() {}

var File_dnd5e_api_v1alpha1_choices_proto protoreflect.FileDescriptor

const file_dnd5e_api_v1alpha1_choices_proto_rawDesc = "" +
	"\n" +
	" dnd5e/api/v1alpha1/choices.proto\x12\x12dnd5e.api.v1alpha1\x1a\x1fdnd5e/api/v1alpha1/common.proto\x1a\x1ednd5e/api/v1alpha1/enums.proto\"\xe3\x05\n" +
	"\x06Choice\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12!\n" +
	"\fchoose_count\x18\x03 \x01(\x05R\vchooseCount\x12C\n" +
	"\vchoice_type\x18\x04 \x01(\x0e2\".dnd5e.api.v1alpha1.ChoiceCategoryR\n" +
	"choiceType\x12G\n" +
	"\rskill_options\x18\x05 \x01(\v2 .dnd5e.api.v1alpha1.SkillOptionsH\x00R\fskillOptions\x12S\n" +
	"\x11equipment_options\x18\x06 \x01(\v2$.dnd5e.api.v1alpha1.EquipmentOptionsH\x00R\x10equipmentOptions\x12P\n" +
	"\x10language_options\x18\a \x01(\v2#.dnd5e.api.v1alpha1.LanguageOptionsH\x00R\x0flanguageOptions\x12D\n" +
	"\ftool_options\x18\b \x01(\v2\x1f.dnd5e.api.v1alpha1.ToolOptionsH\x00R\vtoolOptions\x12`\n" +
	"\x16fighting_style_options\x18\t \x01(\v2(.dnd5e.api.v1alpha1.FightingStyleOptionsH\x00R\x14fightingStyleOptions\x12G\n" +
	"\rspell_options\x18\n" +
	" \x01(\v2 .dnd5e.api.v1alpha1.SpellOptionsH\x00R\fspellOptions\x12S\n" +
	"\x11expertise_options\x18\v \x01(\v2$.dnd5e.api.v1alpha1.ExpertiseOptionsH\x00R\x10expertiseOptionsB\t\n" +
	"\aoptions\"G\n" +
	"\fSkillOptions\x127\n" +
	"\tavailable\x18\x01 \x03(\x0e2\x19.dnd5e.api.v1alpha1.SkillR\tavailable\"Q\n" +
	"\x10EquipmentOptions\x12=\n" +
	"\abundles\x18\x01 \x03(\v2#.dnd5e.api.v1alpha1.EquipmentBundleR\abundles\"\xc8\x01\n" +
	"\x0fEquipmentBundle\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x127\n" +
	"\x05items\x18\x03 \x03(\v2!.dnd5e.api.v1alpha1.EquipmentItemR\x05items\x12V\n" +
	"\x10category_choices\x18\x04 \x03(\v2+.dnd5e.api.v1alpha1.EquipmentCategoryChoiceR\x0fcategoryChoices\"\xe6\x02\n" +
	"\rEquipmentItem\x12!\n" +
	"\fselection_id\x18\x01 \x01(\tR\vselectionId\x12\x1a\n" +
	"\bquantity\x18\x02 \x01(\x05R\bquantity\x124\n" +
	"\x06weapon\x18\x03 \x01(\x0e2\x1a.dnd5e.api.v1alpha1.WeaponH\x00R\x06weapon\x121\n" +
	"\x05armor\x18\x04 \x01(\x0e2\x19.dnd5e.api.v1alpha1.ArmorH\x00R\x05armor\x12.\n" +
	"\x04tool\x18\x05 \x01(\x0e2\x18.dnd5e.api.v1alpha1.ToolH\x00R\x04tool\x12.\n" +
	"\x04pack\x18\x06 \x01(\x0e2\x18.dnd5e.api.v1alpha1.PackH\x00R\x04pack\x12@\n" +
	"\n" +
	"ammunition\x18\a \x01(\x0e2\x1e.dnd5e.api.v1alpha1.AmmunitionH\x00R\n" +
	"ammunitionB\v\n" +
	"\ttype_hint\"\xb1\x02\n" +
	"\x17EquipmentCategoryChoice\x12\x16\n" +
	"\x06choose\x18\x01 \x01(\x05R\x06choose\x12O\n" +
	"\x11weapon_categories\x18\x02 \x03(\x0e2\".dnd5e.api.v1alpha1.WeaponCategoryR\x10weaponCategories\x12L\n" +
	"\x10armor_categories\x18\x03 \x03(\x0e2!.dnd5e.api.v1alpha1.ArmorCategoryR\x0farmorCategories\x12I\n" +
	"\x0ftool_categories\x18\x04 \x03(\x0e2 .dnd5e.api.v1alpha1.ToolCategoryR\x0etoolCategories\x12\x14\n" +
	"\x05label\x18\x05 \x01(\tR\x05label\"M\n" +
	"\x0fLanguageOptions\x12:\n" +
	"\tavailable\x18\x01 \x03(\x0e2\x1c.dnd5e.api.v1alpha1.LanguageR\tavailable\"E\n" +
	"\vToolOptions\x126\n" +
	"\tavailable\x18\x01 \x03(\x0e2\x18.dnd5e.api.v1alpha1.ToolR\tavailable\"W\n" +
	"\x14FightingStyleOptions\x12?\n" +
	"\tavailable\x18\x01 \x03(\x0e2!.dnd5e.api.v1alpha1.FightingStyleR\tavailable\"\xb7\x01\n" +
	"\fSpellOptions\x127\n" +
	"\tavailable\x18\x01 \x03(\x0e2\x19.dnd5e.api.v1alpha1.SpellR\tavailable\x12\x1f\n" +
	"\vspell_level\x18\x02 \x01(\x05R\n" +
	"spellLevel\x12M\n" +
	"\x0eselection_type\x18\x03 \x01(\x0e2&.dnd5e.api.v1alpha1.SpellSelectionTypeR\rselectionType\"\x9b\x01\n" +
	"\x10ExpertiseOptions\x12D\n" +
	"\x10available_skills\x18\x01 \x03(\x0e2\x19.dnd5e.api.v1alpha1.SkillR\x0favailableSkills\x12A\n" +
	"\x0favailable_tools\x18\x02 \x03(\x0e2\x18.dnd5e.api.v1alpha1.ToolR\x0eavailableTools\"\xdb\x05\n" +
	"\x10ChoiceSubmission\x12\x1b\n" +
	"\tchoice_id\x18\x01 \x01(\tR\bchoiceId\x12>\n" +
	"\bcategory\x18\x02 \x01(\x0e2\".dnd5e.api.v1alpha1.ChoiceCategoryR\bcategory\x128\n" +
	"\x06source\x18\x03 \x01(\x0e2 .dnd5e.api.v1alpha1.ChoiceSourceR\x06source\x12\x1b\n" +
	"\toption_id\x18\x04 \x01(\tR\boptionId\x12#\n" +
	"\rselection_ids\x18\x05 \x03(\tR\fselectionIds\x12<\n" +
	"\x06skills\x18\x06 \x01(\v2\".dnd5e.api.v1alpha1.SkillSelectionH\x00R\x06skills\x12F\n" +
	"\tequipment\x18\a \x01(\v2&.dnd5e.api.v1alpha1.EquipmentSelectionH\x00R\tequipment\x12E\n" +
	"\tlanguages\x18\b \x01(\v2%.dnd5e.api.v1alpha1.LanguageSelectionH\x00R\tlanguages\x129\n" +
	"\x05tools\x18\t \x01(\v2!.dnd5e.api.v1alpha1.ToolSelectionH\x00R\x05tools\x12S\n" +
	"\x0efighting_style\x18\n" +
	" \x01(\v2*.dnd5e.api.v1alpha1.FightingStyleSelectionH\x00R\rfightingStyle\x12<\n" +
	"\x06spells\x18\v \x01(\v2\".dnd5e.api.v1alpha1.SpellSelectionH\x00R\x06spells\x12F\n" +
	"\texpertise\x18\f \x01(\v2&.dnd5e.api.v1alpha1.ExpertiseSelectionH\x00R\texpertiseB\v\n" +
	"\tselection\"C\n" +
	"\x0eSkillSelection\x121\n" +
	"\x06skills\x18\x01 \x03(\x0e2\x19.dnd5e.api.v1alpha1.SkillR\x06skills\"V\n" +
	"\x12EquipmentSelection\x12@\n" +
	"\x05items\x18\x01 \x03(\v2*.dnd5e.api.v1alpha1.EquipmentSelectionItemR\x05items\"\xfc\x02\n" +
	"\x16EquipmentSelectionItem\x124\n" +
	"\x06weapon\x18\x01 \x01(\x0e2\x1a.dnd5e.api.v1alpha1.WeaponH\x00R\x06weapon\x121\n" +
	"\x05armor\x18\x02 \x01(\x0e2\x19.dnd5e.api.v1alpha1.ArmorH\x00R\x05armor\x12.\n" +
	"\x04tool\x18\x03 \x01(\x0e2\x18.dnd5e.api.v1alpha1.ToolH\x00R\x04tool\x12.\n" +
	"\x04pack\x18\x04 \x01(\x0e2\x18.dnd5e.api.v1alpha1.PackH\x00R\x04pack\x12@\n" +
	"\n" +
	"ammunition\x18\x05 \x01(\x0e2\x1e.dnd5e.api.v1alpha1.AmmunitionH\x00R\n" +
	"ammunition\x12.\n" +
	"\x12other_equipment_id\x18\x06 \x01(\tH\x00R\x10otherEquipmentId\x12\x1a\n" +
	"\bquantity\x18\a \x01(\x05R\bquantityB\v\n" +
	"\tequipment\"O\n" +
	"\x11LanguageSelection\x12:\n" +
	"\tlanguages\x18\x01 \x03(\x0e2\x1c.dnd5e.api.v1alpha1.LanguageR\tlanguages\"?\n" +
	"\rToolSelection\x12.\n" +
	"\x05tools\x18\x01 \x03(\x0e2\x18.dnd5e.api.v1alpha1.ToolR\x05tools\"Q\n" +
	"\x16FightingStyleSelection\x127\n" +
	"\x05style\x18\x01 \x01(\x0e2!.dnd5e.api.v1alpha1.FightingStyleR\x05style\"C\n" +
	"\x0eSpellSelection\x121\n" +
	"\x06spells\x18\x01 \x03(\x0e2\x19.dnd5e.api.v1alpha1.SpellR\x06spells\"w\n" +
	"\x12ExpertiseSelection\x121\n" +
	"\x06skills\x18\x01 \x03(\x0e2\x19.dnd5e.api.v1alpha1.SkillR\x06skills\x12.\n" +
	"\x05tools\x18\x02 \x03(\x0e2\x18.dnd5e.api.v1alpha1.ToolR\x05tools\"\xf9\x06\n" +
	"\n" +
	"ChoiceData\x12>\n" +
	"\bcategory\x18\x01 \x01(\x0e2\".dnd5e.api.v1alpha1.ChoiceCategoryR\bcategory\x128\n" +
	"\x06source\x18\x02 \x01(\x0e2 .dnd5e.api.v1alpha1.ChoiceSourceR\x06source\x12\x1b\n" +
	"\tchoice_id\x18\x03 \x01(\tR\bchoiceId\x12\x1b\n" +
	"\toption_id\x18\x04 \x01(\tR\boptionId\x12#\n" +
	"\rselection_ids\x18\x05 \x03(\tR\fselectionIds\x12\x14\n" +
	"\x04name\x18\x06 \x01(\tH\x00R\x04name\x12<\n" +
	"\x06skills\x18\a \x01(\v2\".dnd5e.api.v1alpha1.SkillSelectionH\x00R\x06skills\x12E\n" +
	"\tlanguages\x18\b \x01(\v2%.dnd5e.api.v1alpha1.LanguageSelectionH\x00R\tlanguages\x12J\n" +
	"\x0eability_scores\x18\t \x01(\v2!.dnd5e.api.v1alpha1.AbilityScoresH\x00R\rabilityScores\x12S\n" +
	"\x0efighting_style\x18\n" +
	" \x01(\v2*.dnd5e.api.v1alpha1.FightingStyleSelectionH\x00R\rfightingStyle\x12F\n" +
	"\tequipment\x18\v \x01(\v2&.dnd5e.api.v1alpha1.EquipmentSelectionH\x00R\tequipment\x12@\n" +
	"\n" +
	"background\x18\f \x01(\x0e2\x1e.dnd5e.api.v1alpha1.BackgroundH\x00R\n" +
	"background\x12<\n" +
	"\x06spells\x18\r \x01(\v2\".dnd5e.api.v1alpha1.SpellSelectionH\x00R\x06spells\x129\n" +
	"\x05tools\x18\x0e \x01(\v2!.dnd5e.api.v1alpha1.ToolSelectionH\x00R\x05tools\x12F\n" +
	"\texpertise\x18\x0f \x01(\v2&.dnd5e.api.v1alpha1.ExpertiseSelectionH\x00R\texpertiseB\v\n" +
	"\tselection*\xa1\x01\n" +
	"\x12SpellSelectionType\x12$\n" +
	" SPELL_SELECTION_TYPE_UNSPECIFIED\x10\x00\x12\"\n" +
	"\x1eSPELL_SELECTION_TYPE_SPELLBOOK\x10\x01\x12\x1e\n" +
	"\x1aSPELL_SELECTION_TYPE_KNOWN\x10\x02\x12!\n" +
	"\x1dSPELL_SELECTION_TYPE_PREPARED\x10\x03*\xcd\x01\n" +
	"\fChoiceSource\x12\x1d\n" +
	"\x19CHOICE_SOURCE_UNSPECIFIED\x10\x00\x12\x18\n" +
	"\x14CHOICE_SOURCE_PLAYER\x10\x01\x12\x16\n" +
	"\x12CHOICE_SOURCE_RACE\x10\x02\x12\x19\n" +
	"\x15CHOICE_SOURCE_SUBRACE\x10\x03\x12\x17\n" +
	"\x13CHOICE_SOURCE_CLASS\x10\x04\x12\x1c\n" +
	"\x18CHOICE_SOURCE_BACKGROUND\x10\x05\x12\x1a\n" +
	"\x16CHOICE_SOURCE_LEVEL_UP\x10\x06*\xdd\x04\n" +
	"\x0eChoiceCategory\x12\x1f\n" +
	"\x1bCHOICE_CATEGORY_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19CHOICE_CATEGORY_EQUIPMENT\x10\x01\x12\x1a\n" +
	"\x16CHOICE_CATEGORY_SKILLS\x10\x02\x12\x19\n" +
	"\x15CHOICE_CATEGORY_TOOLS\x10\x03\x12\x1d\n" +
	"\x19CHOICE_CATEGORY_LANGUAGES\x10\x04\x12(\n" +
	"$CHOICE_CATEGORY_WEAPON_PROFICIENCIES\x10\x05\x12'\n" +
	"#CHOICE_CATEGORY_ARMOR_PROFICIENCIES\x10\x06\x12\x1a\n" +
	"\x16CHOICE_CATEGORY_SPELLS\x10\a\x12\x19\n" +
	"\x15CHOICE_CATEGORY_FEATS\x10\b\x12\"\n" +
	"\x1eCHOICE_CATEGORY_ABILITY_SCORES\x10\t\x12\x18\n" +
	"\x14CHOICE_CATEGORY_NAME\x10\n" +
	"\x12\"\n" +
	"\x1eCHOICE_CATEGORY_FIGHTING_STYLE\x10\v\x12\x18\n" +
	"\x14CHOICE_CATEGORY_RACE\x10\f\x12\x19\n" +
	"\x15CHOICE_CATEGORY_CLASS\x10\r\x12\x1e\n" +
	"\x1aCHOICE_CATEGORY_BACKGROUND\x10\x0e\x12\x1c\n" +
	"\x18CHOICE_CATEGORY_CANTRIPS\x10\x0f\x12\x1d\n" +
	"\x19CHOICE_CATEGORY_EXPERTISE\x10\x10\x12\x1b\n" +
	"\x17CHOICE_CATEGORY_SUBRACE\x10\x11\x12\x1a\n" +
	"\x16CHOICE_CATEGORY_TRAITS\x10\x12B\xdd\x01\n" +
	"\x16com.dnd5e.api.v1alpha1B\fChoicesProtoP\x01ZKgithub.com/KirkDiggler/rpg-api-protos/gen/go/dnd5e/api/v1alpha1;apiv1alpha1\xa2\x02\x03DAX\xaa\x02\x12Dnd5e.Api.V1alpha1\xca\x02\x12Dnd5e\\Api\\V1alpha1\xe2\x02\x1eDnd5e\\Api\\V1alpha1\\GPBMetadata\xea\x02\x14Dnd5e::Api::V1alpha1b\x06proto3"

var (
	file_dnd5e_api_v1alpha1_choices_proto_rawDescOnce sync.Once
	file_dnd5e_api_v1alpha1_choices_proto_rawDescData []byte
)

func file_dnd5e_api_v1alpha1_choices_proto_rawDescGZIP() []byte {
	file_dnd5e_api_v1alpha1_choices_proto_rawDescOnce.Do(func() {
		file_dnd5e_api_v1alpha1_choices_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_dnd5e_api_v1alpha1_choices_proto_rawDesc), len(file_dnd5e_api_v1alpha1_choices_proto_rawDesc)))
	})
	return file_dnd5e_api_v1alpha1_choices_proto_rawDescData
}

var file_dnd5e_api_v1alpha1_choices_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_dnd5e_api_v1alpha1_choices_proto_msgTypes = make([]protoimpl.MessageInfo, 21)
var file_dnd5e_api_v1alpha1_choices_proto_goTypes = []any{
	(SpellSelectionType)(0),         // 0: dnd5e.api.v1alpha1.SpellSelectionType
	(ChoiceSource)(0),               // 1: dnd5e.api.v1alpha1.ChoiceSource
	(ChoiceCategory)(0),             // 2: dnd5e.api.v1alpha1.ChoiceCategory
	(*Choice)(nil),                  // 3: dnd5e.api.v1alpha1.Choice
	(*SkillOptions)(nil),            // 4: dnd5e.api.v1alpha1.SkillOptions
	(*EquipmentOptions)(nil),        // 5: dnd5e.api.v1alpha1.EquipmentOptions
	(*EquipmentBundle)(nil),         // 6: dnd5e.api.v1alpha1.EquipmentBundle
	(*EquipmentItem)(nil),           // 7: dnd5e.api.v1alpha1.EquipmentItem
	(*EquipmentCategoryChoice)(nil), // 8: dnd5e.api.v1alpha1.EquipmentCategoryChoice
	(*LanguageOptions)(nil),         // 9: dnd5e.api.v1alpha1.LanguageOptions
	(*ToolOptions)(nil),             // 10: dnd5e.api.v1alpha1.ToolOptions
	(*FightingStyleOptions)(nil),    // 11: dnd5e.api.v1alpha1.FightingStyleOptions
	(*SpellOptions)(nil),            // 12: dnd5e.api.v1alpha1.SpellOptions
	(*ExpertiseOptions)(nil),        // 13: dnd5e.api.v1alpha1.ExpertiseOptions
	(*ChoiceSubmission)(nil),        // 14: dnd5e.api.v1alpha1.ChoiceSubmission
	(*SkillSelection)(nil),          // 15: dnd5e.api.v1alpha1.SkillSelection
	(*EquipmentSelection)(nil),      // 16: dnd5e.api.v1alpha1.EquipmentSelection
	(*EquipmentSelectionItem)(nil),  // 17: dnd5e.api.v1alpha1.EquipmentSelectionItem
	(*LanguageSelection)(nil),       // 18: dnd5e.api.v1alpha1.LanguageSelection
	(*ToolSelection)(nil),           // 19: dnd5e.api.v1alpha1.ToolSelection
	(*FightingStyleSelection)(nil),  // 20: dnd5e.api.v1alpha1.FightingStyleSelection
	(*SpellSelection)(nil),          // 21: dnd5e.api.v1alpha1.SpellSelection
	(*ExpertiseSelection)(nil),      // 22: dnd5e.api.v1alpha1.ExpertiseSelection
	(*ChoiceData)(nil),              // 23: dnd5e.api.v1alpha1.ChoiceData
	(Skill)(0),                      // 24: dnd5e.api.v1alpha1.Skill
	(Weapon)(0),                     // 25: dnd5e.api.v1alpha1.Weapon
	(Armor)(0),                      // 26: dnd5e.api.v1alpha1.Armor
	(Tool)(0),                       // 27: dnd5e.api.v1alpha1.Tool
	(Pack)(0),                       // 28: dnd5e.api.v1alpha1.Pack
	(Ammunition)(0),                 // 29: dnd5e.api.v1alpha1.Ammunition
	(WeaponCategory)(0),             // 30: dnd5e.api.v1alpha1.WeaponCategory
	(ArmorCategory)(0),              // 31: dnd5e.api.v1alpha1.ArmorCategory
	(ToolCategory)(0),               // 32: dnd5e.api.v1alpha1.ToolCategory
	(Language)(0),                   // 33: dnd5e.api.v1alpha1.Language
	(FightingStyle)(0),              // 34: dnd5e.api.v1alpha1.FightingStyle
	(Spell)(0),                      // 35: dnd5e.api.v1alpha1.Spell
	(*AbilityScores)(nil),           // 36: dnd5e.api.v1alpha1.AbilityScores
	(Background)(0),                 // 37: dnd5e.api.v1alpha1.Background
}
var file_dnd5e_api_v1alpha1_choices_proto_depIdxs = []int32{
	2,  // 0: dnd5e.api.v1alpha1.Choice.choice_type:type_name -> dnd5e.api.v1alpha1.ChoiceCategory
	4,  // 1: dnd5e.api.v1alpha1.Choice.skill_options:type_name -> dnd5e.api.v1alpha1.SkillOptions
	5,  // 2: dnd5e.api.v1alpha1.Choice.equipment_options:type_name -> dnd5e.api.v1alpha1.EquipmentOptions
	9,  // 3: dnd5e.api.v1alpha1.Choice.language_options:type_name -> dnd5e.api.v1alpha1.LanguageOptions
	10, // 4: dnd5e.api.v1alpha1.Choice.tool_options:type_name -> dnd5e.api.v1alpha1.ToolOptions
	11, // 5: dnd5e.api.v1alpha1.Choice.fighting_style_options:type_name -> dnd5e.api.v1alpha1.FightingStyleOptions
	12, // 6: dnd5e.api.v1alpha1.Choice.spell_options:type_name -> dnd5e.api.v1alpha1.SpellOptions
	13, // 7: dnd5e.api.v1alpha1.Choice.expertise_options:type_name -> dnd5e.api.v1alpha1.ExpertiseOptions
	24, // 8: dnd5e.api.v1alpha1.SkillOptions.available:type_name -> dnd5e.api.v1alpha1.Skill
	6,  // 9: dnd5e.api.v1alpha1.EquipmentOptions.bundles:type_name -> dnd5e.api.v1alpha1.EquipmentBundle
	7,  // 10: dnd5e.api.v1alpha1.EquipmentBundle.items:type_name -> dnd5e.api.v1alpha1.EquipmentItem
	8,  // 11: dnd5e.api.v1alpha1.EquipmentBundle.category_choices:type_name -> dnd5e.api.v1alpha1.EquipmentCategoryChoice
	25, // 12: dnd5e.api.v1alpha1.EquipmentItem.weapon:type_name -> dnd5e.api.v1alpha1.Weapon
	26, // 13: dnd5e.api.v1alpha1.EquipmentItem.armor:type_name -> dnd5e.api.v1alpha1.Armor
	27, // 14: dnd5e.api.v1alpha1.EquipmentItem.tool:type_name -> dnd5e.api.v1alpha1.Tool
	28, // 15: dnd5e.api.v1alpha1.EquipmentItem.pack:type_name -> dnd5e.api.v1alpha1.Pack
	29, // 16: dnd5e.api.v1alpha1.EquipmentItem.ammunition:type_name -> dnd5e.api.v1alpha1.Ammunition
	30, // 17: dnd5e.api.v1alpha1.EquipmentCategoryChoice.weapon_categories:type_name -> dnd5e.api.v1alpha1.WeaponCategory
	31, // 18: dnd5e.api.v1alpha1.EquipmentCategoryChoice.armor_categories:type_name -> dnd5e.api.v1alpha1.ArmorCategory
	32, // 19: dnd5e.api.v1alpha1.EquipmentCategoryChoice.tool_categories:type_name -> dnd5e.api.v1alpha1.ToolCategory
	33, // 20: dnd5e.api.v1alpha1.LanguageOptions.available:type_name -> dnd5e.api.v1alpha1.Language
	27, // 21: dnd5e.api.v1alpha1.ToolOptions.available:type_name -> dnd5e.api.v1alpha1.Tool
	34, // 22: dnd5e.api.v1alpha1.FightingStyleOptions.available:type_name -> dnd5e.api.v1alpha1.FightingStyle
	35, // 23: dnd5e.api.v1alpha1.SpellOptions.available:type_name -> dnd5e.api.v1alpha1.Spell
	0,  // 24: dnd5e.api.v1alpha1.SpellOptions.selection_type:type_name -> dnd5e.api.v1alpha1.SpellSelectionType
	24, // 25: dnd5e.api.v1alpha1.ExpertiseOptions.available_skills:type_name -> dnd5e.api.v1alpha1.Skill
	27, // 26: dnd5e.api.v1alpha1.ExpertiseOptions.available_tools:type_name -> dnd5e.api.v1alpha1.Tool
	2,  // 27: dnd5e.api.v1alpha1.ChoiceSubmission.category:type_name -> dnd5e.api.v1alpha1.ChoiceCategory
	1,  // 28: dnd5e.api.v1alpha1.ChoiceSubmission.source:type_name -> dnd5e.api.v1alpha1.ChoiceSource
	15, // 29: dnd5e.api.v1alpha1.ChoiceSubmission.skills:type_name -> dnd5e.api.v1alpha1.SkillSelection
	16, // 30: dnd5e.api.v1alpha1.ChoiceSubmission.equipment:type_name -> dnd5e.api.v1alpha1.EquipmentSelection
	18, // 31: dnd5e.api.v1alpha1.ChoiceSubmission.languages:type_name -> dnd5e.api.v1alpha1.LanguageSelection
	19, // 32: dnd5e.api.v1alpha1.ChoiceSubmission.tools:type_name -> dnd5e.api.v1alpha1.ToolSelection
	20, // 33: dnd5e.api.v1alpha1.ChoiceSubmission.fighting_style:type_name -> dnd5e.api.v1alpha1.FightingStyleSelection
	21, // 34: dnd5e.api.v1alpha1.ChoiceSubmission.spells:type_name -> dnd5e.api.v1alpha1.SpellSelection
	22, // 35: dnd5e.api.v1alpha1.ChoiceSubmission.expertise:type_name -> dnd5e.api.v1alpha1.ExpertiseSelection
	24, // 36: dnd5e.api.v1alpha1.SkillSelection.skills:type_name -> dnd5e.api.v1alpha1.Skill
	17, // 37: dnd5e.api.v1alpha1.EquipmentSelection.items:type_name -> dnd5e.api.v1alpha1.EquipmentSelectionItem
	25, // 38: dnd5e.api.v1alpha1.EquipmentSelectionItem.weapon:type_name -> dnd5e.api.v1alpha1.Weapon
	26, // 39: dnd5e.api.v1alpha1.EquipmentSelectionItem.armor:type_name -> dnd5e.api.v1alpha1.Armor
	27, // 40: dnd5e.api.v1alpha1.EquipmentSelectionItem.tool:type_name -> dnd5e.api.v1alpha1.Tool
	28, // 41: dnd5e.api.v1alpha1.EquipmentSelectionItem.pack:type_name -> dnd5e.api.v1alpha1.Pack
	29, // 42: dnd5e.api.v1alpha1.EquipmentSelectionItem.ammunition:type_name -> dnd5e.api.v1alpha1.Ammunition
	33, // 43: dnd5e.api.v1alpha1.LanguageSelection.languages:type_name -> dnd5e.api.v1alpha1.Language
	27, // 44: dnd5e.api.v1alpha1.ToolSelection.tools:type_name -> dnd5e.api.v1alpha1.Tool
	34, // 45: dnd5e.api.v1alpha1.FightingStyleSelection.style:type_name -> dnd5e.api.v1alpha1.FightingStyle
	35, // 46: dnd5e.api.v1alpha1.SpellSelection.spells:type_name -> dnd5e.api.v1alpha1.Spell
	24, // 47: dnd5e.api.v1alpha1.ExpertiseSelection.skills:type_name -> dnd5e.api.v1alpha1.Skill
	27, // 48: dnd5e.api.v1alpha1.ExpertiseSelection.tools:type_name -> dnd5e.api.v1alpha1.Tool
	2,  // 49: dnd5e.api.v1alpha1.ChoiceData.category:type_name -> dnd5e.api.v1alpha1.ChoiceCategory
	1,  // 50: dnd5e.api.v1alpha1.ChoiceData.source:type_name -> dnd5e.api.v1alpha1.ChoiceSource
	15, // 51: dnd5e.api.v1alpha1.ChoiceData.skills:type_name -> dnd5e.api.v1alpha1.SkillSelection
	18, // 52: dnd5e.api.v1alpha1.ChoiceData.languages:type_name -> dnd5e.api.v1alpha1.LanguageSelection
	36, // 53: dnd5e.api.v1alpha1.ChoiceData.ability_scores:type_name -> dnd5e.api.v1alpha1.AbilityScores
	20, // 54: dnd5e.api.v1alpha1.ChoiceData.fighting_style:type_name -> dnd5e.api.v1alpha1.FightingStyleSelection
	16, // 55: dnd5e.api.v1alpha1.ChoiceData.equipment:type_name -> dnd5e.api.v1alpha1.EquipmentSelection
	37, // 56: dnd5e.api.v1alpha1.ChoiceData.background:type_name -> dnd5e.api.v1alpha1.Background
	21, // 57: dnd5e.api.v1alpha1.ChoiceData.spells:type_name -> dnd5e.api.v1alpha1.SpellSelection
	19, // 58: dnd5e.api.v1alpha1.ChoiceData.tools:type_name -> dnd5e.api.v1alpha1.ToolSelection
	22, // 59: dnd5e.api.v1alpha1.ChoiceData.expertise:type_name -> dnd5e.api.v1alpha1.ExpertiseSelection
	60, // [60:60] is the sub-list for method output_type
	60, // [60:60] is the sub-list for method input_type
	60, // [60:60] is the sub-list for extension type_name
	60, // [60:60] is the sub-list for extension extendee
	0,  // [0:60] is the sub-list for field type_name
}

func init() { file_dnd5e_api_v1alpha1_choices_proto_init() }
func file_dnd5e_api_v1alpha1_choices_proto_init() {
	if File_dnd5e_api_v1alpha1_choices_proto != nil {
		return
	}
	file_dnd5e_api_v1alpha1_common_proto_init()
	file_dnd5e_api_v1alpha1_enums_proto_init()
	file_dnd5e_api_v1alpha1_choices_proto_msgTypes[0].OneofWrappers = []any{
		(*Choice_SkillOptions)(nil),
		(*Choice_EquipmentOptions)(nil),
		(*Choice_LanguageOptions)(nil),
		(*Choice_ToolOptions)(nil),
		(*Choice_FightingStyleOptions)(nil),
		(*Choice_SpellOptions)(nil),
		(*Choice_ExpertiseOptions)(nil),
	}
	file_dnd5e_api_v1alpha1_choices_proto_msgTypes[4].OneofWrappers = []any{
		(*EquipmentItem_Weapon)(nil),
		(*EquipmentItem_Armor)(nil),
		(*EquipmentItem_Tool)(nil),
		(*EquipmentItem_Pack)(nil),
		(*EquipmentItem_Ammunition)(nil),
	}
	file_dnd5e_api_v1alpha1_choices_proto_msgTypes[11].OneofWrappers = []any{
		(*ChoiceSubmission_Skills)(nil),
		(*ChoiceSubmission_Equipment)(nil),
		(*ChoiceSubmission_Languages)(nil),
		(*ChoiceSubmission_Tools)(nil),
		(*ChoiceSubmission_FightingStyle)(nil),
		(*ChoiceSubmission_Spells)(nil),
		(*ChoiceSubmission_Expertise)(nil),
	}
	file_dnd5e_api_v1alpha1_choices_proto_msgTypes[14].OneofWrappers = []any{
		(*EquipmentSelectionItem_Weapon)(nil),
		(*EquipmentSelectionItem_Armor)(nil),
		(*EquipmentSelectionItem_Tool)(nil),
		(*EquipmentSelectionItem_Pack)(nil),
		(*EquipmentSelectionItem_Ammunition)(nil),
		(*EquipmentSelectionItem_OtherEquipmentId)(nil),
	}
	file_dnd5e_api_v1alpha1_choices_proto_msgTypes[20].OneofWrappers = []any{
		(*ChoiceData_Name)(nil),
		(*ChoiceData_Skills)(nil),
		(*ChoiceData_Languages)(nil),
		(*ChoiceData_AbilityScores)(nil),
		(*ChoiceData_FightingStyle)(nil),
		(*ChoiceData_Equipment)(nil),
		(*ChoiceData_Background)(nil),
		(*ChoiceData_Spells)(nil),
		(*ChoiceData_Tools)(nil),
		(*ChoiceData_Expertise)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_dnd5e_api_v1alpha1_choices_proto_rawDesc), len(file_dnd5e_api_v1alpha1_choices_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   21,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_dnd5e_api_v1alpha1_choices_proto_goTypes,
		DependencyIndexes: file_dnd5e_api_v1alpha1_choices_proto_depIdxs,
		EnumInfos:         file_dnd5e_api_v1alpha1_choices_proto_enumTypes,
		MessageInfos:      file_dnd5e_api_v1alpha1_choices_proto_msgTypes,
	}.Build()
	File_dnd5e_api_v1alpha1_choices_proto = out.File
	file_dnd5e_api_v1alpha1_choices_proto_goTypes = nil
	file_dnd5e_api_v1alpha1_choices_proto_depIdxs = nil
}
